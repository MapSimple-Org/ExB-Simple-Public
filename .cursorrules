# --- Tone & Style Rules ---
- Do not use "—" or excessive dashes in prose or comments.
- Avoid "AI-isms" or overly formal "robotic" language.
- Maintain a direct, peer-to-peer tone with a sense of levity.
- Do not take liberties; if you aren't sure about a logic change, ask first.

# --- Context Awareness ---
- You have access to: 'query-simple', 'helper-simple', and 'shared-code'.
- Focus on WAB-to-ExB parity, specifically replicating eSearch functionality and URL parameter handling.

# --- Technical Standards & Best Practices ---

## 1. Versioning & Build Management
- **The Scalpel Rule**: For every change, increment the MINOR_VERSION or BUILD_NUMBER in `version.ts`. No exceptions.
- **The Save Game Milestone**: Always commit and push a stable, tested baseline before starting high-risk refactors.

## 2. Debugging & Logging
- **No Direct Console Logs**: Never use `console.log()`. Always use the custom `debugLogger`.
- **Feature Flags**: Log specific events using feature switches (e.g., `debugLogger.log('HASH', ...)`).
- **The Log-First Rule**: Investigating bugs? Add `debugLogger` calls to capture state/timing *before* guessing at a fix.

## 3. SQL Performance (The Optimizer)
- **SARGable Queries**: Avoid wrapping database fields in functions like `LOWER()` as it kills index performance.
- **Normalizing Input**: Perform case-insensitive searches by normalizing user input to uppercase in the application logic rather than the SQL `WHERE` clause.
- **Attribute Stripping**: Request ONLY the fields required for display to minimize network payloads.
- **Geometry Generalization**: Use `maxAllowableOffset: 0.1` for all display queries to optimize performance.

## 4. State Management & Transitions
- **The Persistence Trap**: Avoid "ghost values" in forms when switching queries.
- **Clean Transitions**: Use unique React `key` props (incorporating `configId`) to force-unmount and remount components when search contexts change.
- **Atomic Updates**: Group related state changes into a single `setState` call to prevent race conditions and redundant renders.

## 5. Testing Strategy
- **Dual-Layer Testing**:
  - **Unit Tests**: Use Jest for deterministic logic (SQL, URL parsing, utility functions).
  - **Mega-Journey E2E**: Use Playwright to simulate full user sessions, verifying state persistence and multi-widget isolation.

## 6. URL Parameter Handling
- **Hash Fragments (#)**: Best for snappy, interactive UX (no page reload).
- **Query Strings (?)**: Best for external linking and CRM integration.
- **ShortID Logic**: Both formats must resolve to the same underlying search logic using the configured `shortId`.
- **Consumption**: URL parameters should be "consumed" (cleared) when moving into interactive modes (Add/Remove) to prevent loops.

# --- Architectural Patterns ---

## 1. Shared Code Pattern (CRITICAL)
- **Zero Duplication**: Never recreate a utility or component if it exists in `shared-code/common/`.
- **Cross-Widget Sync**: Shared code is the "Single Source of Truth" for loggers, UI tips, and status indicators.

## 2. Widget Communication (The Handshake)
- **Custom Events**: Widgets communicate via a standard event bus (e.g., `querysimple-selection-changed`, `querysimple-widget-state-changed`).
- **Persistence**: Selections must be maintained even when external tools (like Map Identify) are used.

## 3. Component Hierarchy
- **Shell & Hooks**: Keep `widget.tsx` as a clean shell. Move complex logic into modular custom hooks (e.g., `useHashConsumption`, `useWidgetState`).
- **Synchronized Utilities**: Use `selection-utils.ts` for all map highlighting to ensure graphics and native layers stay in sync.

# --- Public Distribution Architecture ---

## 1. Directory Structure (The Root)
The distributed project should maintain a flat structure at the root for maximum "Plug-and-Play" compatibility with Experience Builder's `your-extensions/widgets/` directory:

```
MapSimple-Dev/
├── .cursorrules       <-- Developer guidance (This file)
├── .gitignore         <-- Clean distribution ignore rules
├── README.md          <-- Public-facing documentation
├── query-simple/      <-- Main high-performance search widget
├── helper-simple/     <-- Orchestrator & URL monitor widget
└── shared-code/       <-- Common logic shared between all widgets
```

## 2. Modular Deployment
- **Encapsulation**: Each widget folder (`query-simple`, `helper-simple`) must be self-contained and only depend on `shared-code/`.
- **Manifests**: Every widget must have a valid `manifest.json` at its first level for framework recognition.
- **Source Paths**: Maintain the `src/runtime/` and `src/setting/` structure to ensure the Experience Builder compiler can find entry points.
- **Unit Preservation**: Unit tests (`tests/`) should remain co-located within the widget folders to provide immediate verification for public implementers.
