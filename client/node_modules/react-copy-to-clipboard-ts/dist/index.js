import * as m from "react";
function E(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var C, v;
function h() {
  return v || (v = 1, C = function() {
    var e = document.getSelection();
    if (!e.rangeCount)
      return function() {
      };
    for (var r = document.activeElement, s = [], o = 0; o < e.rangeCount; o++)
      s.push(e.getRangeAt(o));
    switch (r.tagName.toUpperCase()) {
      // .toUpperCase handles XHTML
      case "INPUT":
      case "TEXTAREA":
        r.blur();
        break;
      default:
        r = null;
        break;
    }
    return e.removeAllRanges(), function() {
      e.type === "Caret" && e.removeAllRanges(), e.rangeCount || s.forEach(function(d) {
        e.addRange(d);
      }), r && r.focus();
    };
  }), C;
}
var b, w;
function R() {
  if (w) return b;
  w = 1;
  var e = h(), r = {
    "text/plain": "Text",
    "text/html": "Url",
    default: "Text"
  }, s = "Copy to clipboard: #{key}, Enter";
  function o(n) {
    var t = (/mac os x/i.test(navigator.userAgent) ? "âŒ˜" : "Ctrl") + "+C";
    return n.replace(/#{\s*key\s*}/g, t);
  }
  function d(n, t) {
    var l, i, f, p, u, a, y = !1;
    t || (t = {}), l = t.debug || !1;
    try {
      f = e(), p = document.createRange(), u = document.getSelection(), a = document.createElement("span"), a.textContent = n, a.ariaHidden = "true", a.style.all = "unset", a.style.position = "fixed", a.style.top = 0, a.style.clip = "rect(0, 0, 0, 0)", a.style.whiteSpace = "pre", a.style.webkitUserSelect = "text", a.style.MozUserSelect = "text", a.style.msUserSelect = "text", a.style.userSelect = "text", a.addEventListener("copy", function(c) {
        if (c.stopPropagation(), t.format)
          if (c.preventDefault(), typeof c.clipboardData > "u") {
            l && console.warn("unable to use e.clipboardData"), l && console.warn("trying IE specific stuff"), window.clipboardData.clearData();
            var g = r[t.format] || r.default;
            window.clipboardData.setData(g, n);
          } else
            c.clipboardData.clearData(), c.clipboardData.setData(t.format, n);
        t.onCopy && (c.preventDefault(), t.onCopy(c.clipboardData));
      }), document.body.appendChild(a), p.selectNodeContents(a), u.addRange(p);
      var D = document.execCommand("copy");
      if (!D)
        throw new Error("copy command was unsuccessful");
      y = !0;
    } catch (c) {
      l && console.error("unable to copy using execCommand: ", c), l && console.warn("trying IE specific stuff");
      try {
        window.clipboardData.setData(t.format || "text", n), t.onCopy && t.onCopy(window.clipboardData), y = !0;
      } catch (g) {
        l && console.error("unable to copy using clipboardData: ", g), l && console.error("falling back to prompt"), i = o("message" in t ? t.message : s), window.prompt(i, n);
      }
    } finally {
      u && (typeof u.removeRange == "function" ? u.removeRange(p) : u.removeAllRanges()), a && document.body.removeChild(a), f();
    }
    return y;
  }
  return b = d, b;
}
var T = R();
const k = /* @__PURE__ */ E(T), S = ({
  text: e,
  onCopy: r,
  options: s,
  children: o,
  ...d
}) => {
  const n = m.useCallback(
    (l) => {
      const i = m.Children.only(
        o
      ), f = k(e, s);
      r && r(e, f), i.props.onClick && typeof i.props.onClick == "function" && i.props.onClick(l);
    },
    [e, r, s, o]
  ), t = m.Children.only(o);
  return m.cloneElement(t, { onClick: n, ...d });
};
export {
  S as CopyToClipboard,
  S as default
};
