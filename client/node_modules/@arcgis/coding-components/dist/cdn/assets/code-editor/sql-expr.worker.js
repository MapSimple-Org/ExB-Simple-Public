class Gb {
  constructor() {
    this.listeners = [], this.unexpectedErrorHandler = function(e) {
      setTimeout(() => {
        throw e.stack ? Ds.isErrorNoTelemetry(e) ? new Ds(e.message + `

` + e.stack) : new Error(e.message + `

` + e.stack) : e;
      }, 0);
    };
  }
  emit(e) {
    this.listeners.forEach((r) => {
      r(e);
    });
  }
  onUnexpectedError(e) {
    this.unexpectedErrorHandler(e), this.emit(e);
  }
  // For external errors, we don't want the listeners to be called
  onUnexpectedExternalError(e) {
    this.unexpectedErrorHandler(e);
  }
}
const Bb = new Gb();
function vi(t) {
  qb(t) || Bb.onUnexpectedError(t);
}
function pd(t) {
  if (t instanceof Error) {
    const { name: e, message: r } = t, n = t.stacktrace || t.stack;
    return {
      $isError: !0,
      name: e,
      message: r,
      stack: n,
      noTelemetry: Ds.isErrorNoTelemetry(t)
    };
  }
  return t;
}
const M1 = "Canceled";
function qb(t) {
  return t instanceof Hb ? !0 : t instanceof Error && t.name === M1 && t.message === M1;
}
class Hb extends Error {
  constructor() {
    super(M1), this.name = this.message;
  }
}
class Ds extends Error {
  constructor(e) {
    super(e), this.name = "CodeExpectedError";
  }
  static fromError(e) {
    if (e instanceof Ds)
      return e;
    const r = new Ds();
    return r.message = e.message, r.stack = e.stack, r;
  }
  static isErrorNoTelemetry(e) {
    return e.name === "CodeExpectedError";
  }
}
class hr extends Error {
  constructor(e) {
    super(e || "An unexpected bug occurred."), Object.setPrototypeOf(this, hr.prototype);
  }
}
function Yb(t, e) {
  const r = this;
  let n = !1, s;
  return function() {
    return n || (n = !0, s = t.apply(r, arguments)), s;
  };
}
var ha;
(function(t) {
  function e(U) {
    return U && typeof U == "object" && typeof U[Symbol.iterator] == "function";
  }
  t.is = e;
  const r = Object.freeze([]);
  function n() {
    return r;
  }
  t.empty = n;
  function* s(U) {
    yield U;
  }
  t.single = s;
  function i(U) {
    return e(U) ? U : s(U);
  }
  t.wrap = i;
  function u(U) {
    return U || r;
  }
  t.from = u;
  function* l(U) {
    for (let $ = U.length - 1; $ >= 0; $--)
      yield U[$];
  }
  t.reverse = l;
  function c(U) {
    return !U || U[Symbol.iterator]().next().done === !0;
  }
  t.isEmpty = c;
  function m(U) {
    return U[Symbol.iterator]().next().value;
  }
  t.first = m;
  function _(U, $) {
    let B = 0;
    for (const Z of U)
      if ($(Z, B++))
        return !0;
    return !1;
  }
  t.some = _;
  function y(U, $) {
    for (const B of U)
      if ($(B))
        return B;
  }
  t.find = y;
  function* v(U, $) {
    for (const B of U)
      $(B) && (yield B);
  }
  t.filter = v;
  function* S(U, $) {
    let B = 0;
    for (const Z of U)
      yield $(Z, B++);
  }
  t.map = S;
  function* T(U, $) {
    let B = 0;
    for (const Z of U)
      yield* $(Z, B++);
  }
  t.flatMap = T;
  function* L(...U) {
    for (const $ of U)
      yield* $;
  }
  t.concat = L;
  function D(U, $, B) {
    let Z = B;
    for (const ee of U)
      Z = $(Z, ee);
    return Z;
  }
  t.reduce = D;
  function* V(U, $, B = U.length) {
    for ($ < 0 && ($ += U.length), B < 0 ? B += U.length : B > U.length && (B = U.length); $ < B; $++)
      yield U[$];
  }
  t.slice = V;
  function W(U, $ = Number.POSITIVE_INFINITY) {
    const B = [];
    if ($ === 0)
      return [B, U];
    const Z = U[Symbol.iterator]();
    for (let ee = 0; ee < $; ee++) {
      const ye = Z.next();
      if (ye.done)
        return [B, t.empty()];
      B.push(ye.value);
    }
    return [B, { [Symbol.iterator]() {
      return Z;
    } }];
  }
  t.consume = W;
  async function j(U) {
    const $ = [];
    for await (const B of U)
      $.push(B);
    return Promise.resolve($);
  }
  t.asyncToArray = j;
})(ha || (ha = {}));
function V2(t) {
  if (ha.is(t)) {
    const e = [];
    for (const r of t)
      if (r)
        try {
          r.dispose();
        } catch (n) {
          e.push(n);
        }
    if (e.length === 1)
      throw e[0];
    if (e.length > 1)
      throw new AggregateError(e, "Encountered errors while disposing of store");
    return Array.isArray(t) ? [] : t;
  } else if (t)
    return t.dispose(), t;
}
function Zb(...t) {
  return da(() => V2(t));
}
function da(t) {
  return {
    dispose: Yb(() => {
      t();
    })
  };
}
class Di {
  static {
    this.DISABLE_DISPOSED_WARNING = !1;
  }
  constructor() {
    this._toDispose = /* @__PURE__ */ new Set(), this._isDisposed = !1;
  }
  /**
   * Dispose of all registered disposables and mark this object as disposed.
   *
   * Any future disposables added to this object will be disposed of on `add`.
   */
  dispose() {
    this._isDisposed || (this._isDisposed = !0, this.clear());
  }
  /**
   * @return `true` if this object has been disposed of.
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Dispose of all registered disposables but do not mark this object as disposed.
   */
  clear() {
    if (this._toDispose.size !== 0)
      try {
        V2(this._toDispose);
      } finally {
        this._toDispose.clear();
      }
  }
  /**
   * Add a new {@link IDisposable disposable} to the collection.
   */
  add(e) {
    if (!e)
      return e;
    if (e === this)
      throw new Error("Cannot register a disposable on itself!");
    return this._isDisposed ? Di.DISABLE_DISPOSED_WARNING || console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack) : this._toDispose.add(e), e;
  }
  /**
   * Deletes the value from the store, but does not dispose it.
   */
  deleteAndLeak(e) {
    e && this._toDispose.has(e) && this._toDispose.delete(e);
  }
}
class ma {
  static {
    this.None = Object.freeze({ dispose() {
    } });
  }
  constructor() {
    this._store = new Di(), this._store;
  }
  dispose() {
    this._store.dispose();
  }
  /**
   * Adds `o` to the collection of disposables managed by this object.
   */
  _register(e) {
    if (e === this)
      throw new Error("Cannot register a disposable on itself!");
    return this._store.add(e);
  }
}
class Ve {
  static {
    this.Undefined = new Ve(void 0);
  }
  constructor(e) {
    this.element = e, this.next = Ve.Undefined, this.prev = Ve.Undefined;
  }
}
class Xb {
  constructor() {
    this._first = Ve.Undefined, this._last = Ve.Undefined, this._size = 0;
  }
  get size() {
    return this._size;
  }
  isEmpty() {
    return this._first === Ve.Undefined;
  }
  clear() {
    let e = this._first;
    for (; e !== Ve.Undefined; ) {
      const r = e.next;
      e.prev = Ve.Undefined, e.next = Ve.Undefined, e = r;
    }
    this._first = Ve.Undefined, this._last = Ve.Undefined, this._size = 0;
  }
  unshift(e) {
    return this._insert(e, !1);
  }
  push(e) {
    return this._insert(e, !0);
  }
  _insert(e, r) {
    const n = new Ve(e);
    if (this._first === Ve.Undefined)
      this._first = n, this._last = n;
    else if (r) {
      const i = this._last;
      this._last = n, n.prev = i, i.next = n;
    } else {
      const i = this._first;
      this._first = n, n.next = i, i.prev = n;
    }
    this._size += 1;
    let s = !1;
    return () => {
      s || (s = !0, this._remove(n));
    };
  }
  shift() {
    if (this._first !== Ve.Undefined) {
      const e = this._first.element;
      return this._remove(this._first), e;
    }
  }
  pop() {
    if (this._last !== Ve.Undefined) {
      const e = this._last.element;
      return this._remove(this._last), e;
    }
  }
  _remove(e) {
    if (e.prev !== Ve.Undefined && e.next !== Ve.Undefined) {
      const r = e.prev;
      r.next = e.next, e.next.prev = r;
    } else e.prev === Ve.Undefined && e.next === Ve.Undefined ? (this._first = Ve.Undefined, this._last = Ve.Undefined) : e.next === Ve.Undefined ? (this._last = this._last.prev, this._last.next = Ve.Undefined) : e.prev === Ve.Undefined && (this._first = this._first.next, this._first.prev = Ve.Undefined);
    this._size -= 1;
  }
  *[Symbol.iterator]() {
    let e = this._first;
    for (; e !== Ve.Undefined; )
      yield e.element, e = e.next;
  }
}
const Jb = globalThis.performance && typeof globalThis.performance.now == "function";
class Ya {
  static create(e) {
    return new Ya(e);
  }
  constructor(e) {
    this._now = Jb && e === !1 ? Date.now : globalThis.performance.now.bind(globalThis.performance), this._startTime = this._now(), this._stopTime = -1;
  }
  stop() {
    this._stopTime = this._now();
  }
  reset() {
    this._startTime = this._now(), this._stopTime = -1;
  }
  elapsed() {
    return this._stopTime !== -1 ? this._stopTime - this._startTime : this._now() - this._startTime;
  }
}
var pa;
(function(t) {
  t.None = () => ma.None;
  function e(K, Y) {
    return v(K, () => {
    }, 0, void 0, !0, void 0, Y);
  }
  t.defer = e;
  function r(K) {
    return (Y, re = null, te) => {
      let ae = !1, ge;
      return ge = K((Te) => {
        if (!ae)
          return ge ? ge.dispose() : ae = !0, Y.call(re, Te);
      }, null, te), ae && ge.dispose(), ge;
    };
  }
  t.once = r;
  function n(K, Y) {
    return t.once(t.filter(K, Y));
  }
  t.onceIf = n;
  function s(K, Y, re) {
    return _((te, ae = null, ge) => K((Te) => te.call(ae, Y(Te)), null, ge), re);
  }
  t.map = s;
  function i(K, Y, re) {
    return _((te, ae = null, ge) => K((Te) => {
      Y(Te), te.call(ae, Te);
    }, null, ge), re);
  }
  t.forEach = i;
  function u(K, Y, re) {
    return _((te, ae = null, ge) => K((Te) => Y(Te) && te.call(ae, Te), null, ge), re);
  }
  t.filter = u;
  function l(K) {
    return K;
  }
  t.signal = l;
  function c(...K) {
    return (Y, re = null, te) => {
      const ae = Zb(...K.map((ge) => ge((Te) => Y.call(re, Te))));
      return y(ae, te);
    };
  }
  t.any = c;
  function m(K, Y, re, te) {
    let ae = re;
    return s(K, (ge) => (ae = Y(ae, ge), ae), te);
  }
  t.reduce = m;
  function _(K, Y) {
    let re;
    const te = {
      onWillAddFirstListener() {
        re = K(ae.fire, ae);
      },
      onDidRemoveLastListener() {
        re?.dispose();
      }
    }, ae = new wr(te);
    return Y?.add(ae), ae.event;
  }
  function y(K, Y) {
    return Y instanceof Array ? Y.push(K) : Y && Y.add(K), K;
  }
  function v(K, Y, re = 100, te = !1, ae = !1, ge, Te) {
    let et, lt, qr, fn = 0, en;
    const is = {
      leakWarningThreshold: ge,
      onWillAddFirstListener() {
        et = K((Ot) => {
          fn++, lt = Y(lt, Ot), te && !qr && (tn.fire(lt), lt = void 0), en = () => {
            const ti = lt;
            lt = void 0, qr = void 0, (!te || fn > 1) && tn.fire(ti), fn = 0;
          }, typeof re == "number" ? (clearTimeout(qr), qr = setTimeout(en, re)) : qr === void 0 && (qr = 0, queueMicrotask(en));
        });
      },
      onWillRemoveListener() {
        ae && fn > 0 && en?.();
      },
      onDidRemoveLastListener() {
        en = void 0, et.dispose();
      }
    }, tn = new wr(is);
    return Te?.add(tn), tn.event;
  }
  t.debounce = v;
  function S(K, Y = 0, re) {
    return t.debounce(K, (te, ae) => te ? (te.push(ae), te) : [ae], Y, void 0, !0, void 0, re);
  }
  t.accumulate = S;
  function T(K, Y = (te, ae) => te === ae, re) {
    let te = !0, ae;
    return u(K, (ge) => {
      const Te = te || !Y(ge, ae);
      return te = !1, ae = ge, Te;
    }, re);
  }
  t.latch = T;
  function L(K, Y, re) {
    return [
      t.filter(K, Y, re),
      t.filter(K, (te) => !Y(te), re)
    ];
  }
  t.split = L;
  function D(K, Y = !1, re = [], te) {
    let ae = re.slice(), ge = K((lt) => {
      ae ? ae.push(lt) : et.fire(lt);
    });
    te && te.add(ge);
    const Te = () => {
      ae?.forEach((lt) => et.fire(lt)), ae = null;
    }, et = new wr({
      onWillAddFirstListener() {
        ge || (ge = K((lt) => et.fire(lt)), te && te.add(ge));
      },
      onDidAddFirstListener() {
        ae && (Y ? setTimeout(Te) : Te());
      },
      onDidRemoveLastListener() {
        ge && ge.dispose(), ge = null;
      }
    });
    return te && te.add(et), et.event;
  }
  t.buffer = D;
  function V(K, Y) {
    return (te, ae, ge) => {
      const Te = Y(new j());
      return K(function(et) {
        const lt = Te.evaluate(et);
        lt !== W && te.call(ae, lt);
      }, void 0, ge);
    };
  }
  t.chain = V;
  const W = Symbol("HaltChainable");
  class j {
    constructor() {
      this.steps = [];
    }
    map(Y) {
      return this.steps.push(Y), this;
    }
    forEach(Y) {
      return this.steps.push((re) => (Y(re), re)), this;
    }
    filter(Y) {
      return this.steps.push((re) => Y(re) ? re : W), this;
    }
    reduce(Y, re) {
      let te = re;
      return this.steps.push((ae) => (te = Y(te, ae), te)), this;
    }
    latch(Y = (re, te) => re === te) {
      let re = !0, te;
      return this.steps.push((ae) => {
        const ge = re || !Y(ae, te);
        return re = !1, te = ae, ge ? ae : W;
      }), this;
    }
    evaluate(Y) {
      for (const re of this.steps)
        if (Y = re(Y), Y === W)
          break;
      return Y;
    }
  }
  function U(K, Y, re = (te) => te) {
    const te = (...et) => Te.fire(re(...et)), ae = () => K.on(Y, te), ge = () => K.removeListener(Y, te), Te = new wr({ onWillAddFirstListener: ae, onDidRemoveLastListener: ge });
    return Te.event;
  }
  t.fromNodeEventEmitter = U;
  function $(K, Y, re = (te) => te) {
    const te = (...et) => Te.fire(re(...et)), ae = () => K.addEventListener(Y, te), ge = () => K.removeEventListener(Y, te), Te = new wr({ onWillAddFirstListener: ae, onDidRemoveLastListener: ge });
    return Te.event;
  }
  t.fromDOMEventEmitter = $;
  function B(K) {
    return new Promise((Y) => r(K)(Y));
  }
  t.toPromise = B;
  function Z(K) {
    const Y = new wr();
    return K.then((re) => {
      Y.fire(re);
    }, () => {
      Y.fire(void 0);
    }).finally(() => {
      Y.dispose();
    }), Y.event;
  }
  t.fromPromise = Z;
  function ee(K, Y) {
    return K((re) => Y.fire(re));
  }
  t.forward = ee;
  function ye(K, Y, re) {
    return Y(re), K((te) => Y(te));
  }
  t.runAndSubscribe = ye;
  class Ie {
    constructor(Y, re) {
      this._observable = Y, this._counter = 0, this._hasChanged = !1;
      const te = {
        onWillAddFirstListener: () => {
          Y.addObserver(this), this._observable.reportChanges();
        },
        onDidRemoveLastListener: () => {
          Y.removeObserver(this);
        }
      };
      this.emitter = new wr(te), re && re.add(this.emitter);
    }
    beginUpdate(Y) {
      this._counter++;
    }
    handlePossibleChange(Y) {
    }
    handleChange(Y, re) {
      this._hasChanged = !0;
    }
    endUpdate(Y) {
      this._counter--, this._counter === 0 && (this._observable.reportChanges(), this._hasChanged && (this._hasChanged = !1, this.emitter.fire(this._observable.get())));
    }
  }
  function ve(K, Y) {
    return new Ie(K, Y).emitter.event;
  }
  t.fromObservable = ve;
  function le(K) {
    return (Y, re, te) => {
      let ae = 0, ge = !1;
      const Te = {
        beginUpdate() {
          ae++;
        },
        endUpdate() {
          ae--, ae === 0 && (K.reportChanges(), ge && (ge = !1, Y.call(re)));
        },
        handlePossibleChange() {
        },
        handleChange() {
          ge = !0;
        }
      };
      K.addObserver(Te), K.reportChanges();
      const et = {
        dispose() {
          K.removeObserver(Te);
        }
      };
      return te instanceof Di ? te.add(et) : Array.isArray(te) && te.push(et), et;
    };
  }
  t.fromObservableLight = le;
})(pa || (pa = {}));
class ga {
  static {
    this.all = /* @__PURE__ */ new Set();
  }
  static {
    this._idPool = 0;
  }
  constructor(e) {
    this.listenerCount = 0, this.invocationCount = 0, this.elapsedOverall = 0, this.durations = [], this.name = `${e}_${ga._idPool++}`, ga.all.add(this);
  }
  start(e) {
    this._stopWatch = new Ya(), this.listenerCount = e;
  }
  stop() {
    if (this._stopWatch) {
      const e = this._stopWatch.elapsed();
      this.durations.push(e), this.elapsedOverall += e, this.invocationCount += 1, this._stopWatch = void 0;
    }
  }
}
let Qb = -1;
class Y0 {
  static {
    this._idPool = 1;
  }
  constructor(e, r, n = (Y0._idPool++).toString(16).padStart(3, "0")) {
    this._errorHandler = e, this.threshold = r, this.name = n, this._warnCountdown = 0;
  }
  dispose() {
    this._stacks?.clear();
  }
  check(e, r) {
    const n = this.threshold;
    if (n <= 0 || r < n)
      return;
    this._stacks || (this._stacks = /* @__PURE__ */ new Map());
    const s = this._stacks.get(e.value) || 0;
    if (this._stacks.set(e.value, s + 1), this._warnCountdown -= 1, this._warnCountdown <= 0) {
      this._warnCountdown = n * 0.5;
      const [i, u] = this.getMostFrequentStack(), l = `[${this.name}] potential listener LEAK detected, having ${r} listeners already. MOST frequent listener (${u}):`;
      console.warn(l), console.warn(i);
      const c = new Kb(l, i);
      this._errorHandler(c);
    }
    return () => {
      const i = this._stacks.get(e.value) || 0;
      this._stacks.set(e.value, i - 1);
    };
  }
  getMostFrequentStack() {
    if (!this._stacks)
      return;
    let e, r = 0;
    for (const [n, s] of this._stacks)
      (!e || r < s) && (e = [n, s], r = s);
    return e;
  }
}
class Z0 {
  static create() {
    const e = new Error();
    return new Z0(e.stack ?? "");
  }
  constructor(e) {
    this.value = e;
  }
  print() {
    console.warn(this.value.split(`
`).slice(2).join(`
`));
  }
}
class Kb extends Error {
  constructor(e, r) {
    super(e), this.name = "ListenerLeakError", this.stack = r;
  }
}
class e6 extends Error {
  constructor(e, r) {
    super(e), this.name = "ListenerRefusalError", this.stack = r;
  }
}
class Wf {
  constructor(e) {
    this.value = e;
  }
}
const t6 = 2;
class wr {
  constructor(e) {
    this._size = 0, this._options = e, this._leakageMon = this._options?.leakWarningThreshold ? new Y0(e?.onListenerError ?? vi, this._options?.leakWarningThreshold ?? Qb) : void 0, this._perfMon = this._options?._profName ? new ga(this._options._profName) : void 0, this._deliveryQueue = this._options?.deliveryQueue;
  }
  dispose() {
    this._disposed || (this._disposed = !0, this._deliveryQueue?.current === this && this._deliveryQueue.reset(), this._listeners && (this._listeners = void 0, this._size = 0), this._options?.onDidRemoveLastListener?.(), this._leakageMon?.dispose());
  }
  /**
   * For the public to allow to subscribe
   * to events from this Emitter
   */
  get event() {
    return this._event ??= (e, r, n) => {
      if (this._leakageMon && this._size > this._leakageMon.threshold ** 2) {
        const l = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;
        console.warn(l);
        const c = this._leakageMon.getMostFrequentStack() ?? ["UNKNOWN stack", -1], m = new e6(`${l}. HINT: Stack shows most frequent listener (${c[1]}-times)`, c[0]);
        return (this._options?.onListenerError || vi)(m), ma.None;
      }
      if (this._disposed)
        return ma.None;
      r && (e = e.bind(r));
      const s = new Wf(e);
      let i;
      this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2) && (s.stack = Z0.create(), i = this._leakageMon.check(s.stack, this._size + 1)), this._listeners ? this._listeners instanceof Wf ? (this._deliveryQueue ??= new r6(), this._listeners = [this._listeners, s]) : this._listeners.push(s) : (this._options?.onWillAddFirstListener?.(this), this._listeners = s, this._options?.onDidAddFirstListener?.(this)), this._size++;
      const u = da(() => {
        i?.(), this._removeListener(s);
      });
      return n instanceof Di ? n.add(u) : Array.isArray(n) && n.push(u), u;
    }, this._event;
  }
  _removeListener(e) {
    if (this._options?.onWillRemoveListener?.(this), !this._listeners)
      return;
    if (this._size === 1) {
      this._listeners = void 0, this._options?.onDidRemoveLastListener?.(this), this._size = 0;
      return;
    }
    const r = this._listeners, n = r.indexOf(e);
    if (n === -1)
      throw console.log("disposed?", this._disposed), console.log("size?", this._size), console.log("arr?", JSON.stringify(this._listeners)), new Error("Attempted to dispose unknown listener");
    this._size--, r[n] = void 0;
    const s = this._deliveryQueue.current === this;
    if (this._size * t6 <= r.length) {
      let i = 0;
      for (let u = 0; u < r.length; u++)
        r[u] ? r[i++] = r[u] : s && (this._deliveryQueue.end--, i < this._deliveryQueue.i && this._deliveryQueue.i--);
      r.length = i;
    }
  }
  _deliver(e, r) {
    if (!e)
      return;
    const n = this._options?.onListenerError || vi;
    if (!n) {
      e.value(r);
      return;
    }
    try {
      e.value(r);
    } catch (s) {
      n(s);
    }
  }
  /** Delivers items in the queue. Assumes the queue is ready to go. */
  _deliverQueue(e) {
    const r = e.current._listeners;
    for (; e.i < e.end; )
      this._deliver(r[e.i++], e.value);
    e.reset();
  }
  /**
   * To be kept private to fire an event to
   * subscribers
   */
  fire(e) {
    if (this._deliveryQueue?.current && (this._deliverQueue(this._deliveryQueue), this._perfMon?.stop()), this._perfMon?.start(this._size), this._listeners) if (this._listeners instanceof Wf)
      this._deliver(this._listeners, e);
    else {
      const r = this._deliveryQueue;
      r.enqueue(this, e, this._listeners.length), this._deliverQueue(r);
    }
    this._perfMon?.stop();
  }
  hasListeners() {
    return this._size > 0;
  }
}
class r6 {
  constructor() {
    this.i = -1, this.end = 0;
  }
  enqueue(e, r, n) {
    this.i = 0, this.end = n, this.current = e, this.value = r;
  }
  reset() {
    this.i = this.end, this.current = void 0, this.value = void 0;
  }
}
function n6() {
  return globalThis._VSCODE_NLS_MESSAGES;
}
function z2() {
  return globalThis._VSCODE_NLS_LANGUAGE;
}
const s6 = z2() === "pseudo" || typeof document < "u" && document.location && document.location.hash.indexOf("pseudo=true") >= 0;
function gd(t, e) {
  let r;
  return e.length === 0 ? r = t : r = t.replace(/\{(\d+)\}/g, (n, s) => {
    const i = s[0], u = e[i];
    let l = n;
    return typeof u == "string" ? l = u : (typeof u == "number" || typeof u == "boolean" || u === void 0 || u === null) && (l = String(u)), l;
  }), s6 && (r = "［" + r.replace(/[aouei]/g, "$&$&") + "］"), r;
}
function je(t, e, ...r) {
  return gd(typeof t == "number" ? i6(t, e) : e, r);
}
function i6(t, e) {
  const r = n6()?.[t];
  if (typeof r != "string") {
    if (typeof e == "string")
      return e;
    throw new Error(`!!! NLS MISSING: ${t} !!!`);
  }
  return r;
}
const Ps = "en";
let O1 = !1, C1 = !1, Gf = !1, j2 = !1, X0 = !1, Lo, Bf = Ps, _d = Ps, o6, sn;
const an = globalThis;
let ur;
typeof an.vscode < "u" && typeof an.vscode.process < "u" ? ur = an.vscode.process : typeof process < "u" && typeof process?.versions?.node == "string" && (ur = process);
const a6 = typeof ur?.versions?.electron == "string", u6 = a6 && ur?.type === "renderer";
if (typeof ur == "object") {
  O1 = ur.platform === "win32", C1 = ur.platform === "darwin", Gf = ur.platform === "linux", Gf && ur.env.SNAP && ur.env.SNAP_REVISION, ur.env.CI || ur.env.BUILD_ARTIFACTSTAGINGDIRECTORY, Lo = Ps, Bf = Ps;
  const t = ur.env.VSCODE_NLS_CONFIG;
  if (t)
    try {
      const e = JSON.parse(t);
      Lo = e.userLocale, _d = e.osLocale, Bf = e.resolvedLanguage || Ps, o6 = e.languagePack?.translationsConfigFile;
    } catch {
    }
  j2 = !0;
} else typeof navigator == "object" && !u6 ? (sn = navigator.userAgent, O1 = sn.indexOf("Windows") >= 0, C1 = sn.indexOf("Macintosh") >= 0, (sn.indexOf("Macintosh") >= 0 || sn.indexOf("iPad") >= 0 || sn.indexOf("iPhone") >= 0) && navigator.maxTouchPoints && navigator.maxTouchPoints > 0, Gf = sn.indexOf("Linux") >= 0, sn?.indexOf("Mobi") >= 0, X0 = !0, Bf = z2() || Ps, Lo = navigator.language.toLowerCase(), _d = Lo) : console.error("Unable to resolve platform.");
const Pi = O1, l6 = C1, c6 = j2, f6 = X0, h6 = X0 && typeof an.importScripts == "function", d6 = h6 ? an.origin : void 0, Kr = sn, m6 = typeof an.postMessage == "function" && !an.importScripts;
(() => {
  if (m6) {
    const t = [];
    an.addEventListener("message", (r) => {
      if (r.data && r.data.vscodeScheduleAsyncWork)
        for (let n = 0, s = t.length; n < s; n++) {
          const i = t[n];
          if (i.id === r.data.vscodeScheduleAsyncWork) {
            t.splice(n, 1), i.callback();
            return;
          }
        }
    });
    let e = 0;
    return (r) => {
      const n = ++e;
      t.push({
        id: n,
        callback: r
      }), an.postMessage({ vscodeScheduleAsyncWork: n }, "*");
    };
  }
  return (t) => setTimeout(t);
})();
const p6 = !!(Kr && Kr.indexOf("Chrome") >= 0);
Kr && Kr.indexOf("Firefox") >= 0;
!p6 && Kr && Kr.indexOf("Safari") >= 0;
Kr && Kr.indexOf("Edg/") >= 0;
Kr && Kr.indexOf("Android") >= 0;
function g6(t) {
  return t;
}
class _6 {
  constructor(e, r) {
    this.lastCache = void 0, this.lastArgKey = void 0, typeof e == "function" ? (this._fn = e, this._computeKey = g6) : (this._fn = r, this._computeKey = e.getCacheKey);
  }
  get(e) {
    const r = this._computeKey(e);
    return this.lastArgKey !== r && (this.lastArgKey = r, this.lastCache = this._fn(e)), this.lastCache;
  }
}
class yd {
  constructor(e) {
    this.executor = e, this._didRun = !1;
  }
  /**
   * Get the wrapped value.
   *
   * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only
   * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value
   */
  get value() {
    if (!this._didRun)
      try {
        this._value = this.executor();
      } catch (e) {
        this._error = e;
      } finally {
        this._didRun = !0;
      }
    if (this._error)
      throw this._error;
    return this._value;
  }
  /**
   * Get the wrapped value without forcing evaluation.
   */
  get rawValue() {
    return this._value;
  }
}
function y6(t) {
  return t.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
}
function b6(t) {
  return t.split(/\r\n|\r|\n/);
}
function w6(t) {
  for (let e = 0, r = t.length; e < r; e++) {
    const n = t.charCodeAt(e);
    if (n !== 32 && n !== 9)
      return e;
  }
  return -1;
}
function v6(t, e = t.length - 1) {
  for (let r = e; r >= 0; r--) {
    const n = t.charCodeAt(r);
    if (n !== 32 && n !== 9)
      return r;
  }
  return -1;
}
function W2(t) {
  return t >= 65 && t <= 90;
}
function R1(t) {
  return 55296 <= t && t <= 56319;
}
function S6(t) {
  return 56320 <= t && t <= 57343;
}
function E6(t, e) {
  return (t - 55296 << 10) + (e - 56320) + 65536;
}
function N6(t, e, r) {
  const n = t.charCodeAt(r);
  if (R1(n) && r + 1 < e) {
    const s = t.charCodeAt(r + 1);
    if (S6(s))
      return E6(n, s);
  }
  return n;
}
const x6 = /^[\t\n\r\x20-\x7E]*$/;
function T6(t) {
  return x6.test(t);
}
class An {
  static {
    this.ambiguousCharacterData = new yd(() => JSON.parse('{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],"_default":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"cs":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"es":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"fr":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"it":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ja":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],"ko":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pt-BR":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ru":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"zh-hans":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],"zh-hant":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}'));
  }
  static {
    this.cache = new _6({ getCacheKey: JSON.stringify }, (e) => {
      function r(_) {
        const y = /* @__PURE__ */ new Map();
        for (let v = 0; v < _.length; v += 2)
          y.set(_[v], _[v + 1]);
        return y;
      }
      function n(_, y) {
        const v = new Map(_);
        for (const [S, T] of y)
          v.set(S, T);
        return v;
      }
      function s(_, y) {
        if (!_)
          return y;
        const v = /* @__PURE__ */ new Map();
        for (const [S, T] of _)
          y.has(S) && v.set(S, T);
        return v;
      }
      const i = this.ambiguousCharacterData.value;
      let u = e.filter((_) => !_.startsWith("_") && _ in i);
      u.length === 0 && (u = ["_default"]);
      let l;
      for (const _ of u) {
        const y = r(i[_]);
        l = s(l, y);
      }
      const c = r(i._common), m = n(c, l);
      return new An(m);
    });
  }
  static getInstance(e) {
    return An.cache.get(Array.from(e));
  }
  static {
    this._locales = new yd(() => Object.keys(An.ambiguousCharacterData.value).filter((e) => !e.startsWith("_")));
  }
  static getLocales() {
    return An._locales.value;
  }
  constructor(e) {
    this.confusableDictionary = e;
  }
  isAmbiguous(e) {
    return this.confusableDictionary.has(e);
  }
  /**
   * Returns the non basic ASCII code point that the given code point can be confused,
   * or undefined if such code point does note exist.
   */
  getPrimaryConfusable(e) {
    return this.confusableDictionary.get(e);
  }
  getConfusableCodePoints() {
    return new Set(this.confusableDictionary.keys());
  }
}
class Xn {
  static getRawData() {
    return JSON.parse("[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]");
  }
  static {
    this._data = void 0;
  }
  static getData() {
    return this._data || (this._data = new Set(Xn.getRawData())), this._data;
  }
  static isInvisibleCharacter(e) {
    return Xn.getData().has(e);
  }
  static get codePoints() {
    return Xn.getData();
  }
}
let Os;
const qf = globalThis.vscode;
if (typeof qf < "u" && typeof qf.process < "u") {
  const t = qf.process;
  Os = {
    get platform() {
      return t.platform;
    },
    get arch() {
      return t.arch;
    },
    get env() {
      return t.env;
    },
    cwd() {
      return t.cwd();
    }
  };
} else typeof process < "u" && typeof process?.versions?.node == "string" ? Os = {
  get platform() {
    return process.platform;
  },
  get arch() {
    return process.arch;
  },
  get env() {
    return process.env;
  },
  cwd() {
    return process.env.VSCODE_CWD || process.cwd();
  }
} : Os = {
  // Supported
  get platform() {
    return Pi ? "win32" : l6 ? "darwin" : "linux";
  },
  get arch() {
  },
  // Unsupported
  get env() {
    return {};
  },
  cwd() {
    return "/";
  }
};
const _a = Os.cwd, P6 = Os.env, A6 = Os.platform, L6 = 65, M6 = 97, O6 = 90, C6 = 122, On = 46, Mt = 47, er = 92, pn = 58, R6 = 63;
class G2 extends Error {
  constructor(e, r, n) {
    let s;
    typeof r == "string" && r.indexOf("not ") === 0 ? (s = "must not be", r = r.replace(/^not /, "")) : s = "must be";
    const i = e.indexOf(".") !== -1 ? "property" : "argument";
    let u = `The "${e}" ${i} ${s} of type ${r}`;
    u += `. Received type ${typeof n}`, super(u), this.code = "ERR_INVALID_ARG_TYPE";
  }
}
function I6(t, e) {
  if (t === null || typeof t != "object")
    throw new G2(e, "Object", t);
}
function rt(t, e) {
  if (typeof t != "string")
    throw new G2(e, "string", t);
}
const cn = A6 === "win32";
function we(t) {
  return t === Mt || t === er;
}
function I1(t) {
  return t === Mt;
}
function gn(t) {
  return t >= L6 && t <= O6 || t >= M6 && t <= C6;
}
function ya(t, e, r, n) {
  let s = "", i = 0, u = -1, l = 0, c = 0;
  for (let m = 0; m <= t.length; ++m) {
    if (m < t.length)
      c = t.charCodeAt(m);
    else {
      if (n(c))
        break;
      c = Mt;
    }
    if (n(c)) {
      if (!(u === m - 1 || l === 1)) if (l === 2) {
        if (s.length < 2 || i !== 2 || s.charCodeAt(s.length - 1) !== On || s.charCodeAt(s.length - 2) !== On) {
          if (s.length > 2) {
            const _ = s.lastIndexOf(r);
            _ === -1 ? (s = "", i = 0) : (s = s.slice(0, _), i = s.length - 1 - s.lastIndexOf(r)), u = m, l = 0;
            continue;
          } else if (s.length !== 0) {
            s = "", i = 0, u = m, l = 0;
            continue;
          }
        }
        e && (s += s.length > 0 ? `${r}..` : "..", i = 2);
      } else
        s.length > 0 ? s += `${r}${t.slice(u + 1, m)}` : s = t.slice(u + 1, m), i = m - u - 1;
      u = m, l = 0;
    } else c === On && l !== -1 ? ++l : l = -1;
  }
  return s;
}
function k6(t) {
  return t ? `${t[0] === "." ? "" : "."}${t}` : "";
}
function B2(t, e) {
  I6(e, "pathObject");
  const r = e.dir || e.root, n = e.base || `${e.name || ""}${k6(e.ext)}`;
  return r ? r === e.root ? `${r}${n}` : `${r}${t}${n}` : n;
}
const Gt = {
  // path.resolve([from ...], to)
  resolve(...t) {
    let e = "", r = "", n = !1;
    for (let s = t.length - 1; s >= -1; s--) {
      let i;
      if (s >= 0) {
        if (i = t[s], rt(i, `paths[${s}]`), i.length === 0)
          continue;
      } else e.length === 0 ? i = _a() : (i = P6[`=${e}`] || _a(), (i === void 0 || i.slice(0, 2).toLowerCase() !== e.toLowerCase() && i.charCodeAt(2) === er) && (i = `${e}\\`));
      const u = i.length;
      let l = 0, c = "", m = !1;
      const _ = i.charCodeAt(0);
      if (u === 1)
        we(_) && (l = 1, m = !0);
      else if (we(_))
        if (m = !0, we(i.charCodeAt(1))) {
          let y = 2, v = y;
          for (; y < u && !we(i.charCodeAt(y)); )
            y++;
          if (y < u && y !== v) {
            const S = i.slice(v, y);
            for (v = y; y < u && we(i.charCodeAt(y)); )
              y++;
            if (y < u && y !== v) {
              for (v = y; y < u && !we(i.charCodeAt(y)); )
                y++;
              (y === u || y !== v) && (c = `\\\\${S}\\${i.slice(v, y)}`, l = y);
            }
          }
        } else
          l = 1;
      else gn(_) && i.charCodeAt(1) === pn && (c = i.slice(0, 2), l = 2, u > 2 && we(i.charCodeAt(2)) && (m = !0, l = 3));
      if (c.length > 0)
        if (e.length > 0) {
          if (c.toLowerCase() !== e.toLowerCase())
            continue;
        } else
          e = c;
      if (n) {
        if (e.length > 0)
          break;
      } else if (r = `${i.slice(l)}\\${r}`, n = m, m && e.length > 0)
        break;
    }
    return r = ya(r, !n, "\\", we), n ? `${e}\\${r}` : `${e}${r}` || ".";
  },
  normalize(t) {
    rt(t, "path");
    const e = t.length;
    if (e === 0)
      return ".";
    let r = 0, n, s = !1;
    const i = t.charCodeAt(0);
    if (e === 1)
      return I1(i) ? "\\" : t;
    if (we(i))
      if (s = !0, we(t.charCodeAt(1))) {
        let l = 2, c = l;
        for (; l < e && !we(t.charCodeAt(l)); )
          l++;
        if (l < e && l !== c) {
          const m = t.slice(c, l);
          for (c = l; l < e && we(t.charCodeAt(l)); )
            l++;
          if (l < e && l !== c) {
            for (c = l; l < e && !we(t.charCodeAt(l)); )
              l++;
            if (l === e)
              return `\\\\${m}\\${t.slice(c)}\\`;
            l !== c && (n = `\\\\${m}\\${t.slice(c, l)}`, r = l);
          }
        }
      } else
        r = 1;
    else gn(i) && t.charCodeAt(1) === pn && (n = t.slice(0, 2), r = 2, e > 2 && we(t.charCodeAt(2)) && (s = !0, r = 3));
    let u = r < e ? ya(t.slice(r), !s, "\\", we) : "";
    return u.length === 0 && !s && (u = "."), u.length > 0 && we(t.charCodeAt(e - 1)) && (u += "\\"), n === void 0 ? s ? `\\${u}` : u : s ? `${n}\\${u}` : `${n}${u}`;
  },
  isAbsolute(t) {
    rt(t, "path");
    const e = t.length;
    if (e === 0)
      return !1;
    const r = t.charCodeAt(0);
    return we(r) || // Possible device root
    e > 2 && gn(r) && t.charCodeAt(1) === pn && we(t.charCodeAt(2));
  },
  join(...t) {
    if (t.length === 0)
      return ".";
    let e, r;
    for (let i = 0; i < t.length; ++i) {
      const u = t[i];
      rt(u, "path"), u.length > 0 && (e === void 0 ? e = r = u : e += `\\${u}`);
    }
    if (e === void 0)
      return ".";
    let n = !0, s = 0;
    if (typeof r == "string" && we(r.charCodeAt(0))) {
      ++s;
      const i = r.length;
      i > 1 && we(r.charCodeAt(1)) && (++s, i > 2 && (we(r.charCodeAt(2)) ? ++s : n = !1));
    }
    if (n) {
      for (; s < e.length && we(e.charCodeAt(s)); )
        s++;
      s >= 2 && (e = `\\${e.slice(s)}`);
    }
    return Gt.normalize(e);
  },
  // It will solve the relative path from `from` to `to`, for instance:
  //  from = 'C:\\orandea\\test\\aaa'
  //  to = 'C:\\orandea\\impl\\bbb'
  // The output of the function should be: '..\\..\\impl\\bbb'
  relative(t, e) {
    if (rt(t, "from"), rt(e, "to"), t === e)
      return "";
    const r = Gt.resolve(t), n = Gt.resolve(e);
    if (r === n || (t = r.toLowerCase(), e = n.toLowerCase(), t === e))
      return "";
    let s = 0;
    for (; s < t.length && t.charCodeAt(s) === er; )
      s++;
    let i = t.length;
    for (; i - 1 > s && t.charCodeAt(i - 1) === er; )
      i--;
    const u = i - s;
    let l = 0;
    for (; l < e.length && e.charCodeAt(l) === er; )
      l++;
    let c = e.length;
    for (; c - 1 > l && e.charCodeAt(c - 1) === er; )
      c--;
    const m = c - l, _ = u < m ? u : m;
    let y = -1, v = 0;
    for (; v < _; v++) {
      const T = t.charCodeAt(s + v);
      if (T !== e.charCodeAt(l + v))
        break;
      T === er && (y = v);
    }
    if (v !== _) {
      if (y === -1)
        return n;
    } else {
      if (m > _) {
        if (e.charCodeAt(l + v) === er)
          return n.slice(l + v + 1);
        if (v === 2)
          return n.slice(l + v);
      }
      u > _ && (t.charCodeAt(s + v) === er ? y = v : v === 2 && (y = 3)), y === -1 && (y = 0);
    }
    let S = "";
    for (v = s + y + 1; v <= i; ++v)
      (v === i || t.charCodeAt(v) === er) && (S += S.length === 0 ? ".." : "\\..");
    return l += y, S.length > 0 ? `${S}${n.slice(l, c)}` : (n.charCodeAt(l) === er && ++l, n.slice(l, c));
  },
  toNamespacedPath(t) {
    if (typeof t != "string" || t.length === 0)
      return t;
    const e = Gt.resolve(t);
    if (e.length <= 2)
      return t;
    if (e.charCodeAt(0) === er) {
      if (e.charCodeAt(1) === er) {
        const r = e.charCodeAt(2);
        if (r !== R6 && r !== On)
          return `\\\\?\\UNC\\${e.slice(2)}`;
      }
    } else if (gn(e.charCodeAt(0)) && e.charCodeAt(1) === pn && e.charCodeAt(2) === er)
      return `\\\\?\\${e}`;
    return t;
  },
  dirname(t) {
    rt(t, "path");
    const e = t.length;
    if (e === 0)
      return ".";
    let r = -1, n = 0;
    const s = t.charCodeAt(0);
    if (e === 1)
      return we(s) ? t : ".";
    if (we(s)) {
      if (r = n = 1, we(t.charCodeAt(1))) {
        let l = 2, c = l;
        for (; l < e && !we(t.charCodeAt(l)); )
          l++;
        if (l < e && l !== c) {
          for (c = l; l < e && we(t.charCodeAt(l)); )
            l++;
          if (l < e && l !== c) {
            for (c = l; l < e && !we(t.charCodeAt(l)); )
              l++;
            if (l === e)
              return t;
            l !== c && (r = n = l + 1);
          }
        }
      }
    } else gn(s) && t.charCodeAt(1) === pn && (r = e > 2 && we(t.charCodeAt(2)) ? 3 : 2, n = r);
    let i = -1, u = !0;
    for (let l = e - 1; l >= n; --l)
      if (we(t.charCodeAt(l))) {
        if (!u) {
          i = l;
          break;
        }
      } else
        u = !1;
    if (i === -1) {
      if (r === -1)
        return ".";
      i = r;
    }
    return t.slice(0, i);
  },
  basename(t, e) {
    e !== void 0 && rt(e, "suffix"), rt(t, "path");
    let r = 0, n = -1, s = !0, i;
    if (t.length >= 2 && gn(t.charCodeAt(0)) && t.charCodeAt(1) === pn && (r = 2), e !== void 0 && e.length > 0 && e.length <= t.length) {
      if (e === t)
        return "";
      let u = e.length - 1, l = -1;
      for (i = t.length - 1; i >= r; --i) {
        const c = t.charCodeAt(i);
        if (we(c)) {
          if (!s) {
            r = i + 1;
            break;
          }
        } else
          l === -1 && (s = !1, l = i + 1), u >= 0 && (c === e.charCodeAt(u) ? --u === -1 && (n = i) : (u = -1, n = l));
      }
      return r === n ? n = l : n === -1 && (n = t.length), t.slice(r, n);
    }
    for (i = t.length - 1; i >= r; --i)
      if (we(t.charCodeAt(i))) {
        if (!s) {
          r = i + 1;
          break;
        }
      } else n === -1 && (s = !1, n = i + 1);
    return n === -1 ? "" : t.slice(r, n);
  },
  extname(t) {
    rt(t, "path");
    let e = 0, r = -1, n = 0, s = -1, i = !0, u = 0;
    t.length >= 2 && t.charCodeAt(1) === pn && gn(t.charCodeAt(0)) && (e = n = 2);
    for (let l = t.length - 1; l >= e; --l) {
      const c = t.charCodeAt(l);
      if (we(c)) {
        if (!i) {
          n = l + 1;
          break;
        }
        continue;
      }
      s === -1 && (i = !1, s = l + 1), c === On ? r === -1 ? r = l : u !== 1 && (u = 1) : r !== -1 && (u = -1);
    }
    return r === -1 || s === -1 || // We saw a non-dot character immediately before the dot
    u === 0 || // The (right-most) trimmed path component is exactly '..'
    u === 1 && r === s - 1 && r === n + 1 ? "" : t.slice(r, s);
  },
  format: B2.bind(null, "\\"),
  parse(t) {
    rt(t, "path");
    const e = { root: "", dir: "", base: "", ext: "", name: "" };
    if (t.length === 0)
      return e;
    const r = t.length;
    let n = 0, s = t.charCodeAt(0);
    if (r === 1)
      return we(s) ? (e.root = e.dir = t, e) : (e.base = e.name = t, e);
    if (we(s)) {
      if (n = 1, we(t.charCodeAt(1))) {
        let y = 2, v = y;
        for (; y < r && !we(t.charCodeAt(y)); )
          y++;
        if (y < r && y !== v) {
          for (v = y; y < r && we(t.charCodeAt(y)); )
            y++;
          if (y < r && y !== v) {
            for (v = y; y < r && !we(t.charCodeAt(y)); )
              y++;
            y === r ? n = y : y !== v && (n = y + 1);
          }
        }
      }
    } else if (gn(s) && t.charCodeAt(1) === pn) {
      if (r <= 2)
        return e.root = e.dir = t, e;
      if (n = 2, we(t.charCodeAt(2))) {
        if (r === 3)
          return e.root = e.dir = t, e;
        n = 3;
      }
    }
    n > 0 && (e.root = t.slice(0, n));
    let i = -1, u = n, l = -1, c = !0, m = t.length - 1, _ = 0;
    for (; m >= n; --m) {
      if (s = t.charCodeAt(m), we(s)) {
        if (!c) {
          u = m + 1;
          break;
        }
        continue;
      }
      l === -1 && (c = !1, l = m + 1), s === On ? i === -1 ? i = m : _ !== 1 && (_ = 1) : i !== -1 && (_ = -1);
    }
    return l !== -1 && (i === -1 || // We saw a non-dot character immediately before the dot
    _ === 0 || // The (right-most) trimmed path component is exactly '..'
    _ === 1 && i === l - 1 && i === u + 1 ? e.base = e.name = t.slice(u, l) : (e.name = t.slice(u, i), e.base = t.slice(u, l), e.ext = t.slice(i, l))), u > 0 && u !== n ? e.dir = t.slice(0, u - 1) : e.dir = e.root, e;
  },
  sep: "\\",
  delimiter: ";",
  win32: null,
  posix: null
}, D6 = (() => {
  if (cn) {
    const t = /\\/g;
    return () => {
      const e = _a().replace(t, "/");
      return e.slice(e.indexOf("/"));
    };
  }
  return () => _a();
})(), Bt = {
  // path.resolve([from ...], to)
  resolve(...t) {
    let e = "", r = !1;
    for (let n = t.length - 1; n >= -1 && !r; n--) {
      const s = n >= 0 ? t[n] : D6();
      rt(s, `paths[${n}]`), s.length !== 0 && (e = `${s}/${e}`, r = s.charCodeAt(0) === Mt);
    }
    return e = ya(e, !r, "/", I1), r ? `/${e}` : e.length > 0 ? e : ".";
  },
  normalize(t) {
    if (rt(t, "path"), t.length === 0)
      return ".";
    const e = t.charCodeAt(0) === Mt, r = t.charCodeAt(t.length - 1) === Mt;
    return t = ya(t, !e, "/", I1), t.length === 0 ? e ? "/" : r ? "./" : "." : (r && (t += "/"), e ? `/${t}` : t);
  },
  isAbsolute(t) {
    return rt(t, "path"), t.length > 0 && t.charCodeAt(0) === Mt;
  },
  join(...t) {
    if (t.length === 0)
      return ".";
    let e;
    for (let r = 0; r < t.length; ++r) {
      const n = t[r];
      rt(n, "path"), n.length > 0 && (e === void 0 ? e = n : e += `/${n}`);
    }
    return e === void 0 ? "." : Bt.normalize(e);
  },
  relative(t, e) {
    if (rt(t, "from"), rt(e, "to"), t === e || (t = Bt.resolve(t), e = Bt.resolve(e), t === e))
      return "";
    const r = 1, n = t.length, s = n - r, i = 1, u = e.length - i, l = s < u ? s : u;
    let c = -1, m = 0;
    for (; m < l; m++) {
      const y = t.charCodeAt(r + m);
      if (y !== e.charCodeAt(i + m))
        break;
      y === Mt && (c = m);
    }
    if (m === l)
      if (u > l) {
        if (e.charCodeAt(i + m) === Mt)
          return e.slice(i + m + 1);
        if (m === 0)
          return e.slice(i + m);
      } else s > l && (t.charCodeAt(r + m) === Mt ? c = m : m === 0 && (c = 0));
    let _ = "";
    for (m = r + c + 1; m <= n; ++m)
      (m === n || t.charCodeAt(m) === Mt) && (_ += _.length === 0 ? ".." : "/..");
    return `${_}${e.slice(i + c)}`;
  },
  toNamespacedPath(t) {
    return t;
  },
  dirname(t) {
    if (rt(t, "path"), t.length === 0)
      return ".";
    const e = t.charCodeAt(0) === Mt;
    let r = -1, n = !0;
    for (let s = t.length - 1; s >= 1; --s)
      if (t.charCodeAt(s) === Mt) {
        if (!n) {
          r = s;
          break;
        }
      } else
        n = !1;
    return r === -1 ? e ? "/" : "." : e && r === 1 ? "//" : t.slice(0, r);
  },
  basename(t, e) {
    e !== void 0 && rt(e, "ext"), rt(t, "path");
    let r = 0, n = -1, s = !0, i;
    if (e !== void 0 && e.length > 0 && e.length <= t.length) {
      if (e === t)
        return "";
      let u = e.length - 1, l = -1;
      for (i = t.length - 1; i >= 0; --i) {
        const c = t.charCodeAt(i);
        if (c === Mt) {
          if (!s) {
            r = i + 1;
            break;
          }
        } else
          l === -1 && (s = !1, l = i + 1), u >= 0 && (c === e.charCodeAt(u) ? --u === -1 && (n = i) : (u = -1, n = l));
      }
      return r === n ? n = l : n === -1 && (n = t.length), t.slice(r, n);
    }
    for (i = t.length - 1; i >= 0; --i)
      if (t.charCodeAt(i) === Mt) {
        if (!s) {
          r = i + 1;
          break;
        }
      } else n === -1 && (s = !1, n = i + 1);
    return n === -1 ? "" : t.slice(r, n);
  },
  extname(t) {
    rt(t, "path");
    let e = -1, r = 0, n = -1, s = !0, i = 0;
    for (let u = t.length - 1; u >= 0; --u) {
      const l = t.charCodeAt(u);
      if (l === Mt) {
        if (!s) {
          r = u + 1;
          break;
        }
        continue;
      }
      n === -1 && (s = !1, n = u + 1), l === On ? e === -1 ? e = u : i !== 1 && (i = 1) : e !== -1 && (i = -1);
    }
    return e === -1 || n === -1 || // We saw a non-dot character immediately before the dot
    i === 0 || // The (right-most) trimmed path component is exactly '..'
    i === 1 && e === n - 1 && e === r + 1 ? "" : t.slice(e, n);
  },
  format: B2.bind(null, "/"),
  parse(t) {
    rt(t, "path");
    const e = { root: "", dir: "", base: "", ext: "", name: "" };
    if (t.length === 0)
      return e;
    const r = t.charCodeAt(0) === Mt;
    let n;
    r ? (e.root = "/", n = 1) : n = 0;
    let s = -1, i = 0, u = -1, l = !0, c = t.length - 1, m = 0;
    for (; c >= n; --c) {
      const _ = t.charCodeAt(c);
      if (_ === Mt) {
        if (!l) {
          i = c + 1;
          break;
        }
        continue;
      }
      u === -1 && (l = !1, u = c + 1), _ === On ? s === -1 ? s = c : m !== 1 && (m = 1) : s !== -1 && (m = -1);
    }
    if (u !== -1) {
      const _ = i === 0 && r ? 1 : i;
      s === -1 || // We saw a non-dot character immediately before the dot
      m === 0 || // The (right-most) trimmed path component is exactly '..'
      m === 1 && s === u - 1 && s === i + 1 ? e.base = e.name = t.slice(_, u) : (e.name = t.slice(_, s), e.base = t.slice(_, u), e.ext = t.slice(s, u));
    }
    return i > 0 ? e.dir = t.slice(0, i - 1) : r && (e.dir = "/"), e;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
};
Bt.win32 = Gt.win32 = Gt;
Bt.posix = Gt.posix = Bt;
cn ? Gt.normalize : Bt.normalize;
const $6 = cn ? Gt.join : Bt.join;
cn ? Gt.resolve : Bt.resolve;
cn ? Gt.relative : Bt.relative;
cn ? Gt.dirname : Bt.dirname;
cn ? Gt.basename : Bt.basename;
cn ? Gt.extname : Bt.extname;
cn ? Gt.sep : Bt.sep;
const F6 = /^\w[\w\d+.-]*$/, U6 = /^\//, V6 = /^\/\//;
function z6(t, e) {
  if (!t.scheme && e)
    throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t.authority}", path: "${t.path}", query: "${t.query}", fragment: "${t.fragment}"}`);
  if (t.scheme && !F6.test(t.scheme))
    throw new Error("[UriError]: Scheme contains illegal characters.");
  if (t.path) {
    if (t.authority) {
      if (!U6.test(t.path))
        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
    } else if (V6.test(t.path))
      throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
  }
}
function j6(t, e) {
  return !t && !e ? "file" : t;
}
function W6(t, e) {
  switch (t) {
    case "https":
    case "http":
    case "file":
      e ? e[0] !== $r && (e = $r + e) : e = $r;
      break;
  }
  return e;
}
const Ue = "", $r = "/", G6 = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
let Jr = class Go {
  static isUri(e) {
    return e instanceof Go ? !0 : e ? typeof e.authority == "string" && typeof e.fragment == "string" && typeof e.path == "string" && typeof e.query == "string" && typeof e.scheme == "string" && typeof e.fsPath == "string" && typeof e.with == "function" && typeof e.toString == "function" : !1;
  }
  /**
   * @internal
   */
  constructor(e, r, n, s, i, u = !1) {
    typeof e == "object" ? (this.scheme = e.scheme || Ue, this.authority = e.authority || Ue, this.path = e.path || Ue, this.query = e.query || Ue, this.fragment = e.fragment || Ue) : (this.scheme = j6(e, u), this.authority = r || Ue, this.path = W6(this.scheme, n || Ue), this.query = s || Ue, this.fragment = i || Ue, z6(this, u));
  }
  // ---- filesystem path -----------------------
  /**
   * Returns a string representing the corresponding file system path of this URI.
   * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
   * platform specific path separator.
   *
   * * Will *not* validate the path for invalid characters and semantics.
   * * Will *not* look at the scheme of this URI.
   * * The result shall *not* be used for display purposes but for accessing a file on disk.
   *
   *
   * The *difference* to `URI#path` is the use of the platform specific separator and the handling
   * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
   *
   * ```ts
      const u = URI.parse('file://server/c$/folder/file.txt')
      u.authority === 'server'
      u.path === '/shares/c$/file.txt'
      u.fsPath === '\\server\c$\folder\file.txt'
  ```
   *
   * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
   * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
   * with URIs that represent files on disk (`file` scheme).
   */
  get fsPath() {
    return k1(this, !1);
  }
  // ---- modify to new -------------------------
  with(e) {
    if (!e)
      return this;
    let { scheme: r, authority: n, path: s, query: i, fragment: u } = e;
    return r === void 0 ? r = this.scheme : r === null && (r = Ue), n === void 0 ? n = this.authority : n === null && (n = Ue), s === void 0 ? s = this.path : s === null && (s = Ue), i === void 0 ? i = this.query : i === null && (i = Ue), u === void 0 ? u = this.fragment : u === null && (u = Ue), r === this.scheme && n === this.authority && s === this.path && i === this.query && u === this.fragment ? this : new ls(r, n, s, i, u);
  }
  // ---- parse & validate ------------------------
  /**
   * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,
   * `file:///usr/home`, or `scheme:with/path`.
   *
   * @param value A string which represents an URI (see `URI#toString`).
   */
  static parse(e, r = !1) {
    const n = G6.exec(e);
    return n ? new ls(n[2] || Ue, Mo(n[4] || Ue), Mo(n[5] || Ue), Mo(n[7] || Ue), Mo(n[9] || Ue), r) : new ls(Ue, Ue, Ue, Ue, Ue);
  }
  /**
   * Creates a new URI from a file system path, e.g. `c:\my\files`,
   * `/usr/home`, or `\\server\share\some\path`.
   *
   * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
   * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
   * `URI.parse('file://' + path)` because the path might contain characters that are
   * interpreted (# and ?). See the following sample:
   * ```ts
  const good = URI.file('/coding/c#/project1');
  good.scheme === 'file';
  good.path === '/coding/c#/project1';
  good.fragment === '';
  const bad = URI.parse('file://' + '/coding/c#/project1');
  bad.scheme === 'file';
  bad.path === '/coding/c'; // path is now broken
  bad.fragment === '/project1';
  ```
   *
   * @param path A file system path (see `URI#fsPath`)
   */
  static file(e) {
    let r = Ue;
    if (Pi && (e = e.replace(/\\/g, $r)), e[0] === $r && e[1] === $r) {
      const n = e.indexOf($r, 2);
      n === -1 ? (r = e.substring(2), e = $r) : (r = e.substring(2, n), e = e.substring(n) || $r);
    }
    return new ls("file", r, e, Ue, Ue);
  }
  /**
   * Creates new URI from uri components.
   *
   * Unless `strict` is `true` the scheme is defaults to be `file`. This function performs
   * validation and should be used for untrusted uri components retrieved from storage,
   * user input, command arguments etc
   */
  static from(e, r) {
    return new ls(e.scheme, e.authority, e.path, e.query, e.fragment, r);
  }
  /**
   * Join a URI path with path fragments and normalizes the resulting path.
   *
   * @param uri The input URI.
   * @param pathFragment The path fragment to add to the URI path.
   * @returns The resulting URI.
   */
  static joinPath(e, ...r) {
    if (!e.path)
      throw new Error("[UriError]: cannot call joinPath on URI without path");
    let n;
    return Pi && e.scheme === "file" ? n = Go.file(Gt.join(k1(e, !0), ...r)).path : n = Bt.join(e.path, ...r), e.with({ path: n });
  }
  // ---- printing/externalize ---------------------------
  /**
   * Creates a string representation for this URI. It's guaranteed that calling
   * `URI.parse` with the result of this function creates an URI which is equal
   * to this URI.
   *
   * * The result shall *not* be used for display purposes but for externalization or transport.
   * * The result will be encoded using the percentage encoding and encoding happens mostly
   * ignore the scheme-specific encoding rules.
   *
   * @param skipEncoding Do not encode the result, default is `false`
   */
  toString(e = !1) {
    return D1(this, e);
  }
  toJSON() {
    return this;
  }
  static revive(e) {
    if (e) {
      if (e instanceof Go)
        return e;
      {
        const r = new ls(e);
        return r._formatted = e.external ?? null, r._fsPath = e._sep === q2 ? e.fsPath ?? null : null, r;
      }
    } else return e;
  }
};
const q2 = Pi ? 1 : void 0;
class ls extends Jr {
  constructor() {
    super(...arguments), this._formatted = null, this._fsPath = null;
  }
  get fsPath() {
    return this._fsPath || (this._fsPath = k1(this, !1)), this._fsPath;
  }
  toString(e = !1) {
    return e ? D1(this, !0) : (this._formatted || (this._formatted = D1(this, !1)), this._formatted);
  }
  toJSON() {
    const e = {
      $mid: 1
      /* MarshalledId.Uri */
    };
    return this._fsPath && (e.fsPath = this._fsPath, e._sep = q2), this._formatted && (e.external = this._formatted), this.path && (e.path = this.path), this.scheme && (e.scheme = this.scheme), this.authority && (e.authority = this.authority), this.query && (e.query = this.query), this.fragment && (e.fragment = this.fragment), e;
  }
}
const H2 = {
  58: "%3A",
  // gen-delims
  47: "%2F",
  63: "%3F",
  35: "%23",
  91: "%5B",
  93: "%5D",
  64: "%40",
  33: "%21",
  // sub-delims
  36: "%24",
  38: "%26",
  39: "%27",
  40: "%28",
  41: "%29",
  42: "%2A",
  43: "%2B",
  44: "%2C",
  59: "%3B",
  61: "%3D",
  32: "%20"
};
function bd(t, e, r) {
  let n, s = -1;
  for (let i = 0; i < t.length; i++) {
    const u = t.charCodeAt(i);
    if (u >= 97 && u <= 122 || u >= 65 && u <= 90 || u >= 48 && u <= 57 || u === 45 || u === 46 || u === 95 || u === 126 || e && u === 47 || r && u === 91 || r && u === 93 || r && u === 58)
      s !== -1 && (n += encodeURIComponent(t.substring(s, i)), s = -1), n !== void 0 && (n += t.charAt(i));
    else {
      n === void 0 && (n = t.substr(0, i));
      const l = H2[u];
      l !== void 0 ? (s !== -1 && (n += encodeURIComponent(t.substring(s, i)), s = -1), n += l) : s === -1 && (s = i);
    }
  }
  return s !== -1 && (n += encodeURIComponent(t.substring(s))), n !== void 0 ? n : t;
}
function B6(t) {
  let e;
  for (let r = 0; r < t.length; r++) {
    const n = t.charCodeAt(r);
    n === 35 || n === 63 ? (e === void 0 && (e = t.substr(0, r)), e += H2[n]) : e !== void 0 && (e += t[r]);
  }
  return e !== void 0 ? e : t;
}
function k1(t, e) {
  let r;
  return t.authority && t.path.length > 1 && t.scheme === "file" ? r = `//${t.authority}${t.path}` : t.path.charCodeAt(0) === 47 && (t.path.charCodeAt(1) >= 65 && t.path.charCodeAt(1) <= 90 || t.path.charCodeAt(1) >= 97 && t.path.charCodeAt(1) <= 122) && t.path.charCodeAt(2) === 58 ? e ? r = t.path.substr(1) : r = t.path[1].toLowerCase() + t.path.substr(2) : r = t.path, Pi && (r = r.replace(/\//g, "\\")), r;
}
function D1(t, e) {
  const r = e ? B6 : bd;
  let n = "", { scheme: s, authority: i, path: u, query: l, fragment: c } = t;
  if (s && (n += s, n += ":"), (i || s === "file") && (n += $r, n += $r), i) {
    let m = i.indexOf("@");
    if (m !== -1) {
      const _ = i.substr(0, m);
      i = i.substr(m + 1), m = _.lastIndexOf(":"), m === -1 ? n += r(_, !1, !1) : (n += r(_.substr(0, m), !1, !1), n += ":", n += r(_.substr(m + 1), !1, !0)), n += "@";
    }
    i = i.toLowerCase(), m = i.lastIndexOf(":"), m === -1 ? n += r(i, !1, !0) : (n += r(i.substr(0, m), !1, !0), n += i.substr(m));
  }
  if (u) {
    if (u.length >= 3 && u.charCodeAt(0) === 47 && u.charCodeAt(2) === 58) {
      const m = u.charCodeAt(1);
      m >= 65 && m <= 90 && (u = `/${String.fromCharCode(m + 32)}:${u.substr(3)}`);
    } else if (u.length >= 2 && u.charCodeAt(1) === 58) {
      const m = u.charCodeAt(0);
      m >= 65 && m <= 90 && (u = `${String.fromCharCode(m + 32)}:${u.substr(2)}`);
    }
    n += r(u, !0, !1);
  }
  return l && (n += "?", n += r(l, !1, !1)), c && (n += "#", n += e ? c : bd(c, !1, !1)), n;
}
function Y2(t) {
  try {
    return decodeURIComponent(t);
  } catch {
    return t.length > 3 ? t.substr(0, 3) + Y2(t.substr(3)) : t;
  }
}
const wd = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
function Mo(t) {
  return t.match(wd) ? t.replace(wd, (e) => Y2(e)) : t;
}
var Ln;
(function(t) {
  t.inMemory = "inmemory", t.vscode = "vscode", t.internal = "private", t.walkThrough = "walkThrough", t.walkThroughSnippet = "walkThroughSnippet", t.http = "http", t.https = "https", t.file = "file", t.mailto = "mailto", t.untitled = "untitled", t.data = "data", t.command = "command", t.vscodeRemote = "vscode-remote", t.vscodeRemoteResource = "vscode-remote-resource", t.vscodeManagedRemoteResource = "vscode-managed-remote-resource", t.vscodeUserData = "vscode-userdata", t.vscodeCustomEditor = "vscode-custom-editor", t.vscodeNotebookCell = "vscode-notebook-cell", t.vscodeNotebookCellMetadata = "vscode-notebook-cell-metadata", t.vscodeNotebookCellMetadataDiff = "vscode-notebook-cell-metadata-diff", t.vscodeNotebookCellOutput = "vscode-notebook-cell-output", t.vscodeNotebookCellOutputDiff = "vscode-notebook-cell-output-diff", t.vscodeNotebookMetadata = "vscode-notebook-metadata", t.vscodeInteractiveInput = "vscode-interactive-input", t.vscodeSettings = "vscode-settings", t.vscodeWorkspaceTrust = "vscode-workspace-trust", t.vscodeTerminal = "vscode-terminal", t.vscodeChatCodeBlock = "vscode-chat-code-block", t.vscodeChatCodeCompareBlock = "vscode-chat-code-compare-block", t.vscodeChatSesssion = "vscode-chat-editor", t.webviewPanel = "webview-panel", t.vscodeWebview = "vscode-webview", t.extension = "extension", t.vscodeFileResource = "vscode-file", t.tmp = "tmp", t.vsls = "vsls", t.vscodeSourceControl = "vscode-scm", t.commentsInput = "comment", t.codeSetting = "code-setting", t.outputChannel = "output";
})(Ln || (Ln = {}));
const q6 = "tkn";
class H6 {
  constructor() {
    this._hosts = /* @__PURE__ */ Object.create(null), this._ports = /* @__PURE__ */ Object.create(null), this._connectionTokens = /* @__PURE__ */ Object.create(null), this._preferredWebSchema = "http", this._delegate = null, this._serverRootPath = "/";
  }
  setPreferredWebSchema(e) {
    this._preferredWebSchema = e;
  }
  get _remoteResourcesPath() {
    return Bt.join(this._serverRootPath, Ln.vscodeRemoteResource);
  }
  rewrite(e) {
    if (this._delegate)
      try {
        return this._delegate(e);
      } catch (l) {
        return vi(l), e;
      }
    const r = e.authority;
    let n = this._hosts[r];
    n && n.indexOf(":") !== -1 && n.indexOf("[") === -1 && (n = `[${n}]`);
    const s = this._ports[r], i = this._connectionTokens[r];
    let u = `path=${encodeURIComponent(e.path)}`;
    return typeof i == "string" && (u += `&${q6}=${encodeURIComponent(i)}`), Jr.from({
      scheme: f6 ? this._preferredWebSchema : Ln.vscodeRemoteResource,
      authority: `${n}:${s}`,
      path: this._remoteResourcesPath,
      query: u
    });
  }
}
const Y6 = new H6(), Z6 = "vscode-app";
class ba {
  static {
    this.FALLBACK_AUTHORITY = Z6;
  }
  /**
   * Returns a URI to use in contexts where the browser is responsible
   * for loading (e.g. fetch()) or when used within the DOM.
   *
   * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
   */
  asBrowserUri(e) {
    const r = this.toUri(e);
    return this.uriToBrowserUri(r);
  }
  /**
   * Returns a URI to use in contexts where the browser is responsible
   * for loading (e.g. fetch()) or when used within the DOM.
   *
   * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
   */
  uriToBrowserUri(e) {
    return e.scheme === Ln.vscodeRemote ? Y6.rewrite(e) : (
      // ...only ever for `file` resources
      e.scheme === Ln.file && // ...and we run in native environments
      (c6 || // ...or web worker extensions on desktop
      d6 === `${Ln.vscodeFileResource}://${ba.FALLBACK_AUTHORITY}`) ? e.with({
        scheme: Ln.vscodeFileResource,
        // We need to provide an authority here so that it can serve
        // as origin for network and loading matters in chromium.
        // If the URI is not coming with an authority already, we
        // add our own
        authority: e.authority || ba.FALLBACK_AUTHORITY,
        query: null,
        fragment: null
      }) : e
    );
  }
  toUri(e, r) {
    if (Jr.isUri(e))
      return e;
    if (globalThis._VSCODE_FILE_ROOT) {
      const n = globalThis._VSCODE_FILE_ROOT;
      if (/^\w[\w\d+.-]*:\/\//.test(n))
        return Jr.joinPath(Jr.parse(n, !0), e);
      const s = $6(n, e);
      return Jr.file(s);
    }
    return Jr.parse(r.toUrl(e));
  }
}
const Z2 = new ba();
var vd;
(function(t) {
  const e = /* @__PURE__ */ new Map([
    ["1", { "Cross-Origin-Opener-Policy": "same-origin" }],
    ["2", { "Cross-Origin-Embedder-Policy": "require-corp" }],
    ["3", { "Cross-Origin-Opener-Policy": "same-origin", "Cross-Origin-Embedder-Policy": "require-corp" }]
  ]);
  t.CoopAndCoep = Object.freeze(e.get("3"));
  const r = "vscode-coi";
  function n(i) {
    let u;
    typeof i == "string" ? u = new URL(i).searchParams : i instanceof URL ? u = i.searchParams : Jr.isUri(i) && (u = new URL(i.toString(!0)).searchParams);
    const l = u?.get(r);
    if (l)
      return e.get(l);
  }
  t.getHeadersFromQuery = n;
  function s(i, u, l) {
    if (!globalThis.crossOriginIsolated)
      return;
    const c = u && l ? "3" : l ? "2" : "1";
    i instanceof URLSearchParams ? i.set(r, c) : i[r] = c;
  }
  t.addSearchParam = s;
})(vd || (vd = {}));
const Hf = "default", X6 = "$initialize";
class J6 {
  constructor(e, r, n, s, i) {
    this.vsWorker = e, this.req = r, this.channel = n, this.method = s, this.args = i, this.type = 0;
  }
}
class Sd {
  constructor(e, r, n, s) {
    this.vsWorker = e, this.seq = r, this.res = n, this.err = s, this.type = 1;
  }
}
class Q6 {
  constructor(e, r, n, s, i) {
    this.vsWorker = e, this.req = r, this.channel = n, this.eventName = s, this.arg = i, this.type = 2;
  }
}
class K6 {
  constructor(e, r, n) {
    this.vsWorker = e, this.req = r, this.event = n, this.type = 3;
  }
}
class e5 {
  constructor(e, r) {
    this.vsWorker = e, this.req = r, this.type = 4;
  }
}
class t5 {
  constructor(e) {
    this._workerId = -1, this._handler = e, this._lastSentReq = 0, this._pendingReplies = /* @__PURE__ */ Object.create(null), this._pendingEmitters = /* @__PURE__ */ new Map(), this._pendingEvents = /* @__PURE__ */ new Map();
  }
  setWorkerId(e) {
    this._workerId = e;
  }
  sendMessage(e, r, n) {
    const s = String(++this._lastSentReq);
    return new Promise((i, u) => {
      this._pendingReplies[s] = {
        resolve: i,
        reject: u
      }, this._send(new J6(this._workerId, s, e, r, n));
    });
  }
  listen(e, r, n) {
    let s = null;
    const i = new wr({
      onWillAddFirstListener: () => {
        s = String(++this._lastSentReq), this._pendingEmitters.set(s, i), this._send(new Q6(this._workerId, s, e, r, n));
      },
      onDidRemoveLastListener: () => {
        this._pendingEmitters.delete(s), this._send(new e5(this._workerId, s)), s = null;
      }
    });
    return i.event;
  }
  handleMessage(e) {
    !e || !e.vsWorker || this._workerId !== -1 && e.vsWorker !== this._workerId || this._handleMessage(e);
  }
  createProxyToRemoteChannel(e, r) {
    const n = {
      get: (s, i) => (typeof i == "string" && !s[i] && (J2(i) ? s[i] = (u) => this.listen(e, i, u) : X2(i) ? s[i] = this.listen(e, i, void 0) : i.charCodeAt(0) === 36 && (s[i] = async (...u) => (await r?.(), this.sendMessage(e, i, u)))), s[i])
    };
    return new Proxy(/* @__PURE__ */ Object.create(null), n);
  }
  _handleMessage(e) {
    switch (e.type) {
      case 1:
        return this._handleReplyMessage(e);
      case 0:
        return this._handleRequestMessage(e);
      case 2:
        return this._handleSubscribeEventMessage(e);
      case 3:
        return this._handleEventMessage(e);
      case 4:
        return this._handleUnsubscribeEventMessage(e);
    }
  }
  _handleReplyMessage(e) {
    if (!this._pendingReplies[e.seq]) {
      console.warn("Got reply to unknown seq");
      return;
    }
    const r = this._pendingReplies[e.seq];
    if (delete this._pendingReplies[e.seq], e.err) {
      let n = e.err;
      e.err.$isError && (n = new Error(), n.name = e.err.name, n.message = e.err.message, n.stack = e.err.stack), r.reject(n);
      return;
    }
    r.resolve(e.res);
  }
  _handleRequestMessage(e) {
    const r = e.req;
    this._handler.handleMessage(e.channel, e.method, e.args).then((s) => {
      this._send(new Sd(this._workerId, r, s, void 0));
    }, (s) => {
      s.detail instanceof Error && (s.detail = pd(s.detail)), this._send(new Sd(this._workerId, r, void 0, pd(s)));
    });
  }
  _handleSubscribeEventMessage(e) {
    const r = e.req, n = this._handler.handleEvent(e.channel, e.eventName, e.arg)((s) => {
      this._send(new K6(this._workerId, r, s));
    });
    this._pendingEvents.set(r, n);
  }
  _handleEventMessage(e) {
    if (!this._pendingEmitters.has(e.req)) {
      console.warn("Got event for unknown req");
      return;
    }
    this._pendingEmitters.get(e.req).fire(e.event);
  }
  _handleUnsubscribeEventMessage(e) {
    if (!this._pendingEvents.has(e.req)) {
      console.warn("Got unsubscribe for unknown req");
      return;
    }
    this._pendingEvents.get(e.req).dispose(), this._pendingEvents.delete(e.req);
  }
  _send(e) {
    const r = [];
    if (e.type === 0)
      for (let n = 0; n < e.args.length; n++)
        e.args[n] instanceof ArrayBuffer && r.push(e.args[n]);
    else e.type === 1 && e.res instanceof ArrayBuffer && r.push(e.res);
    this._handler.sendMessage(e, r);
  }
}
function X2(t) {
  return t[0] === "o" && t[1] === "n" && W2(t.charCodeAt(2));
}
function J2(t) {
  return /^onDynamic/.test(t) && W2(t.charCodeAt(9));
}
class r5 {
  constructor(e, r) {
    this._localChannels = /* @__PURE__ */ new Map(), this._remoteChannels = /* @__PURE__ */ new Map(), this._requestHandlerFactory = r, this._requestHandler = null, this._protocol = new t5({
      sendMessage: (n, s) => {
        e(n, s);
      },
      handleMessage: (n, s, i) => this._handleMessage(n, s, i),
      handleEvent: (n, s, i) => this._handleEvent(n, s, i)
    });
  }
  onmessage(e) {
    this._protocol.handleMessage(e);
  }
  _handleMessage(e, r, n) {
    if (e === Hf && r === X6)
      return this.initialize(n[0], n[1], n[2]);
    const s = e === Hf ? this._requestHandler : this._localChannels.get(e);
    if (!s)
      return Promise.reject(new Error(`Missing channel ${e} on worker thread`));
    if (typeof s[r] != "function")
      return Promise.reject(new Error(`Missing method ${r} on worker thread channel ${e}`));
    try {
      return Promise.resolve(s[r].apply(s, n));
    } catch (i) {
      return Promise.reject(i);
    }
  }
  _handleEvent(e, r, n) {
    const s = e === Hf ? this._requestHandler : this._localChannels.get(e);
    if (!s)
      throw new Error(`Missing channel ${e} on worker thread`);
    if (J2(r)) {
      const i = s[r].call(s, n);
      if (typeof i != "function")
        throw new Error(`Missing dynamic event ${r} on request handler.`);
      return i;
    }
    if (X2(r)) {
      const i = s[r];
      if (typeof i != "function")
        throw new Error(`Missing event ${r} on request handler.`);
      return i;
    }
    throw new Error(`Malformed event name ${r}`);
  }
  getChannel(e) {
    if (!this._remoteChannels.has(e)) {
      const r = this._protocol.createProxyToRemoteChannel(e);
      this._remoteChannels.set(e, r);
    }
    return this._remoteChannels.get(e);
  }
  async initialize(e, r, n) {
    if (this._protocol.setWorkerId(e), this._requestHandlerFactory) {
      this._requestHandler = this._requestHandlerFactory(this);
      return;
    }
    return r && (typeof r.baseUrl < "u" && delete r.baseUrl, typeof r.paths < "u" && typeof r.paths.vs < "u" && delete r.paths.vs, typeof r.trustedTypesPolicy < "u" && delete r.trustedTypesPolicy, r.catchError = !0, globalThis.require.config(r)), import(`${Z2.asBrowserUri(`${n}.js`).toString(!0)}`).then((i) => {
      if (this._requestHandler = i.create(this), !this._requestHandler)
        throw new Error("No RequestHandler!");
    });
  }
}
class Sn {
  /**
   * Constructs a new DiffChange with the given sequence information
   * and content.
   */
  constructor(e, r, n, s) {
    this.originalStart = e, this.originalLength = r, this.modifiedStart = n, this.modifiedLength = s;
  }
  /**
   * The end point (exclusive) of the change in the original sequence.
   */
  getOriginalEnd() {
    return this.originalStart + this.originalLength;
  }
  /**
   * The end point (exclusive) of the change in the modified sequence.
   */
  getModifiedEnd() {
    return this.modifiedStart + this.modifiedLength;
  }
}
function Ed(t, e) {
  return (e << 5) - e + t | 0;
}
function n5(t, e) {
  e = Ed(149417, e);
  for (let r = 0, n = t.length; r < n; r++)
    e = Ed(t.charCodeAt(r), e);
  return e;
}
class Nd {
  constructor(e) {
    this.source = e;
  }
  getElements() {
    const e = this.source, r = new Int32Array(e.length);
    for (let n = 0, s = e.length; n < s; n++)
      r[n] = e.charCodeAt(n);
    return r;
  }
}
function s5(t, e, r) {
  return new Tn(new Nd(t), new Nd(e)).ComputeDiff(r).changes;
}
class cs {
  static Assert(e, r) {
    if (!e)
      throw new Error(r);
  }
}
class fs {
  /**
   * Copies a range of elements from an Array starting at the specified source index and pastes
   * them to another Array starting at the specified destination index. The length and the indexes
   * are specified as 64-bit integers.
   * sourceArray:
   *		The Array that contains the data to copy.
   * sourceIndex:
   *		A 64-bit integer that represents the index in the sourceArray at which copying begins.
   * destinationArray:
   *		The Array that receives the data.
   * destinationIndex:
   *		A 64-bit integer that represents the index in the destinationArray at which storing begins.
   * length:
   *		A 64-bit integer that represents the number of elements to copy.
   */
  static Copy(e, r, n, s, i) {
    for (let u = 0; u < i; u++)
      n[s + u] = e[r + u];
  }
  static Copy2(e, r, n, s, i) {
    for (let u = 0; u < i; u++)
      n[s + u] = e[r + u];
  }
}
class xd {
  /**
   * Constructs a new DiffChangeHelper for the given DiffSequences.
   */
  constructor() {
    this.m_changes = [], this.m_originalStart = 1073741824, this.m_modifiedStart = 1073741824, this.m_originalCount = 0, this.m_modifiedCount = 0;
  }
  /**
   * Marks the beginning of the next change in the set of differences.
   */
  MarkNextChange() {
    (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.m_changes.push(new Sn(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount)), this.m_originalCount = 0, this.m_modifiedCount = 0, this.m_originalStart = 1073741824, this.m_modifiedStart = 1073741824;
  }
  /**
   * Adds the original element at the given position to the elements
   * affected by the current change. The modified index gives context
   * to the change position with respect to the original sequence.
   * @param originalIndex The index of the original element to add.
   * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.
   */
  AddOriginalElement(e, r) {
    this.m_originalStart = Math.min(this.m_originalStart, e), this.m_modifiedStart = Math.min(this.m_modifiedStart, r), this.m_originalCount++;
  }
  /**
   * Adds the modified element at the given position to the elements
   * affected by the current change. The original index gives context
   * to the change position with respect to the modified sequence.
   * @param originalIndex The index of the original element that provides corresponding position in the original sequence.
   * @param modifiedIndex The index of the modified element to add.
   */
  AddModifiedElement(e, r) {
    this.m_originalStart = Math.min(this.m_originalStart, e), this.m_modifiedStart = Math.min(this.m_modifiedStart, r), this.m_modifiedCount++;
  }
  /**
   * Retrieves all of the changes marked by the class.
   */
  getChanges() {
    return (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.MarkNextChange(), this.m_changes;
  }
  /**
   * Retrieves all of the changes marked by the class in the reverse order
   */
  getReverseChanges() {
    return (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.MarkNextChange(), this.m_changes.reverse(), this.m_changes;
  }
}
class Tn {
  /**
   * Constructs the DiffFinder
   */
  constructor(e, r, n = null) {
    this.ContinueProcessingPredicate = n, this._originalSequence = e, this._modifiedSequence = r;
    const [s, i, u] = Tn._getElements(e), [l, c, m] = Tn._getElements(r);
    this._hasStrings = u && m, this._originalStringElements = s, this._originalElementsOrHash = i, this._modifiedStringElements = l, this._modifiedElementsOrHash = c, this.m_forwardHistory = [], this.m_reverseHistory = [];
  }
  static _isStringArray(e) {
    return e.length > 0 && typeof e[0] == "string";
  }
  static _getElements(e) {
    const r = e.getElements();
    if (Tn._isStringArray(r)) {
      const n = new Int32Array(r.length);
      for (let s = 0, i = r.length; s < i; s++)
        n[s] = n5(r[s], 0);
      return [r, n, !0];
    }
    return r instanceof Int32Array ? [[], r, !1] : [[], new Int32Array(r), !1];
  }
  ElementsAreEqual(e, r) {
    return this._originalElementsOrHash[e] !== this._modifiedElementsOrHash[r] ? !1 : this._hasStrings ? this._originalStringElements[e] === this._modifiedStringElements[r] : !0;
  }
  ElementsAreStrictEqual(e, r) {
    if (!this.ElementsAreEqual(e, r))
      return !1;
    const n = Tn._getStrictElement(this._originalSequence, e), s = Tn._getStrictElement(this._modifiedSequence, r);
    return n === s;
  }
  static _getStrictElement(e, r) {
    return typeof e.getStrictElement == "function" ? e.getStrictElement(r) : null;
  }
  OriginalElementsAreEqual(e, r) {
    return this._originalElementsOrHash[e] !== this._originalElementsOrHash[r] ? !1 : this._hasStrings ? this._originalStringElements[e] === this._originalStringElements[r] : !0;
  }
  ModifiedElementsAreEqual(e, r) {
    return this._modifiedElementsOrHash[e] !== this._modifiedElementsOrHash[r] ? !1 : this._hasStrings ? this._modifiedStringElements[e] === this._modifiedStringElements[r] : !0;
  }
  ComputeDiff(e) {
    return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, e);
  }
  /**
   * Computes the differences between the original and modified input
   * sequences on the bounded range.
   * @returns An array of the differences between the two input sequences.
   */
  _ComputeDiff(e, r, n, s, i) {
    const u = [!1];
    let l = this.ComputeDiffRecursive(e, r, n, s, u);
    return i && (l = this.PrettifyChanges(l)), {
      quitEarly: u[0],
      changes: l
    };
  }
  /**
   * Private helper method which computes the differences on the bounded range
   * recursively.
   * @returns An array of the differences between the two input sequences.
   */
  ComputeDiffRecursive(e, r, n, s, i) {
    for (i[0] = !1; e <= r && n <= s && this.ElementsAreEqual(e, n); )
      e++, n++;
    for (; r >= e && s >= n && this.ElementsAreEqual(r, s); )
      r--, s--;
    if (e > r || n > s) {
      let y;
      return n <= s ? (cs.Assert(e === r + 1, "originalStart should only be one more than originalEnd"), y = [
        new Sn(e, 0, n, s - n + 1)
      ]) : e <= r ? (cs.Assert(n === s + 1, "modifiedStart should only be one more than modifiedEnd"), y = [
        new Sn(e, r - e + 1, n, 0)
      ]) : (cs.Assert(e === r + 1, "originalStart should only be one more than originalEnd"), cs.Assert(n === s + 1, "modifiedStart should only be one more than modifiedEnd"), y = []), y;
    }
    const u = [0], l = [0], c = this.ComputeRecursionPoint(e, r, n, s, u, l, i), m = u[0], _ = l[0];
    if (c !== null)
      return c;
    if (!i[0]) {
      const y = this.ComputeDiffRecursive(e, m, n, _, i);
      let v = [];
      return i[0] ? v = [
        new Sn(m + 1, r - (m + 1) + 1, _ + 1, s - (_ + 1) + 1)
      ] : v = this.ComputeDiffRecursive(m + 1, r, _ + 1, s, i), this.ConcatenateChanges(y, v);
    }
    return [
      new Sn(e, r - e + 1, n, s - n + 1)
    ];
  }
  WALKTRACE(e, r, n, s, i, u, l, c, m, _, y, v, S, T, L, D, V, W) {
    let j = null, U = null, $ = new xd(), B = r, Z = n, ee = S[0] - D[0] - s, ye = -1073741824, Ie = this.m_forwardHistory.length - 1;
    do {
      const ve = ee + e;
      ve === B || ve < Z && m[ve - 1] < m[ve + 1] ? (y = m[ve + 1], T = y - ee - s, y < ye && $.MarkNextChange(), ye = y, $.AddModifiedElement(y + 1, T), ee = ve + 1 - e) : (y = m[ve - 1] + 1, T = y - ee - s, y < ye && $.MarkNextChange(), ye = y - 1, $.AddOriginalElement(y, T + 1), ee = ve - 1 - e), Ie >= 0 && (m = this.m_forwardHistory[Ie], e = m[0], B = 1, Z = m.length - 1);
    } while (--Ie >= -1);
    if (j = $.getReverseChanges(), W[0]) {
      let ve = S[0] + 1, le = D[0] + 1;
      if (j !== null && j.length > 0) {
        const K = j[j.length - 1];
        ve = Math.max(ve, K.getOriginalEnd()), le = Math.max(le, K.getModifiedEnd());
      }
      U = [
        new Sn(ve, v - ve + 1, le, L - le + 1)
      ];
    } else {
      $ = new xd(), B = u, Z = l, ee = S[0] - D[0] - c, ye = 1073741824, Ie = V ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
      do {
        const ve = ee + i;
        ve === B || ve < Z && _[ve - 1] >= _[ve + 1] ? (y = _[ve + 1] - 1, T = y - ee - c, y > ye && $.MarkNextChange(), ye = y + 1, $.AddOriginalElement(y + 1, T + 1), ee = ve + 1 - i) : (y = _[ve - 1], T = y - ee - c, y > ye && $.MarkNextChange(), ye = y, $.AddModifiedElement(y + 1, T + 1), ee = ve - 1 - i), Ie >= 0 && (_ = this.m_reverseHistory[Ie], i = _[0], B = 1, Z = _.length - 1);
      } while (--Ie >= -1);
      U = $.getChanges();
    }
    return this.ConcatenateChanges(j, U);
  }
  /**
   * Given the range to compute the diff on, this method finds the point:
   * (midOriginal, midModified)
   * that exists in the middle of the LCS of the two sequences and
   * is the point at which the LCS problem may be broken down recursively.
   * This method will try to keep the LCS trace in memory. If the LCS recursion
   * point is calculated and the full trace is available in memory, then this method
   * will return the change list.
   * @param originalStart The start bound of the original sequence range
   * @param originalEnd The end bound of the original sequence range
   * @param modifiedStart The start bound of the modified sequence range
   * @param modifiedEnd The end bound of the modified sequence range
   * @param midOriginal The middle point of the original sequence range
   * @param midModified The middle point of the modified sequence range
   * @returns The diff changes, if available, otherwise null
   */
  ComputeRecursionPoint(e, r, n, s, i, u, l) {
    let c = 0, m = 0, _ = 0, y = 0, v = 0, S = 0;
    e--, n--, i[0] = 0, u[0] = 0, this.m_forwardHistory = [], this.m_reverseHistory = [];
    const T = r - e + (s - n), L = T + 1, D = new Int32Array(L), V = new Int32Array(L), W = s - n, j = r - e, U = e - n, $ = r - s, Z = (j - W) % 2 === 0;
    D[W] = e, V[j] = r, l[0] = !1;
    for (let ee = 1; ee <= T / 2 + 1; ee++) {
      let ye = 0, Ie = 0;
      _ = this.ClipDiagonalBound(W - ee, ee, W, L), y = this.ClipDiagonalBound(W + ee, ee, W, L);
      for (let le = _; le <= y; le += 2) {
        le === _ || le < y && D[le - 1] < D[le + 1] ? c = D[le + 1] : c = D[le - 1] + 1, m = c - (le - W) - U;
        const K = c;
        for (; c < r && m < s && this.ElementsAreEqual(c + 1, m + 1); )
          c++, m++;
        if (D[le] = c, c + m > ye + Ie && (ye = c, Ie = m), !Z && Math.abs(le - j) <= ee - 1 && c >= V[le])
          return i[0] = c, u[0] = m, K <= V[le] && ee <= 1448 ? this.WALKTRACE(W, _, y, U, j, v, S, $, D, V, c, r, i, m, s, u, Z, l) : null;
      }
      const ve = (ye - e + (Ie - n) - ee) / 2;
      if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(ye, ve))
        return l[0] = !0, i[0] = ye, u[0] = Ie, ve > 0 && ee <= 1448 ? this.WALKTRACE(W, _, y, U, j, v, S, $, D, V, c, r, i, m, s, u, Z, l) : (e++, n++, [
          new Sn(e, r - e + 1, n, s - n + 1)
        ]);
      v = this.ClipDiagonalBound(j - ee, ee, j, L), S = this.ClipDiagonalBound(j + ee, ee, j, L);
      for (let le = v; le <= S; le += 2) {
        le === v || le < S && V[le - 1] >= V[le + 1] ? c = V[le + 1] - 1 : c = V[le - 1], m = c - (le - j) - $;
        const K = c;
        for (; c > e && m > n && this.ElementsAreEqual(c, m); )
          c--, m--;
        if (V[le] = c, Z && Math.abs(le - W) <= ee && c <= D[le])
          return i[0] = c, u[0] = m, K >= D[le] && ee <= 1448 ? this.WALKTRACE(W, _, y, U, j, v, S, $, D, V, c, r, i, m, s, u, Z, l) : null;
      }
      if (ee <= 1447) {
        let le = new Int32Array(y - _ + 2);
        le[0] = W - _ + 1, fs.Copy2(D, _, le, 1, y - _ + 1), this.m_forwardHistory.push(le), le = new Int32Array(S - v + 2), le[0] = j - v + 1, fs.Copy2(V, v, le, 1, S - v + 1), this.m_reverseHistory.push(le);
      }
    }
    return this.WALKTRACE(W, _, y, U, j, v, S, $, D, V, c, r, i, m, s, u, Z, l);
  }
  /**
   * Shifts the given changes to provide a more intuitive diff.
   * While the first element in a diff matches the first element after the diff,
   * we shift the diff down.
   *
   * @param changes The list of changes to shift
   * @returns The shifted changes
   */
  PrettifyChanges(e) {
    for (let r = 0; r < e.length; r++) {
      const n = e[r], s = r < e.length - 1 ? e[r + 1].originalStart : this._originalElementsOrHash.length, i = r < e.length - 1 ? e[r + 1].modifiedStart : this._modifiedElementsOrHash.length, u = n.originalLength > 0, l = n.modifiedLength > 0;
      for (; n.originalStart + n.originalLength < s && n.modifiedStart + n.modifiedLength < i && (!u || this.OriginalElementsAreEqual(n.originalStart, n.originalStart + n.originalLength)) && (!l || this.ModifiedElementsAreEqual(n.modifiedStart, n.modifiedStart + n.modifiedLength)); ) {
        const m = this.ElementsAreStrictEqual(n.originalStart, n.modifiedStart);
        if (this.ElementsAreStrictEqual(n.originalStart + n.originalLength, n.modifiedStart + n.modifiedLength) && !m)
          break;
        n.originalStart++, n.modifiedStart++;
      }
      const c = [null];
      if (r < e.length - 1 && this.ChangesOverlap(e[r], e[r + 1], c)) {
        e[r] = c[0], e.splice(r + 1, 1), r--;
        continue;
      }
    }
    for (let r = e.length - 1; r >= 0; r--) {
      const n = e[r];
      let s = 0, i = 0;
      if (r > 0) {
        const y = e[r - 1];
        s = y.originalStart + y.originalLength, i = y.modifiedStart + y.modifiedLength;
      }
      const u = n.originalLength > 0, l = n.modifiedLength > 0;
      let c = 0, m = this._boundaryScore(n.originalStart, n.originalLength, n.modifiedStart, n.modifiedLength);
      for (let y = 1; ; y++) {
        const v = n.originalStart - y, S = n.modifiedStart - y;
        if (v < s || S < i || u && !this.OriginalElementsAreEqual(v, v + n.originalLength) || l && !this.ModifiedElementsAreEqual(S, S + n.modifiedLength))
          break;
        const L = (v === s && S === i ? 5 : 0) + this._boundaryScore(v, n.originalLength, S, n.modifiedLength);
        L > m && (m = L, c = y);
      }
      n.originalStart -= c, n.modifiedStart -= c;
      const _ = [null];
      if (r > 0 && this.ChangesOverlap(e[r - 1], e[r], _)) {
        e[r - 1] = _[0], e.splice(r, 1), r++;
        continue;
      }
    }
    if (this._hasStrings)
      for (let r = 1, n = e.length; r < n; r++) {
        const s = e[r - 1], i = e[r], u = i.originalStart - s.originalStart - s.originalLength, l = s.originalStart, c = i.originalStart + i.originalLength, m = c - l, _ = s.modifiedStart, y = i.modifiedStart + i.modifiedLength, v = y - _;
        if (u < 5 && m < 20 && v < 20) {
          const S = this._findBetterContiguousSequence(l, m, _, v, u);
          if (S) {
            const [T, L] = S;
            (T !== s.originalStart + s.originalLength || L !== s.modifiedStart + s.modifiedLength) && (s.originalLength = T - s.originalStart, s.modifiedLength = L - s.modifiedStart, i.originalStart = T + u, i.modifiedStart = L + u, i.originalLength = c - i.originalStart, i.modifiedLength = y - i.modifiedStart);
          }
        }
      }
    return e;
  }
  _findBetterContiguousSequence(e, r, n, s, i) {
    if (r < i || s < i)
      return null;
    const u = e + r - i + 1, l = n + s - i + 1;
    let c = 0, m = 0, _ = 0;
    for (let y = e; y < u; y++)
      for (let v = n; v < l; v++) {
        const S = this._contiguousSequenceScore(y, v, i);
        S > 0 && S > c && (c = S, m = y, _ = v);
      }
    return c > 0 ? [m, _] : null;
  }
  _contiguousSequenceScore(e, r, n) {
    let s = 0;
    for (let i = 0; i < n; i++) {
      if (!this.ElementsAreEqual(e + i, r + i))
        return 0;
      s += this._originalStringElements[e + i].length;
    }
    return s;
  }
  _OriginalIsBoundary(e) {
    return e <= 0 || e >= this._originalElementsOrHash.length - 1 ? !0 : this._hasStrings && /^\s*$/.test(this._originalStringElements[e]);
  }
  _OriginalRegionIsBoundary(e, r) {
    if (this._OriginalIsBoundary(e) || this._OriginalIsBoundary(e - 1))
      return !0;
    if (r > 0) {
      const n = e + r;
      if (this._OriginalIsBoundary(n - 1) || this._OriginalIsBoundary(n))
        return !0;
    }
    return !1;
  }
  _ModifiedIsBoundary(e) {
    return e <= 0 || e >= this._modifiedElementsOrHash.length - 1 ? !0 : this._hasStrings && /^\s*$/.test(this._modifiedStringElements[e]);
  }
  _ModifiedRegionIsBoundary(e, r) {
    if (this._ModifiedIsBoundary(e) || this._ModifiedIsBoundary(e - 1))
      return !0;
    if (r > 0) {
      const n = e + r;
      if (this._ModifiedIsBoundary(n - 1) || this._ModifiedIsBoundary(n))
        return !0;
    }
    return !1;
  }
  _boundaryScore(e, r, n, s) {
    const i = this._OriginalRegionIsBoundary(e, r) ? 1 : 0, u = this._ModifiedRegionIsBoundary(n, s) ? 1 : 0;
    return i + u;
  }
  /**
   * Concatenates the two input DiffChange lists and returns the resulting
   * list.
   * @param The left changes
   * @param The right changes
   * @returns The concatenated list
   */
  ConcatenateChanges(e, r) {
    const n = [];
    if (e.length === 0 || r.length === 0)
      return r.length > 0 ? r : e;
    if (this.ChangesOverlap(e[e.length - 1], r[0], n)) {
      const s = new Array(e.length + r.length - 1);
      return fs.Copy(e, 0, s, 0, e.length - 1), s[e.length - 1] = n[0], fs.Copy(r, 1, s, e.length, r.length - 1), s;
    } else {
      const s = new Array(e.length + r.length);
      return fs.Copy(e, 0, s, 0, e.length), fs.Copy(r, 0, s, e.length, r.length), s;
    }
  }
  /**
   * Returns true if the two changes overlap and can be merged into a single
   * change
   * @param left The left change
   * @param right The right change
   * @param mergedChange The merged change if the two overlap, null otherwise
   * @returns True if the two changes overlap
   */
  ChangesOverlap(e, r, n) {
    if (cs.Assert(e.originalStart <= r.originalStart, "Left change is not less than or equal to right change"), cs.Assert(e.modifiedStart <= r.modifiedStart, "Left change is not less than or equal to right change"), e.originalStart + e.originalLength >= r.originalStart || e.modifiedStart + e.modifiedLength >= r.modifiedStart) {
      const s = e.originalStart;
      let i = e.originalLength;
      const u = e.modifiedStart;
      let l = e.modifiedLength;
      return e.originalStart + e.originalLength >= r.originalStart && (i = r.originalStart + r.originalLength - e.originalStart), e.modifiedStart + e.modifiedLength >= r.modifiedStart && (l = r.modifiedStart + r.modifiedLength - e.modifiedStart), n[0] = new Sn(s, i, u, l), !0;
    } else
      return n[0] = null, !1;
  }
  /**
   * Helper method used to clip a diagonal index to the range of valid
   * diagonals. This also decides whether or not the diagonal index,
   * if it exceeds the boundary, should be clipped to the boundary or clipped
   * one inside the boundary depending on the Even/Odd status of the boundary
   * and numDifferences.
   * @param diagonal The index of the diagonal to clip.
   * @param numDifferences The current number of differences being iterated upon.
   * @param diagonalBaseIndex The base reference diagonal.
   * @param numDiagonals The total number of diagonals.
   * @returns The clipped diagonal index.
   */
  ClipDiagonalBound(e, r, n, s) {
    if (e >= 0 && e < s)
      return e;
    const i = n, u = s - n - 1, l = r % 2 === 0;
    if (e < 0) {
      const c = i % 2 === 0;
      return l === c ? 0 : 1;
    } else {
      const c = u % 2 === 0;
      return l === c ? s - 1 : s - 2;
    }
  }
}
let st = class Hn {
  constructor(e, r) {
    this.lineNumber = e, this.column = r;
  }
  /**
   * Create a new position from this position.
   *
   * @param newLineNumber new line number
   * @param newColumn new column
   */
  with(e = this.lineNumber, r = this.column) {
    return e === this.lineNumber && r === this.column ? this : new Hn(e, r);
  }
  /**
   * Derive a new position from this position.
   *
   * @param deltaLineNumber line number delta
   * @param deltaColumn column delta
   */
  delta(e = 0, r = 0) {
    return this.with(this.lineNumber + e, this.column + r);
  }
  /**
   * Test if this position equals other position
   */
  equals(e) {
    return Hn.equals(this, e);
  }
  /**
   * Test if position `a` equals position `b`
   */
  static equals(e, r) {
    return !e && !r ? !0 : !!e && !!r && e.lineNumber === r.lineNumber && e.column === r.column;
  }
  /**
   * Test if this position is before other position.
   * If the two positions are equal, the result will be false.
   */
  isBefore(e) {
    return Hn.isBefore(this, e);
  }
  /**
   * Test if position `a` is before position `b`.
   * If the two positions are equal, the result will be false.
   */
  static isBefore(e, r) {
    return e.lineNumber < r.lineNumber ? !0 : r.lineNumber < e.lineNumber ? !1 : e.column < r.column;
  }
  /**
   * Test if this position is before other position.
   * If the two positions are equal, the result will be true.
   */
  isBeforeOrEqual(e) {
    return Hn.isBeforeOrEqual(this, e);
  }
  /**
   * Test if position `a` is before position `b`.
   * If the two positions are equal, the result will be true.
   */
  static isBeforeOrEqual(e, r) {
    return e.lineNumber < r.lineNumber ? !0 : r.lineNumber < e.lineNumber ? !1 : e.column <= r.column;
  }
  /**
   * A function that compares positions, useful for sorting
   */
  static compare(e, r) {
    const n = e.lineNumber | 0, s = r.lineNumber | 0;
    if (n === s) {
      const i = e.column | 0, u = r.column | 0;
      return i - u;
    }
    return n - s;
  }
  /**
   * Clone this position.
   */
  clone() {
    return new Hn(this.lineNumber, this.column);
  }
  /**
   * Convert to a human-readable representation.
   */
  toString() {
    return "(" + this.lineNumber + "," + this.column + ")";
  }
  // ---
  /**
   * Create a `Position` from an `IPosition`.
   */
  static lift(e) {
    return new Hn(e.lineNumber, e.column);
  }
  /**
   * Test if `obj` is an `IPosition`.
   */
  static isIPosition(e) {
    return e && typeof e.lineNumber == "number" && typeof e.column == "number";
  }
  toJSON() {
    return {
      lineNumber: this.lineNumber,
      column: this.column
    };
  }
}, xe = class ot {
  constructor(e, r, n, s) {
    e > n || e === n && r > s ? (this.startLineNumber = n, this.startColumn = s, this.endLineNumber = e, this.endColumn = r) : (this.startLineNumber = e, this.startColumn = r, this.endLineNumber = n, this.endColumn = s);
  }
  /**
   * Test if this range is empty.
   */
  isEmpty() {
    return ot.isEmpty(this);
  }
  /**
   * Test if `range` is empty.
   */
  static isEmpty(e) {
    return e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn;
  }
  /**
   * Test if position is in this range. If the position is at the edges, will return true.
   */
  containsPosition(e) {
    return ot.containsPosition(this, e);
  }
  /**
   * Test if `position` is in `range`. If the position is at the edges, will return true.
   */
  static containsPosition(e, r) {
    return !(r.lineNumber < e.startLineNumber || r.lineNumber > e.endLineNumber || r.lineNumber === e.startLineNumber && r.column < e.startColumn || r.lineNumber === e.endLineNumber && r.column > e.endColumn);
  }
  /**
   * Test if `position` is in `range`. If the position is at the edges, will return false.
   * @internal
   */
  static strictContainsPosition(e, r) {
    return !(r.lineNumber < e.startLineNumber || r.lineNumber > e.endLineNumber || r.lineNumber === e.startLineNumber && r.column <= e.startColumn || r.lineNumber === e.endLineNumber && r.column >= e.endColumn);
  }
  /**
   * Test if range is in this range. If the range is equal to this range, will return true.
   */
  containsRange(e) {
    return ot.containsRange(this, e);
  }
  /**
   * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
   */
  static containsRange(e, r) {
    return !(r.startLineNumber < e.startLineNumber || r.endLineNumber < e.startLineNumber || r.startLineNumber > e.endLineNumber || r.endLineNumber > e.endLineNumber || r.startLineNumber === e.startLineNumber && r.startColumn < e.startColumn || r.endLineNumber === e.endLineNumber && r.endColumn > e.endColumn);
  }
  /**
   * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
   */
  strictContainsRange(e) {
    return ot.strictContainsRange(this, e);
  }
  /**
   * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.
   */
  static strictContainsRange(e, r) {
    return !(r.startLineNumber < e.startLineNumber || r.endLineNumber < e.startLineNumber || r.startLineNumber > e.endLineNumber || r.endLineNumber > e.endLineNumber || r.startLineNumber === e.startLineNumber && r.startColumn <= e.startColumn || r.endLineNumber === e.endLineNumber && r.endColumn >= e.endColumn);
  }
  /**
   * A reunion of the two ranges.
   * The smallest position will be used as the start point, and the largest one as the end point.
   */
  plusRange(e) {
    return ot.plusRange(this, e);
  }
  /**
   * A reunion of the two ranges.
   * The smallest position will be used as the start point, and the largest one as the end point.
   */
  static plusRange(e, r) {
    let n, s, i, u;
    return r.startLineNumber < e.startLineNumber ? (n = r.startLineNumber, s = r.startColumn) : r.startLineNumber === e.startLineNumber ? (n = r.startLineNumber, s = Math.min(r.startColumn, e.startColumn)) : (n = e.startLineNumber, s = e.startColumn), r.endLineNumber > e.endLineNumber ? (i = r.endLineNumber, u = r.endColumn) : r.endLineNumber === e.endLineNumber ? (i = r.endLineNumber, u = Math.max(r.endColumn, e.endColumn)) : (i = e.endLineNumber, u = e.endColumn), new ot(n, s, i, u);
  }
  /**
   * A intersection of the two ranges.
   */
  intersectRanges(e) {
    return ot.intersectRanges(this, e);
  }
  /**
   * A intersection of the two ranges.
   */
  static intersectRanges(e, r) {
    let n = e.startLineNumber, s = e.startColumn, i = e.endLineNumber, u = e.endColumn;
    const l = r.startLineNumber, c = r.startColumn, m = r.endLineNumber, _ = r.endColumn;
    return n < l ? (n = l, s = c) : n === l && (s = Math.max(s, c)), i > m ? (i = m, u = _) : i === m && (u = Math.min(u, _)), n > i || n === i && s > u ? null : new ot(n, s, i, u);
  }
  /**
   * Test if this range equals other.
   */
  equalsRange(e) {
    return ot.equalsRange(this, e);
  }
  /**
   * Test if range `a` equals `b`.
   */
  static equalsRange(e, r) {
    return !e && !r ? !0 : !!e && !!r && e.startLineNumber === r.startLineNumber && e.startColumn === r.startColumn && e.endLineNumber === r.endLineNumber && e.endColumn === r.endColumn;
  }
  /**
   * Return the end position (which will be after or equal to the start position)
   */
  getEndPosition() {
    return ot.getEndPosition(this);
  }
  /**
   * Return the end position (which will be after or equal to the start position)
   */
  static getEndPosition(e) {
    return new st(e.endLineNumber, e.endColumn);
  }
  /**
   * Return the start position (which will be before or equal to the end position)
   */
  getStartPosition() {
    return ot.getStartPosition(this);
  }
  /**
   * Return the start position (which will be before or equal to the end position)
   */
  static getStartPosition(e) {
    return new st(e.startLineNumber, e.startColumn);
  }
  /**
   * Transform to a user presentable string representation.
   */
  toString() {
    return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]";
  }
  /**
   * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
   */
  setEndPosition(e, r) {
    return new ot(this.startLineNumber, this.startColumn, e, r);
  }
  /**
   * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
   */
  setStartPosition(e, r) {
    return new ot(e, r, this.endLineNumber, this.endColumn);
  }
  /**
   * Create a new empty range using this range's start position.
   */
  collapseToStart() {
    return ot.collapseToStart(this);
  }
  /**
   * Create a new empty range using this range's start position.
   */
  static collapseToStart(e) {
    return new ot(e.startLineNumber, e.startColumn, e.startLineNumber, e.startColumn);
  }
  /**
   * Create a new empty range using this range's end position.
   */
  collapseToEnd() {
    return ot.collapseToEnd(this);
  }
  /**
   * Create a new empty range using this range's end position.
   */
  static collapseToEnd(e) {
    return new ot(e.endLineNumber, e.endColumn, e.endLineNumber, e.endColumn);
  }
  /**
   * Moves the range by the given amount of lines.
   */
  delta(e) {
    return new ot(this.startLineNumber + e, this.startColumn, this.endLineNumber + e, this.endColumn);
  }
  // ---
  static fromPositions(e, r = e) {
    return new ot(e.lineNumber, e.column, r.lineNumber, r.column);
  }
  static lift(e) {
    return e ? new ot(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn) : null;
  }
  /**
   * Test if `obj` is an `IRange`.
   */
  static isIRange(e) {
    return e && typeof e.startLineNumber == "number" && typeof e.startColumn == "number" && typeof e.endLineNumber == "number" && typeof e.endColumn == "number";
  }
  /**
   * Test if the two ranges are touching in any way.
   */
  static areIntersectingOrTouching(e, r) {
    return !(e.endLineNumber < r.startLineNumber || e.endLineNumber === r.startLineNumber && e.endColumn < r.startColumn || r.endLineNumber < e.startLineNumber || r.endLineNumber === e.startLineNumber && r.endColumn < e.startColumn);
  }
  /**
   * Test if the two ranges are intersecting. If the ranges are touching it returns true.
   */
  static areIntersecting(e, r) {
    return !(e.endLineNumber < r.startLineNumber || e.endLineNumber === r.startLineNumber && e.endColumn <= r.startColumn || r.endLineNumber < e.startLineNumber || r.endLineNumber === e.startLineNumber && r.endColumn <= e.startColumn);
  }
  /**
   * A function that compares ranges, useful for sorting ranges
   * It will first compare ranges on the startPosition and then on the endPosition
   */
  static compareRangesUsingStarts(e, r) {
    if (e && r) {
      const i = e.startLineNumber | 0, u = r.startLineNumber | 0;
      if (i === u) {
        const l = e.startColumn | 0, c = r.startColumn | 0;
        if (l === c) {
          const m = e.endLineNumber | 0, _ = r.endLineNumber | 0;
          if (m === _) {
            const y = e.endColumn | 0, v = r.endColumn | 0;
            return y - v;
          }
          return m - _;
        }
        return l - c;
      }
      return i - u;
    }
    return (e ? 1 : 0) - (r ? 1 : 0);
  }
  /**
   * A function that compares ranges, useful for sorting ranges
   * It will first compare ranges on the endPosition and then on the startPosition
   */
  static compareRangesUsingEnds(e, r) {
    return e.endLineNumber === r.endLineNumber ? e.endColumn === r.endColumn ? e.startLineNumber === r.startLineNumber ? e.startColumn - r.startColumn : e.startLineNumber - r.startLineNumber : e.endColumn - r.endColumn : e.endLineNumber - r.endLineNumber;
  }
  /**
   * Test if the range spans multiple lines.
   */
  static spansMultipleLines(e) {
    return e.endLineNumber > e.startLineNumber;
  }
  toJSON() {
    return this;
  }
};
function Td(t) {
  return t < 0 ? 0 : t > 255 ? 255 : t | 0;
}
function hs(t) {
  return t < 0 ? 0 : t > 4294967295 ? 4294967295 : t | 0;
}
class J0 {
  constructor(e) {
    const r = Td(e);
    this._defaultValue = r, this._asciiMap = J0._createAsciiMap(r), this._map = /* @__PURE__ */ new Map();
  }
  static _createAsciiMap(e) {
    const r = new Uint8Array(256);
    return r.fill(e), r;
  }
  set(e, r) {
    const n = Td(r);
    e >= 0 && e < 256 ? this._asciiMap[e] = n : this._map.set(e, n);
  }
  get(e) {
    return e >= 0 && e < 256 ? this._asciiMap[e] : this._map.get(e) || this._defaultValue;
  }
  clear() {
    this._asciiMap.fill(this._defaultValue), this._map.clear();
  }
}
class i5 {
  constructor(e, r, n) {
    const s = new Uint8Array(e * r);
    for (let i = 0, u = e * r; i < u; i++)
      s[i] = n;
    this._data = s, this.rows = e, this.cols = r;
  }
  get(e, r) {
    return this._data[e * this.cols + r];
  }
  set(e, r, n) {
    this._data[e * this.cols + r] = n;
  }
}
class o5 {
  constructor(e) {
    let r = 0, n = 0;
    for (let i = 0, u = e.length; i < u; i++) {
      const [l, c, m] = e[i];
      c > r && (r = c), l > n && (n = l), m > n && (n = m);
    }
    r++, n++;
    const s = new i5(
      n,
      r,
      0
      /* State.Invalid */
    );
    for (let i = 0, u = e.length; i < u; i++) {
      const [l, c, m] = e[i];
      s.set(l, c, m);
    }
    this._states = s, this._maxCharCode = r;
  }
  nextState(e, r) {
    return r < 0 || r >= this._maxCharCode ? 0 : this._states.get(e, r);
  }
}
let Yf = null;
function a5() {
  return Yf === null && (Yf = new o5([
    [
      1,
      104,
      2
      /* State.H */
    ],
    [
      1,
      72,
      2
      /* State.H */
    ],
    [
      1,
      102,
      6
      /* State.F */
    ],
    [
      1,
      70,
      6
      /* State.F */
    ],
    [
      2,
      116,
      3
      /* State.HT */
    ],
    [
      2,
      84,
      3
      /* State.HT */
    ],
    [
      3,
      116,
      4
      /* State.HTT */
    ],
    [
      3,
      84,
      4
      /* State.HTT */
    ],
    [
      4,
      112,
      5
      /* State.HTTP */
    ],
    [
      4,
      80,
      5
      /* State.HTTP */
    ],
    [
      5,
      115,
      9
      /* State.BeforeColon */
    ],
    [
      5,
      83,
      9
      /* State.BeforeColon */
    ],
    [
      5,
      58,
      10
      /* State.AfterColon */
    ],
    [
      6,
      105,
      7
      /* State.FI */
    ],
    [
      6,
      73,
      7
      /* State.FI */
    ],
    [
      7,
      108,
      8
      /* State.FIL */
    ],
    [
      7,
      76,
      8
      /* State.FIL */
    ],
    [
      8,
      101,
      9
      /* State.BeforeColon */
    ],
    [
      8,
      69,
      9
      /* State.BeforeColon */
    ],
    [
      9,
      58,
      10
      /* State.AfterColon */
    ],
    [
      10,
      47,
      11
      /* State.AlmostThere */
    ],
    [
      11,
      47,
      12
      /* State.End */
    ]
  ])), Yf;
}
let li = null;
function u5() {
  if (li === null) {
    li = new J0(
      0
      /* CharacterClass.None */
    );
    const t = ` 	<>'"、。｡､，．：；‘〈「『〔（［｛｢｣｝］）〕』」〉’｀～…`;
    for (let r = 0; r < t.length; r++)
      li.set(
        t.charCodeAt(r),
        1
        /* CharacterClass.ForceTermination */
      );
    const e = ".,;:";
    for (let r = 0; r < e.length; r++)
      li.set(
        e.charCodeAt(r),
        2
        /* CharacterClass.CannotEndIn */
      );
  }
  return li;
}
class wa {
  static _createLink(e, r, n, s, i) {
    let u = i - 1;
    do {
      const l = r.charCodeAt(u);
      if (e.get(l) !== 2)
        break;
      u--;
    } while (u > s);
    if (s > 0) {
      const l = r.charCodeAt(s - 1), c = r.charCodeAt(u);
      (l === 40 && c === 41 || l === 91 && c === 93 || l === 123 && c === 125) && u--;
    }
    return {
      range: {
        startLineNumber: n,
        startColumn: s + 1,
        endLineNumber: n,
        endColumn: u + 2
      },
      url: r.substring(s, u + 1)
    };
  }
  static computeLinks(e, r = a5()) {
    const n = u5(), s = [];
    for (let i = 1, u = e.getLineCount(); i <= u; i++) {
      const l = e.getLineContent(i), c = l.length;
      let m = 0, _ = 0, y = 0, v = 1, S = !1, T = !1, L = !1, D = !1;
      for (; m < c; ) {
        let V = !1;
        const W = l.charCodeAt(m);
        if (v === 13) {
          let j;
          switch (W) {
            case 40:
              S = !0, j = 0;
              break;
            case 41:
              j = S ? 0 : 1;
              break;
            case 91:
              L = !0, T = !0, j = 0;
              break;
            case 93:
              L = !1, j = T ? 0 : 1;
              break;
            case 123:
              D = !0, j = 0;
              break;
            case 125:
              j = D ? 0 : 1;
              break;
            // The following three rules make it that ' or " or ` are allowed inside links
            // only if the link is wrapped by some other quote character
            case 39:
            case 34:
            case 96:
              y === W ? j = 1 : y === 39 || y === 34 || y === 96 ? j = 0 : j = 1;
              break;
            case 42:
              j = y === 42 ? 1 : 0;
              break;
            case 124:
              j = y === 124 ? 1 : 0;
              break;
            case 32:
              j = L ? 0 : 1;
              break;
            default:
              j = n.get(W);
          }
          j === 1 && (s.push(wa._createLink(n, l, i, _, m)), V = !0);
        } else if (v === 12) {
          let j;
          W === 91 ? (T = !0, j = 0) : j = n.get(W), j === 1 ? V = !0 : v = 13;
        } else
          v = r.nextState(v, W), v === 0 && (V = !0);
        V && (v = 1, S = !1, T = !1, D = !1, _ = m + 1, y = W), m++;
      }
      v === 13 && s.push(wa._createLink(n, l, i, _, c));
    }
    return s;
  }
}
function l5(t) {
  return !t || typeof t.getLineCount != "function" || typeof t.getLineContent != "function" ? [] : wa.computeLinks(t);
}
class Q0 {
  constructor() {
    this._defaultValueSet = [
      ["true", "false"],
      ["True", "False"],
      ["Private", "Public", "Friend", "ReadOnly", "Partial", "Protected", "WriteOnly"],
      ["public", "protected", "private"]
    ];
  }
  static {
    this.INSTANCE = new Q0();
  }
  navigateValueSet(e, r, n, s, i) {
    if (e && r) {
      const u = this.doNavigateValueSet(r, i);
      if (u)
        return {
          range: e,
          value: u
        };
    }
    if (n && s) {
      const u = this.doNavigateValueSet(s, i);
      if (u)
        return {
          range: n,
          value: u
        };
    }
    return null;
  }
  doNavigateValueSet(e, r) {
    const n = this.numberReplace(e, r);
    return n !== null ? n : this.textReplace(e, r);
  }
  numberReplace(e, r) {
    const n = Math.pow(10, e.length - (e.lastIndexOf(".") + 1));
    let s = Number(e);
    const i = parseFloat(e);
    return !isNaN(s) && !isNaN(i) && s === i ? s === 0 && !r ? null : (s = Math.floor(s * n), s += r ? n : -n, String(s / n)) : null;
  }
  textReplace(e, r) {
    return this.valueSetsReplace(this._defaultValueSet, e, r);
  }
  valueSetsReplace(e, r, n) {
    let s = null;
    for (let i = 0, u = e.length; s === null && i < u; i++)
      s = this.valueSetReplace(e[i], r, n);
    return s;
  }
  valueSetReplace(e, r, n) {
    let s = e.indexOf(r);
    return s >= 0 ? (s += n ? 1 : -1, s < 0 ? s = e.length - 1 : s %= e.length, e[s]) : null;
  }
}
const Q2 = Object.freeze(function(t, e) {
  const r = setTimeout(t.bind(e), 0);
  return { dispose() {
    clearTimeout(r);
  } };
});
var va;
(function(t) {
  function e(r) {
    return r === t.None || r === t.Cancelled || r instanceof Bo ? !0 : !r || typeof r != "object" ? !1 : typeof r.isCancellationRequested == "boolean" && typeof r.onCancellationRequested == "function";
  }
  t.isCancellationToken = e, t.None = Object.freeze({
    isCancellationRequested: !1,
    onCancellationRequested: pa.None
  }), t.Cancelled = Object.freeze({
    isCancellationRequested: !0,
    onCancellationRequested: Q2
  });
})(va || (va = {}));
class Bo {
  constructor() {
    this._isCancelled = !1, this._emitter = null;
  }
  cancel() {
    this._isCancelled || (this._isCancelled = !0, this._emitter && (this._emitter.fire(void 0), this.dispose()));
  }
  get isCancellationRequested() {
    return this._isCancelled;
  }
  get onCancellationRequested() {
    return this._isCancelled ? Q2 : (this._emitter || (this._emitter = new wr()), this._emitter.event);
  }
  dispose() {
    this._emitter && (this._emitter.dispose(), this._emitter = null);
  }
}
class c5 {
  constructor(e) {
    this._token = void 0, this._parentListener = void 0, this._parentListener = e && e.onCancellationRequested(this.cancel, this);
  }
  get token() {
    return this._token || (this._token = new Bo()), this._token;
  }
  cancel() {
    this._token ? this._token instanceof Bo && this._token.cancel() : this._token = va.Cancelled;
  }
  dispose(e = !1) {
    e && this.cancel(), this._parentListener?.dispose(), this._token ? this._token instanceof Bo && this._token.dispose() : this._token = va.None;
  }
}
class K0 {
  constructor() {
    this._keyCodeToStr = [], this._strToKeyCode = /* @__PURE__ */ Object.create(null);
  }
  define(e, r) {
    this._keyCodeToStr[e] = r, this._strToKeyCode[r.toLowerCase()] = e;
  }
  keyCodeToStr(e) {
    return this._keyCodeToStr[e];
  }
  strToKeyCode(e) {
    return this._strToKeyCode[e.toLowerCase()] || 0;
  }
}
const qo = new K0(), $1 = new K0(), F1 = new K0(), f5 = new Array(230), h5 = /* @__PURE__ */ Object.create(null), d5 = /* @__PURE__ */ Object.create(null);
(function() {
  const t = "", e = [
    // immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel
    [1, 0, "None", 0, "unknown", 0, "VK_UNKNOWN", t, t],
    [1, 1, "Hyper", 0, t, 0, t, t, t],
    [1, 2, "Super", 0, t, 0, t, t, t],
    [1, 3, "Fn", 0, t, 0, t, t, t],
    [1, 4, "FnLock", 0, t, 0, t, t, t],
    [1, 5, "Suspend", 0, t, 0, t, t, t],
    [1, 6, "Resume", 0, t, 0, t, t, t],
    [1, 7, "Turbo", 0, t, 0, t, t, t],
    [1, 8, "Sleep", 0, t, 0, "VK_SLEEP", t, t],
    [1, 9, "WakeUp", 0, t, 0, t, t, t],
    [0, 10, "KeyA", 31, "A", 65, "VK_A", t, t],
    [0, 11, "KeyB", 32, "B", 66, "VK_B", t, t],
    [0, 12, "KeyC", 33, "C", 67, "VK_C", t, t],
    [0, 13, "KeyD", 34, "D", 68, "VK_D", t, t],
    [0, 14, "KeyE", 35, "E", 69, "VK_E", t, t],
    [0, 15, "KeyF", 36, "F", 70, "VK_F", t, t],
    [0, 16, "KeyG", 37, "G", 71, "VK_G", t, t],
    [0, 17, "KeyH", 38, "H", 72, "VK_H", t, t],
    [0, 18, "KeyI", 39, "I", 73, "VK_I", t, t],
    [0, 19, "KeyJ", 40, "J", 74, "VK_J", t, t],
    [0, 20, "KeyK", 41, "K", 75, "VK_K", t, t],
    [0, 21, "KeyL", 42, "L", 76, "VK_L", t, t],
    [0, 22, "KeyM", 43, "M", 77, "VK_M", t, t],
    [0, 23, "KeyN", 44, "N", 78, "VK_N", t, t],
    [0, 24, "KeyO", 45, "O", 79, "VK_O", t, t],
    [0, 25, "KeyP", 46, "P", 80, "VK_P", t, t],
    [0, 26, "KeyQ", 47, "Q", 81, "VK_Q", t, t],
    [0, 27, "KeyR", 48, "R", 82, "VK_R", t, t],
    [0, 28, "KeyS", 49, "S", 83, "VK_S", t, t],
    [0, 29, "KeyT", 50, "T", 84, "VK_T", t, t],
    [0, 30, "KeyU", 51, "U", 85, "VK_U", t, t],
    [0, 31, "KeyV", 52, "V", 86, "VK_V", t, t],
    [0, 32, "KeyW", 53, "W", 87, "VK_W", t, t],
    [0, 33, "KeyX", 54, "X", 88, "VK_X", t, t],
    [0, 34, "KeyY", 55, "Y", 89, "VK_Y", t, t],
    [0, 35, "KeyZ", 56, "Z", 90, "VK_Z", t, t],
    [0, 36, "Digit1", 22, "1", 49, "VK_1", t, t],
    [0, 37, "Digit2", 23, "2", 50, "VK_2", t, t],
    [0, 38, "Digit3", 24, "3", 51, "VK_3", t, t],
    [0, 39, "Digit4", 25, "4", 52, "VK_4", t, t],
    [0, 40, "Digit5", 26, "5", 53, "VK_5", t, t],
    [0, 41, "Digit6", 27, "6", 54, "VK_6", t, t],
    [0, 42, "Digit7", 28, "7", 55, "VK_7", t, t],
    [0, 43, "Digit8", 29, "8", 56, "VK_8", t, t],
    [0, 44, "Digit9", 30, "9", 57, "VK_9", t, t],
    [0, 45, "Digit0", 21, "0", 48, "VK_0", t, t],
    [1, 46, "Enter", 3, "Enter", 13, "VK_RETURN", t, t],
    [1, 47, "Escape", 9, "Escape", 27, "VK_ESCAPE", t, t],
    [1, 48, "Backspace", 1, "Backspace", 8, "VK_BACK", t, t],
    [1, 49, "Tab", 2, "Tab", 9, "VK_TAB", t, t],
    [1, 50, "Space", 10, "Space", 32, "VK_SPACE", t, t],
    [0, 51, "Minus", 88, "-", 189, "VK_OEM_MINUS", "-", "OEM_MINUS"],
    [0, 52, "Equal", 86, "=", 187, "VK_OEM_PLUS", "=", "OEM_PLUS"],
    [0, 53, "BracketLeft", 92, "[", 219, "VK_OEM_4", "[", "OEM_4"],
    [0, 54, "BracketRight", 94, "]", 221, "VK_OEM_6", "]", "OEM_6"],
    [0, 55, "Backslash", 93, "\\", 220, "VK_OEM_5", "\\", "OEM_5"],
    [0, 56, "IntlHash", 0, t, 0, t, t, t],
    // has been dropped from the w3c spec
    [0, 57, "Semicolon", 85, ";", 186, "VK_OEM_1", ";", "OEM_1"],
    [0, 58, "Quote", 95, "'", 222, "VK_OEM_7", "'", "OEM_7"],
    [0, 59, "Backquote", 91, "`", 192, "VK_OEM_3", "`", "OEM_3"],
    [0, 60, "Comma", 87, ",", 188, "VK_OEM_COMMA", ",", "OEM_COMMA"],
    [0, 61, "Period", 89, ".", 190, "VK_OEM_PERIOD", ".", "OEM_PERIOD"],
    [0, 62, "Slash", 90, "/", 191, "VK_OEM_2", "/", "OEM_2"],
    [1, 63, "CapsLock", 8, "CapsLock", 20, "VK_CAPITAL", t, t],
    [1, 64, "F1", 59, "F1", 112, "VK_F1", t, t],
    [1, 65, "F2", 60, "F2", 113, "VK_F2", t, t],
    [1, 66, "F3", 61, "F3", 114, "VK_F3", t, t],
    [1, 67, "F4", 62, "F4", 115, "VK_F4", t, t],
    [1, 68, "F5", 63, "F5", 116, "VK_F5", t, t],
    [1, 69, "F6", 64, "F6", 117, "VK_F6", t, t],
    [1, 70, "F7", 65, "F7", 118, "VK_F7", t, t],
    [1, 71, "F8", 66, "F8", 119, "VK_F8", t, t],
    [1, 72, "F9", 67, "F9", 120, "VK_F9", t, t],
    [1, 73, "F10", 68, "F10", 121, "VK_F10", t, t],
    [1, 74, "F11", 69, "F11", 122, "VK_F11", t, t],
    [1, 75, "F12", 70, "F12", 123, "VK_F12", t, t],
    [1, 76, "PrintScreen", 0, t, 0, t, t, t],
    [1, 77, "ScrollLock", 84, "ScrollLock", 145, "VK_SCROLL", t, t],
    [1, 78, "Pause", 7, "PauseBreak", 19, "VK_PAUSE", t, t],
    [1, 79, "Insert", 19, "Insert", 45, "VK_INSERT", t, t],
    [1, 80, "Home", 14, "Home", 36, "VK_HOME", t, t],
    [1, 81, "PageUp", 11, "PageUp", 33, "VK_PRIOR", t, t],
    [1, 82, "Delete", 20, "Delete", 46, "VK_DELETE", t, t],
    [1, 83, "End", 13, "End", 35, "VK_END", t, t],
    [1, 84, "PageDown", 12, "PageDown", 34, "VK_NEXT", t, t],
    [1, 85, "ArrowRight", 17, "RightArrow", 39, "VK_RIGHT", "Right", t],
    [1, 86, "ArrowLeft", 15, "LeftArrow", 37, "VK_LEFT", "Left", t],
    [1, 87, "ArrowDown", 18, "DownArrow", 40, "VK_DOWN", "Down", t],
    [1, 88, "ArrowUp", 16, "UpArrow", 38, "VK_UP", "Up", t],
    [1, 89, "NumLock", 83, "NumLock", 144, "VK_NUMLOCK", t, t],
    [1, 90, "NumpadDivide", 113, "NumPad_Divide", 111, "VK_DIVIDE", t, t],
    [1, 91, "NumpadMultiply", 108, "NumPad_Multiply", 106, "VK_MULTIPLY", t, t],
    [1, 92, "NumpadSubtract", 111, "NumPad_Subtract", 109, "VK_SUBTRACT", t, t],
    [1, 93, "NumpadAdd", 109, "NumPad_Add", 107, "VK_ADD", t, t],
    [1, 94, "NumpadEnter", 3, t, 0, t, t, t],
    [1, 95, "Numpad1", 99, "NumPad1", 97, "VK_NUMPAD1", t, t],
    [1, 96, "Numpad2", 100, "NumPad2", 98, "VK_NUMPAD2", t, t],
    [1, 97, "Numpad3", 101, "NumPad3", 99, "VK_NUMPAD3", t, t],
    [1, 98, "Numpad4", 102, "NumPad4", 100, "VK_NUMPAD4", t, t],
    [1, 99, "Numpad5", 103, "NumPad5", 101, "VK_NUMPAD5", t, t],
    [1, 100, "Numpad6", 104, "NumPad6", 102, "VK_NUMPAD6", t, t],
    [1, 101, "Numpad7", 105, "NumPad7", 103, "VK_NUMPAD7", t, t],
    [1, 102, "Numpad8", 106, "NumPad8", 104, "VK_NUMPAD8", t, t],
    [1, 103, "Numpad9", 107, "NumPad9", 105, "VK_NUMPAD9", t, t],
    [1, 104, "Numpad0", 98, "NumPad0", 96, "VK_NUMPAD0", t, t],
    [1, 105, "NumpadDecimal", 112, "NumPad_Decimal", 110, "VK_DECIMAL", t, t],
    [0, 106, "IntlBackslash", 97, "OEM_102", 226, "VK_OEM_102", t, t],
    [1, 107, "ContextMenu", 58, "ContextMenu", 93, t, t, t],
    [1, 108, "Power", 0, t, 0, t, t, t],
    [1, 109, "NumpadEqual", 0, t, 0, t, t, t],
    [1, 110, "F13", 71, "F13", 124, "VK_F13", t, t],
    [1, 111, "F14", 72, "F14", 125, "VK_F14", t, t],
    [1, 112, "F15", 73, "F15", 126, "VK_F15", t, t],
    [1, 113, "F16", 74, "F16", 127, "VK_F16", t, t],
    [1, 114, "F17", 75, "F17", 128, "VK_F17", t, t],
    [1, 115, "F18", 76, "F18", 129, "VK_F18", t, t],
    [1, 116, "F19", 77, "F19", 130, "VK_F19", t, t],
    [1, 117, "F20", 78, "F20", 131, "VK_F20", t, t],
    [1, 118, "F21", 79, "F21", 132, "VK_F21", t, t],
    [1, 119, "F22", 80, "F22", 133, "VK_F22", t, t],
    [1, 120, "F23", 81, "F23", 134, "VK_F23", t, t],
    [1, 121, "F24", 82, "F24", 135, "VK_F24", t, t],
    [1, 122, "Open", 0, t, 0, t, t, t],
    [1, 123, "Help", 0, t, 0, t, t, t],
    [1, 124, "Select", 0, t, 0, t, t, t],
    [1, 125, "Again", 0, t, 0, t, t, t],
    [1, 126, "Undo", 0, t, 0, t, t, t],
    [1, 127, "Cut", 0, t, 0, t, t, t],
    [1, 128, "Copy", 0, t, 0, t, t, t],
    [1, 129, "Paste", 0, t, 0, t, t, t],
    [1, 130, "Find", 0, t, 0, t, t, t],
    [1, 131, "AudioVolumeMute", 117, "AudioVolumeMute", 173, "VK_VOLUME_MUTE", t, t],
    [1, 132, "AudioVolumeUp", 118, "AudioVolumeUp", 175, "VK_VOLUME_UP", t, t],
    [1, 133, "AudioVolumeDown", 119, "AudioVolumeDown", 174, "VK_VOLUME_DOWN", t, t],
    [1, 134, "NumpadComma", 110, "NumPad_Separator", 108, "VK_SEPARATOR", t, t],
    [0, 135, "IntlRo", 115, "ABNT_C1", 193, "VK_ABNT_C1", t, t],
    [1, 136, "KanaMode", 0, t, 0, t, t, t],
    [0, 137, "IntlYen", 0, t, 0, t, t, t],
    [1, 138, "Convert", 0, t, 0, t, t, t],
    [1, 139, "NonConvert", 0, t, 0, t, t, t],
    [1, 140, "Lang1", 0, t, 0, t, t, t],
    [1, 141, "Lang2", 0, t, 0, t, t, t],
    [1, 142, "Lang3", 0, t, 0, t, t, t],
    [1, 143, "Lang4", 0, t, 0, t, t, t],
    [1, 144, "Lang5", 0, t, 0, t, t, t],
    [1, 145, "Abort", 0, t, 0, t, t, t],
    [1, 146, "Props", 0, t, 0, t, t, t],
    [1, 147, "NumpadParenLeft", 0, t, 0, t, t, t],
    [1, 148, "NumpadParenRight", 0, t, 0, t, t, t],
    [1, 149, "NumpadBackspace", 0, t, 0, t, t, t],
    [1, 150, "NumpadMemoryStore", 0, t, 0, t, t, t],
    [1, 151, "NumpadMemoryRecall", 0, t, 0, t, t, t],
    [1, 152, "NumpadMemoryClear", 0, t, 0, t, t, t],
    [1, 153, "NumpadMemoryAdd", 0, t, 0, t, t, t],
    [1, 154, "NumpadMemorySubtract", 0, t, 0, t, t, t],
    [1, 155, "NumpadClear", 131, "Clear", 12, "VK_CLEAR", t, t],
    [1, 156, "NumpadClearEntry", 0, t, 0, t, t, t],
    [1, 0, t, 5, "Ctrl", 17, "VK_CONTROL", t, t],
    [1, 0, t, 4, "Shift", 16, "VK_SHIFT", t, t],
    [1, 0, t, 6, "Alt", 18, "VK_MENU", t, t],
    [1, 0, t, 57, "Meta", 91, "VK_COMMAND", t, t],
    [1, 157, "ControlLeft", 5, t, 0, "VK_LCONTROL", t, t],
    [1, 158, "ShiftLeft", 4, t, 0, "VK_LSHIFT", t, t],
    [1, 159, "AltLeft", 6, t, 0, "VK_LMENU", t, t],
    [1, 160, "MetaLeft", 57, t, 0, "VK_LWIN", t, t],
    [1, 161, "ControlRight", 5, t, 0, "VK_RCONTROL", t, t],
    [1, 162, "ShiftRight", 4, t, 0, "VK_RSHIFT", t, t],
    [1, 163, "AltRight", 6, t, 0, "VK_RMENU", t, t],
    [1, 164, "MetaRight", 57, t, 0, "VK_RWIN", t, t],
    [1, 165, "BrightnessUp", 0, t, 0, t, t, t],
    [1, 166, "BrightnessDown", 0, t, 0, t, t, t],
    [1, 167, "MediaPlay", 0, t, 0, t, t, t],
    [1, 168, "MediaRecord", 0, t, 0, t, t, t],
    [1, 169, "MediaFastForward", 0, t, 0, t, t, t],
    [1, 170, "MediaRewind", 0, t, 0, t, t, t],
    [1, 171, "MediaTrackNext", 124, "MediaTrackNext", 176, "VK_MEDIA_NEXT_TRACK", t, t],
    [1, 172, "MediaTrackPrevious", 125, "MediaTrackPrevious", 177, "VK_MEDIA_PREV_TRACK", t, t],
    [1, 173, "MediaStop", 126, "MediaStop", 178, "VK_MEDIA_STOP", t, t],
    [1, 174, "Eject", 0, t, 0, t, t, t],
    [1, 175, "MediaPlayPause", 127, "MediaPlayPause", 179, "VK_MEDIA_PLAY_PAUSE", t, t],
    [1, 176, "MediaSelect", 128, "LaunchMediaPlayer", 181, "VK_MEDIA_LAUNCH_MEDIA_SELECT", t, t],
    [1, 177, "LaunchMail", 129, "LaunchMail", 180, "VK_MEDIA_LAUNCH_MAIL", t, t],
    [1, 178, "LaunchApp2", 130, "LaunchApp2", 183, "VK_MEDIA_LAUNCH_APP2", t, t],
    [1, 179, "LaunchApp1", 0, t, 0, "VK_MEDIA_LAUNCH_APP1", t, t],
    [1, 180, "SelectTask", 0, t, 0, t, t, t],
    [1, 181, "LaunchScreenSaver", 0, t, 0, t, t, t],
    [1, 182, "BrowserSearch", 120, "BrowserSearch", 170, "VK_BROWSER_SEARCH", t, t],
    [1, 183, "BrowserHome", 121, "BrowserHome", 172, "VK_BROWSER_HOME", t, t],
    [1, 184, "BrowserBack", 122, "BrowserBack", 166, "VK_BROWSER_BACK", t, t],
    [1, 185, "BrowserForward", 123, "BrowserForward", 167, "VK_BROWSER_FORWARD", t, t],
    [1, 186, "BrowserStop", 0, t, 0, "VK_BROWSER_STOP", t, t],
    [1, 187, "BrowserRefresh", 0, t, 0, "VK_BROWSER_REFRESH", t, t],
    [1, 188, "BrowserFavorites", 0, t, 0, "VK_BROWSER_FAVORITES", t, t],
    [1, 189, "ZoomToggle", 0, t, 0, t, t, t],
    [1, 190, "MailReply", 0, t, 0, t, t, t],
    [1, 191, "MailForward", 0, t, 0, t, t, t],
    [1, 192, "MailSend", 0, t, 0, t, t, t],
    // See https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html
    // If an Input Method Editor is processing key input and the event is keydown, return 229.
    [1, 0, t, 114, "KeyInComposition", 229, t, t, t],
    [1, 0, t, 116, "ABNT_C2", 194, "VK_ABNT_C2", t, t],
    [1, 0, t, 96, "OEM_8", 223, "VK_OEM_8", t, t],
    [1, 0, t, 0, t, 0, "VK_KANA", t, t],
    [1, 0, t, 0, t, 0, "VK_HANGUL", t, t],
    [1, 0, t, 0, t, 0, "VK_JUNJA", t, t],
    [1, 0, t, 0, t, 0, "VK_FINAL", t, t],
    [1, 0, t, 0, t, 0, "VK_HANJA", t, t],
    [1, 0, t, 0, t, 0, "VK_KANJI", t, t],
    [1, 0, t, 0, t, 0, "VK_CONVERT", t, t],
    [1, 0, t, 0, t, 0, "VK_NONCONVERT", t, t],
    [1, 0, t, 0, t, 0, "VK_ACCEPT", t, t],
    [1, 0, t, 0, t, 0, "VK_MODECHANGE", t, t],
    [1, 0, t, 0, t, 0, "VK_SELECT", t, t],
    [1, 0, t, 0, t, 0, "VK_PRINT", t, t],
    [1, 0, t, 0, t, 0, "VK_EXECUTE", t, t],
    [1, 0, t, 0, t, 0, "VK_SNAPSHOT", t, t],
    [1, 0, t, 0, t, 0, "VK_HELP", t, t],
    [1, 0, t, 0, t, 0, "VK_APPS", t, t],
    [1, 0, t, 0, t, 0, "VK_PROCESSKEY", t, t],
    [1, 0, t, 0, t, 0, "VK_PACKET", t, t],
    [1, 0, t, 0, t, 0, "VK_DBE_SBCSCHAR", t, t],
    [1, 0, t, 0, t, 0, "VK_DBE_DBCSCHAR", t, t],
    [1, 0, t, 0, t, 0, "VK_ATTN", t, t],
    [1, 0, t, 0, t, 0, "VK_CRSEL", t, t],
    [1, 0, t, 0, t, 0, "VK_EXSEL", t, t],
    [1, 0, t, 0, t, 0, "VK_EREOF", t, t],
    [1, 0, t, 0, t, 0, "VK_PLAY", t, t],
    [1, 0, t, 0, t, 0, "VK_ZOOM", t, t],
    [1, 0, t, 0, t, 0, "VK_NONAME", t, t],
    [1, 0, t, 0, t, 0, "VK_PA1", t, t],
    [1, 0, t, 0, t, 0, "VK_OEM_CLEAR", t, t]
  ], r = [], n = [];
  for (const s of e) {
    const [i, u, l, c, m, _, y, v, S] = s;
    if (n[u] || (n[u] = !0, h5[l] = u, d5[l.toLowerCase()] = u), !r[c]) {
      if (r[c] = !0, !m)
        throw new Error(`String representation missing for key code ${c} around scan code ${l}`);
      qo.define(c, m), $1.define(c, v || m), F1.define(c, S || v || m);
    }
    _ && (f5[_] = c);
  }
})();
var Pd;
(function(t) {
  function e(l) {
    return qo.keyCodeToStr(l);
  }
  t.toString = e;
  function r(l) {
    return qo.strToKeyCode(l);
  }
  t.fromString = r;
  function n(l) {
    return $1.keyCodeToStr(l);
  }
  t.toUserSettingsUS = n;
  function s(l) {
    return F1.keyCodeToStr(l);
  }
  t.toUserSettingsGeneral = s;
  function i(l) {
    return $1.strToKeyCode(l) || F1.strToKeyCode(l);
  }
  t.fromUserSettings = i;
  function u(l) {
    if (l >= 98 && l <= 113)
      return null;
    switch (l) {
      case 16:
        return "Up";
      case 18:
        return "Down";
      case 15:
        return "Left";
      case 17:
        return "Right";
    }
    return qo.keyCodeToStr(l);
  }
  t.toElectronAccelerator = u;
})(Pd || (Pd = {}));
function m5(t, e) {
  const r = (e & 65535) << 16 >>> 0;
  return (t | r) >>> 0;
}
class ar extends xe {
  constructor(e, r, n, s) {
    super(e, r, n, s), this.selectionStartLineNumber = e, this.selectionStartColumn = r, this.positionLineNumber = n, this.positionColumn = s;
  }
  /**
   * Transform to a human-readable representation.
   */
  toString() {
    return "[" + this.selectionStartLineNumber + "," + this.selectionStartColumn + " -> " + this.positionLineNumber + "," + this.positionColumn + "]";
  }
  /**
   * Test if equals other selection.
   */
  equalsSelection(e) {
    return ar.selectionsEqual(this, e);
  }
  /**
   * Test if the two selections are equal.
   */
  static selectionsEqual(e, r) {
    return e.selectionStartLineNumber === r.selectionStartLineNumber && e.selectionStartColumn === r.selectionStartColumn && e.positionLineNumber === r.positionLineNumber && e.positionColumn === r.positionColumn;
  }
  /**
   * Get directions (LTR or RTL).
   */
  getDirection() {
    return this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn ? 0 : 1;
  }
  /**
   * Create a new selection with a different `positionLineNumber` and `positionColumn`.
   */
  setEndPosition(e, r) {
    return this.getDirection() === 0 ? new ar(this.startLineNumber, this.startColumn, e, r) : new ar(e, r, this.startLineNumber, this.startColumn);
  }
  /**
   * Get the position at `positionLineNumber` and `positionColumn`.
   */
  getPosition() {
    return new st(this.positionLineNumber, this.positionColumn);
  }
  /**
   * Get the position at the start of the selection.
  */
  getSelectionStart() {
    return new st(this.selectionStartLineNumber, this.selectionStartColumn);
  }
  /**
   * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
   */
  setStartPosition(e, r) {
    return this.getDirection() === 0 ? new ar(e, r, this.endLineNumber, this.endColumn) : new ar(this.endLineNumber, this.endColumn, e, r);
  }
  // ----
  /**
   * Create a `Selection` from one or two positions
   */
  static fromPositions(e, r = e) {
    return new ar(e.lineNumber, e.column, r.lineNumber, r.column);
  }
  /**
   * Creates a `Selection` from a range, given a direction.
   */
  static fromRange(e, r) {
    return r === 0 ? new ar(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn) : new ar(e.endLineNumber, e.endColumn, e.startLineNumber, e.startColumn);
  }
  /**
   * Create a `Selection` from an `ISelection`.
   */
  static liftSelection(e) {
    return new ar(e.selectionStartLineNumber, e.selectionStartColumn, e.positionLineNumber, e.positionColumn);
  }
  /**
   * `a` equals `b`.
   */
  static selectionsArrEqual(e, r) {
    if (e && !r || !e && r)
      return !1;
    if (!e && !r)
      return !0;
    if (e.length !== r.length)
      return !1;
    for (let n = 0, s = e.length; n < s; n++)
      if (!this.selectionsEqual(e[n], r[n]))
        return !1;
    return !0;
  }
  /**
   * Test if `obj` is an `ISelection`.
   */
  static isISelection(e) {
    return e && typeof e.selectionStartLineNumber == "number" && typeof e.selectionStartColumn == "number" && typeof e.positionLineNumber == "number" && typeof e.positionColumn == "number";
  }
  /**
   * Create with a direction.
   */
  static createWithDirection(e, r, n, s, i) {
    return i === 0 ? new ar(e, r, n, s) : new ar(n, s, e, r);
  }
}
function p5(t) {
  return typeof t == "string";
}
const Ad = /* @__PURE__ */ Object.create(null);
function g(t, e) {
  if (p5(e)) {
    const r = Ad[e];
    if (r === void 0)
      throw new Error(`${t} references an unknown codicon: ${e}`);
    e = r;
  }
  return Ad[t] = e, { id: t };
}
const g5 = {
  add: g("add", 6e4),
  plus: g("plus", 6e4),
  gistNew: g("gist-new", 6e4),
  repoCreate: g("repo-create", 6e4),
  lightbulb: g("lightbulb", 60001),
  lightBulb: g("light-bulb", 60001),
  repo: g("repo", 60002),
  repoDelete: g("repo-delete", 60002),
  gistFork: g("gist-fork", 60003),
  repoForked: g("repo-forked", 60003),
  gitPullRequest: g("git-pull-request", 60004),
  gitPullRequestAbandoned: g("git-pull-request-abandoned", 60004),
  recordKeys: g("record-keys", 60005),
  keyboard: g("keyboard", 60005),
  tag: g("tag", 60006),
  gitPullRequestLabel: g("git-pull-request-label", 60006),
  tagAdd: g("tag-add", 60006),
  tagRemove: g("tag-remove", 60006),
  person: g("person", 60007),
  personFollow: g("person-follow", 60007),
  personOutline: g("person-outline", 60007),
  personFilled: g("person-filled", 60007),
  gitBranch: g("git-branch", 60008),
  gitBranchCreate: g("git-branch-create", 60008),
  gitBranchDelete: g("git-branch-delete", 60008),
  sourceControl: g("source-control", 60008),
  mirror: g("mirror", 60009),
  mirrorPublic: g("mirror-public", 60009),
  star: g("star", 60010),
  starAdd: g("star-add", 60010),
  starDelete: g("star-delete", 60010),
  starEmpty: g("star-empty", 60010),
  comment: g("comment", 60011),
  commentAdd: g("comment-add", 60011),
  alert: g("alert", 60012),
  warning: g("warning", 60012),
  search: g("search", 60013),
  searchSave: g("search-save", 60013),
  logOut: g("log-out", 60014),
  signOut: g("sign-out", 60014),
  logIn: g("log-in", 60015),
  signIn: g("sign-in", 60015),
  eye: g("eye", 60016),
  eyeUnwatch: g("eye-unwatch", 60016),
  eyeWatch: g("eye-watch", 60016),
  circleFilled: g("circle-filled", 60017),
  primitiveDot: g("primitive-dot", 60017),
  closeDirty: g("close-dirty", 60017),
  debugBreakpoint: g("debug-breakpoint", 60017),
  debugBreakpointDisabled: g("debug-breakpoint-disabled", 60017),
  debugHint: g("debug-hint", 60017),
  terminalDecorationSuccess: g("terminal-decoration-success", 60017),
  primitiveSquare: g("primitive-square", 60018),
  edit: g("edit", 60019),
  pencil: g("pencil", 60019),
  info: g("info", 60020),
  issueOpened: g("issue-opened", 60020),
  gistPrivate: g("gist-private", 60021),
  gitForkPrivate: g("git-fork-private", 60021),
  lock: g("lock", 60021),
  mirrorPrivate: g("mirror-private", 60021),
  close: g("close", 60022),
  removeClose: g("remove-close", 60022),
  x: g("x", 60022),
  repoSync: g("repo-sync", 60023),
  sync: g("sync", 60023),
  clone: g("clone", 60024),
  desktopDownload: g("desktop-download", 60024),
  beaker: g("beaker", 60025),
  microscope: g("microscope", 60025),
  vm: g("vm", 60026),
  deviceDesktop: g("device-desktop", 60026),
  file: g("file", 60027),
  fileText: g("file-text", 60027),
  more: g("more", 60028),
  ellipsis: g("ellipsis", 60028),
  kebabHorizontal: g("kebab-horizontal", 60028),
  mailReply: g("mail-reply", 60029),
  reply: g("reply", 60029),
  organization: g("organization", 60030),
  organizationFilled: g("organization-filled", 60030),
  organizationOutline: g("organization-outline", 60030),
  newFile: g("new-file", 60031),
  fileAdd: g("file-add", 60031),
  newFolder: g("new-folder", 60032),
  fileDirectoryCreate: g("file-directory-create", 60032),
  trash: g("trash", 60033),
  trashcan: g("trashcan", 60033),
  history: g("history", 60034),
  clock: g("clock", 60034),
  folder: g("folder", 60035),
  fileDirectory: g("file-directory", 60035),
  symbolFolder: g("symbol-folder", 60035),
  logoGithub: g("logo-github", 60036),
  markGithub: g("mark-github", 60036),
  github: g("github", 60036),
  terminal: g("terminal", 60037),
  console: g("console", 60037),
  repl: g("repl", 60037),
  zap: g("zap", 60038),
  symbolEvent: g("symbol-event", 60038),
  error: g("error", 60039),
  stop: g("stop", 60039),
  variable: g("variable", 60040),
  symbolVariable: g("symbol-variable", 60040),
  array: g("array", 60042),
  symbolArray: g("symbol-array", 60042),
  symbolModule: g("symbol-module", 60043),
  symbolPackage: g("symbol-package", 60043),
  symbolNamespace: g("symbol-namespace", 60043),
  symbolObject: g("symbol-object", 60043),
  symbolMethod: g("symbol-method", 60044),
  symbolFunction: g("symbol-function", 60044),
  symbolConstructor: g("symbol-constructor", 60044),
  symbolBoolean: g("symbol-boolean", 60047),
  symbolNull: g("symbol-null", 60047),
  symbolNumeric: g("symbol-numeric", 60048),
  symbolNumber: g("symbol-number", 60048),
  symbolStructure: g("symbol-structure", 60049),
  symbolStruct: g("symbol-struct", 60049),
  symbolParameter: g("symbol-parameter", 60050),
  symbolTypeParameter: g("symbol-type-parameter", 60050),
  symbolKey: g("symbol-key", 60051),
  symbolText: g("symbol-text", 60051),
  symbolReference: g("symbol-reference", 60052),
  goToFile: g("go-to-file", 60052),
  symbolEnum: g("symbol-enum", 60053),
  symbolValue: g("symbol-value", 60053),
  symbolRuler: g("symbol-ruler", 60054),
  symbolUnit: g("symbol-unit", 60054),
  activateBreakpoints: g("activate-breakpoints", 60055),
  archive: g("archive", 60056),
  arrowBoth: g("arrow-both", 60057),
  arrowDown: g("arrow-down", 60058),
  arrowLeft: g("arrow-left", 60059),
  arrowRight: g("arrow-right", 60060),
  arrowSmallDown: g("arrow-small-down", 60061),
  arrowSmallLeft: g("arrow-small-left", 60062),
  arrowSmallRight: g("arrow-small-right", 60063),
  arrowSmallUp: g("arrow-small-up", 60064),
  arrowUp: g("arrow-up", 60065),
  bell: g("bell", 60066),
  bold: g("bold", 60067),
  book: g("book", 60068),
  bookmark: g("bookmark", 60069),
  debugBreakpointConditionalUnverified: g("debug-breakpoint-conditional-unverified", 60070),
  debugBreakpointConditional: g("debug-breakpoint-conditional", 60071),
  debugBreakpointConditionalDisabled: g("debug-breakpoint-conditional-disabled", 60071),
  debugBreakpointDataUnverified: g("debug-breakpoint-data-unverified", 60072),
  debugBreakpointData: g("debug-breakpoint-data", 60073),
  debugBreakpointDataDisabled: g("debug-breakpoint-data-disabled", 60073),
  debugBreakpointLogUnverified: g("debug-breakpoint-log-unverified", 60074),
  debugBreakpointLog: g("debug-breakpoint-log", 60075),
  debugBreakpointLogDisabled: g("debug-breakpoint-log-disabled", 60075),
  briefcase: g("briefcase", 60076),
  broadcast: g("broadcast", 60077),
  browser: g("browser", 60078),
  bug: g("bug", 60079),
  calendar: g("calendar", 60080),
  caseSensitive: g("case-sensitive", 60081),
  check: g("check", 60082),
  checklist: g("checklist", 60083),
  chevronDown: g("chevron-down", 60084),
  chevronLeft: g("chevron-left", 60085),
  chevronRight: g("chevron-right", 60086),
  chevronUp: g("chevron-up", 60087),
  chromeClose: g("chrome-close", 60088),
  chromeMaximize: g("chrome-maximize", 60089),
  chromeMinimize: g("chrome-minimize", 60090),
  chromeRestore: g("chrome-restore", 60091),
  circleOutline: g("circle-outline", 60092),
  circle: g("circle", 60092),
  debugBreakpointUnverified: g("debug-breakpoint-unverified", 60092),
  terminalDecorationIncomplete: g("terminal-decoration-incomplete", 60092),
  circleSlash: g("circle-slash", 60093),
  circuitBoard: g("circuit-board", 60094),
  clearAll: g("clear-all", 60095),
  clippy: g("clippy", 60096),
  closeAll: g("close-all", 60097),
  cloudDownload: g("cloud-download", 60098),
  cloudUpload: g("cloud-upload", 60099),
  code: g("code", 60100),
  collapseAll: g("collapse-all", 60101),
  colorMode: g("color-mode", 60102),
  commentDiscussion: g("comment-discussion", 60103),
  creditCard: g("credit-card", 60105),
  dash: g("dash", 60108),
  dashboard: g("dashboard", 60109),
  database: g("database", 60110),
  debugContinue: g("debug-continue", 60111),
  debugDisconnect: g("debug-disconnect", 60112),
  debugPause: g("debug-pause", 60113),
  debugRestart: g("debug-restart", 60114),
  debugStart: g("debug-start", 60115),
  debugStepInto: g("debug-step-into", 60116),
  debugStepOut: g("debug-step-out", 60117),
  debugStepOver: g("debug-step-over", 60118),
  debugStop: g("debug-stop", 60119),
  debug: g("debug", 60120),
  deviceCameraVideo: g("device-camera-video", 60121),
  deviceCamera: g("device-camera", 60122),
  deviceMobile: g("device-mobile", 60123),
  diffAdded: g("diff-added", 60124),
  diffIgnored: g("diff-ignored", 60125),
  diffModified: g("diff-modified", 60126),
  diffRemoved: g("diff-removed", 60127),
  diffRenamed: g("diff-renamed", 60128),
  diff: g("diff", 60129),
  diffSidebyside: g("diff-sidebyside", 60129),
  discard: g("discard", 60130),
  editorLayout: g("editor-layout", 60131),
  emptyWindow: g("empty-window", 60132),
  exclude: g("exclude", 60133),
  extensions: g("extensions", 60134),
  eyeClosed: g("eye-closed", 60135),
  fileBinary: g("file-binary", 60136),
  fileCode: g("file-code", 60137),
  fileMedia: g("file-media", 60138),
  filePdf: g("file-pdf", 60139),
  fileSubmodule: g("file-submodule", 60140),
  fileSymlinkDirectory: g("file-symlink-directory", 60141),
  fileSymlinkFile: g("file-symlink-file", 60142),
  fileZip: g("file-zip", 60143),
  files: g("files", 60144),
  filter: g("filter", 60145),
  flame: g("flame", 60146),
  foldDown: g("fold-down", 60147),
  foldUp: g("fold-up", 60148),
  fold: g("fold", 60149),
  folderActive: g("folder-active", 60150),
  folderOpened: g("folder-opened", 60151),
  gear: g("gear", 60152),
  gift: g("gift", 60153),
  gistSecret: g("gist-secret", 60154),
  gist: g("gist", 60155),
  gitCommit: g("git-commit", 60156),
  gitCompare: g("git-compare", 60157),
  compareChanges: g("compare-changes", 60157),
  gitMerge: g("git-merge", 60158),
  githubAction: g("github-action", 60159),
  githubAlt: g("github-alt", 60160),
  globe: g("globe", 60161),
  grabber: g("grabber", 60162),
  graph: g("graph", 60163),
  gripper: g("gripper", 60164),
  heart: g("heart", 60165),
  home: g("home", 60166),
  horizontalRule: g("horizontal-rule", 60167),
  hubot: g("hubot", 60168),
  inbox: g("inbox", 60169),
  issueReopened: g("issue-reopened", 60171),
  issues: g("issues", 60172),
  italic: g("italic", 60173),
  jersey: g("jersey", 60174),
  json: g("json", 60175),
  kebabVertical: g("kebab-vertical", 60176),
  key: g("key", 60177),
  law: g("law", 60178),
  lightbulbAutofix: g("lightbulb-autofix", 60179),
  linkExternal: g("link-external", 60180),
  link: g("link", 60181),
  listOrdered: g("list-ordered", 60182),
  listUnordered: g("list-unordered", 60183),
  liveShare: g("live-share", 60184),
  loading: g("loading", 60185),
  location: g("location", 60186),
  mailRead: g("mail-read", 60187),
  mail: g("mail", 60188),
  markdown: g("markdown", 60189),
  megaphone: g("megaphone", 60190),
  mention: g("mention", 60191),
  milestone: g("milestone", 60192),
  gitPullRequestMilestone: g("git-pull-request-milestone", 60192),
  mortarBoard: g("mortar-board", 60193),
  move: g("move", 60194),
  multipleWindows: g("multiple-windows", 60195),
  mute: g("mute", 60196),
  noNewline: g("no-newline", 60197),
  note: g("note", 60198),
  octoface: g("octoface", 60199),
  openPreview: g("open-preview", 60200),
  package: g("package", 60201),
  paintcan: g("paintcan", 60202),
  pin: g("pin", 60203),
  play: g("play", 60204),
  run: g("run", 60204),
  plug: g("plug", 60205),
  preserveCase: g("preserve-case", 60206),
  preview: g("preview", 60207),
  project: g("project", 60208),
  pulse: g("pulse", 60209),
  question: g("question", 60210),
  quote: g("quote", 60211),
  radioTower: g("radio-tower", 60212),
  reactions: g("reactions", 60213),
  references: g("references", 60214),
  refresh: g("refresh", 60215),
  regex: g("regex", 60216),
  remoteExplorer: g("remote-explorer", 60217),
  remote: g("remote", 60218),
  remove: g("remove", 60219),
  replaceAll: g("replace-all", 60220),
  replace: g("replace", 60221),
  repoClone: g("repo-clone", 60222),
  repoForcePush: g("repo-force-push", 60223),
  repoPull: g("repo-pull", 60224),
  repoPush: g("repo-push", 60225),
  report: g("report", 60226),
  requestChanges: g("request-changes", 60227),
  rocket: g("rocket", 60228),
  rootFolderOpened: g("root-folder-opened", 60229),
  rootFolder: g("root-folder", 60230),
  rss: g("rss", 60231),
  ruby: g("ruby", 60232),
  saveAll: g("save-all", 60233),
  saveAs: g("save-as", 60234),
  save: g("save", 60235),
  screenFull: g("screen-full", 60236),
  screenNormal: g("screen-normal", 60237),
  searchStop: g("search-stop", 60238),
  server: g("server", 60240),
  settingsGear: g("settings-gear", 60241),
  settings: g("settings", 60242),
  shield: g("shield", 60243),
  smiley: g("smiley", 60244),
  sortPrecedence: g("sort-precedence", 60245),
  splitHorizontal: g("split-horizontal", 60246),
  splitVertical: g("split-vertical", 60247),
  squirrel: g("squirrel", 60248),
  starFull: g("star-full", 60249),
  starHalf: g("star-half", 60250),
  symbolClass: g("symbol-class", 60251),
  symbolColor: g("symbol-color", 60252),
  symbolConstant: g("symbol-constant", 60253),
  symbolEnumMember: g("symbol-enum-member", 60254),
  symbolField: g("symbol-field", 60255),
  symbolFile: g("symbol-file", 60256),
  symbolInterface: g("symbol-interface", 60257),
  symbolKeyword: g("symbol-keyword", 60258),
  symbolMisc: g("symbol-misc", 60259),
  symbolOperator: g("symbol-operator", 60260),
  symbolProperty: g("symbol-property", 60261),
  wrench: g("wrench", 60261),
  wrenchSubaction: g("wrench-subaction", 60261),
  symbolSnippet: g("symbol-snippet", 60262),
  tasklist: g("tasklist", 60263),
  telescope: g("telescope", 60264),
  textSize: g("text-size", 60265),
  threeBars: g("three-bars", 60266),
  thumbsdown: g("thumbsdown", 60267),
  thumbsup: g("thumbsup", 60268),
  tools: g("tools", 60269),
  triangleDown: g("triangle-down", 60270),
  triangleLeft: g("triangle-left", 60271),
  triangleRight: g("triangle-right", 60272),
  triangleUp: g("triangle-up", 60273),
  twitter: g("twitter", 60274),
  unfold: g("unfold", 60275),
  unlock: g("unlock", 60276),
  unmute: g("unmute", 60277),
  unverified: g("unverified", 60278),
  verified: g("verified", 60279),
  versions: g("versions", 60280),
  vmActive: g("vm-active", 60281),
  vmOutline: g("vm-outline", 60282),
  vmRunning: g("vm-running", 60283),
  watch: g("watch", 60284),
  whitespace: g("whitespace", 60285),
  wholeWord: g("whole-word", 60286),
  window: g("window", 60287),
  wordWrap: g("word-wrap", 60288),
  zoomIn: g("zoom-in", 60289),
  zoomOut: g("zoom-out", 60290),
  listFilter: g("list-filter", 60291),
  listFlat: g("list-flat", 60292),
  listSelection: g("list-selection", 60293),
  selection: g("selection", 60293),
  listTree: g("list-tree", 60294),
  debugBreakpointFunctionUnverified: g("debug-breakpoint-function-unverified", 60295),
  debugBreakpointFunction: g("debug-breakpoint-function", 60296),
  debugBreakpointFunctionDisabled: g("debug-breakpoint-function-disabled", 60296),
  debugStackframeActive: g("debug-stackframe-active", 60297),
  circleSmallFilled: g("circle-small-filled", 60298),
  debugStackframeDot: g("debug-stackframe-dot", 60298),
  terminalDecorationMark: g("terminal-decoration-mark", 60298),
  debugStackframe: g("debug-stackframe", 60299),
  debugStackframeFocused: g("debug-stackframe-focused", 60299),
  debugBreakpointUnsupported: g("debug-breakpoint-unsupported", 60300),
  symbolString: g("symbol-string", 60301),
  debugReverseContinue: g("debug-reverse-continue", 60302),
  debugStepBack: g("debug-step-back", 60303),
  debugRestartFrame: g("debug-restart-frame", 60304),
  debugAlt: g("debug-alt", 60305),
  callIncoming: g("call-incoming", 60306),
  callOutgoing: g("call-outgoing", 60307),
  menu: g("menu", 60308),
  expandAll: g("expand-all", 60309),
  feedback: g("feedback", 60310),
  gitPullRequestReviewer: g("git-pull-request-reviewer", 60310),
  groupByRefType: g("group-by-ref-type", 60311),
  ungroupByRefType: g("ungroup-by-ref-type", 60312),
  account: g("account", 60313),
  gitPullRequestAssignee: g("git-pull-request-assignee", 60313),
  bellDot: g("bell-dot", 60314),
  debugConsole: g("debug-console", 60315),
  library: g("library", 60316),
  output: g("output", 60317),
  runAll: g("run-all", 60318),
  syncIgnored: g("sync-ignored", 60319),
  pinned: g("pinned", 60320),
  githubInverted: g("github-inverted", 60321),
  serverProcess: g("server-process", 60322),
  serverEnvironment: g("server-environment", 60323),
  pass: g("pass", 60324),
  issueClosed: g("issue-closed", 60324),
  stopCircle: g("stop-circle", 60325),
  playCircle: g("play-circle", 60326),
  record: g("record", 60327),
  debugAltSmall: g("debug-alt-small", 60328),
  vmConnect: g("vm-connect", 60329),
  cloud: g("cloud", 60330),
  merge: g("merge", 60331),
  export: g("export", 60332),
  graphLeft: g("graph-left", 60333),
  magnet: g("magnet", 60334),
  notebook: g("notebook", 60335),
  redo: g("redo", 60336),
  checkAll: g("check-all", 60337),
  pinnedDirty: g("pinned-dirty", 60338),
  passFilled: g("pass-filled", 60339),
  circleLargeFilled: g("circle-large-filled", 60340),
  circleLarge: g("circle-large", 60341),
  circleLargeOutline: g("circle-large-outline", 60341),
  combine: g("combine", 60342),
  gather: g("gather", 60342),
  table: g("table", 60343),
  variableGroup: g("variable-group", 60344),
  typeHierarchy: g("type-hierarchy", 60345),
  typeHierarchySub: g("type-hierarchy-sub", 60346),
  typeHierarchySuper: g("type-hierarchy-super", 60347),
  gitPullRequestCreate: g("git-pull-request-create", 60348),
  runAbove: g("run-above", 60349),
  runBelow: g("run-below", 60350),
  notebookTemplate: g("notebook-template", 60351),
  debugRerun: g("debug-rerun", 60352),
  workspaceTrusted: g("workspace-trusted", 60353),
  workspaceUntrusted: g("workspace-untrusted", 60354),
  workspaceUnknown: g("workspace-unknown", 60355),
  terminalCmd: g("terminal-cmd", 60356),
  terminalDebian: g("terminal-debian", 60357),
  terminalLinux: g("terminal-linux", 60358),
  terminalPowershell: g("terminal-powershell", 60359),
  terminalTmux: g("terminal-tmux", 60360),
  terminalUbuntu: g("terminal-ubuntu", 60361),
  terminalBash: g("terminal-bash", 60362),
  arrowSwap: g("arrow-swap", 60363),
  copy: g("copy", 60364),
  personAdd: g("person-add", 60365),
  filterFilled: g("filter-filled", 60366),
  wand: g("wand", 60367),
  debugLineByLine: g("debug-line-by-line", 60368),
  inspect: g("inspect", 60369),
  layers: g("layers", 60370),
  layersDot: g("layers-dot", 60371),
  layersActive: g("layers-active", 60372),
  compass: g("compass", 60373),
  compassDot: g("compass-dot", 60374),
  compassActive: g("compass-active", 60375),
  azure: g("azure", 60376),
  issueDraft: g("issue-draft", 60377),
  gitPullRequestClosed: g("git-pull-request-closed", 60378),
  gitPullRequestDraft: g("git-pull-request-draft", 60379),
  debugAll: g("debug-all", 60380),
  debugCoverage: g("debug-coverage", 60381),
  runErrors: g("run-errors", 60382),
  folderLibrary: g("folder-library", 60383),
  debugContinueSmall: g("debug-continue-small", 60384),
  beakerStop: g("beaker-stop", 60385),
  graphLine: g("graph-line", 60386),
  graphScatter: g("graph-scatter", 60387),
  pieChart: g("pie-chart", 60388),
  bracket: g("bracket", 60175),
  bracketDot: g("bracket-dot", 60389),
  bracketError: g("bracket-error", 60390),
  lockSmall: g("lock-small", 60391),
  azureDevops: g("azure-devops", 60392),
  verifiedFilled: g("verified-filled", 60393),
  newline: g("newline", 60394),
  layout: g("layout", 60395),
  layoutActivitybarLeft: g("layout-activitybar-left", 60396),
  layoutActivitybarRight: g("layout-activitybar-right", 60397),
  layoutPanelLeft: g("layout-panel-left", 60398),
  layoutPanelCenter: g("layout-panel-center", 60399),
  layoutPanelJustify: g("layout-panel-justify", 60400),
  layoutPanelRight: g("layout-panel-right", 60401),
  layoutPanel: g("layout-panel", 60402),
  layoutSidebarLeft: g("layout-sidebar-left", 60403),
  layoutSidebarRight: g("layout-sidebar-right", 60404),
  layoutStatusbar: g("layout-statusbar", 60405),
  layoutMenubar: g("layout-menubar", 60406),
  layoutCentered: g("layout-centered", 60407),
  target: g("target", 60408),
  indent: g("indent", 60409),
  recordSmall: g("record-small", 60410),
  errorSmall: g("error-small", 60411),
  terminalDecorationError: g("terminal-decoration-error", 60411),
  arrowCircleDown: g("arrow-circle-down", 60412),
  arrowCircleLeft: g("arrow-circle-left", 60413),
  arrowCircleRight: g("arrow-circle-right", 60414),
  arrowCircleUp: g("arrow-circle-up", 60415),
  layoutSidebarRightOff: g("layout-sidebar-right-off", 60416),
  layoutPanelOff: g("layout-panel-off", 60417),
  layoutSidebarLeftOff: g("layout-sidebar-left-off", 60418),
  blank: g("blank", 60419),
  heartFilled: g("heart-filled", 60420),
  map: g("map", 60421),
  mapHorizontal: g("map-horizontal", 60421),
  foldHorizontal: g("fold-horizontal", 60421),
  mapFilled: g("map-filled", 60422),
  mapHorizontalFilled: g("map-horizontal-filled", 60422),
  foldHorizontalFilled: g("fold-horizontal-filled", 60422),
  circleSmall: g("circle-small", 60423),
  bellSlash: g("bell-slash", 60424),
  bellSlashDot: g("bell-slash-dot", 60425),
  commentUnresolved: g("comment-unresolved", 60426),
  gitPullRequestGoToChanges: g("git-pull-request-go-to-changes", 60427),
  gitPullRequestNewChanges: g("git-pull-request-new-changes", 60428),
  searchFuzzy: g("search-fuzzy", 60429),
  commentDraft: g("comment-draft", 60430),
  send: g("send", 60431),
  sparkle: g("sparkle", 60432),
  insert: g("insert", 60433),
  mic: g("mic", 60434),
  thumbsdownFilled: g("thumbsdown-filled", 60435),
  thumbsupFilled: g("thumbsup-filled", 60436),
  coffee: g("coffee", 60437),
  snake: g("snake", 60438),
  game: g("game", 60439),
  vr: g("vr", 60440),
  chip: g("chip", 60441),
  piano: g("piano", 60442),
  music: g("music", 60443),
  micFilled: g("mic-filled", 60444),
  repoFetch: g("repo-fetch", 60445),
  copilot: g("copilot", 60446),
  lightbulbSparkle: g("lightbulb-sparkle", 60447),
  robot: g("robot", 60448),
  sparkleFilled: g("sparkle-filled", 60449),
  diffSingle: g("diff-single", 60450),
  diffMultiple: g("diff-multiple", 60451),
  surroundWith: g("surround-with", 60452),
  share: g("share", 60453),
  gitStash: g("git-stash", 60454),
  gitStashApply: g("git-stash-apply", 60455),
  gitStashPop: g("git-stash-pop", 60456),
  vscode: g("vscode", 60457),
  vscodeInsiders: g("vscode-insiders", 60458),
  codeOss: g("code-oss", 60459),
  runCoverage: g("run-coverage", 60460),
  runAllCoverage: g("run-all-coverage", 60461),
  coverage: g("coverage", 60462),
  githubProject: g("github-project", 60463),
  mapVertical: g("map-vertical", 60464),
  foldVertical: g("fold-vertical", 60464),
  mapVerticalFilled: g("map-vertical-filled", 60465),
  foldVerticalFilled: g("fold-vertical-filled", 60465),
  goToSearch: g("go-to-search", 60466),
  percentage: g("percentage", 60467),
  sortPercentage: g("sort-percentage", 60467),
  attach: g("attach", 60468)
}, _5 = {
  dialogError: g("dialog-error", "error"),
  dialogWarning: g("dialog-warning", "warning"),
  dialogInfo: g("dialog-info", "info"),
  dialogClose: g("dialog-close", "close"),
  treeItemExpanded: g("tree-item-expanded", "chevron-down"),
  // collapsed is done with rotation
  treeFilterOnTypeOn: g("tree-filter-on-type-on", "list-filter"),
  treeFilterOnTypeOff: g("tree-filter-on-type-off", "list-selection"),
  treeFilterClear: g("tree-filter-clear", "close"),
  treeItemLoading: g("tree-item-loading", "loading"),
  menuSelection: g("menu-selection", "check"),
  menuSubmenu: g("menu-submenu", "chevron-right"),
  menuBarMore: g("menubar-more", "more"),
  scrollbarButtonLeft: g("scrollbar-button-left", "triangle-left"),
  scrollbarButtonRight: g("scrollbar-button-right", "triangle-right"),
  scrollbarButtonUp: g("scrollbar-button-up", "triangle-up"),
  scrollbarButtonDown: g("scrollbar-button-down", "triangle-down"),
  toolBarMore: g("toolbar-more", "more"),
  quickInputBack: g("quick-input-back", "arrow-left"),
  dropDownButton: g("drop-down-button", 60084),
  symbolCustomColor: g("symbol-customcolor", 60252),
  exportIcon: g("export", 60332),
  workspaceUnspecified: g("workspace-unspecified", 60355),
  newLine: g("newline", 60394),
  thumbsDownFilled: g("thumbsdown-filled", 60435),
  thumbsUpFilled: g("thumbsup-filled", 60436),
  gitFetch: g("git-fetch", 60445),
  lightbulbSparkleAutofix: g("lightbulb-sparkle-autofix", 60447),
  debugBreakpointPending: g("debug-breakpoint-pending", 60377)
}, oe = {
  ...g5,
  ..._5
};
class K2 {
  constructor() {
    this._tokenizationSupports = /* @__PURE__ */ new Map(), this._factories = /* @__PURE__ */ new Map(), this._onDidChange = new wr(), this.onDidChange = this._onDidChange.event, this._colorMap = null;
  }
  handleChange(e) {
    this._onDidChange.fire({
      changedLanguages: e,
      changedColorMap: !1
    });
  }
  register(e, r) {
    return this._tokenizationSupports.set(e, r), this.handleChange([e]), da(() => {
      this._tokenizationSupports.get(e) === r && (this._tokenizationSupports.delete(e), this.handleChange([e]));
    });
  }
  get(e) {
    return this._tokenizationSupports.get(e) || null;
  }
  registerFactory(e, r) {
    this._factories.get(e)?.dispose();
    const n = new y5(this, e, r);
    return this._factories.set(e, n), da(() => {
      const s = this._factories.get(e);
      !s || s !== n || (this._factories.delete(e), s.dispose());
    });
  }
  async getOrCreate(e) {
    const r = this.get(e);
    if (r)
      return r;
    const n = this._factories.get(e);
    return !n || n.isResolved ? null : (await n.resolve(), this.get(e));
  }
  isResolved(e) {
    if (this.get(e))
      return !0;
    const n = this._factories.get(e);
    return !!(!n || n.isResolved);
  }
  setColorMap(e) {
    this._colorMap = e, this._onDidChange.fire({
      changedLanguages: Array.from(this._tokenizationSupports.keys()),
      changedColorMap: !0
    });
  }
  getColorMap() {
    return this._colorMap;
  }
  getDefaultBackground() {
    return this._colorMap && this._colorMap.length > 2 ? this._colorMap[
      2
      /* ColorId.DefaultBackground */
    ] : null;
  }
}
class y5 extends ma {
  get isResolved() {
    return this._isResolved;
  }
  constructor(e, r, n) {
    super(), this._registry = e, this._languageId = r, this._factory = n, this._isDisposed = !1, this._resolvePromise = null, this._isResolved = !1;
  }
  dispose() {
    this._isDisposed = !0, super.dispose();
  }
  async resolve() {
    return this._resolvePromise || (this._resolvePromise = this._create()), this._resolvePromise;
  }
  async _create() {
    const e = await this._factory.tokenizationSupport;
    this._isResolved = !0, e && !this._isDisposed && this._register(this._registry.register(this._languageId, e));
  }
}
let b5 = class {
  constructor(e, r, n) {
    this.offset = e, this.type = r, this.language = n, this._tokenBrand = void 0;
  }
  toString() {
    return "(" + this.offset + ", " + this.type + ")";
  }
};
var Ld;
(function(t) {
  t[t.Increase = 0] = "Increase", t[t.Decrease = 1] = "Decrease";
})(Ld || (Ld = {}));
var Md;
(function(t) {
  const e = /* @__PURE__ */ new Map();
  e.set(0, oe.symbolMethod), e.set(1, oe.symbolFunction), e.set(2, oe.symbolConstructor), e.set(3, oe.symbolField), e.set(4, oe.symbolVariable), e.set(5, oe.symbolClass), e.set(6, oe.symbolStruct), e.set(7, oe.symbolInterface), e.set(8, oe.symbolModule), e.set(9, oe.symbolProperty), e.set(10, oe.symbolEvent), e.set(11, oe.symbolOperator), e.set(12, oe.symbolUnit), e.set(13, oe.symbolValue), e.set(15, oe.symbolEnum), e.set(14, oe.symbolConstant), e.set(15, oe.symbolEnum), e.set(16, oe.symbolEnumMember), e.set(17, oe.symbolKeyword), e.set(27, oe.symbolSnippet), e.set(18, oe.symbolText), e.set(19, oe.symbolColor), e.set(20, oe.symbolFile), e.set(21, oe.symbolReference), e.set(22, oe.symbolCustomColor), e.set(23, oe.symbolFolder), e.set(24, oe.symbolTypeParameter), e.set(25, oe.account), e.set(26, oe.issues);
  function r(i) {
    let u = e.get(i);
    return u || (console.info("No codicon found for CompletionItemKind " + i), u = oe.symbolProperty), u;
  }
  t.toIcon = r;
  const n = /* @__PURE__ */ new Map();
  n.set(
    "method",
    0
    /* CompletionItemKind.Method */
  ), n.set(
    "function",
    1
    /* CompletionItemKind.Function */
  ), n.set(
    "constructor",
    2
    /* CompletionItemKind.Constructor */
  ), n.set(
    "field",
    3
    /* CompletionItemKind.Field */
  ), n.set(
    "variable",
    4
    /* CompletionItemKind.Variable */
  ), n.set(
    "class",
    5
    /* CompletionItemKind.Class */
  ), n.set(
    "struct",
    6
    /* CompletionItemKind.Struct */
  ), n.set(
    "interface",
    7
    /* CompletionItemKind.Interface */
  ), n.set(
    "module",
    8
    /* CompletionItemKind.Module */
  ), n.set(
    "property",
    9
    /* CompletionItemKind.Property */
  ), n.set(
    "event",
    10
    /* CompletionItemKind.Event */
  ), n.set(
    "operator",
    11
    /* CompletionItemKind.Operator */
  ), n.set(
    "unit",
    12
    /* CompletionItemKind.Unit */
  ), n.set(
    "value",
    13
    /* CompletionItemKind.Value */
  ), n.set(
    "constant",
    14
    /* CompletionItemKind.Constant */
  ), n.set(
    "enum",
    15
    /* CompletionItemKind.Enum */
  ), n.set(
    "enum-member",
    16
    /* CompletionItemKind.EnumMember */
  ), n.set(
    "enumMember",
    16
    /* CompletionItemKind.EnumMember */
  ), n.set(
    "keyword",
    17
    /* CompletionItemKind.Keyword */
  ), n.set(
    "snippet",
    27
    /* CompletionItemKind.Snippet */
  ), n.set(
    "text",
    18
    /* CompletionItemKind.Text */
  ), n.set(
    "color",
    19
    /* CompletionItemKind.Color */
  ), n.set(
    "file",
    20
    /* CompletionItemKind.File */
  ), n.set(
    "reference",
    21
    /* CompletionItemKind.Reference */
  ), n.set(
    "customcolor",
    22
    /* CompletionItemKind.Customcolor */
  ), n.set(
    "folder",
    23
    /* CompletionItemKind.Folder */
  ), n.set(
    "type-parameter",
    24
    /* CompletionItemKind.TypeParameter */
  ), n.set(
    "typeParameter",
    24
    /* CompletionItemKind.TypeParameter */
  ), n.set(
    "account",
    25
    /* CompletionItemKind.User */
  ), n.set(
    "issue",
    26
    /* CompletionItemKind.Issue */
  );
  function s(i, u) {
    let l = n.get(i);
    return typeof l > "u" && !u && (l = 9), l;
  }
  t.fromString = s;
})(Md || (Md = {}));
var Od;
(function(t) {
  t[t.Automatic = 0] = "Automatic", t[t.Explicit = 1] = "Explicit";
})(Od || (Od = {}));
var Cd;
(function(t) {
  t[t.Automatic = 0] = "Automatic", t[t.PasteAs = 1] = "PasteAs";
})(Cd || (Cd = {}));
var Rd;
(function(t) {
  t[t.Invoke = 1] = "Invoke", t[t.TriggerCharacter = 2] = "TriggerCharacter", t[t.ContentChange = 3] = "ContentChange";
})(Rd || (Rd = {}));
var Id;
(function(t) {
  t[t.Text = 0] = "Text", t[t.Read = 1] = "Read", t[t.Write = 2] = "Write";
})(Id || (Id = {}));
je("Array", "array"), je("Boolean", "boolean"), je("Class", "class"), je("Constant", "constant"), je("Constructor", "constructor"), je("Enum", "enumeration"), je("EnumMember", "enumeration member"), je("Event", "event"), je("Field", "field"), je("File", "file"), je("Function", "function"), je("Interface", "interface"), je("Key", "key"), je("Method", "method"), je("Module", "module"), je("Namespace", "namespace"), je("Null", "null"), je("Number", "number"), je("Object", "object"), je("Operator", "operator"), je("Package", "package"), je("Property", "property"), je("String", "string"), je("Struct", "struct"), je("TypeParameter", "type parameter"), je("Variable", "variable");
var kd;
(function(t) {
  const e = /* @__PURE__ */ new Map();
  e.set(0, oe.symbolFile), e.set(1, oe.symbolModule), e.set(2, oe.symbolNamespace), e.set(3, oe.symbolPackage), e.set(4, oe.symbolClass), e.set(5, oe.symbolMethod), e.set(6, oe.symbolProperty), e.set(7, oe.symbolField), e.set(8, oe.symbolConstructor), e.set(9, oe.symbolEnum), e.set(10, oe.symbolInterface), e.set(11, oe.symbolFunction), e.set(12, oe.symbolVariable), e.set(13, oe.symbolConstant), e.set(14, oe.symbolString), e.set(15, oe.symbolNumber), e.set(16, oe.symbolBoolean), e.set(17, oe.symbolArray), e.set(18, oe.symbolObject), e.set(19, oe.symbolKey), e.set(20, oe.symbolNull), e.set(21, oe.symbolEnumMember), e.set(22, oe.symbolStruct), e.set(23, oe.symbolEvent), e.set(24, oe.symbolOperator), e.set(25, oe.symbolTypeParameter);
  function r(n) {
    let s = e.get(n);
    return s || (console.info("No codicon found for SymbolKind " + n), s = oe.symbolProperty), s;
  }
  t.toIcon = r;
})(kd || (kd = {}));
let aT = class En {
  static {
    this.Comment = new En("comment");
  }
  static {
    this.Imports = new En("imports");
  }
  static {
    this.Region = new En("region");
  }
  /**
   * Returns a {@link FoldingRangeKind} for the given value.
   *
   * @param value of the kind.
   */
  static fromValue(e) {
    switch (e) {
      case "comment":
        return En.Comment;
      case "imports":
        return En.Imports;
      case "region":
        return En.Region;
    }
    return new En(e);
  }
  /**
   * Creates a new {@link FoldingRangeKind}.
   *
   * @param value of the kind.
   */
  constructor(e) {
    this.value = e;
  }
};
var Dd;
(function(t) {
  t[t.AIGenerated = 1] = "AIGenerated";
})(Dd || (Dd = {}));
var $d;
(function(t) {
  t[t.Invoke = 0] = "Invoke", t[t.Automatic = 1] = "Automatic";
})($d || ($d = {}));
var Fd;
(function(t) {
  function e(r) {
    return !r || typeof r != "object" ? !1 : typeof r.id == "string" && typeof r.title == "string";
  }
  t.is = e;
})(Fd || (Fd = {}));
var Ud;
(function(t) {
  t[t.Type = 1] = "Type", t[t.Parameter = 2] = "Parameter";
})(Ud || (Ud = {}));
new K2();
new K2();
var Vd;
(function(t) {
  t[t.Invoke = 0] = "Invoke", t[t.Automatic = 1] = "Automatic";
})(Vd || (Vd = {}));
var zd;
(function(t) {
  t[t.Unknown = 0] = "Unknown", t[t.Disabled = 1] = "Disabled", t[t.Enabled = 2] = "Enabled";
})(zd || (zd = {}));
var jd;
(function(t) {
  t[t.Invoke = 1] = "Invoke", t[t.Auto = 2] = "Auto";
})(jd || (jd = {}));
var Wd;
(function(t) {
  t[t.None = 0] = "None", t[t.KeepWhitespace = 1] = "KeepWhitespace", t[t.InsertAsSnippet = 4] = "InsertAsSnippet";
})(Wd || (Wd = {}));
var Gd;
(function(t) {
  t[t.Method = 0] = "Method", t[t.Function = 1] = "Function", t[t.Constructor = 2] = "Constructor", t[t.Field = 3] = "Field", t[t.Variable = 4] = "Variable", t[t.Class = 5] = "Class", t[t.Struct = 6] = "Struct", t[t.Interface = 7] = "Interface", t[t.Module = 8] = "Module", t[t.Property = 9] = "Property", t[t.Event = 10] = "Event", t[t.Operator = 11] = "Operator", t[t.Unit = 12] = "Unit", t[t.Value = 13] = "Value", t[t.Constant = 14] = "Constant", t[t.Enum = 15] = "Enum", t[t.EnumMember = 16] = "EnumMember", t[t.Keyword = 17] = "Keyword", t[t.Text = 18] = "Text", t[t.Color = 19] = "Color", t[t.File = 20] = "File", t[t.Reference = 21] = "Reference", t[t.Customcolor = 22] = "Customcolor", t[t.Folder = 23] = "Folder", t[t.TypeParameter = 24] = "TypeParameter", t[t.User = 25] = "User", t[t.Issue = 26] = "Issue", t[t.Snippet = 27] = "Snippet";
})(Gd || (Gd = {}));
var Bd;
(function(t) {
  t[t.Deprecated = 1] = "Deprecated";
})(Bd || (Bd = {}));
var qd;
(function(t) {
  t[t.Invoke = 0] = "Invoke", t[t.TriggerCharacter = 1] = "TriggerCharacter", t[t.TriggerForIncompleteCompletions = 2] = "TriggerForIncompleteCompletions";
})(qd || (qd = {}));
var Hd;
(function(t) {
  t[t.EXACT = 0] = "EXACT", t[t.ABOVE = 1] = "ABOVE", t[t.BELOW = 2] = "BELOW";
})(Hd || (Hd = {}));
var Yd;
(function(t) {
  t[t.NotSet = 0] = "NotSet", t[t.ContentFlush = 1] = "ContentFlush", t[t.RecoverFromMarkers = 2] = "RecoverFromMarkers", t[t.Explicit = 3] = "Explicit", t[t.Paste = 4] = "Paste", t[t.Undo = 5] = "Undo", t[t.Redo = 6] = "Redo";
})(Yd || (Yd = {}));
var Zd;
(function(t) {
  t[t.LF = 1] = "LF", t[t.CRLF = 2] = "CRLF";
})(Zd || (Zd = {}));
var Xd;
(function(t) {
  t[t.Text = 0] = "Text", t[t.Read = 1] = "Read", t[t.Write = 2] = "Write";
})(Xd || (Xd = {}));
var Jd;
(function(t) {
  t[t.None = 0] = "None", t[t.Keep = 1] = "Keep", t[t.Brackets = 2] = "Brackets", t[t.Advanced = 3] = "Advanced", t[t.Full = 4] = "Full";
})(Jd || (Jd = {}));
var Qd;
(function(t) {
  t[t.acceptSuggestionOnCommitCharacter = 0] = "acceptSuggestionOnCommitCharacter", t[t.acceptSuggestionOnEnter = 1] = "acceptSuggestionOnEnter", t[t.accessibilitySupport = 2] = "accessibilitySupport", t[t.accessibilityPageSize = 3] = "accessibilityPageSize", t[t.ariaLabel = 4] = "ariaLabel", t[t.ariaRequired = 5] = "ariaRequired", t[t.autoClosingBrackets = 6] = "autoClosingBrackets", t[t.autoClosingComments = 7] = "autoClosingComments", t[t.screenReaderAnnounceInlineSuggestion = 8] = "screenReaderAnnounceInlineSuggestion", t[t.autoClosingDelete = 9] = "autoClosingDelete", t[t.autoClosingOvertype = 10] = "autoClosingOvertype", t[t.autoClosingQuotes = 11] = "autoClosingQuotes", t[t.autoIndent = 12] = "autoIndent", t[t.automaticLayout = 13] = "automaticLayout", t[t.autoSurround = 14] = "autoSurround", t[t.bracketPairColorization = 15] = "bracketPairColorization", t[t.guides = 16] = "guides", t[t.codeLens = 17] = "codeLens", t[t.codeLensFontFamily = 18] = "codeLensFontFamily", t[t.codeLensFontSize = 19] = "codeLensFontSize", t[t.colorDecorators = 20] = "colorDecorators", t[t.colorDecoratorsLimit = 21] = "colorDecoratorsLimit", t[t.columnSelection = 22] = "columnSelection", t[t.comments = 23] = "comments", t[t.contextmenu = 24] = "contextmenu", t[t.copyWithSyntaxHighlighting = 25] = "copyWithSyntaxHighlighting", t[t.cursorBlinking = 26] = "cursorBlinking", t[t.cursorSmoothCaretAnimation = 27] = "cursorSmoothCaretAnimation", t[t.cursorStyle = 28] = "cursorStyle", t[t.cursorSurroundingLines = 29] = "cursorSurroundingLines", t[t.cursorSurroundingLinesStyle = 30] = "cursorSurroundingLinesStyle", t[t.cursorWidth = 31] = "cursorWidth", t[t.disableLayerHinting = 32] = "disableLayerHinting", t[t.disableMonospaceOptimizations = 33] = "disableMonospaceOptimizations", t[t.domReadOnly = 34] = "domReadOnly", t[t.dragAndDrop = 35] = "dragAndDrop", t[t.dropIntoEditor = 36] = "dropIntoEditor", t[t.emptySelectionClipboard = 37] = "emptySelectionClipboard", t[t.experimentalWhitespaceRendering = 38] = "experimentalWhitespaceRendering", t[t.extraEditorClassName = 39] = "extraEditorClassName", t[t.fastScrollSensitivity = 40] = "fastScrollSensitivity", t[t.find = 41] = "find", t[t.fixedOverflowWidgets = 42] = "fixedOverflowWidgets", t[t.folding = 43] = "folding", t[t.foldingStrategy = 44] = "foldingStrategy", t[t.foldingHighlight = 45] = "foldingHighlight", t[t.foldingImportsByDefault = 46] = "foldingImportsByDefault", t[t.foldingMaximumRegions = 47] = "foldingMaximumRegions", t[t.unfoldOnClickAfterEndOfLine = 48] = "unfoldOnClickAfterEndOfLine", t[t.fontFamily = 49] = "fontFamily", t[t.fontInfo = 50] = "fontInfo", t[t.fontLigatures = 51] = "fontLigatures", t[t.fontSize = 52] = "fontSize", t[t.fontWeight = 53] = "fontWeight", t[t.fontVariations = 54] = "fontVariations", t[t.formatOnPaste = 55] = "formatOnPaste", t[t.formatOnType = 56] = "formatOnType", t[t.glyphMargin = 57] = "glyphMargin", t[t.gotoLocation = 58] = "gotoLocation", t[t.hideCursorInOverviewRuler = 59] = "hideCursorInOverviewRuler", t[t.hover = 60] = "hover", t[t.inDiffEditor = 61] = "inDiffEditor", t[t.inlineSuggest = 62] = "inlineSuggest", t[t.inlineEdit = 63] = "inlineEdit", t[t.letterSpacing = 64] = "letterSpacing", t[t.lightbulb = 65] = "lightbulb", t[t.lineDecorationsWidth = 66] = "lineDecorationsWidth", t[t.lineHeight = 67] = "lineHeight", t[t.lineNumbers = 68] = "lineNumbers", t[t.lineNumbersMinChars = 69] = "lineNumbersMinChars", t[t.linkedEditing = 70] = "linkedEditing", t[t.links = 71] = "links", t[t.matchBrackets = 72] = "matchBrackets", t[t.minimap = 73] = "minimap", t[t.mouseStyle = 74] = "mouseStyle", t[t.mouseWheelScrollSensitivity = 75] = "mouseWheelScrollSensitivity", t[t.mouseWheelZoom = 76] = "mouseWheelZoom", t[t.multiCursorMergeOverlapping = 77] = "multiCursorMergeOverlapping", t[t.multiCursorModifier = 78] = "multiCursorModifier", t[t.multiCursorPaste = 79] = "multiCursorPaste", t[t.multiCursorLimit = 80] = "multiCursorLimit", t[t.occurrencesHighlight = 81] = "occurrencesHighlight", t[t.overviewRulerBorder = 82] = "overviewRulerBorder", t[t.overviewRulerLanes = 83] = "overviewRulerLanes", t[t.padding = 84] = "padding", t[t.pasteAs = 85] = "pasteAs", t[t.parameterHints = 86] = "parameterHints", t[t.peekWidgetDefaultFocus = 87] = "peekWidgetDefaultFocus", t[t.placeholder = 88] = "placeholder", t[t.definitionLinkOpensInPeek = 89] = "definitionLinkOpensInPeek", t[t.quickSuggestions = 90] = "quickSuggestions", t[t.quickSuggestionsDelay = 91] = "quickSuggestionsDelay", t[t.readOnly = 92] = "readOnly", t[t.readOnlyMessage = 93] = "readOnlyMessage", t[t.renameOnType = 94] = "renameOnType", t[t.renderControlCharacters = 95] = "renderControlCharacters", t[t.renderFinalNewline = 96] = "renderFinalNewline", t[t.renderLineHighlight = 97] = "renderLineHighlight", t[t.renderLineHighlightOnlyWhenFocus = 98] = "renderLineHighlightOnlyWhenFocus", t[t.renderValidationDecorations = 99] = "renderValidationDecorations", t[t.renderWhitespace = 100] = "renderWhitespace", t[t.revealHorizontalRightPadding = 101] = "revealHorizontalRightPadding", t[t.roundedSelection = 102] = "roundedSelection", t[t.rulers = 103] = "rulers", t[t.scrollbar = 104] = "scrollbar", t[t.scrollBeyondLastColumn = 105] = "scrollBeyondLastColumn", t[t.scrollBeyondLastLine = 106] = "scrollBeyondLastLine", t[t.scrollPredominantAxis = 107] = "scrollPredominantAxis", t[t.selectionClipboard = 108] = "selectionClipboard", t[t.selectionHighlight = 109] = "selectionHighlight", t[t.selectOnLineNumbers = 110] = "selectOnLineNumbers", t[t.showFoldingControls = 111] = "showFoldingControls", t[t.showUnused = 112] = "showUnused", t[t.snippetSuggestions = 113] = "snippetSuggestions", t[t.smartSelect = 114] = "smartSelect", t[t.smoothScrolling = 115] = "smoothScrolling", t[t.stickyScroll = 116] = "stickyScroll", t[t.stickyTabStops = 117] = "stickyTabStops", t[t.stopRenderingLineAfter = 118] = "stopRenderingLineAfter", t[t.suggest = 119] = "suggest", t[t.suggestFontSize = 120] = "suggestFontSize", t[t.suggestLineHeight = 121] = "suggestLineHeight", t[t.suggestOnTriggerCharacters = 122] = "suggestOnTriggerCharacters", t[t.suggestSelection = 123] = "suggestSelection", t[t.tabCompletion = 124] = "tabCompletion", t[t.tabIndex = 125] = "tabIndex", t[t.unicodeHighlighting = 126] = "unicodeHighlighting", t[t.unusualLineTerminators = 127] = "unusualLineTerminators", t[t.useShadowDOM = 128] = "useShadowDOM", t[t.useTabStops = 129] = "useTabStops", t[t.wordBreak = 130] = "wordBreak", t[t.wordSegmenterLocales = 131] = "wordSegmenterLocales", t[t.wordSeparators = 132] = "wordSeparators", t[t.wordWrap = 133] = "wordWrap", t[t.wordWrapBreakAfterCharacters = 134] = "wordWrapBreakAfterCharacters", t[t.wordWrapBreakBeforeCharacters = 135] = "wordWrapBreakBeforeCharacters", t[t.wordWrapColumn = 136] = "wordWrapColumn", t[t.wordWrapOverride1 = 137] = "wordWrapOverride1", t[t.wordWrapOverride2 = 138] = "wordWrapOverride2", t[t.wrappingIndent = 139] = "wrappingIndent", t[t.wrappingStrategy = 140] = "wrappingStrategy", t[t.showDeprecated = 141] = "showDeprecated", t[t.inlayHints = 142] = "inlayHints", t[t.editorClassName = 143] = "editorClassName", t[t.pixelRatio = 144] = "pixelRatio", t[t.tabFocusMode = 145] = "tabFocusMode", t[t.layoutInfo = 146] = "layoutInfo", t[t.wrappingInfo = 147] = "wrappingInfo", t[t.defaultColorDecorators = 148] = "defaultColorDecorators", t[t.colorDecoratorsActivatedOn = 149] = "colorDecoratorsActivatedOn", t[t.inlineCompletionsAccessibilityVerbose = 150] = "inlineCompletionsAccessibilityVerbose";
})(Qd || (Qd = {}));
var Kd;
(function(t) {
  t[t.TextDefined = 0] = "TextDefined", t[t.LF = 1] = "LF", t[t.CRLF = 2] = "CRLF";
})(Kd || (Kd = {}));
var em;
(function(t) {
  t[t.LF = 0] = "LF", t[t.CRLF = 1] = "CRLF";
})(em || (em = {}));
var tm;
(function(t) {
  t[t.Left = 1] = "Left", t[t.Center = 2] = "Center", t[t.Right = 3] = "Right";
})(tm || (tm = {}));
var rm;
(function(t) {
  t[t.Increase = 0] = "Increase", t[t.Decrease = 1] = "Decrease";
})(rm || (rm = {}));
var nm;
(function(t) {
  t[t.None = 0] = "None", t[t.Indent = 1] = "Indent", t[t.IndentOutdent = 2] = "IndentOutdent", t[t.Outdent = 3] = "Outdent";
})(nm || (nm = {}));
var sm;
(function(t) {
  t[t.Both = 0] = "Both", t[t.Right = 1] = "Right", t[t.Left = 2] = "Left", t[t.None = 3] = "None";
})(sm || (sm = {}));
var im;
(function(t) {
  t[t.Type = 1] = "Type", t[t.Parameter = 2] = "Parameter";
})(im || (im = {}));
var om;
(function(t) {
  t[t.Automatic = 0] = "Automatic", t[t.Explicit = 1] = "Explicit";
})(om || (om = {}));
var am;
(function(t) {
  t[t.Invoke = 0] = "Invoke", t[t.Automatic = 1] = "Automatic";
})(am || (am = {}));
var U1;
(function(t) {
  t[t.DependsOnKbLayout = -1] = "DependsOnKbLayout", t[t.Unknown = 0] = "Unknown", t[t.Backspace = 1] = "Backspace", t[t.Tab = 2] = "Tab", t[t.Enter = 3] = "Enter", t[t.Shift = 4] = "Shift", t[t.Ctrl = 5] = "Ctrl", t[t.Alt = 6] = "Alt", t[t.PauseBreak = 7] = "PauseBreak", t[t.CapsLock = 8] = "CapsLock", t[t.Escape = 9] = "Escape", t[t.Space = 10] = "Space", t[t.PageUp = 11] = "PageUp", t[t.PageDown = 12] = "PageDown", t[t.End = 13] = "End", t[t.Home = 14] = "Home", t[t.LeftArrow = 15] = "LeftArrow", t[t.UpArrow = 16] = "UpArrow", t[t.RightArrow = 17] = "RightArrow", t[t.DownArrow = 18] = "DownArrow", t[t.Insert = 19] = "Insert", t[t.Delete = 20] = "Delete", t[t.Digit0 = 21] = "Digit0", t[t.Digit1 = 22] = "Digit1", t[t.Digit2 = 23] = "Digit2", t[t.Digit3 = 24] = "Digit3", t[t.Digit4 = 25] = "Digit4", t[t.Digit5 = 26] = "Digit5", t[t.Digit6 = 27] = "Digit6", t[t.Digit7 = 28] = "Digit7", t[t.Digit8 = 29] = "Digit8", t[t.Digit9 = 30] = "Digit9", t[t.KeyA = 31] = "KeyA", t[t.KeyB = 32] = "KeyB", t[t.KeyC = 33] = "KeyC", t[t.KeyD = 34] = "KeyD", t[t.KeyE = 35] = "KeyE", t[t.KeyF = 36] = "KeyF", t[t.KeyG = 37] = "KeyG", t[t.KeyH = 38] = "KeyH", t[t.KeyI = 39] = "KeyI", t[t.KeyJ = 40] = "KeyJ", t[t.KeyK = 41] = "KeyK", t[t.KeyL = 42] = "KeyL", t[t.KeyM = 43] = "KeyM", t[t.KeyN = 44] = "KeyN", t[t.KeyO = 45] = "KeyO", t[t.KeyP = 46] = "KeyP", t[t.KeyQ = 47] = "KeyQ", t[t.KeyR = 48] = "KeyR", t[t.KeyS = 49] = "KeyS", t[t.KeyT = 50] = "KeyT", t[t.KeyU = 51] = "KeyU", t[t.KeyV = 52] = "KeyV", t[t.KeyW = 53] = "KeyW", t[t.KeyX = 54] = "KeyX", t[t.KeyY = 55] = "KeyY", t[t.KeyZ = 56] = "KeyZ", t[t.Meta = 57] = "Meta", t[t.ContextMenu = 58] = "ContextMenu", t[t.F1 = 59] = "F1", t[t.F2 = 60] = "F2", t[t.F3 = 61] = "F3", t[t.F4 = 62] = "F4", t[t.F5 = 63] = "F5", t[t.F6 = 64] = "F6", t[t.F7 = 65] = "F7", t[t.F8 = 66] = "F8", t[t.F9 = 67] = "F9", t[t.F10 = 68] = "F10", t[t.F11 = 69] = "F11", t[t.F12 = 70] = "F12", t[t.F13 = 71] = "F13", t[t.F14 = 72] = "F14", t[t.F15 = 73] = "F15", t[t.F16 = 74] = "F16", t[t.F17 = 75] = "F17", t[t.F18 = 76] = "F18", t[t.F19 = 77] = "F19", t[t.F20 = 78] = "F20", t[t.F21 = 79] = "F21", t[t.F22 = 80] = "F22", t[t.F23 = 81] = "F23", t[t.F24 = 82] = "F24", t[t.NumLock = 83] = "NumLock", t[t.ScrollLock = 84] = "ScrollLock", t[t.Semicolon = 85] = "Semicolon", t[t.Equal = 86] = "Equal", t[t.Comma = 87] = "Comma", t[t.Minus = 88] = "Minus", t[t.Period = 89] = "Period", t[t.Slash = 90] = "Slash", t[t.Backquote = 91] = "Backquote", t[t.BracketLeft = 92] = "BracketLeft", t[t.Backslash = 93] = "Backslash", t[t.BracketRight = 94] = "BracketRight", t[t.Quote = 95] = "Quote", t[t.OEM_8 = 96] = "OEM_8", t[t.IntlBackslash = 97] = "IntlBackslash", t[t.Numpad0 = 98] = "Numpad0", t[t.Numpad1 = 99] = "Numpad1", t[t.Numpad2 = 100] = "Numpad2", t[t.Numpad3 = 101] = "Numpad3", t[t.Numpad4 = 102] = "Numpad4", t[t.Numpad5 = 103] = "Numpad5", t[t.Numpad6 = 104] = "Numpad6", t[t.Numpad7 = 105] = "Numpad7", t[t.Numpad8 = 106] = "Numpad8", t[t.Numpad9 = 107] = "Numpad9", t[t.NumpadMultiply = 108] = "NumpadMultiply", t[t.NumpadAdd = 109] = "NumpadAdd", t[t.NUMPAD_SEPARATOR = 110] = "NUMPAD_SEPARATOR", t[t.NumpadSubtract = 111] = "NumpadSubtract", t[t.NumpadDecimal = 112] = "NumpadDecimal", t[t.NumpadDivide = 113] = "NumpadDivide", t[t.KEY_IN_COMPOSITION = 114] = "KEY_IN_COMPOSITION", t[t.ABNT_C1 = 115] = "ABNT_C1", t[t.ABNT_C2 = 116] = "ABNT_C2", t[t.AudioVolumeMute = 117] = "AudioVolumeMute", t[t.AudioVolumeUp = 118] = "AudioVolumeUp", t[t.AudioVolumeDown = 119] = "AudioVolumeDown", t[t.BrowserSearch = 120] = "BrowserSearch", t[t.BrowserHome = 121] = "BrowserHome", t[t.BrowserBack = 122] = "BrowserBack", t[t.BrowserForward = 123] = "BrowserForward", t[t.MediaTrackNext = 124] = "MediaTrackNext", t[t.MediaTrackPrevious = 125] = "MediaTrackPrevious", t[t.MediaStop = 126] = "MediaStop", t[t.MediaPlayPause = 127] = "MediaPlayPause", t[t.LaunchMediaPlayer = 128] = "LaunchMediaPlayer", t[t.LaunchMail = 129] = "LaunchMail", t[t.LaunchApp2 = 130] = "LaunchApp2", t[t.Clear = 131] = "Clear", t[t.MAX_VALUE = 132] = "MAX_VALUE";
})(U1 || (U1 = {}));
var V1;
(function(t) {
  t[t.Hint = 1] = "Hint", t[t.Info = 2] = "Info", t[t.Warning = 4] = "Warning", t[t.Error = 8] = "Error";
})(V1 || (V1 = {}));
var z1;
(function(t) {
  t[t.Unnecessary = 1] = "Unnecessary", t[t.Deprecated = 2] = "Deprecated";
})(z1 || (z1 = {}));
var um;
(function(t) {
  t[t.Inline = 1] = "Inline", t[t.Gutter = 2] = "Gutter";
})(um || (um = {}));
var lm;
(function(t) {
  t[t.Normal = 1] = "Normal", t[t.Underlined = 2] = "Underlined";
})(lm || (lm = {}));
var cm;
(function(t) {
  t[t.UNKNOWN = 0] = "UNKNOWN", t[t.TEXTAREA = 1] = "TEXTAREA", t[t.GUTTER_GLYPH_MARGIN = 2] = "GUTTER_GLYPH_MARGIN", t[t.GUTTER_LINE_NUMBERS = 3] = "GUTTER_LINE_NUMBERS", t[t.GUTTER_LINE_DECORATIONS = 4] = "GUTTER_LINE_DECORATIONS", t[t.GUTTER_VIEW_ZONE = 5] = "GUTTER_VIEW_ZONE", t[t.CONTENT_TEXT = 6] = "CONTENT_TEXT", t[t.CONTENT_EMPTY = 7] = "CONTENT_EMPTY", t[t.CONTENT_VIEW_ZONE = 8] = "CONTENT_VIEW_ZONE", t[t.CONTENT_WIDGET = 9] = "CONTENT_WIDGET", t[t.OVERVIEW_RULER = 10] = "OVERVIEW_RULER", t[t.SCROLLBAR = 11] = "SCROLLBAR", t[t.OVERLAY_WIDGET = 12] = "OVERLAY_WIDGET", t[t.OUTSIDE_EDITOR = 13] = "OUTSIDE_EDITOR";
})(cm || (cm = {}));
var fm;
(function(t) {
  t[t.AIGenerated = 1] = "AIGenerated";
})(fm || (fm = {}));
var hm;
(function(t) {
  t[t.Invoke = 0] = "Invoke", t[t.Automatic = 1] = "Automatic";
})(hm || (hm = {}));
var dm;
(function(t) {
  t[t.TOP_RIGHT_CORNER = 0] = "TOP_RIGHT_CORNER", t[t.BOTTOM_RIGHT_CORNER = 1] = "BOTTOM_RIGHT_CORNER", t[t.TOP_CENTER = 2] = "TOP_CENTER";
})(dm || (dm = {}));
var mm;
(function(t) {
  t[t.Left = 1] = "Left", t[t.Center = 2] = "Center", t[t.Right = 4] = "Right", t[t.Full = 7] = "Full";
})(mm || (mm = {}));
var pm;
(function(t) {
  t[t.Word = 0] = "Word", t[t.Line = 1] = "Line", t[t.Suggest = 2] = "Suggest";
})(pm || (pm = {}));
var gm;
(function(t) {
  t[t.Left = 0] = "Left", t[t.Right = 1] = "Right", t[t.None = 2] = "None", t[t.LeftOfInjectedText = 3] = "LeftOfInjectedText", t[t.RightOfInjectedText = 4] = "RightOfInjectedText";
})(gm || (gm = {}));
var _m;
(function(t) {
  t[t.Off = 0] = "Off", t[t.On = 1] = "On", t[t.Relative = 2] = "Relative", t[t.Interval = 3] = "Interval", t[t.Custom = 4] = "Custom";
})(_m || (_m = {}));
var ym;
(function(t) {
  t[t.None = 0] = "None", t[t.Text = 1] = "Text", t[t.Blocks = 2] = "Blocks";
})(ym || (ym = {}));
var bm;
(function(t) {
  t[t.Smooth = 0] = "Smooth", t[t.Immediate = 1] = "Immediate";
})(bm || (bm = {}));
var wm;
(function(t) {
  t[t.Auto = 1] = "Auto", t[t.Hidden = 2] = "Hidden", t[t.Visible = 3] = "Visible";
})(wm || (wm = {}));
var j1;
(function(t) {
  t[t.LTR = 0] = "LTR", t[t.RTL = 1] = "RTL";
})(j1 || (j1 = {}));
var vm;
(function(t) {
  t.Off = "off", t.OnCode = "onCode", t.On = "on";
})(vm || (vm = {}));
var Sm;
(function(t) {
  t[t.Invoke = 1] = "Invoke", t[t.TriggerCharacter = 2] = "TriggerCharacter", t[t.ContentChange = 3] = "ContentChange";
})(Sm || (Sm = {}));
var Em;
(function(t) {
  t[t.File = 0] = "File", t[t.Module = 1] = "Module", t[t.Namespace = 2] = "Namespace", t[t.Package = 3] = "Package", t[t.Class = 4] = "Class", t[t.Method = 5] = "Method", t[t.Property = 6] = "Property", t[t.Field = 7] = "Field", t[t.Constructor = 8] = "Constructor", t[t.Enum = 9] = "Enum", t[t.Interface = 10] = "Interface", t[t.Function = 11] = "Function", t[t.Variable = 12] = "Variable", t[t.Constant = 13] = "Constant", t[t.String = 14] = "String", t[t.Number = 15] = "Number", t[t.Boolean = 16] = "Boolean", t[t.Array = 17] = "Array", t[t.Object = 18] = "Object", t[t.Key = 19] = "Key", t[t.Null = 20] = "Null", t[t.EnumMember = 21] = "EnumMember", t[t.Struct = 22] = "Struct", t[t.Event = 23] = "Event", t[t.Operator = 24] = "Operator", t[t.TypeParameter = 25] = "TypeParameter";
})(Em || (Em = {}));
var Nm;
(function(t) {
  t[t.Deprecated = 1] = "Deprecated";
})(Nm || (Nm = {}));
var xm;
(function(t) {
  t[t.Hidden = 0] = "Hidden", t[t.Blink = 1] = "Blink", t[t.Smooth = 2] = "Smooth", t[t.Phase = 3] = "Phase", t[t.Expand = 4] = "Expand", t[t.Solid = 5] = "Solid";
})(xm || (xm = {}));
var Tm;
(function(t) {
  t[t.Line = 1] = "Line", t[t.Block = 2] = "Block", t[t.Underline = 3] = "Underline", t[t.LineThin = 4] = "LineThin", t[t.BlockOutline = 5] = "BlockOutline", t[t.UnderlineThin = 6] = "UnderlineThin";
})(Tm || (Tm = {}));
var Pm;
(function(t) {
  t[t.AlwaysGrowsWhenTypingAtEdges = 0] = "AlwaysGrowsWhenTypingAtEdges", t[t.NeverGrowsWhenTypingAtEdges = 1] = "NeverGrowsWhenTypingAtEdges", t[t.GrowsOnlyWhenTypingBefore = 2] = "GrowsOnlyWhenTypingBefore", t[t.GrowsOnlyWhenTypingAfter = 3] = "GrowsOnlyWhenTypingAfter";
})(Pm || (Pm = {}));
var Am;
(function(t) {
  t[t.None = 0] = "None", t[t.Same = 1] = "Same", t[t.Indent = 2] = "Indent", t[t.DeepIndent = 3] = "DeepIndent";
})(Am || (Am = {}));
class w5 {
  static {
    this.CtrlCmd = 2048;
  }
  static {
    this.Shift = 1024;
  }
  static {
    this.Alt = 512;
  }
  static {
    this.WinCtrl = 256;
  }
  static chord(e, r) {
    return m5(e, r);
  }
}
function v5() {
  return {
    editor: void 0,
    // undefined override expected here
    languages: void 0,
    // undefined override expected here
    CancellationTokenSource: c5,
    Emitter: wr,
    KeyCode: U1,
    KeyMod: w5,
    Position: st,
    Range: xe,
    Selection: ar,
    SelectionDirection: j1,
    MarkerSeverity: V1,
    MarkerTag: z1,
    Uri: Jr,
    Token: b5
  };
}
class Sa {
  static {
    this.CHANNEL_NAME = "editorWorkerHost";
  }
  static getChannel(e) {
    return e.getChannel(Sa.CHANNEL_NAME);
  }
  static setChannel(e, r) {
    e.setChannel(Sa.CHANNEL_NAME, r);
  }
}
var Lm;
class S5 {
  constructor() {
    this[Lm] = "LinkedMap", this._map = /* @__PURE__ */ new Map(), this._head = void 0, this._tail = void 0, this._size = 0, this._state = 0;
  }
  clear() {
    this._map.clear(), this._head = void 0, this._tail = void 0, this._size = 0, this._state++;
  }
  isEmpty() {
    return !this._head && !this._tail;
  }
  get size() {
    return this._size;
  }
  get first() {
    return this._head?.value;
  }
  get last() {
    return this._tail?.value;
  }
  has(e) {
    return this._map.has(e);
  }
  get(e, r = 0) {
    const n = this._map.get(e);
    if (n)
      return r !== 0 && this.touch(n, r), n.value;
  }
  set(e, r, n = 0) {
    let s = this._map.get(e);
    if (s)
      s.value = r, n !== 0 && this.touch(s, n);
    else {
      switch (s = { key: e, value: r, next: void 0, previous: void 0 }, n) {
        case 0:
          this.addItemLast(s);
          break;
        case 1:
          this.addItemFirst(s);
          break;
        case 2:
          this.addItemLast(s);
          break;
        default:
          this.addItemLast(s);
          break;
      }
      this._map.set(e, s), this._size++;
    }
    return this;
  }
  delete(e) {
    return !!this.remove(e);
  }
  remove(e) {
    const r = this._map.get(e);
    if (r)
      return this._map.delete(e), this.removeItem(r), this._size--, r.value;
  }
  shift() {
    if (!this._head && !this._tail)
      return;
    if (!this._head || !this._tail)
      throw new Error("Invalid list");
    const e = this._head;
    return this._map.delete(e.key), this.removeItem(e), this._size--, e.value;
  }
  forEach(e, r) {
    const n = this._state;
    let s = this._head;
    for (; s; ) {
      if (r ? e.bind(r)(s.value, s.key, this) : e(s.value, s.key, this), this._state !== n)
        throw new Error("LinkedMap got modified during iteration.");
      s = s.next;
    }
  }
  keys() {
    const e = this, r = this._state;
    let n = this._head;
    const s = {
      [Symbol.iterator]() {
        return s;
      },
      next() {
        if (e._state !== r)
          throw new Error("LinkedMap got modified during iteration.");
        if (n) {
          const i = { value: n.key, done: !1 };
          return n = n.next, i;
        } else
          return { value: void 0, done: !0 };
      }
    };
    return s;
  }
  values() {
    const e = this, r = this._state;
    let n = this._head;
    const s = {
      [Symbol.iterator]() {
        return s;
      },
      next() {
        if (e._state !== r)
          throw new Error("LinkedMap got modified during iteration.");
        if (n) {
          const i = { value: n.value, done: !1 };
          return n = n.next, i;
        } else
          return { value: void 0, done: !0 };
      }
    };
    return s;
  }
  entries() {
    const e = this, r = this._state;
    let n = this._head;
    const s = {
      [Symbol.iterator]() {
        return s;
      },
      next() {
        if (e._state !== r)
          throw new Error("LinkedMap got modified during iteration.");
        if (n) {
          const i = { value: [n.key, n.value], done: !1 };
          return n = n.next, i;
        } else
          return { value: void 0, done: !0 };
      }
    };
    return s;
  }
  [(Lm = Symbol.toStringTag, Symbol.iterator)]() {
    return this.entries();
  }
  trimOld(e) {
    if (e >= this.size)
      return;
    if (e === 0) {
      this.clear();
      return;
    }
    let r = this._head, n = this.size;
    for (; r && n > e; )
      this._map.delete(r.key), r = r.next, n--;
    this._head = r, this._size = n, r && (r.previous = void 0), this._state++;
  }
  trimNew(e) {
    if (e >= this.size)
      return;
    if (e === 0) {
      this.clear();
      return;
    }
    let r = this._tail, n = this.size;
    for (; r && n > e; )
      this._map.delete(r.key), r = r.previous, n--;
    this._tail = r, this._size = n, r && (r.next = void 0), this._state++;
  }
  addItemFirst(e) {
    if (!this._head && !this._tail)
      this._tail = e;
    else if (this._head)
      e.next = this._head, this._head.previous = e;
    else
      throw new Error("Invalid list");
    this._head = e, this._state++;
  }
  addItemLast(e) {
    if (!this._head && !this._tail)
      this._head = e;
    else if (this._tail)
      e.previous = this._tail, this._tail.next = e;
    else
      throw new Error("Invalid list");
    this._tail = e, this._state++;
  }
  removeItem(e) {
    if (e === this._head && e === this._tail)
      this._head = void 0, this._tail = void 0;
    else if (e === this._head) {
      if (!e.next)
        throw new Error("Invalid list");
      e.next.previous = void 0, this._head = e.next;
    } else if (e === this._tail) {
      if (!e.previous)
        throw new Error("Invalid list");
      e.previous.next = void 0, this._tail = e.previous;
    } else {
      const r = e.next, n = e.previous;
      if (!r || !n)
        throw new Error("Invalid list");
      r.previous = n, n.next = r;
    }
    e.next = void 0, e.previous = void 0, this._state++;
  }
  touch(e, r) {
    if (!this._head || !this._tail)
      throw new Error("Invalid list");
    if (!(r !== 1 && r !== 2)) {
      if (r === 1) {
        if (e === this._head)
          return;
        const n = e.next, s = e.previous;
        e === this._tail ? (s.next = void 0, this._tail = s) : (n.previous = s, s.next = n), e.previous = void 0, e.next = this._head, this._head.previous = e, this._head = e, this._state++;
      } else if (r === 2) {
        if (e === this._tail)
          return;
        const n = e.next, s = e.previous;
        e === this._head ? (n.previous = void 0, this._head = n) : (n.previous = s, s.next = n), e.next = void 0, e.previous = this._tail, this._tail.next = e, this._tail = e, this._state++;
      }
    }
  }
  toJSON() {
    const e = [];
    return this.forEach((r, n) => {
      e.push([n, r]);
    }), e;
  }
  fromJSON(e) {
    this.clear();
    for (const [r, n] of e)
      this.set(r, n);
  }
}
class E5 extends S5 {
  constructor(e, r = 1) {
    super(), this._limit = e, this._ratio = Math.min(Math.max(0, r), 1);
  }
  get limit() {
    return this._limit;
  }
  set limit(e) {
    this._limit = e, this.checkTrim();
  }
  get(e, r = 2) {
    return super.get(e, r);
  }
  peek(e) {
    return super.get(
      e,
      0
      /* Touch.None */
    );
  }
  set(e, r) {
    return super.set(
      e,
      r,
      2
      /* Touch.AsNew */
    ), this;
  }
  checkTrim() {
    this.size > this._limit && this.trim(Math.round(this._limit * this._ratio));
  }
}
class N5 extends E5 {
  constructor(e, r = 1) {
    super(e, r);
  }
  trim(e) {
    this.trimOld(e);
  }
  set(e, r) {
    return super.set(e, r), this.checkTrim(), this;
  }
}
class x5 {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  add(e, r) {
    let n = this.map.get(e);
    n || (n = /* @__PURE__ */ new Set(), this.map.set(e, n)), n.add(r);
  }
  delete(e, r) {
    const n = this.map.get(e);
    n && (n.delete(r), n.size === 0 && this.map.delete(e));
  }
  forEach(e, r) {
    const n = this.map.get(e);
    n && n.forEach(r);
  }
  get(e) {
    const r = this.map.get(e);
    return r || /* @__PURE__ */ new Set();
  }
}
new N5(10);
function T5(t) {
  let e = [];
  for (; Object.prototype !== t; )
    e = e.concat(Object.getOwnPropertyNames(t)), t = Object.getPrototypeOf(t);
  return e;
}
function Mm(t) {
  const e = [];
  for (const r of T5(t))
    typeof t[r] == "function" && e.push(r);
  return e;
}
function P5(t, e) {
  const r = (s) => function() {
    const i = Array.prototype.slice.call(arguments, 0);
    return e(s, i);
  }, n = {};
  for (const s of t)
    n[s] = r(s);
  return n;
}
var Om;
(function(t) {
  t[t.Left = 1] = "Left", t[t.Center = 2] = "Center", t[t.Right = 4] = "Right", t[t.Full = 7] = "Full";
})(Om || (Om = {}));
var Cm;
(function(t) {
  t[t.Left = 1] = "Left", t[t.Center = 2] = "Center", t[t.Right = 3] = "Right";
})(Cm || (Cm = {}));
var Rm;
(function(t) {
  t[t.Both = 0] = "Both", t[t.Right = 1] = "Right", t[t.Left = 2] = "Left", t[t.None = 3] = "None";
})(Rm || (Rm = {}));
function A5(t, e, r, n, s) {
  if (n === 0)
    return !0;
  const i = e.charCodeAt(n - 1);
  if (t.get(i) !== 0 || i === 13 || i === 10)
    return !0;
  if (s > 0) {
    const u = e.charCodeAt(n);
    if (t.get(u) !== 0)
      return !0;
  }
  return !1;
}
function L5(t, e, r, n, s) {
  if (n + s === r)
    return !0;
  const i = e.charCodeAt(n + s);
  if (t.get(i) !== 0 || i === 13 || i === 10)
    return !0;
  if (s > 0) {
    const u = e.charCodeAt(n + s - 1);
    if (t.get(u) !== 0)
      return !0;
  }
  return !1;
}
function M5(t, e, r, n, s) {
  return A5(t, e, r, n, s) && L5(t, e, r, n, s);
}
class O5 {
  constructor(e, r) {
    this._wordSeparators = e, this._searchRegex = r, this._prevMatchStartIndex = -1, this._prevMatchLength = 0;
  }
  reset(e) {
    this._searchRegex.lastIndex = e, this._prevMatchStartIndex = -1, this._prevMatchLength = 0;
  }
  next(e) {
    const r = e.length;
    let n;
    do {
      if (this._prevMatchStartIndex + this._prevMatchLength === r || (n = this._searchRegex.exec(e), !n))
        return null;
      const s = n.index, i = n[0].length;
      if (s === this._prevMatchStartIndex && i === this._prevMatchLength) {
        if (i === 0) {
          N6(e, r, this._searchRegex.lastIndex) > 65535 ? this._searchRegex.lastIndex += 2 : this._searchRegex.lastIndex += 1;
          continue;
        }
        return null;
      }
      if (this._prevMatchStartIndex = s, this._prevMatchLength = i, !this._wordSeparators || M5(this._wordSeparators, e, r, s, i))
        return n;
    } while (n);
    return null;
  }
}
function C5(t, e = "Unreachable") {
  throw new Error(e);
}
function Ea(t) {
  if (!t()) {
    debugger;
    t(), vi(new hr("Assertion Failed"));
  }
}
function e_(t, e) {
  let r = 0;
  for (; r < t.length - 1; ) {
    const n = t[r], s = t[r + 1];
    if (!e(n, s))
      return !1;
    r++;
  }
  return !0;
}
const R5 = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
function I5(t = "") {
  let e = "(-?\\d*\\.\\d\\w*)|([^";
  for (const r of R5)
    t.indexOf(r) >= 0 || (e += "\\" + r);
  return e += "\\s]+)", new RegExp(e, "g");
}
const t_ = I5();
function r_(t) {
  let e = t_;
  if (t && t instanceof RegExp)
    if (t.global)
      e = t;
    else {
      let r = "g";
      t.ignoreCase && (r += "i"), t.multiline && (r += "m"), t.unicode && (r += "u"), e = new RegExp(t.source, r);
    }
  return e.lastIndex = 0, e;
}
const n_ = new Xb();
n_.unshift({
  maxLen: 1e3,
  windowSize: 15,
  timeBudget: 150
});
function eh(t, e, r, n, s) {
  if (e = r_(e), s || (s = ha.first(n_)), r.length > s.maxLen) {
    let m = t - s.maxLen / 2;
    return m < 0 ? m = 0 : n += m, r = r.substring(m, t + s.maxLen / 2), eh(t, e, r, n, s);
  }
  const i = Date.now(), u = t - 1 - n;
  let l = -1, c = null;
  for (let m = 1; !(Date.now() - i >= s.timeBudget); m++) {
    const _ = u - s.windowSize * m;
    e.lastIndex = Math.max(0, _);
    const y = k5(e, r, u, l);
    if (!y && c || (c = y, _ <= 0))
      break;
    l = _;
  }
  if (c) {
    const m = {
      word: c[0],
      startColumn: n + 1 + c.index,
      endColumn: n + 1 + c.index + c[0].length
    };
    return e.lastIndex = 0, m;
  }
  return null;
}
function k5(t, e, r, n) {
  let s;
  for (; s = t.exec(e); ) {
    const i = s.index || 0;
    if (i <= r && t.lastIndex >= r)
      return s;
    if (n > 0 && i > n)
      return null;
  }
  return null;
}
class D5 {
  static computeUnicodeHighlights(e, r, n) {
    const s = n ? n.startLineNumber : 1, i = n ? n.endLineNumber : e.getLineCount(), u = new Im(r), l = u.getCandidateCodePoints();
    let c;
    l === "allNonBasicAscii" ? c = new RegExp("[^\\t\\n\\r\\x20-\\x7E]", "g") : c = new RegExp(`${$5(Array.from(l))}`, "g");
    const m = new O5(null, c), _ = [];
    let y = !1, v, S = 0, T = 0, L = 0;
    e: for (let D = s, V = i; D <= V; D++) {
      const W = e.getLineContent(D), j = W.length;
      m.reset(0);
      do
        if (v = m.next(W), v) {
          let U = v.index, $ = v.index + v[0].length;
          if (U > 0) {
            const ye = W.charCodeAt(U - 1);
            R1(ye) && U--;
          }
          if ($ + 1 < j) {
            const ye = W.charCodeAt($ - 1);
            R1(ye) && $++;
          }
          const B = W.substring(U, $);
          let Z = eh(U + 1, t_, W, 0);
          Z && Z.endColumn <= U + 1 && (Z = null);
          const ee = u.shouldHighlightNonBasicASCII(B, Z ? Z.word : null);
          if (ee !== 0) {
            if (ee === 3 ? S++ : ee === 2 ? T++ : ee === 1 ? L++ : C5(), _.length >= 1e3) {
              y = !0;
              break e;
            }
            _.push(new xe(D, U + 1, D, $ + 1));
          }
        }
      while (v);
    }
    return {
      ranges: _,
      hasMore: y,
      ambiguousCharacterCount: S,
      invisibleCharacterCount: T,
      nonBasicAsciiCharacterCount: L
    };
  }
  static computeUnicodeHighlightReason(e, r) {
    const n = new Im(r);
    switch (n.shouldHighlightNonBasicASCII(e, null)) {
      case 0:
        return null;
      case 2:
        return {
          kind: 1
          /* UnicodeHighlighterReasonKind.Invisible */
        };
      case 3: {
        const i = e.codePointAt(0), u = n.ambiguousCharacters.getPrimaryConfusable(i), l = An.getLocales().filter((c) => !An.getInstance(/* @__PURE__ */ new Set([...r.allowedLocales, c])).isAmbiguous(i));
        return { kind: 0, confusableWith: String.fromCodePoint(u), notAmbiguousInLocales: l };
      }
      case 1:
        return {
          kind: 2
          /* UnicodeHighlighterReasonKind.NonBasicAscii */
        };
    }
  }
}
function $5(t, e) {
  return `[${y6(t.map((n) => String.fromCodePoint(n)).join(""))}]`;
}
class Im {
  constructor(e) {
    this.options = e, this.allowedCodePoints = new Set(e.allowedCodePoints), this.ambiguousCharacters = An.getInstance(new Set(e.allowedLocales));
  }
  getCandidateCodePoints() {
    if (this.options.nonBasicASCII)
      return "allNonBasicAscii";
    const e = /* @__PURE__ */ new Set();
    if (this.options.invisibleCharacters)
      for (const r of Xn.codePoints)
        km(String.fromCodePoint(r)) || e.add(r);
    if (this.options.ambiguousCharacters)
      for (const r of this.ambiguousCharacters.getConfusableCodePoints())
        e.add(r);
    for (const r of this.allowedCodePoints)
      e.delete(r);
    return e;
  }
  shouldHighlightNonBasicASCII(e, r) {
    const n = e.codePointAt(0);
    if (this.allowedCodePoints.has(n))
      return 0;
    if (this.options.nonBasicASCII)
      return 1;
    let s = !1, i = !1;
    if (r)
      for (const u of r) {
        const l = u.codePointAt(0), c = T6(u);
        s = s || c, !c && !this.ambiguousCharacters.isAmbiguous(l) && !Xn.isInvisibleCharacter(l) && (i = !0);
      }
    return (
      /* Don't allow mixing weird looking characters with ASCII */
      !s && /* Is there an obviously weird looking character? */
      i ? 0 : this.options.invisibleCharacters && !km(e) && Xn.isInvisibleCharacter(n) ? 2 : this.options.ambiguousCharacters && this.ambiguousCharacters.isAmbiguous(n) ? 3 : 0
    );
  }
}
function km(t) {
  return t === " " || t === `
` || t === "	";
}
class Ho {
  constructor(e, r, n) {
    this.changes = e, this.moves = r, this.hitTimeout = n;
  }
}
class F5 {
  constructor(e, r) {
    this.lineRangeMapping = e, this.changes = r;
  }
}
class Ne {
  static addRange(e, r) {
    let n = 0;
    for (; n < r.length && r[n].endExclusive < e.start; )
      n++;
    let s = n;
    for (; s < r.length && r[s].start <= e.endExclusive; )
      s++;
    if (n === s)
      r.splice(n, 0, e);
    else {
      const i = Math.min(e.start, r[n].start), u = Math.max(e.endExclusive, r[s - 1].endExclusive);
      r.splice(n, s - n, new Ne(i, u));
    }
  }
  static tryCreate(e, r) {
    if (!(e > r))
      return new Ne(e, r);
  }
  static ofLength(e) {
    return new Ne(0, e);
  }
  static ofStartAndLength(e, r) {
    return new Ne(e, e + r);
  }
  constructor(e, r) {
    if (this.start = e, this.endExclusive = r, e > r)
      throw new hr(`Invalid range: ${this.toString()}`);
  }
  get isEmpty() {
    return this.start === this.endExclusive;
  }
  delta(e) {
    return new Ne(this.start + e, this.endExclusive + e);
  }
  deltaStart(e) {
    return new Ne(this.start + e, this.endExclusive);
  }
  deltaEnd(e) {
    return new Ne(this.start, this.endExclusive + e);
  }
  get length() {
    return this.endExclusive - this.start;
  }
  toString() {
    return `[${this.start}, ${this.endExclusive})`;
  }
  contains(e) {
    return this.start <= e && e < this.endExclusive;
  }
  /**
   * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)
   * The joined range is the smallest range that contains both ranges.
   */
  join(e) {
    return new Ne(Math.min(this.start, e.start), Math.max(this.endExclusive, e.endExclusive));
  }
  /**
   * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)
   *
   * The resulting range is empty if the ranges do not intersect, but touch.
   * If the ranges don't even touch, the result is undefined.
   */
  intersect(e) {
    const r = Math.max(this.start, e.start), n = Math.min(this.endExclusive, e.endExclusive);
    if (r <= n)
      return new Ne(r, n);
  }
  intersects(e) {
    const r = Math.max(this.start, e.start), n = Math.min(this.endExclusive, e.endExclusive);
    return r < n;
  }
  isBefore(e) {
    return this.endExclusive <= e.start;
  }
  isAfter(e) {
    return this.start >= e.endExclusive;
  }
  slice(e) {
    return e.slice(this.start, this.endExclusive);
  }
  substring(e) {
    return e.substring(this.start, this.endExclusive);
  }
  /**
   * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.
   * The range must not be empty.
   */
  clip(e) {
    if (this.isEmpty)
      throw new hr(`Invalid clipping range: ${this.toString()}`);
    return Math.max(this.start, Math.min(this.endExclusive - 1, e));
  }
  /**
   * Returns `r := value + k * length` such that `r` is contained in this range.
   * The range must not be empty.
   *
   * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.
   */
  clipCyclic(e) {
    if (this.isEmpty)
      throw new hr(`Invalid clipping range: ${this.toString()}`);
    return e < this.start ? this.endExclusive - (this.start - e) % this.length : e >= this.endExclusive ? this.start + (e - this.start) % this.length : e;
  }
  forEach(e) {
    for (let r = this.start; r < this.endExclusive; r++)
      e(r);
  }
}
function $s(t, e) {
  const r = Ai(t, e);
  return r === -1 ? void 0 : t[r];
}
function Ai(t, e, r = 0, n = t.length) {
  let s = r, i = n;
  for (; s < i; ) {
    const u = Math.floor((s + i) / 2);
    e(t[u]) ? s = u + 1 : i = u;
  }
  return s - 1;
}
function U5(t, e) {
  const r = W1(t, e);
  return r === t.length ? void 0 : t[r];
}
function W1(t, e, r = 0, n = t.length) {
  let s = r, i = n;
  for (; s < i; ) {
    const u = Math.floor((s + i) / 2);
    e(t[u]) ? i = u : s = u + 1;
  }
  return s;
}
class Za {
  static {
    this.assertInvariants = !1;
  }
  constructor(e) {
    this._array = e, this._findLastMonotonousLastIdx = 0;
  }
  /**
   * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!
   * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.
   */
  findLastMonotonous(e) {
    if (Za.assertInvariants) {
      if (this._prevFindLastPredicate) {
        for (const n of this._array)
          if (this._prevFindLastPredicate(n) && !e(n))
            throw new Error("MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.");
      }
      this._prevFindLastPredicate = e;
    }
    const r = Ai(this._array, e, this._findLastMonotonousLastIdx);
    return this._findLastMonotonousLastIdx = r + 1, r === -1 ? void 0 : this._array[r];
  }
}
class be {
  static fromRangeInclusive(e) {
    return new be(e.startLineNumber, e.endLineNumber + 1);
  }
  /**
   * @param lineRanges An array of sorted line ranges.
   */
  static joinMany(e) {
    if (e.length === 0)
      return [];
    let r = new Qr(e[0].slice());
    for (let n = 1; n < e.length; n++)
      r = r.getUnion(new Qr(e[n].slice()));
    return r.ranges;
  }
  static join(e) {
    if (e.length === 0)
      throw new hr("lineRanges cannot be empty");
    let r = e[0].startLineNumber, n = e[0].endLineNumberExclusive;
    for (let s = 1; s < e.length; s++)
      r = Math.min(r, e[s].startLineNumber), n = Math.max(n, e[s].endLineNumberExclusive);
    return new be(r, n);
  }
  static ofLength(e, r) {
    return new be(e, e + r);
  }
  /**
   * @internal
   */
  static deserialize(e) {
    return new be(e[0], e[1]);
  }
  constructor(e, r) {
    if (e > r)
      throw new hr(`startLineNumber ${e} cannot be after endLineNumberExclusive ${r}`);
    this.startLineNumber = e, this.endLineNumberExclusive = r;
  }
  /**
   * Indicates if this line range contains the given line number.
   */
  contains(e) {
    return this.startLineNumber <= e && e < this.endLineNumberExclusive;
  }
  /**
   * Indicates if this line range is empty.
   */
  get isEmpty() {
    return this.startLineNumber === this.endLineNumberExclusive;
  }
  /**
   * Moves this line range by the given offset of line numbers.
   */
  delta(e) {
    return new be(this.startLineNumber + e, this.endLineNumberExclusive + e);
  }
  deltaLength(e) {
    return new be(this.startLineNumber, this.endLineNumberExclusive + e);
  }
  /**
   * The number of lines this line range spans.
   */
  get length() {
    return this.endLineNumberExclusive - this.startLineNumber;
  }
  /**
   * Creates a line range that combines this and the given line range.
   */
  join(e) {
    return new be(Math.min(this.startLineNumber, e.startLineNumber), Math.max(this.endLineNumberExclusive, e.endLineNumberExclusive));
  }
  toString() {
    return `[${this.startLineNumber},${this.endLineNumberExclusive})`;
  }
  /**
   * The resulting range is empty if the ranges do not intersect, but touch.
   * If the ranges don't even touch, the result is undefined.
   */
  intersect(e) {
    const r = Math.max(this.startLineNumber, e.startLineNumber), n = Math.min(this.endLineNumberExclusive, e.endLineNumberExclusive);
    if (r <= n)
      return new be(r, n);
  }
  intersectsStrict(e) {
    return this.startLineNumber < e.endLineNumberExclusive && e.startLineNumber < this.endLineNumberExclusive;
  }
  overlapOrTouch(e) {
    return this.startLineNumber <= e.endLineNumberExclusive && e.startLineNumber <= this.endLineNumberExclusive;
  }
  equals(e) {
    return this.startLineNumber === e.startLineNumber && this.endLineNumberExclusive === e.endLineNumberExclusive;
  }
  toInclusiveRange() {
    return this.isEmpty ? null : new xe(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);
  }
  /**
   * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!
  */
  toExclusiveRange() {
    return new xe(this.startLineNumber, 1, this.endLineNumberExclusive, 1);
  }
  mapToLineArray(e) {
    const r = [];
    for (let n = this.startLineNumber; n < this.endLineNumberExclusive; n++)
      r.push(e(n));
    return r;
  }
  forEach(e) {
    for (let r = this.startLineNumber; r < this.endLineNumberExclusive; r++)
      e(r);
  }
  /**
   * @internal
   */
  serialize() {
    return [this.startLineNumber, this.endLineNumberExclusive];
  }
  includes(e) {
    return this.startLineNumber <= e && e < this.endLineNumberExclusive;
  }
  /**
   * Converts this 1-based line range to a 0-based offset range (subtracts 1!).
   * @internal
   */
  toOffsetRange() {
    return new Ne(this.startLineNumber - 1, this.endLineNumberExclusive - 1);
  }
}
class Qr {
  constructor(e = []) {
    this._normalizedRanges = e;
  }
  get ranges() {
    return this._normalizedRanges;
  }
  addRange(e) {
    if (e.length === 0)
      return;
    const r = W1(this._normalizedRanges, (s) => s.endLineNumberExclusive >= e.startLineNumber), n = Ai(this._normalizedRanges, (s) => s.startLineNumber <= e.endLineNumberExclusive) + 1;
    if (r === n)
      this._normalizedRanges.splice(r, 0, e);
    else if (r === n - 1) {
      const s = this._normalizedRanges[r];
      this._normalizedRanges[r] = s.join(e);
    } else {
      const s = this._normalizedRanges[r].join(this._normalizedRanges[n - 1]).join(e);
      this._normalizedRanges.splice(r, n - r, s);
    }
  }
  contains(e) {
    const r = $s(this._normalizedRanges, (n) => n.startLineNumber <= e);
    return !!r && r.endLineNumberExclusive > e;
  }
  intersects(e) {
    const r = $s(this._normalizedRanges, (n) => n.startLineNumber < e.endLineNumberExclusive);
    return !!r && r.endLineNumberExclusive > e.startLineNumber;
  }
  getUnion(e) {
    if (this._normalizedRanges.length === 0)
      return e;
    if (e._normalizedRanges.length === 0)
      return this;
    const r = [];
    let n = 0, s = 0, i = null;
    for (; n < this._normalizedRanges.length || s < e._normalizedRanges.length; ) {
      let u = null;
      if (n < this._normalizedRanges.length && s < e._normalizedRanges.length) {
        const l = this._normalizedRanges[n], c = e._normalizedRanges[s];
        l.startLineNumber < c.startLineNumber ? (u = l, n++) : (u = c, s++);
      } else n < this._normalizedRanges.length ? (u = this._normalizedRanges[n], n++) : (u = e._normalizedRanges[s], s++);
      i === null ? i = u : i.endLineNumberExclusive >= u.startLineNumber ? i = new be(i.startLineNumber, Math.max(i.endLineNumberExclusive, u.endLineNumberExclusive)) : (r.push(i), i = u);
    }
    return i !== null && r.push(i), new Qr(r);
  }
  /**
   * Subtracts all ranges in this set from `range` and returns the result.
   */
  subtractFrom(e) {
    const r = W1(this._normalizedRanges, (u) => u.endLineNumberExclusive >= e.startLineNumber), n = Ai(this._normalizedRanges, (u) => u.startLineNumber <= e.endLineNumberExclusive) + 1;
    if (r === n)
      return new Qr([e]);
    const s = [];
    let i = e.startLineNumber;
    for (let u = r; u < n; u++) {
      const l = this._normalizedRanges[u];
      l.startLineNumber > i && s.push(new be(i, l.startLineNumber)), i = l.endLineNumberExclusive;
    }
    return i < e.endLineNumberExclusive && s.push(new be(i, e.endLineNumberExclusive)), new Qr(s);
  }
  toString() {
    return this._normalizedRanges.map((e) => e.toString()).join(", ");
  }
  getIntersection(e) {
    const r = [];
    let n = 0, s = 0;
    for (; n < this._normalizedRanges.length && s < e._normalizedRanges.length; ) {
      const i = this._normalizedRanges[n], u = e._normalizedRanges[s], l = i.intersect(u);
      l && !l.isEmpty && r.push(l), i.endLineNumberExclusive < u.endLineNumberExclusive ? n++ : s++;
    }
    return new Qr(r);
  }
  getWithDelta(e) {
    return new Qr(this._normalizedRanges.map((r) => r.delta(e)));
  }
}
class Ss {
  static {
    this.zero = new Ss(0, 0);
  }
  static betweenPositions(e, r) {
    return e.lineNumber === r.lineNumber ? new Ss(0, r.column - e.column) : new Ss(r.lineNumber - e.lineNumber, r.column - 1);
  }
  static ofRange(e) {
    return Ss.betweenPositions(e.getStartPosition(), e.getEndPosition());
  }
  static ofText(e) {
    let r = 0, n = 0;
    for (const s of e)
      s === `
` ? (r++, n = 0) : n++;
    return new Ss(r, n);
  }
  constructor(e, r) {
    this.lineCount = e, this.columnCount = r;
  }
  isGreaterThanOrEqualTo(e) {
    return this.lineCount !== e.lineCount ? this.lineCount > e.lineCount : this.columnCount >= e.columnCount;
  }
  createRange(e) {
    return this.lineCount === 0 ? new xe(e.lineNumber, e.column, e.lineNumber, e.column + this.columnCount) : new xe(e.lineNumber, e.column, e.lineNumber + this.lineCount, this.columnCount + 1);
  }
  addToPosition(e) {
    return this.lineCount === 0 ? new st(e.lineNumber, e.column + this.columnCount) : new st(e.lineNumber + this.lineCount, this.columnCount + 1);
  }
  toString() {
    return `${this.lineCount},${this.columnCount}`;
  }
}
class V5 {
  constructor(e, r) {
    this.range = e, this.text = r;
  }
  toSingleEditOperation() {
    return {
      range: this.range,
      text: this.text
    };
  }
}
class Nr {
  static inverse(e, r, n) {
    const s = [];
    let i = 1, u = 1;
    for (const c of e) {
      const m = new Nr(new be(i, c.original.startLineNumber), new be(u, c.modified.startLineNumber));
      m.modified.isEmpty || s.push(m), i = c.original.endLineNumberExclusive, u = c.modified.endLineNumberExclusive;
    }
    const l = new Nr(new be(i, r + 1), new be(u, n + 1));
    return l.modified.isEmpty || s.push(l), s;
  }
  static clip(e, r, n) {
    const s = [];
    for (const i of e) {
      const u = i.original.intersect(r), l = i.modified.intersect(n);
      u && !u.isEmpty && l && !l.isEmpty && s.push(new Nr(u, l));
    }
    return s;
  }
  constructor(e, r) {
    this.original = e, this.modified = r;
  }
  toString() {
    return `{${this.original.toString()}->${this.modified.toString()}}`;
  }
  flip() {
    return new Nr(this.modified, this.original);
  }
  join(e) {
    return new Nr(this.original.join(e.original), this.modified.join(e.modified));
  }
  /**
   * This method assumes that the LineRangeMapping describes a valid diff!
   * I.e. if one range is empty, the other range cannot be the entire document.
   * It avoids various problems when the line range points to non-existing line-numbers.
  */
  toRangeMapping() {
    const e = this.original.toInclusiveRange(), r = this.modified.toInclusiveRange();
    if (e && r)
      return new Fr(e, r);
    if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {
      if (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1))
        throw new hr("not a valid diff");
      return new Fr(new xe(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new xe(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));
    } else
      return new Fr(new xe(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), new xe(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER));
  }
  /**
   * This method assumes that the LineRangeMapping describes a valid diff!
   * I.e. if one range is empty, the other range cannot be the entire document.
   * It avoids various problems when the line range points to non-existing line-numbers.
  */
  toRangeMapping2(e, r) {
    if (Dm(this.original.endLineNumberExclusive, e) && Dm(this.modified.endLineNumberExclusive, r))
      return new Fr(new xe(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new xe(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));
    if (!this.original.isEmpty && !this.modified.isEmpty)
      return new Fr(xe.fromPositions(new st(this.original.startLineNumber, 1), ds(new st(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), e)), xe.fromPositions(new st(this.modified.startLineNumber, 1), ds(new st(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), r)));
    if (this.original.startLineNumber > 1 && this.modified.startLineNumber > 1)
      return new Fr(xe.fromPositions(ds(new st(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER), e), ds(new st(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), e)), xe.fromPositions(ds(new st(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER), r), ds(new st(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), r)));
    throw new hr();
  }
}
function ds(t, e) {
  if (t.lineNumber < 1)
    return new st(1, 1);
  if (t.lineNumber > e.length)
    return new st(e.length, e[e.length - 1].length + 1);
  const r = e[t.lineNumber - 1];
  return t.column > r.length + 1 ? new st(t.lineNumber, r.length + 1) : t;
}
function Dm(t, e) {
  return t >= 1 && t <= e.length;
}
class un extends Nr {
  static fromRangeMappings(e) {
    const r = be.join(e.map((s) => be.fromRangeInclusive(s.originalRange))), n = be.join(e.map((s) => be.fromRangeInclusive(s.modifiedRange)));
    return new un(r, n, e);
  }
  constructor(e, r, n) {
    super(e, r), this.innerChanges = n;
  }
  flip() {
    return new un(this.modified, this.original, this.innerChanges?.map((e) => e.flip()));
  }
  withInnerChangesFromLineRanges() {
    return new un(this.original, this.modified, [this.toRangeMapping()]);
  }
}
class Fr {
  static assertSorted(e) {
    for (let r = 1; r < e.length; r++) {
      const n = e[r - 1], s = e[r];
      if (!(n.originalRange.getEndPosition().isBeforeOrEqual(s.originalRange.getStartPosition()) && n.modifiedRange.getEndPosition().isBeforeOrEqual(s.modifiedRange.getStartPosition())))
        throw new hr("Range mappings must be sorted");
    }
  }
  constructor(e, r) {
    this.originalRange = e, this.modifiedRange = r;
  }
  toString() {
    return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;
  }
  flip() {
    return new Fr(this.modifiedRange, this.originalRange);
  }
  /**
   * Creates a single text edit that describes the change from the original to the modified text.
  */
  toTextEdit(e) {
    const r = e.getValueOfRange(this.modifiedRange);
    return new V5(this.originalRange, r);
  }
}
const z5 = 3;
class j5 {
  computeDiff(e, r, n) {
    const i = new B5(e, r, {
      maxComputationTime: n.maxComputationTimeMs,
      shouldIgnoreTrimWhitespace: n.ignoreTrimWhitespace,
      shouldComputeCharChanges: !0,
      shouldMakePrettyDiff: !0,
      shouldPostProcessCharChanges: !0
    }).computeDiff(), u = [];
    let l = null;
    for (const c of i.changes) {
      let m;
      c.originalEndLineNumber === 0 ? m = new be(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1) : m = new be(c.originalStartLineNumber, c.originalEndLineNumber + 1);
      let _;
      c.modifiedEndLineNumber === 0 ? _ = new be(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1) : _ = new be(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);
      let y = new un(m, _, c.charChanges?.map((v) => new Fr(new xe(v.originalStartLineNumber, v.originalStartColumn, v.originalEndLineNumber, v.originalEndColumn), new xe(v.modifiedStartLineNumber, v.modifiedStartColumn, v.modifiedEndLineNumber, v.modifiedEndColumn))));
      l && (l.modified.endLineNumberExclusive === y.modified.startLineNumber || l.original.endLineNumberExclusive === y.original.startLineNumber) && (y = new un(l.original.join(y.original), l.modified.join(y.modified), l.innerChanges && y.innerChanges ? l.innerChanges.concat(y.innerChanges) : void 0), u.pop()), u.push(y), l = y;
    }
    return Ea(() => e_(u, (c, m) => m.original.startLineNumber - c.original.endLineNumberExclusive === m.modified.startLineNumber - c.modified.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
    c.original.endLineNumberExclusive < m.original.startLineNumber && c.modified.endLineNumberExclusive < m.modified.startLineNumber)), new Ho(u, [], i.quitEarly);
  }
}
function s_(t, e, r, n) {
  return new Tn(t, e, r).ComputeDiff(n);
}
let $m = class {
  constructor(e) {
    const r = [], n = [];
    for (let s = 0, i = e.length; s < i; s++)
      r[s] = G1(e[s], 1), n[s] = B1(e[s], 1);
    this.lines = e, this._startColumns = r, this._endColumns = n;
  }
  getElements() {
    const e = [];
    for (let r = 0, n = this.lines.length; r < n; r++)
      e[r] = this.lines[r].substring(this._startColumns[r] - 1, this._endColumns[r] - 1);
    return e;
  }
  getStrictElement(e) {
    return this.lines[e];
  }
  getStartLineNumber(e) {
    return e + 1;
  }
  getEndLineNumber(e) {
    return e + 1;
  }
  createCharSequence(e, r, n) {
    const s = [], i = [], u = [];
    let l = 0;
    for (let c = r; c <= n; c++) {
      const m = this.lines[c], _ = e ? this._startColumns[c] : 1, y = e ? this._endColumns[c] : m.length + 1;
      for (let v = _; v < y; v++)
        s[l] = m.charCodeAt(v - 1), i[l] = c + 1, u[l] = v, l++;
      !e && c < n && (s[l] = 10, i[l] = c + 1, u[l] = m.length + 1, l++);
    }
    return new W5(s, i, u);
  }
};
class W5 {
  constructor(e, r, n) {
    this._charCodes = e, this._lineNumbers = r, this._columns = n;
  }
  toString() {
    return "[" + this._charCodes.map((e, r) => (e === 10 ? "\\n" : String.fromCharCode(e)) + `-(${this._lineNumbers[r]},${this._columns[r]})`).join(", ") + "]";
  }
  _assertIndex(e, r) {
    if (e < 0 || e >= r.length)
      throw new Error("Illegal index");
  }
  getElements() {
    return this._charCodes;
  }
  getStartLineNumber(e) {
    return e > 0 && e === this._lineNumbers.length ? this.getEndLineNumber(e - 1) : (this._assertIndex(e, this._lineNumbers), this._lineNumbers[e]);
  }
  getEndLineNumber(e) {
    return e === -1 ? this.getStartLineNumber(e + 1) : (this._assertIndex(e, this._lineNumbers), this._charCodes[e] === 10 ? this._lineNumbers[e] + 1 : this._lineNumbers[e]);
  }
  getStartColumn(e) {
    return e > 0 && e === this._columns.length ? this.getEndColumn(e - 1) : (this._assertIndex(e, this._columns), this._columns[e]);
  }
  getEndColumn(e) {
    return e === -1 ? this.getStartColumn(e + 1) : (this._assertIndex(e, this._columns), this._charCodes[e] === 10 ? 1 : this._columns[e] + 1);
  }
}
class Cs {
  constructor(e, r, n, s, i, u, l, c) {
    this.originalStartLineNumber = e, this.originalStartColumn = r, this.originalEndLineNumber = n, this.originalEndColumn = s, this.modifiedStartLineNumber = i, this.modifiedStartColumn = u, this.modifiedEndLineNumber = l, this.modifiedEndColumn = c;
  }
  static createFromDiffChange(e, r, n) {
    const s = r.getStartLineNumber(e.originalStart), i = r.getStartColumn(e.originalStart), u = r.getEndLineNumber(e.originalStart + e.originalLength - 1), l = r.getEndColumn(e.originalStart + e.originalLength - 1), c = n.getStartLineNumber(e.modifiedStart), m = n.getStartColumn(e.modifiedStart), _ = n.getEndLineNumber(e.modifiedStart + e.modifiedLength - 1), y = n.getEndColumn(e.modifiedStart + e.modifiedLength - 1);
    return new Cs(s, i, u, l, c, m, _, y);
  }
}
function G5(t) {
  if (t.length <= 1)
    return t;
  const e = [t[0]];
  let r = e[0];
  for (let n = 1, s = t.length; n < s; n++) {
    const i = t[n], u = i.originalStart - (r.originalStart + r.originalLength), l = i.modifiedStart - (r.modifiedStart + r.modifiedLength);
    Math.min(u, l) < z5 ? (r.originalLength = i.originalStart + i.originalLength - r.originalStart, r.modifiedLength = i.modifiedStart + i.modifiedLength - r.modifiedStart) : (e.push(i), r = i);
  }
  return e;
}
class Si {
  constructor(e, r, n, s, i) {
    this.originalStartLineNumber = e, this.originalEndLineNumber = r, this.modifiedStartLineNumber = n, this.modifiedEndLineNumber = s, this.charChanges = i;
  }
  static createFromDiffResult(e, r, n, s, i, u, l) {
    let c, m, _, y, v;
    if (r.originalLength === 0 ? (c = n.getStartLineNumber(r.originalStart) - 1, m = 0) : (c = n.getStartLineNumber(r.originalStart), m = n.getEndLineNumber(r.originalStart + r.originalLength - 1)), r.modifiedLength === 0 ? (_ = s.getStartLineNumber(r.modifiedStart) - 1, y = 0) : (_ = s.getStartLineNumber(r.modifiedStart), y = s.getEndLineNumber(r.modifiedStart + r.modifiedLength - 1)), u && r.originalLength > 0 && r.originalLength < 20 && r.modifiedLength > 0 && r.modifiedLength < 20 && i()) {
      const S = n.createCharSequence(e, r.originalStart, r.originalStart + r.originalLength - 1), T = s.createCharSequence(e, r.modifiedStart, r.modifiedStart + r.modifiedLength - 1);
      if (S.getElements().length > 0 && T.getElements().length > 0) {
        let L = s_(S, T, i, !0).changes;
        l && (L = G5(L)), v = [];
        for (let D = 0, V = L.length; D < V; D++)
          v.push(Cs.createFromDiffChange(L[D], S, T));
      }
    }
    return new Si(c, m, _, y, v);
  }
}
class B5 {
  constructor(e, r, n) {
    this.shouldComputeCharChanges = n.shouldComputeCharChanges, this.shouldPostProcessCharChanges = n.shouldPostProcessCharChanges, this.shouldIgnoreTrimWhitespace = n.shouldIgnoreTrimWhitespace, this.shouldMakePrettyDiff = n.shouldMakePrettyDiff, this.originalLines = e, this.modifiedLines = r, this.original = new $m(e), this.modified = new $m(r), this.continueLineDiff = Fm(n.maxComputationTime), this.continueCharDiff = Fm(n.maxComputationTime === 0 ? 0 : Math.min(n.maxComputationTime, 5e3));
  }
  computeDiff() {
    if (this.original.lines.length === 1 && this.original.lines[0].length === 0)
      return this.modified.lines.length === 1 && this.modified.lines[0].length === 0 ? {
        quitEarly: !1,
        changes: []
      } : {
        quitEarly: !1,
        changes: [{
          originalStartLineNumber: 1,
          originalEndLineNumber: 1,
          modifiedStartLineNumber: 1,
          modifiedEndLineNumber: this.modified.lines.length,
          charChanges: void 0
        }]
      };
    if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0)
      return {
        quitEarly: !1,
        changes: [{
          originalStartLineNumber: 1,
          originalEndLineNumber: this.original.lines.length,
          modifiedStartLineNumber: 1,
          modifiedEndLineNumber: 1,
          charChanges: void 0
        }]
      };
    const e = s_(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff), r = e.changes, n = e.quitEarly;
    if (this.shouldIgnoreTrimWhitespace) {
      const l = [];
      for (let c = 0, m = r.length; c < m; c++)
        l.push(Si.createFromDiffResult(this.shouldIgnoreTrimWhitespace, r[c], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
      return {
        quitEarly: n,
        changes: l
      };
    }
    const s = [];
    let i = 0, u = 0;
    for (let l = -1, c = r.length; l < c; l++) {
      const m = l + 1 < c ? r[l + 1] : null, _ = m ? m.originalStart : this.originalLines.length, y = m ? m.modifiedStart : this.modifiedLines.length;
      for (; i < _ && u < y; ) {
        const v = this.originalLines[i], S = this.modifiedLines[u];
        if (v !== S) {
          {
            let T = G1(v, 1), L = G1(S, 1);
            for (; T > 1 && L > 1; ) {
              const D = v.charCodeAt(T - 2), V = S.charCodeAt(L - 2);
              if (D !== V)
                break;
              T--, L--;
            }
            (T > 1 || L > 1) && this._pushTrimWhitespaceCharChange(s, i + 1, 1, T, u + 1, 1, L);
          }
          {
            let T = B1(v, 1), L = B1(S, 1);
            const D = v.length + 1, V = S.length + 1;
            for (; T < D && L < V; ) {
              const W = v.charCodeAt(T - 1), j = v.charCodeAt(L - 1);
              if (W !== j)
                break;
              T++, L++;
            }
            (T < D || L < V) && this._pushTrimWhitespaceCharChange(s, i + 1, T, D, u + 1, L, V);
          }
        }
        i++, u++;
      }
      m && (s.push(Si.createFromDiffResult(this.shouldIgnoreTrimWhitespace, m, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges)), i += m.originalLength, u += m.modifiedLength);
    }
    return {
      quitEarly: n,
      changes: s
    };
  }
  _pushTrimWhitespaceCharChange(e, r, n, s, i, u, l) {
    if (this._mergeTrimWhitespaceCharChange(e, r, n, s, i, u, l))
      return;
    let c;
    this.shouldComputeCharChanges && (c = [new Cs(r, n, r, s, i, u, i, l)]), e.push(new Si(r, r, i, i, c));
  }
  _mergeTrimWhitespaceCharChange(e, r, n, s, i, u, l) {
    const c = e.length;
    if (c === 0)
      return !1;
    const m = e[c - 1];
    return m.originalEndLineNumber === 0 || m.modifiedEndLineNumber === 0 ? !1 : m.originalEndLineNumber === r && m.modifiedEndLineNumber === i ? (this.shouldComputeCharChanges && m.charChanges && m.charChanges.push(new Cs(r, n, r, s, i, u, i, l)), !0) : m.originalEndLineNumber + 1 === r && m.modifiedEndLineNumber + 1 === i ? (m.originalEndLineNumber = r, m.modifiedEndLineNumber = i, this.shouldComputeCharChanges && m.charChanges && m.charChanges.push(new Cs(r, n, r, s, i, u, i, l)), !0) : !1;
  }
}
function G1(t, e) {
  const r = w6(t);
  return r === -1 ? e : r + 1;
}
function B1(t, e) {
  const r = v6(t);
  return r === -1 ? e : r + 2;
}
function Fm(t) {
  if (t === 0)
    return () => !0;
  const e = Date.now();
  return () => Date.now() - e < t;
}
function q5(t, e, r = (n, s) => n === s) {
  if (t === e)
    return !0;
  if (!t || !e || t.length !== e.length)
    return !1;
  for (let n = 0, s = t.length; n < s; n++)
    if (!r(t[n], e[n]))
      return !1;
  return !0;
}
function* H5(t, e) {
  let r, n;
  for (const s of t)
    n !== void 0 && e(n, s) ? r.push(s) : (r && (yield r), r = [s]), n = s;
  r && (yield r);
}
function Y5(t, e) {
  for (let r = 0; r <= t.length; r++)
    e(r === 0 ? void 0 : t[r - 1], r === t.length ? void 0 : t[r]);
}
function Z5(t, e) {
  for (let r = 0; r < t.length; r++)
    e(r === 0 ? void 0 : t[r - 1], t[r], r + 1 === t.length ? void 0 : t[r + 1]);
}
function X5(t, e) {
  for (const r of e)
    t.push(r);
}
var q1;
(function(t) {
  function e(i) {
    return i < 0;
  }
  t.isLessThan = e;
  function r(i) {
    return i <= 0;
  }
  t.isLessThanOrEqual = r;
  function n(i) {
    return i > 0;
  }
  t.isGreaterThan = n;
  function s(i) {
    return i === 0;
  }
  t.isNeitherLessOrGreaterThan = s, t.greaterThan = 1, t.lessThan = -1, t.neitherLessOrGreaterThan = 0;
})(q1 || (q1 = {}));
function Yo(t, e) {
  return (r, n) => e(t(r), t(n));
}
const Zo = (t, e) => t - e;
function J5(t) {
  return (e, r) => -t(e, r);
}
class Xo {
  static {
    this.empty = new Xo((e) => {
    });
  }
  constructor(e) {
    this.iterate = e;
  }
  toArray() {
    const e = [];
    return this.iterate((r) => (e.push(r), !0)), e;
  }
  filter(e) {
    return new Xo((r) => this.iterate((n) => e(n) ? r(n) : !0));
  }
  map(e) {
    return new Xo((r) => this.iterate((n) => r(e(n))));
  }
  findLast(e) {
    let r;
    return this.iterate((n) => (e(n) && (r = n), !0)), r;
  }
  findLastMaxBy(e) {
    let r, n = !0;
    return this.iterate((s) => ((n || q1.isGreaterThan(e(s, r))) && (n = !1, r = s), !0)), r;
  }
}
class ln {
  static trivial(e, r) {
    return new ln([new Je(Ne.ofLength(e.length), Ne.ofLength(r.length))], !1);
  }
  static trivialTimedOut(e, r) {
    return new ln([new Je(Ne.ofLength(e.length), Ne.ofLength(r.length))], !0);
  }
  constructor(e, r) {
    this.diffs = e, this.hitTimeout = r;
  }
}
class Je {
  static invert(e, r) {
    const n = [];
    return Y5(e, (s, i) => {
      n.push(Je.fromOffsetPairs(s ? s.getEndExclusives() : zr.zero, i ? i.getStarts() : new zr(r, (s ? s.seq2Range.endExclusive - s.seq1Range.endExclusive : 0) + r)));
    }), n;
  }
  static fromOffsetPairs(e, r) {
    return new Je(new Ne(e.offset1, r.offset1), new Ne(e.offset2, r.offset2));
  }
  static assertSorted(e) {
    let r;
    for (const n of e) {
      if (r && !(r.seq1Range.endExclusive <= n.seq1Range.start && r.seq2Range.endExclusive <= n.seq2Range.start))
        throw new hr("Sequence diffs must be sorted");
      r = n;
    }
  }
  constructor(e, r) {
    this.seq1Range = e, this.seq2Range = r;
  }
  swap() {
    return new Je(this.seq2Range, this.seq1Range);
  }
  toString() {
    return `${this.seq1Range} <-> ${this.seq2Range}`;
  }
  join(e) {
    return new Je(this.seq1Range.join(e.seq1Range), this.seq2Range.join(e.seq2Range));
  }
  delta(e) {
    return e === 0 ? this : new Je(this.seq1Range.delta(e), this.seq2Range.delta(e));
  }
  deltaStart(e) {
    return e === 0 ? this : new Je(this.seq1Range.deltaStart(e), this.seq2Range.deltaStart(e));
  }
  deltaEnd(e) {
    return e === 0 ? this : new Je(this.seq1Range.deltaEnd(e), this.seq2Range.deltaEnd(e));
  }
  intersect(e) {
    const r = this.seq1Range.intersect(e.seq1Range), n = this.seq2Range.intersect(e.seq2Range);
    if (!(!r || !n))
      return new Je(r, n);
  }
  getStarts() {
    return new zr(this.seq1Range.start, this.seq2Range.start);
  }
  getEndExclusives() {
    return new zr(this.seq1Range.endExclusive, this.seq2Range.endExclusive);
  }
}
class zr {
  static {
    this.zero = new zr(0, 0);
  }
  static {
    this.max = new zr(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
  }
  constructor(e, r) {
    this.offset1 = e, this.offset2 = r;
  }
  toString() {
    return `${this.offset1} <-> ${this.offset2}`;
  }
  delta(e) {
    return e === 0 ? this : new zr(this.offset1 + e, this.offset2 + e);
  }
  equals(e) {
    return this.offset1 === e.offset1 && this.offset2 === e.offset2;
  }
}
class $i {
  static {
    this.instance = new $i();
  }
  isValid() {
    return !0;
  }
}
class Q5 {
  constructor(e) {
    if (this.timeout = e, this.startTime = Date.now(), this.valid = !0, e <= 0)
      throw new hr("timeout must be positive");
  }
  // Recommendation: Set a log-point `{this.disable()}` in the body
  isValid() {
    if (!(Date.now() - this.startTime < this.timeout) && this.valid) {
      this.valid = !1;
      debugger;
    }
    return this.valid;
  }
}
class Zf {
  constructor(e, r) {
    this.width = e, this.height = r, this.array = [], this.array = new Array(e * r);
  }
  get(e, r) {
    return this.array[e + r * this.width];
  }
  set(e, r, n) {
    this.array[e + r * this.width] = n;
  }
}
function H1(t) {
  return t === 32 || t === 9;
}
class Li {
  static {
    this.chrKeys = /* @__PURE__ */ new Map();
  }
  static getKey(e) {
    let r = this.chrKeys.get(e);
    return r === void 0 && (r = this.chrKeys.size, this.chrKeys.set(e, r)), r;
  }
  constructor(e, r, n) {
    this.range = e, this.lines = r, this.source = n, this.histogram = [];
    let s = 0;
    for (let i = e.startLineNumber - 1; i < e.endLineNumberExclusive - 1; i++) {
      const u = r[i];
      for (let c = 0; c < u.length; c++) {
        s++;
        const m = u[c], _ = Li.getKey(m);
        this.histogram[_] = (this.histogram[_] || 0) + 1;
      }
      s++;
      const l = Li.getKey(`
`);
      this.histogram[l] = (this.histogram[l] || 0) + 1;
    }
    this.totalCount = s;
  }
  computeSimilarity(e) {
    let r = 0;
    const n = Math.max(this.histogram.length, e.histogram.length);
    for (let s = 0; s < n; s++)
      r += Math.abs((this.histogram[s] ?? 0) - (e.histogram[s] ?? 0));
    return 1 - r / (this.totalCount + e.totalCount);
  }
}
class K5 {
  compute(e, r, n = $i.instance, s) {
    if (e.length === 0 || r.length === 0)
      return ln.trivial(e, r);
    const i = new Zf(e.length, r.length), u = new Zf(e.length, r.length), l = new Zf(e.length, r.length);
    for (let T = 0; T < e.length; T++)
      for (let L = 0; L < r.length; L++) {
        if (!n.isValid())
          return ln.trivialTimedOut(e, r);
        const D = T === 0 ? 0 : i.get(T - 1, L), V = L === 0 ? 0 : i.get(T, L - 1);
        let W;
        e.getElement(T) === r.getElement(L) ? (T === 0 || L === 0 ? W = 0 : W = i.get(T - 1, L - 1), T > 0 && L > 0 && u.get(T - 1, L - 1) === 3 && (W += l.get(T - 1, L - 1)), W += s ? s(T, L) : 1) : W = -1;
        const j = Math.max(D, V, W);
        if (j === W) {
          const U = T > 0 && L > 0 ? l.get(T - 1, L - 1) : 0;
          l.set(T, L, U + 1), u.set(T, L, 3);
        } else j === D ? (l.set(T, L, 0), u.set(T, L, 1)) : j === V && (l.set(T, L, 0), u.set(T, L, 2));
        i.set(T, L, j);
      }
    const c = [];
    let m = e.length, _ = r.length;
    function y(T, L) {
      (T + 1 !== m || L + 1 !== _) && c.push(new Je(new Ne(T + 1, m), new Ne(L + 1, _))), m = T, _ = L;
    }
    let v = e.length - 1, S = r.length - 1;
    for (; v >= 0 && S >= 0; )
      u.get(v, S) === 3 ? (y(v, S), v--, S--) : u.get(v, S) === 1 ? v-- : S--;
    return y(-1, -1), c.reverse(), new ln(c, !1);
  }
}
class i_ {
  compute(e, r, n = $i.instance) {
    if (e.length === 0 || r.length === 0)
      return ln.trivial(e, r);
    const s = e, i = r;
    function u(L, D) {
      for (; L < s.length && D < i.length && s.getElement(L) === i.getElement(D); )
        L++, D++;
      return L;
    }
    let l = 0;
    const c = new e8();
    c.set(0, u(0, 0));
    const m = new t8();
    m.set(0, c.get(0) === 0 ? null : new Um(null, 0, 0, c.get(0)));
    let _ = 0;
    e: for (; ; ) {
      if (l++, !n.isValid())
        return ln.trivialTimedOut(s, i);
      const L = -Math.min(l, i.length + l % 2), D = Math.min(l, s.length + l % 2);
      for (_ = L; _ <= D; _ += 2) {
        const V = _ === D ? -1 : c.get(_ + 1), W = _ === L ? -1 : c.get(_ - 1) + 1, j = Math.min(Math.max(V, W), s.length), U = j - _;
        if (j > s.length || U > i.length)
          continue;
        const $ = u(j, U);
        c.set(_, $);
        const B = j === V ? m.get(_ + 1) : m.get(_ - 1);
        if (m.set(_, $ !== j ? new Um(B, j, U, $ - j) : B), c.get(_) === s.length && c.get(_) - _ === i.length)
          break e;
      }
    }
    let y = m.get(_);
    const v = [];
    let S = s.length, T = i.length;
    for (; ; ) {
      const L = y ? y.x + y.length : 0, D = y ? y.y + y.length : 0;
      if ((L !== S || D !== T) && v.push(new Je(new Ne(L, S), new Ne(D, T))), !y)
        break;
      S = y.x, T = y.y, y = y.prev;
    }
    return v.reverse(), new ln(v, !1);
  }
}
class Um {
  constructor(e, r, n, s) {
    this.prev = e, this.x = r, this.y = n, this.length = s;
  }
}
class e8 {
  constructor() {
    this.positiveArr = new Int32Array(10), this.negativeArr = new Int32Array(10);
  }
  get(e) {
    return e < 0 ? (e = -e - 1, this.negativeArr[e]) : this.positiveArr[e];
  }
  set(e, r) {
    if (e < 0) {
      if (e = -e - 1, e >= this.negativeArr.length) {
        const n = this.negativeArr;
        this.negativeArr = new Int32Array(n.length * 2), this.negativeArr.set(n);
      }
      this.negativeArr[e] = r;
    } else {
      if (e >= this.positiveArr.length) {
        const n = this.positiveArr;
        this.positiveArr = new Int32Array(n.length * 2), this.positiveArr.set(n);
      }
      this.positiveArr[e] = r;
    }
  }
}
class t8 {
  constructor() {
    this.positiveArr = [], this.negativeArr = [];
  }
  get(e) {
    return e < 0 ? (e = -e - 1, this.negativeArr[e]) : this.positiveArr[e];
  }
  set(e, r) {
    e < 0 ? (e = -e - 1, this.negativeArr[e] = r) : this.positiveArr[e] = r;
  }
}
class Na {
  constructor(e, r, n) {
    this.lines = e, this.range = r, this.considerWhitespaceChanges = n, this.elements = [], this.firstElementOffsetByLineIdx = [], this.lineStartOffsets = [], this.trimmedWsLengthsByLineIdx = [], this.firstElementOffsetByLineIdx.push(0);
    for (let s = this.range.startLineNumber; s <= this.range.endLineNumber; s++) {
      let i = e[s - 1], u = 0;
      s === this.range.startLineNumber && this.range.startColumn > 1 && (u = this.range.startColumn - 1, i = i.substring(u)), this.lineStartOffsets.push(u);
      let l = 0;
      if (!n) {
        const m = i.trimStart();
        l = i.length - m.length, i = m.trimEnd();
      }
      this.trimmedWsLengthsByLineIdx.push(l);
      const c = s === this.range.endLineNumber ? Math.min(this.range.endColumn - 1 - u - l, i.length) : i.length;
      for (let m = 0; m < c; m++)
        this.elements.push(i.charCodeAt(m));
      s < this.range.endLineNumber && (this.elements.push(10), this.firstElementOffsetByLineIdx.push(this.elements.length));
    }
  }
  toString() {
    return `Slice: "${this.text}"`;
  }
  get text() {
    return this.getText(new Ne(0, this.length));
  }
  getText(e) {
    return this.elements.slice(e.start, e.endExclusive).map((r) => String.fromCharCode(r)).join("");
  }
  getElement(e) {
    return this.elements[e];
  }
  get length() {
    return this.elements.length;
  }
  getBoundaryScore(e) {
    const r = zm(e > 0 ? this.elements[e - 1] : -1), n = zm(e < this.elements.length ? this.elements[e] : -1);
    if (r === 7 && n === 8)
      return 0;
    if (r === 8)
      return 150;
    let s = 0;
    return r !== n && (s += 10, r === 0 && n === 1 && (s += 1)), s += Vm(r), s += Vm(n), s;
  }
  translateOffset(e, r = "right") {
    const n = Ai(this.firstElementOffsetByLineIdx, (i) => i <= e), s = e - this.firstElementOffsetByLineIdx[n];
    return new st(this.range.startLineNumber + n, 1 + this.lineStartOffsets[n] + s + (s === 0 && r === "left" ? 0 : this.trimmedWsLengthsByLineIdx[n]));
  }
  translateRange(e) {
    const r = this.translateOffset(e.start, "right"), n = this.translateOffset(e.endExclusive, "left");
    return n.isBefore(r) ? xe.fromPositions(n, n) : xe.fromPositions(r, n);
  }
  /**
   * Finds the word that contains the character at the given offset
   */
  findWordContaining(e) {
    if (e < 0 || e >= this.elements.length || !Xf(this.elements[e]))
      return;
    let r = e;
    for (; r > 0 && Xf(this.elements[r - 1]); )
      r--;
    let n = e;
    for (; n < this.elements.length && Xf(this.elements[n]); )
      n++;
    return new Ne(r, n);
  }
  countLinesIn(e) {
    return this.translateOffset(e.endExclusive).lineNumber - this.translateOffset(e.start).lineNumber;
  }
  isStronglyEqual(e, r) {
    return this.elements[e] === this.elements[r];
  }
  extendToFullLines(e) {
    const r = $s(this.firstElementOffsetByLineIdx, (s) => s <= e.start) ?? 0, n = U5(this.firstElementOffsetByLineIdx, (s) => e.endExclusive <= s) ?? this.elements.length;
    return new Ne(r, n);
  }
}
function Xf(t) {
  return t >= 97 && t <= 122 || t >= 65 && t <= 90 || t >= 48 && t <= 57;
}
const r8 = {
  0: 0,
  1: 0,
  2: 0,
  3: 10,
  4: 2,
  5: 30,
  6: 3,
  7: 10,
  8: 10
};
function Vm(t) {
  return r8[t];
}
function zm(t) {
  return t === 10 ? 8 : t === 13 ? 7 : H1(t) ? 6 : t >= 97 && t <= 122 ? 0 : t >= 65 && t <= 90 ? 1 : t >= 48 && t <= 57 ? 2 : t === -1 ? 3 : t === 44 || t === 59 ? 5 : 4;
}
function n8(t, e, r, n, s, i) {
  let { moves: u, excludedChanges: l } = i8(t, e, r, i);
  if (!i.isValid())
    return [];
  const c = t.filter((_) => !l.has(_)), m = o8(c, n, s, e, r, i);
  return X5(u, m), u = a8(u), u = u.filter((_) => {
    const y = _.original.toOffsetRange().slice(e).map((S) => S.trim());
    return y.join(`
`).length >= 15 && s8(y, (S) => S.length >= 2) >= 2;
  }), u = u8(t, u), u;
}
function s8(t, e) {
  let r = 0;
  for (const n of t)
    e(n) && r++;
  return r;
}
function i8(t, e, r, n) {
  const s = [], i = t.filter((c) => c.modified.isEmpty && c.original.length >= 3).map((c) => new Li(c.original, e, c)), u = new Set(t.filter((c) => c.original.isEmpty && c.modified.length >= 3).map((c) => new Li(c.modified, r, c))), l = /* @__PURE__ */ new Set();
  for (const c of i) {
    let m = -1, _;
    for (const y of u) {
      const v = c.computeSimilarity(y);
      v > m && (m = v, _ = y);
    }
    if (m > 0.9 && _ && (u.delete(_), s.push(new Nr(c.range, _.range)), l.add(c.source), l.add(_.source)), !n.isValid())
      return { moves: s, excludedChanges: l };
  }
  return { moves: s, excludedChanges: l };
}
function o8(t, e, r, n, s, i) {
  const u = [], l = new x5();
  for (const v of t)
    for (let S = v.original.startLineNumber; S < v.original.endLineNumberExclusive - 2; S++) {
      const T = `${e[S - 1]}:${e[S + 1 - 1]}:${e[S + 2 - 1]}`;
      l.add(T, { range: new be(S, S + 3) });
    }
  const c = [];
  t.sort(Yo((v) => v.modified.startLineNumber, Zo));
  for (const v of t) {
    let S = [];
    for (let T = v.modified.startLineNumber; T < v.modified.endLineNumberExclusive - 2; T++) {
      const L = `${r[T - 1]}:${r[T + 1 - 1]}:${r[T + 2 - 1]}`, D = new be(T, T + 3), V = [];
      l.forEach(L, ({ range: W }) => {
        for (const U of S)
          if (U.originalLineRange.endLineNumberExclusive + 1 === W.endLineNumberExclusive && U.modifiedLineRange.endLineNumberExclusive + 1 === D.endLineNumberExclusive) {
            U.originalLineRange = new be(U.originalLineRange.startLineNumber, W.endLineNumberExclusive), U.modifiedLineRange = new be(U.modifiedLineRange.startLineNumber, D.endLineNumberExclusive), V.push(U);
            return;
          }
        const j = {
          modifiedLineRange: D,
          originalLineRange: W
        };
        c.push(j), V.push(j);
      }), S = V;
    }
    if (!i.isValid())
      return [];
  }
  c.sort(J5(Yo((v) => v.modifiedLineRange.length, Zo)));
  const m = new Qr(), _ = new Qr();
  for (const v of c) {
    const S = v.modifiedLineRange.startLineNumber - v.originalLineRange.startLineNumber, T = m.subtractFrom(v.modifiedLineRange), L = _.subtractFrom(v.originalLineRange).getWithDelta(S), D = T.getIntersection(L);
    for (const V of D.ranges) {
      if (V.length < 3)
        continue;
      const W = V, j = V.delta(-S);
      u.push(new Nr(j, W)), m.addRange(W), _.addRange(j);
    }
  }
  u.sort(Yo((v) => v.original.startLineNumber, Zo));
  const y = new Za(t);
  for (let v = 0; v < u.length; v++) {
    const S = u[v], T = y.findLastMonotonous((B) => B.original.startLineNumber <= S.original.startLineNumber), L = $s(t, (B) => B.modified.startLineNumber <= S.modified.startLineNumber), D = Math.max(S.original.startLineNumber - T.original.startLineNumber, S.modified.startLineNumber - L.modified.startLineNumber), V = y.findLastMonotonous((B) => B.original.startLineNumber < S.original.endLineNumberExclusive), W = $s(t, (B) => B.modified.startLineNumber < S.modified.endLineNumberExclusive), j = Math.max(V.original.endLineNumberExclusive - S.original.endLineNumberExclusive, W.modified.endLineNumberExclusive - S.modified.endLineNumberExclusive);
    let U;
    for (U = 0; U < D; U++) {
      const B = S.original.startLineNumber - U - 1, Z = S.modified.startLineNumber - U - 1;
      if (B > n.length || Z > s.length || m.contains(Z) || _.contains(B) || !jm(n[B - 1], s[Z - 1], i))
        break;
    }
    U > 0 && (_.addRange(new be(S.original.startLineNumber - U, S.original.startLineNumber)), m.addRange(new be(S.modified.startLineNumber - U, S.modified.startLineNumber)));
    let $;
    for ($ = 0; $ < j; $++) {
      const B = S.original.endLineNumberExclusive + $, Z = S.modified.endLineNumberExclusive + $;
      if (B > n.length || Z > s.length || m.contains(Z) || _.contains(B) || !jm(n[B - 1], s[Z - 1], i))
        break;
    }
    $ > 0 && (_.addRange(new be(S.original.endLineNumberExclusive, S.original.endLineNumberExclusive + $)), m.addRange(new be(S.modified.endLineNumberExclusive, S.modified.endLineNumberExclusive + $))), (U > 0 || $ > 0) && (u[v] = new Nr(new be(S.original.startLineNumber - U, S.original.endLineNumberExclusive + $), new be(S.modified.startLineNumber - U, S.modified.endLineNumberExclusive + $)));
  }
  return u;
}
function jm(t, e, r) {
  if (t.trim() === e.trim())
    return !0;
  if (t.length > 300 && e.length > 300)
    return !1;
  const s = new i_().compute(new Na([t], new xe(1, 1, 1, t.length), !1), new Na([e], new xe(1, 1, 1, e.length), !1), r);
  let i = 0;
  const u = Je.invert(s.diffs, t.length);
  for (const _ of u)
    _.seq1Range.forEach((y) => {
      H1(t.charCodeAt(y)) || i++;
    });
  function l(_) {
    let y = 0;
    for (let v = 0; v < t.length; v++)
      H1(_.charCodeAt(v)) || y++;
    return y;
  }
  const c = l(t.length > e.length ? t : e);
  return i / c > 0.6 && c > 10;
}
function a8(t) {
  if (t.length === 0)
    return t;
  t.sort(Yo((r) => r.original.startLineNumber, Zo));
  const e = [t[0]];
  for (let r = 1; r < t.length; r++) {
    const n = e[e.length - 1], s = t[r], i = s.original.startLineNumber - n.original.endLineNumberExclusive, u = s.modified.startLineNumber - n.modified.endLineNumberExclusive;
    if (i >= 0 && u >= 0 && i + u <= 2) {
      e[e.length - 1] = n.join(s);
      continue;
    }
    e.push(s);
  }
  return e;
}
function u8(t, e) {
  const r = new Za(t);
  return e = e.filter((n) => {
    const s = r.findLastMonotonous((l) => l.original.startLineNumber < n.original.endLineNumberExclusive) || new Nr(new be(1, 1), new be(1, 1)), i = $s(t, (l) => l.modified.startLineNumber < n.modified.endLineNumberExclusive);
    return s !== i;
  }), e;
}
function Wm(t, e, r) {
  let n = r;
  return n = Gm(t, e, n), n = Gm(t, e, n), n = l8(t, e, n), n;
}
function Gm(t, e, r) {
  if (r.length === 0)
    return r;
  const n = [];
  n.push(r[0]);
  for (let i = 1; i < r.length; i++) {
    const u = n[n.length - 1];
    let l = r[i];
    if (l.seq1Range.isEmpty || l.seq2Range.isEmpty) {
      const c = l.seq1Range.start - u.seq1Range.endExclusive;
      let m;
      for (m = 1; m <= c && !(t.getElement(l.seq1Range.start - m) !== t.getElement(l.seq1Range.endExclusive - m) || e.getElement(l.seq2Range.start - m) !== e.getElement(l.seq2Range.endExclusive - m)); m++)
        ;
      if (m--, m === c) {
        n[n.length - 1] = new Je(new Ne(u.seq1Range.start, l.seq1Range.endExclusive - c), new Ne(u.seq2Range.start, l.seq2Range.endExclusive - c));
        continue;
      }
      l = l.delta(-m);
    }
    n.push(l);
  }
  const s = [];
  for (let i = 0; i < n.length - 1; i++) {
    const u = n[i + 1];
    let l = n[i];
    if (l.seq1Range.isEmpty || l.seq2Range.isEmpty) {
      const c = u.seq1Range.start - l.seq1Range.endExclusive;
      let m;
      for (m = 0; m < c && !(!t.isStronglyEqual(l.seq1Range.start + m, l.seq1Range.endExclusive + m) || !e.isStronglyEqual(l.seq2Range.start + m, l.seq2Range.endExclusive + m)); m++)
        ;
      if (m === c) {
        n[i + 1] = new Je(new Ne(l.seq1Range.start + c, u.seq1Range.endExclusive), new Ne(l.seq2Range.start + c, u.seq2Range.endExclusive));
        continue;
      }
      m > 0 && (l = l.delta(m));
    }
    s.push(l);
  }
  return n.length > 0 && s.push(n[n.length - 1]), s;
}
function l8(t, e, r) {
  if (!t.getBoundaryScore || !e.getBoundaryScore)
    return r;
  for (let n = 0; n < r.length; n++) {
    const s = n > 0 ? r[n - 1] : void 0, i = r[n], u = n + 1 < r.length ? r[n + 1] : void 0, l = new Ne(s ? s.seq1Range.endExclusive + 1 : 0, u ? u.seq1Range.start - 1 : t.length), c = new Ne(s ? s.seq2Range.endExclusive + 1 : 0, u ? u.seq2Range.start - 1 : e.length);
    i.seq1Range.isEmpty ? r[n] = Bm(i, t, e, l, c) : i.seq2Range.isEmpty && (r[n] = Bm(i.swap(), e, t, c, l).swap());
  }
  return r;
}
function Bm(t, e, r, n, s) {
  let u = 1;
  for (; t.seq1Range.start - u >= n.start && t.seq2Range.start - u >= s.start && r.isStronglyEqual(t.seq2Range.start - u, t.seq2Range.endExclusive - u) && u < 100; )
    u++;
  u--;
  let l = 0;
  for (; t.seq1Range.start + l < n.endExclusive && t.seq2Range.endExclusive + l < s.endExclusive && r.isStronglyEqual(t.seq2Range.start + l, t.seq2Range.endExclusive + l) && l < 100; )
    l++;
  if (u === 0 && l === 0)
    return t;
  let c = 0, m = -1;
  for (let _ = -u; _ <= l; _++) {
    const y = t.seq2Range.start + _, v = t.seq2Range.endExclusive + _, S = t.seq1Range.start + _, T = e.getBoundaryScore(S) + r.getBoundaryScore(y) + r.getBoundaryScore(v);
    T > m && (m = T, c = _);
  }
  return t.delta(c);
}
function c8(t, e, r) {
  const n = [];
  for (const s of r) {
    const i = n[n.length - 1];
    if (!i) {
      n.push(s);
      continue;
    }
    s.seq1Range.start - i.seq1Range.endExclusive <= 2 || s.seq2Range.start - i.seq2Range.endExclusive <= 2 ? n[n.length - 1] = new Je(i.seq1Range.join(s.seq1Range), i.seq2Range.join(s.seq2Range)) : n.push(s);
  }
  return n;
}
function f8(t, e, r) {
  const n = Je.invert(r, t.length), s = [];
  let i = new zr(0, 0);
  function u(c, m) {
    if (c.offset1 < i.offset1 || c.offset2 < i.offset2)
      return;
    const _ = t.findWordContaining(c.offset1), y = e.findWordContaining(c.offset2);
    if (!_ || !y)
      return;
    let v = new Je(_, y);
    const S = v.intersect(m);
    let T = S.seq1Range.length, L = S.seq2Range.length;
    for (; n.length > 0; ) {
      const D = n[0];
      if (!(D.seq1Range.intersects(v.seq1Range) || D.seq2Range.intersects(v.seq2Range)))
        break;
      const W = t.findWordContaining(D.seq1Range.start), j = e.findWordContaining(D.seq2Range.start), U = new Je(W, j), $ = U.intersect(D);
      if (T += $.seq1Range.length, L += $.seq2Range.length, v = v.join(U), v.seq1Range.endExclusive >= D.seq1Range.endExclusive)
        n.shift();
      else
        break;
    }
    T + L < (v.seq1Range.length + v.seq2Range.length) * 2 / 3 && s.push(v), i = v.getEndExclusives();
  }
  for (; n.length > 0; ) {
    const c = n.shift();
    c.seq1Range.isEmpty || (u(c.getStarts(), c), u(c.getEndExclusives().delta(-1), c));
  }
  return h8(r, s);
}
function h8(t, e) {
  const r = [];
  for (; t.length > 0 || e.length > 0; ) {
    const n = t[0], s = e[0];
    let i;
    n && (!s || n.seq1Range.start < s.seq1Range.start) ? i = t.shift() : i = e.shift(), r.length > 0 && r[r.length - 1].seq1Range.endExclusive >= i.seq1Range.start ? r[r.length - 1] = r[r.length - 1].join(i) : r.push(i);
  }
  return r;
}
function d8(t, e, r) {
  let n = r;
  if (n.length === 0)
    return n;
  let s = 0, i;
  do {
    i = !1;
    const l = [
      n[0]
    ];
    for (let c = 1; c < n.length; c++) {
      let y = function(S, T) {
        const L = new Ne(_.seq1Range.endExclusive, m.seq1Range.start);
        return t.getText(L).replace(/\s/g, "").length <= 4 && (S.seq1Range.length + S.seq2Range.length > 5 || T.seq1Range.length + T.seq2Range.length > 5);
      };
      var u = y;
      const m = n[c], _ = l[l.length - 1];
      y(_, m) ? (i = !0, l[l.length - 1] = l[l.length - 1].join(m)) : l.push(m);
    }
    n = l;
  } while (s++ < 10 && i);
  return n;
}
function m8(t, e, r) {
  let n = r;
  if (n.length === 0)
    return n;
  let s = 0, i;
  do {
    i = !1;
    const c = [
      n[0]
    ];
    for (let m = 1; m < n.length; m++) {
      let v = function(T, L) {
        const D = new Ne(y.seq1Range.endExclusive, _.seq1Range.start);
        if (t.countLinesIn(D) > 5 || D.length > 500)
          return !1;
        const W = t.getText(D).trim();
        if (W.length > 20 || W.split(/\r\n|\r|\n/).length > 1)
          return !1;
        const j = t.countLinesIn(T.seq1Range), U = T.seq1Range.length, $ = e.countLinesIn(T.seq2Range), B = T.seq2Range.length, Z = t.countLinesIn(L.seq1Range), ee = L.seq1Range.length, ye = e.countLinesIn(L.seq2Range), Ie = L.seq2Range.length, ve = 2 * 40 + 50;
        function le(K) {
          return Math.min(K, ve);
        }
        return Math.pow(Math.pow(le(j * 40 + U), 1.5) + Math.pow(le($ * 40 + B), 1.5), 1.5) + Math.pow(Math.pow(le(Z * 40 + ee), 1.5) + Math.pow(le(ye * 40 + Ie), 1.5), 1.5) > (ve ** 1.5) ** 1.5 * 1.3;
      };
      var l = v;
      const _ = n[m], y = c[c.length - 1];
      v(y, _) ? (i = !0, c[c.length - 1] = c[c.length - 1].join(_)) : c.push(_);
    }
    n = c;
  } while (s++ < 10 && i);
  const u = [];
  return Z5(n, (c, m, _) => {
    let y = m;
    function v(W) {
      return W.length > 0 && W.trim().length <= 3 && m.seq1Range.length + m.seq2Range.length > 100;
    }
    const S = t.extendToFullLines(m.seq1Range), T = t.getText(new Ne(S.start, m.seq1Range.start));
    v(T) && (y = y.deltaStart(-T.length));
    const L = t.getText(new Ne(m.seq1Range.endExclusive, S.endExclusive));
    v(L) && (y = y.deltaEnd(L.length));
    const D = Je.fromOffsetPairs(c ? c.getEndExclusives() : zr.zero, _ ? _.getStarts() : zr.max), V = y.intersect(D);
    u.length > 0 && V.getStarts().equals(u[u.length - 1].getEndExclusives()) ? u[u.length - 1] = u[u.length - 1].join(V) : u.push(V);
  }), u;
}
class qm {
  constructor(e, r) {
    this.trimmedHash = e, this.lines = r;
  }
  getElement(e) {
    return this.trimmedHash[e];
  }
  get length() {
    return this.trimmedHash.length;
  }
  getBoundaryScore(e) {
    const r = e === 0 ? 0 : Hm(this.lines[e - 1]), n = e === this.lines.length ? 0 : Hm(this.lines[e]);
    return 1e3 - (r + n);
  }
  getText(e) {
    return this.lines.slice(e.start, e.endExclusive).join(`
`);
  }
  isStronglyEqual(e, r) {
    return this.lines[e] === this.lines[r];
  }
}
function Hm(t) {
  let e = 0;
  for (; e < t.length && (t.charCodeAt(e) === 32 || t.charCodeAt(e) === 9); )
    e++;
  return e;
}
class p8 {
  constructor() {
    this.dynamicProgrammingDiffing = new K5(), this.myersDiffingAlgorithm = new i_();
  }
  computeDiff(e, r, n) {
    if (e.length <= 1 && q5(e, r, ($, B) => $ === B))
      return new Ho([], [], !1);
    if (e.length === 1 && e[0].length === 0 || r.length === 1 && r[0].length === 0)
      return new Ho([
        new un(new be(1, e.length + 1), new be(1, r.length + 1), [
          new Fr(new xe(1, 1, e.length, e[e.length - 1].length + 1), new xe(1, 1, r.length, r[r.length - 1].length + 1))
        ])
      ], [], !1);
    const s = n.maxComputationTimeMs === 0 ? $i.instance : new Q5(n.maxComputationTimeMs), i = !n.ignoreTrimWhitespace, u = /* @__PURE__ */ new Map();
    function l($) {
      let B = u.get($);
      return B === void 0 && (B = u.size, u.set($, B)), B;
    }
    const c = e.map(($) => l($.trim())), m = r.map(($) => l($.trim())), _ = new qm(c, e), y = new qm(m, r), v = _.length + y.length < 1700 ? this.dynamicProgrammingDiffing.compute(_, y, s, ($, B) => e[$] === r[B] ? r[B].length === 0 ? 0.1 : 1 + Math.log(1 + r[B].length) : 0.99) : this.myersDiffingAlgorithm.compute(_, y, s);
    let S = v.diffs, T = v.hitTimeout;
    S = Wm(_, y, S), S = d8(_, y, S);
    const L = [], D = ($) => {
      if (i)
        for (let B = 0; B < $; B++) {
          const Z = V + B, ee = W + B;
          if (e[Z] !== r[ee]) {
            const ye = this.refineDiff(e, r, new Je(new Ne(Z, Z + 1), new Ne(ee, ee + 1)), s, i);
            for (const Ie of ye.mappings)
              L.push(Ie);
            ye.hitTimeout && (T = !0);
          }
        }
    };
    let V = 0, W = 0;
    for (const $ of S) {
      Ea(() => $.seq1Range.start - V === $.seq2Range.start - W);
      const B = $.seq1Range.start - V;
      D(B), V = $.seq1Range.endExclusive, W = $.seq2Range.endExclusive;
      const Z = this.refineDiff(e, r, $, s, i);
      Z.hitTimeout && (T = !0);
      for (const ee of Z.mappings)
        L.push(ee);
    }
    D(e.length - V);
    const j = Ym(L, e, r);
    let U = [];
    return n.computeMoves && (U = this.computeMoves(j, e, r, c, m, s, i)), Ea(() => {
      function $(Z, ee) {
        if (Z.lineNumber < 1 || Z.lineNumber > ee.length)
          return !1;
        const ye = ee[Z.lineNumber - 1];
        return !(Z.column < 1 || Z.column > ye.length + 1);
      }
      function B(Z, ee) {
        return !(Z.startLineNumber < 1 || Z.startLineNumber > ee.length + 1 || Z.endLineNumberExclusive < 1 || Z.endLineNumberExclusive > ee.length + 1);
      }
      for (const Z of j) {
        if (!Z.innerChanges)
          return !1;
        for (const ee of Z.innerChanges)
          if (!($(ee.modifiedRange.getStartPosition(), r) && $(ee.modifiedRange.getEndPosition(), r) && $(ee.originalRange.getStartPosition(), e) && $(ee.originalRange.getEndPosition(), e)))
            return !1;
        if (!B(Z.modified, r) || !B(Z.original, e))
          return !1;
      }
      return !0;
    }), new Ho(j, U, T);
  }
  computeMoves(e, r, n, s, i, u, l) {
    return n8(e, r, n, s, i, u).map((_) => {
      const y = this.refineDiff(r, n, new Je(_.original.toOffsetRange(), _.modified.toOffsetRange()), u, l), v = Ym(y.mappings, r, n, !0);
      return new F5(_, v);
    });
  }
  refineDiff(e, r, n, s, i) {
    const l = _8(n).toRangeMapping2(e, r), c = new Na(e, l.originalRange, i), m = new Na(r, l.modifiedRange, i), _ = c.length + m.length < 500 ? this.dynamicProgrammingDiffing.compute(c, m, s) : this.myersDiffingAlgorithm.compute(c, m, s);
    let y = _.diffs;
    return y = Wm(c, m, y), y = f8(c, m, y), y = c8(c, m, y), y = m8(c, m, y), {
      mappings: y.map((S) => new Fr(c.translateRange(S.seq1Range), m.translateRange(S.seq2Range))),
      hitTimeout: _.hitTimeout
    };
  }
}
function Ym(t, e, r, n = !1) {
  const s = [];
  for (const i of H5(t.map((u) => g8(u, e, r)), (u, l) => u.original.overlapOrTouch(l.original) || u.modified.overlapOrTouch(l.modified))) {
    const u = i[0], l = i[i.length - 1];
    s.push(new un(u.original.join(l.original), u.modified.join(l.modified), i.map((c) => c.innerChanges[0])));
  }
  return Ea(() => !n && s.length > 0 && (s[0].modified.startLineNumber !== s[0].original.startLineNumber || r.length - s[s.length - 1].modified.endLineNumberExclusive !== e.length - s[s.length - 1].original.endLineNumberExclusive) ? !1 : e_(s, (i, u) => u.original.startLineNumber - i.original.endLineNumberExclusive === u.modified.startLineNumber - i.modified.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
  i.original.endLineNumberExclusive < u.original.startLineNumber && i.modified.endLineNumberExclusive < u.modified.startLineNumber)), s;
}
function g8(t, e, r) {
  let n = 0, s = 0;
  t.modifiedRange.endColumn === 1 && t.originalRange.endColumn === 1 && t.originalRange.startLineNumber + n <= t.originalRange.endLineNumber && t.modifiedRange.startLineNumber + n <= t.modifiedRange.endLineNumber && (s = -1), t.modifiedRange.startColumn - 1 >= r[t.modifiedRange.startLineNumber - 1].length && t.originalRange.startColumn - 1 >= e[t.originalRange.startLineNumber - 1].length && t.originalRange.startLineNumber <= t.originalRange.endLineNumber + s && t.modifiedRange.startLineNumber <= t.modifiedRange.endLineNumber + s && (n = 1);
  const i = new be(t.originalRange.startLineNumber + n, t.originalRange.endLineNumber + 1 + s), u = new be(t.modifiedRange.startLineNumber + n, t.modifiedRange.endLineNumber + 1 + s);
  return new un(i, u, [t]);
}
function _8(t) {
  return new Nr(new be(t.seq1Range.start + 1, t.seq1Range.endExclusive + 1), new be(t.seq2Range.start + 1, t.seq2Range.endExclusive + 1));
}
const Zm = {
  getLegacy: () => new j5(),
  getDefault: () => new p8()
};
function Cn(t, e) {
  const r = Math.pow(10, e);
  return Math.round(t * r) / r;
}
class Et {
  constructor(e, r, n, s = 1) {
    this._rgbaBrand = void 0, this.r = Math.min(255, Math.max(0, e)) | 0, this.g = Math.min(255, Math.max(0, r)) | 0, this.b = Math.min(255, Math.max(0, n)) | 0, this.a = Cn(Math.max(Math.min(1, s), 0), 3);
  }
  static equals(e, r) {
    return e.r === r.r && e.g === r.g && e.b === r.b && e.a === r.a;
  }
}
class vr {
  constructor(e, r, n, s) {
    this._hslaBrand = void 0, this.h = Math.max(Math.min(360, e), 0) | 0, this.s = Cn(Math.max(Math.min(1, r), 0), 3), this.l = Cn(Math.max(Math.min(1, n), 0), 3), this.a = Cn(Math.max(Math.min(1, s), 0), 3);
  }
  static equals(e, r) {
    return e.h === r.h && e.s === r.s && e.l === r.l && e.a === r.a;
  }
  /**
   * Converts an RGB color value to HSL. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes r, g, and b are contained in the set [0, 255] and
   * returns h in the set [0, 360], s, and l in the set [0, 1].
   */
  static fromRGBA(e) {
    const r = e.r / 255, n = e.g / 255, s = e.b / 255, i = e.a, u = Math.max(r, n, s), l = Math.min(r, n, s);
    let c = 0, m = 0;
    const _ = (l + u) / 2, y = u - l;
    if (y > 0) {
      switch (m = Math.min(_ <= 0.5 ? y / (2 * _) : y / (2 - 2 * _), 1), u) {
        case r:
          c = (n - s) / y + (n < s ? 6 : 0);
          break;
        case n:
          c = (s - r) / y + 2;
          break;
        case s:
          c = (r - n) / y + 4;
          break;
      }
      c *= 60, c = Math.round(c);
    }
    return new vr(c, m, _, i);
  }
  static _hue2rgb(e, r, n) {
    return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (r - e) * 6 * n : n < 1 / 2 ? r : n < 2 / 3 ? e + (r - e) * (2 / 3 - n) * 6 : e;
  }
  /**
   * Converts an HSL color value to RGB. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and
   * returns r, g, and b in the set [0, 255].
   */
  static toRGBA(e) {
    const r = e.h / 360, { s: n, l: s, a: i } = e;
    let u, l, c;
    if (n === 0)
      u = l = c = s;
    else {
      const m = s < 0.5 ? s * (1 + n) : s + n - s * n, _ = 2 * s - m;
      u = vr._hue2rgb(_, m, r + 1 / 3), l = vr._hue2rgb(_, m, r), c = vr._hue2rgb(_, m, r - 1 / 3);
    }
    return new Et(Math.round(u * 255), Math.round(l * 255), Math.round(c * 255), i);
  }
}
class As {
  constructor(e, r, n, s) {
    this._hsvaBrand = void 0, this.h = Math.max(Math.min(360, e), 0) | 0, this.s = Cn(Math.max(Math.min(1, r), 0), 3), this.v = Cn(Math.max(Math.min(1, n), 0), 3), this.a = Cn(Math.max(Math.min(1, s), 0), 3);
  }
  static equals(e, r) {
    return e.h === r.h && e.s === r.s && e.v === r.v && e.a === r.a;
  }
  // from http://www.rapidtables.com/convert/color/rgb-to-hsv.htm
  static fromRGBA(e) {
    const r = e.r / 255, n = e.g / 255, s = e.b / 255, i = Math.max(r, n, s), u = Math.min(r, n, s), l = i - u, c = i === 0 ? 0 : l / i;
    let m;
    return l === 0 ? m = 0 : i === r ? m = ((n - s) / l % 6 + 6) % 6 : i === n ? m = (s - r) / l + 2 : m = (r - n) / l + 4, new As(Math.round(m * 60), c, i, e.a);
  }
  // from http://www.rapidtables.com/convert/color/hsv-to-rgb.htm
  static toRGBA(e) {
    const { h: r, s: n, v: s, a: i } = e, u = s * n, l = u * (1 - Math.abs(r / 60 % 2 - 1)), c = s - u;
    let [m, _, y] = [0, 0, 0];
    return r < 60 ? (m = u, _ = l) : r < 120 ? (m = l, _ = u) : r < 180 ? (_ = u, y = l) : r < 240 ? (_ = l, y = u) : r < 300 ? (m = l, y = u) : r <= 360 && (m = u, y = l), m = Math.round((m + c) * 255), _ = Math.round((_ + c) * 255), y = Math.round((y + c) * 255), new Et(m, _, y, i);
  }
}
let xa = class ht {
  static fromHex(e) {
    return ht.Format.CSS.parseHex(e) || ht.red;
  }
  static equals(e, r) {
    return !e && !r ? !0 : !e || !r ? !1 : e.equals(r);
  }
  get hsla() {
    return this._hsla ? this._hsla : vr.fromRGBA(this.rgba);
  }
  get hsva() {
    return this._hsva ? this._hsva : As.fromRGBA(this.rgba);
  }
  constructor(e) {
    if (e)
      if (e instanceof Et)
        this.rgba = e;
      else if (e instanceof vr)
        this._hsla = e, this.rgba = vr.toRGBA(e);
      else if (e instanceof As)
        this._hsva = e, this.rgba = As.toRGBA(e);
      else
        throw new Error("Invalid color ctor argument");
    else throw new Error("Color needs a value");
  }
  equals(e) {
    return !!e && Et.equals(this.rgba, e.rgba) && vr.equals(this.hsla, e.hsla) && As.equals(this.hsva, e.hsva);
  }
  /**
   * http://www.w3.org/TR/WCAG20/#relativeluminancedef
   * Returns the number in the set [0, 1]. O => Darkest Black. 1 => Lightest white.
   */
  getRelativeLuminance() {
    const e = ht._relativeLuminanceForComponent(this.rgba.r), r = ht._relativeLuminanceForComponent(this.rgba.g), n = ht._relativeLuminanceForComponent(this.rgba.b), s = 0.2126 * e + 0.7152 * r + 0.0722 * n;
    return Cn(s, 4);
  }
  static _relativeLuminanceForComponent(e) {
    const r = e / 255;
    return r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
  }
  /**
   *	http://24ways.org/2010/calculating-color-contrast
   *  Return 'true' if lighter color otherwise 'false'
   */
  isLighter() {
    return (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1e3 >= 128;
  }
  isLighterThan(e) {
    const r = this.getRelativeLuminance(), n = e.getRelativeLuminance();
    return r > n;
  }
  isDarkerThan(e) {
    const r = this.getRelativeLuminance(), n = e.getRelativeLuminance();
    return r < n;
  }
  lighten(e) {
    return new ht(new vr(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * e, this.hsla.a));
  }
  darken(e) {
    return new ht(new vr(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * e, this.hsla.a));
  }
  transparent(e) {
    const { r, g: n, b: s, a: i } = this.rgba;
    return new ht(new Et(r, n, s, i * e));
  }
  isTransparent() {
    return this.rgba.a === 0;
  }
  isOpaque() {
    return this.rgba.a === 1;
  }
  opposite() {
    return new ht(new Et(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));
  }
  makeOpaque(e) {
    if (this.isOpaque() || e.rgba.a !== 1)
      return this;
    const { r, g: n, b: s, a: i } = this.rgba;
    return new ht(new Et(e.rgba.r - i * (e.rgba.r - r), e.rgba.g - i * (e.rgba.g - n), e.rgba.b - i * (e.rgba.b - s), 1));
  }
  toString() {
    return this._toString || (this._toString = ht.Format.CSS.format(this)), this._toString;
  }
  static getLighterColor(e, r, n) {
    if (e.isLighterThan(r))
      return e;
    n = n || 0.5;
    const s = e.getRelativeLuminance(), i = r.getRelativeLuminance();
    return n = n * (i - s) / i, e.lighten(n);
  }
  static getDarkerColor(e, r, n) {
    if (e.isDarkerThan(r))
      return e;
    n = n || 0.5;
    const s = e.getRelativeLuminance(), i = r.getRelativeLuminance();
    return n = n * (s - i) / s, e.darken(n);
  }
  static {
    this.white = new ht(new Et(255, 255, 255, 1));
  }
  static {
    this.black = new ht(new Et(0, 0, 0, 1));
  }
  static {
    this.red = new ht(new Et(255, 0, 0, 1));
  }
  static {
    this.blue = new ht(new Et(0, 0, 255, 1));
  }
  static {
    this.green = new ht(new Et(0, 255, 0, 1));
  }
  static {
    this.cyan = new ht(new Et(0, 255, 255, 1));
  }
  static {
    this.lightgrey = new ht(new Et(211, 211, 211, 1));
  }
  static {
    this.transparent = new ht(new Et(0, 0, 0, 0));
  }
};
(function(t) {
  (function(e) {
    (function(r) {
      function n(S) {
        return S.rgba.a === 1 ? `rgb(${S.rgba.r}, ${S.rgba.g}, ${S.rgba.b})` : t.Format.CSS.formatRGBA(S);
      }
      r.formatRGB = n;
      function s(S) {
        return `rgba(${S.rgba.r}, ${S.rgba.g}, ${S.rgba.b}, ${+S.rgba.a.toFixed(2)})`;
      }
      r.formatRGBA = s;
      function i(S) {
        return S.hsla.a === 1 ? `hsl(${S.hsla.h}, ${(S.hsla.s * 100).toFixed(2)}%, ${(S.hsla.l * 100).toFixed(2)}%)` : t.Format.CSS.formatHSLA(S);
      }
      r.formatHSL = i;
      function u(S) {
        return `hsla(${S.hsla.h}, ${(S.hsla.s * 100).toFixed(2)}%, ${(S.hsla.l * 100).toFixed(2)}%, ${S.hsla.a.toFixed(2)})`;
      }
      r.formatHSLA = u;
      function l(S) {
        const T = S.toString(16);
        return T.length !== 2 ? "0" + T : T;
      }
      function c(S) {
        return `#${l(S.rgba.r)}${l(S.rgba.g)}${l(S.rgba.b)}`;
      }
      r.formatHex = c;
      function m(S, T = !1) {
        return T && S.rgba.a === 1 ? t.Format.CSS.formatHex(S) : `#${l(S.rgba.r)}${l(S.rgba.g)}${l(S.rgba.b)}${l(Math.round(S.rgba.a * 255))}`;
      }
      r.formatHexA = m;
      function _(S) {
        return S.isOpaque() ? t.Format.CSS.formatHex(S) : t.Format.CSS.formatRGBA(S);
      }
      r.format = _;
      function y(S) {
        const T = S.length;
        if (T === 0 || S.charCodeAt(0) !== 35)
          return null;
        if (T === 7) {
          const L = 16 * v(S.charCodeAt(1)) + v(S.charCodeAt(2)), D = 16 * v(S.charCodeAt(3)) + v(S.charCodeAt(4)), V = 16 * v(S.charCodeAt(5)) + v(S.charCodeAt(6));
          return new t(new Et(L, D, V, 1));
        }
        if (T === 9) {
          const L = 16 * v(S.charCodeAt(1)) + v(S.charCodeAt(2)), D = 16 * v(S.charCodeAt(3)) + v(S.charCodeAt(4)), V = 16 * v(S.charCodeAt(5)) + v(S.charCodeAt(6)), W = 16 * v(S.charCodeAt(7)) + v(S.charCodeAt(8));
          return new t(new Et(L, D, V, W / 255));
        }
        if (T === 4) {
          const L = v(S.charCodeAt(1)), D = v(S.charCodeAt(2)), V = v(S.charCodeAt(3));
          return new t(new Et(16 * L + L, 16 * D + D, 16 * V + V));
        }
        if (T === 5) {
          const L = v(S.charCodeAt(1)), D = v(S.charCodeAt(2)), V = v(S.charCodeAt(3)), W = v(S.charCodeAt(4));
          return new t(new Et(16 * L + L, 16 * D + D, 16 * V + V, (16 * W + W) / 255));
        }
        return null;
      }
      r.parseHex = y;
      function v(S) {
        switch (S) {
          case 48:
            return 0;
          case 49:
            return 1;
          case 50:
            return 2;
          case 51:
            return 3;
          case 52:
            return 4;
          case 53:
            return 5;
          case 54:
            return 6;
          case 55:
            return 7;
          case 56:
            return 8;
          case 57:
            return 9;
          case 97:
            return 10;
          case 65:
            return 10;
          case 98:
            return 11;
          case 66:
            return 11;
          case 99:
            return 12;
          case 67:
            return 12;
          case 100:
            return 13;
          case 68:
            return 13;
          case 101:
            return 14;
          case 69:
            return 14;
          case 102:
            return 15;
          case 70:
            return 15;
        }
        return 0;
      }
    })(e.CSS || (e.CSS = {}));
  })(t.Format || (t.Format = {}));
})(xa || (xa = {}));
function o_(t) {
  const e = [];
  for (const r of t) {
    const n = Number(r);
    (n || n === 0 && r.replace(/\s/g, "") !== "") && e.push(n);
  }
  return e;
}
function th(t, e, r, n) {
  return {
    red: t / 255,
    blue: r / 255,
    green: e / 255,
    alpha: n
  };
}
function ci(t, e) {
  const r = e.index, n = e[0].length;
  if (!r)
    return;
  const s = t.positionAt(r);
  return {
    startLineNumber: s.lineNumber,
    startColumn: s.column,
    endLineNumber: s.lineNumber,
    endColumn: s.column + n
  };
}
function y8(t, e) {
  if (!t)
    return;
  const r = xa.Format.CSS.parseHex(e);
  if (r)
    return {
      range: t,
      color: th(r.rgba.r, r.rgba.g, r.rgba.b, r.rgba.a)
    };
}
function Xm(t, e, r) {
  if (!t || e.length !== 1)
    return;
  const s = e[0].values(), i = o_(s);
  return {
    range: t,
    color: th(i[0], i[1], i[2], r ? i[3] : 1)
  };
}
function Jm(t, e, r) {
  if (!t || e.length !== 1)
    return;
  const s = e[0].values(), i = o_(s), u = new xa(new vr(i[0], i[1] / 100, i[2] / 100, r ? i[3] : 1));
  return {
    range: t,
    color: th(u.rgba.r, u.rgba.g, u.rgba.b, u.rgba.a)
  };
}
function fi(t, e) {
  return typeof t == "string" ? [...t.matchAll(e)] : t.findMatches(e);
}
function b8(t) {
  const e = [], n = fi(t, /\b(rgb|rgba|hsl|hsla)(\([0-9\s,.\%]*\))|(#)([A-Fa-f0-9]{3})\b|(#)([A-Fa-f0-9]{4})\b|(#)([A-Fa-f0-9]{6})\b|(#)([A-Fa-f0-9]{8})\b/gm);
  if (n.length > 0)
    for (const s of n) {
      const i = s.filter((m) => m !== void 0), u = i[1], l = i[2];
      if (!l)
        continue;
      let c;
      if (u === "rgb") {
        const m = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*\)$/gm;
        c = Xm(ci(t, s), fi(l, m), !1);
      } else if (u === "rgba") {
        const m = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
        c = Xm(ci(t, s), fi(l, m), !0);
      } else if (u === "hsl") {
        const m = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*\)$/gm;
        c = Jm(ci(t, s), fi(l, m), !1);
      } else if (u === "hsla") {
        const m = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
        c = Jm(ci(t, s), fi(l, m), !0);
      } else u === "#" && (c = y8(ci(t, s), u + l));
      c && e.push(c);
    }
  return e;
}
function w8(t) {
  return !t || typeof t.getValue != "function" || typeof t.positionAt != "function" ? [] : b8(t);
}
const Qm = new RegExp("\\bMARK:\\s*(.*)$", "d"), v8 = /^-+|-+$/g;
function S8(t, e) {
  let r = [];
  if (e.findRegionSectionHeaders && e.foldingRules?.markers) {
    const n = E8(t, e);
    r = r.concat(n);
  }
  if (e.findMarkSectionHeaders) {
    const n = N8(t);
    r = r.concat(n);
  }
  return r;
}
function E8(t, e) {
  const r = [], n = t.getLineCount();
  for (let s = 1; s <= n; s++) {
    const i = t.getLineContent(s), u = i.match(e.foldingRules.markers.start);
    if (u) {
      const l = { startLineNumber: s, startColumn: u[0].length + 1, endLineNumber: s, endColumn: i.length + 1 };
      if (l.endColumn > l.startColumn) {
        const c = {
          range: l,
          ...a_(i.substring(u[0].length)),
          shouldBeInComments: !1
        };
        (c.text || c.hasSeparatorLine) && r.push(c);
      }
    }
  }
  return r;
}
function N8(t) {
  const e = [], r = t.getLineCount();
  for (let n = 1; n <= r; n++) {
    const s = t.getLineContent(n);
    x8(s, n, e);
  }
  return e;
}
function x8(t, e, r) {
  Qm.lastIndex = 0;
  const n = Qm.exec(t);
  if (n) {
    const s = n.indices[1][0] + 1, i = n.indices[1][1] + 1, u = { startLineNumber: e, startColumn: s, endLineNumber: e, endColumn: i };
    if (u.endColumn > u.startColumn) {
      const l = {
        range: u,
        ...a_(n[1]),
        shouldBeInComments: !0
      };
      (l.text || l.hasSeparatorLine) && r.push(l);
    }
  }
}
function a_(t) {
  t = t.trim();
  const e = t.startsWith("-");
  return t = t.replace(v8, ""), { text: t, hasSeparatorLine: e };
}
var Km;
(function(t) {
  async function e(n) {
    let s;
    const i = await Promise.all(n.map((u) => u.then((l) => l, (l) => {
      s || (s = l);
    })));
    if (typeof s < "u")
      throw s;
    return i;
  }
  t.settled = e;
  function r(n) {
    return new Promise(async (s, i) => {
      try {
        await n(s, i);
      } catch (u) {
        i(u);
      }
    });
  }
  t.withAsyncBody = r;
})(Km || (Km = {}));
class sr {
  static fromArray(e) {
    return new sr((r) => {
      r.emitMany(e);
    });
  }
  static fromPromise(e) {
    return new sr(async (r) => {
      r.emitMany(await e);
    });
  }
  static fromPromises(e) {
    return new sr(async (r) => {
      await Promise.all(e.map(async (n) => r.emitOne(await n)));
    });
  }
  static merge(e) {
    return new sr(async (r) => {
      await Promise.all(e.map(async (n) => {
        for await (const s of n)
          r.emitOne(s);
      }));
    });
  }
  static {
    this.EMPTY = sr.fromArray([]);
  }
  constructor(e, r) {
    this._state = 0, this._results = [], this._error = null, this._onReturn = r, this._onStateChanged = new wr(), queueMicrotask(async () => {
      const n = {
        emitOne: (s) => this.emitOne(s),
        emitMany: (s) => this.emitMany(s),
        reject: (s) => this.reject(s)
      };
      try {
        await Promise.resolve(e(n)), this.resolve();
      } catch (s) {
        this.reject(s);
      } finally {
        n.emitOne = void 0, n.emitMany = void 0, n.reject = void 0;
      }
    });
  }
  [Symbol.asyncIterator]() {
    let e = 0;
    return {
      next: async () => {
        do {
          if (this._state === 2)
            throw this._error;
          if (e < this._results.length)
            return { done: !1, value: this._results[e++] };
          if (this._state === 1)
            return { done: !0, value: void 0 };
          await pa.toPromise(this._onStateChanged.event);
        } while (!0);
      },
      return: async () => (this._onReturn?.(), { done: !0, value: void 0 })
    };
  }
  static map(e, r) {
    return new sr(async (n) => {
      for await (const s of e)
        n.emitOne(r(s));
    });
  }
  map(e) {
    return sr.map(this, e);
  }
  static filter(e, r) {
    return new sr(async (n) => {
      for await (const s of e)
        r(s) && n.emitOne(s);
    });
  }
  filter(e) {
    return sr.filter(this, e);
  }
  static coalesce(e) {
    return sr.filter(e, (r) => !!r);
  }
  coalesce() {
    return sr.coalesce(this);
  }
  static async toPromise(e) {
    const r = [];
    for await (const n of e)
      r.push(n);
    return r;
  }
  toPromise() {
    return sr.toPromise(this);
  }
  /**
   * The value will be appended at the end.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  emitOne(e) {
    this._state === 0 && (this._results.push(e), this._onStateChanged.fire());
  }
  /**
   * The values will be appended at the end.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  emitMany(e) {
    this._state === 0 && (this._results = this._results.concat(e), this._onStateChanged.fire());
  }
  /**
   * Calling `resolve()` will mark the result array as complete.
   *
   * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  resolve() {
    this._state === 0 && (this._state = 1, this._onStateChanged.fire());
  }
  /**
   * Writing an error will permanently invalidate this iterable.
   * The current users will receive an error thrown, as will all future users.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  reject(e) {
    this._state === 0 && (this._state = 2, this._error = e, this._onStateChanged.fire());
  }
}
class T8 {
  constructor(e) {
    this.values = e, this.prefixSum = new Uint32Array(e.length), this.prefixSumValidIndex = new Int32Array(1), this.prefixSumValidIndex[0] = -1;
  }
  insertValues(e, r) {
    e = hs(e);
    const n = this.values, s = this.prefixSum, i = r.length;
    return i === 0 ? !1 : (this.values = new Uint32Array(n.length + i), this.values.set(n.subarray(0, e), 0), this.values.set(n.subarray(e), e + i), this.values.set(r, e), e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), this.prefixSum = new Uint32Array(this.values.length), this.prefixSumValidIndex[0] >= 0 && this.prefixSum.set(s.subarray(0, this.prefixSumValidIndex[0] + 1)), !0);
  }
  setValue(e, r) {
    return e = hs(e), r = hs(r), this.values[e] === r ? !1 : (this.values[e] = r, e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), !0);
  }
  removeValues(e, r) {
    e = hs(e), r = hs(r);
    const n = this.values, s = this.prefixSum;
    if (e >= n.length)
      return !1;
    const i = n.length - e;
    return r >= i && (r = i), r === 0 ? !1 : (this.values = new Uint32Array(n.length - r), this.values.set(n.subarray(0, e), 0), this.values.set(n.subarray(e + r), e), this.prefixSum = new Uint32Array(this.values.length), e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), this.prefixSumValidIndex[0] >= 0 && this.prefixSum.set(s.subarray(0, this.prefixSumValidIndex[0] + 1)), !0);
  }
  getTotalSum() {
    return this.values.length === 0 ? 0 : this._getPrefixSum(this.values.length - 1);
  }
  /**
   * Returns the sum of the first `index + 1` many items.
   * @returns `SUM(0 <= j <= index, values[j])`.
   */
  getPrefixSum(e) {
    return e < 0 ? 0 : (e = hs(e), this._getPrefixSum(e));
  }
  _getPrefixSum(e) {
    if (e <= this.prefixSumValidIndex[0])
      return this.prefixSum[e];
    let r = this.prefixSumValidIndex[0] + 1;
    r === 0 && (this.prefixSum[0] = this.values[0], r++), e >= this.values.length && (e = this.values.length - 1);
    for (let n = r; n <= e; n++)
      this.prefixSum[n] = this.prefixSum[n - 1] + this.values[n];
    return this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], e), this.prefixSum[e];
  }
  getIndexOf(e) {
    e = Math.floor(e), this.getTotalSum();
    let r = 0, n = this.values.length - 1, s = 0, i = 0, u = 0;
    for (; r <= n; )
      if (s = r + (n - r) / 2 | 0, i = this.prefixSum[s], u = i - this.values[s], e < u)
        n = s - 1;
      else if (e >= i)
        r = s + 1;
      else
        break;
    return new P8(s, e - u);
  }
}
class P8 {
  constructor(e, r) {
    this.index = e, this.remainder = r, this._prefixSumIndexOfResultBrand = void 0, this.index = e, this.remainder = r;
  }
}
class A8 {
  constructor(e, r, n, s) {
    this._uri = e, this._lines = r, this._eol = n, this._versionId = s, this._lineStarts = null, this._cachedTextValue = null;
  }
  dispose() {
    this._lines.length = 0;
  }
  get version() {
    return this._versionId;
  }
  getText() {
    return this._cachedTextValue === null && (this._cachedTextValue = this._lines.join(this._eol)), this._cachedTextValue;
  }
  onEvents(e) {
    e.eol && e.eol !== this._eol && (this._eol = e.eol, this._lineStarts = null);
    const r = e.changes;
    for (const n of r)
      this._acceptDeleteRange(n.range), this._acceptInsertText(new st(n.range.startLineNumber, n.range.startColumn), n.text);
    this._versionId = e.versionId, this._cachedTextValue = null;
  }
  _ensureLineStarts() {
    if (!this._lineStarts) {
      const e = this._eol.length, r = this._lines.length, n = new Uint32Array(r);
      for (let s = 0; s < r; s++)
        n[s] = this._lines[s].length + e;
      this._lineStarts = new T8(n);
    }
  }
  /**
   * All changes to a line's text go through this method
   */
  _setLineText(e, r) {
    this._lines[e] = r, this._lineStarts && this._lineStarts.setValue(e, this._lines[e].length + this._eol.length);
  }
  _acceptDeleteRange(e) {
    if (e.startLineNumber === e.endLineNumber) {
      if (e.startColumn === e.endColumn)
        return;
      this._setLineText(e.startLineNumber - 1, this._lines[e.startLineNumber - 1].substring(0, e.startColumn - 1) + this._lines[e.startLineNumber - 1].substring(e.endColumn - 1));
      return;
    }
    this._setLineText(e.startLineNumber - 1, this._lines[e.startLineNumber - 1].substring(0, e.startColumn - 1) + this._lines[e.endLineNumber - 1].substring(e.endColumn - 1)), this._lines.splice(e.startLineNumber, e.endLineNumber - e.startLineNumber), this._lineStarts && this._lineStarts.removeValues(e.startLineNumber, e.endLineNumber - e.startLineNumber);
  }
  _acceptInsertText(e, r) {
    if (r.length === 0)
      return;
    const n = b6(r);
    if (n.length === 1) {
      this._setLineText(e.lineNumber - 1, this._lines[e.lineNumber - 1].substring(0, e.column - 1) + n[0] + this._lines[e.lineNumber - 1].substring(e.column - 1));
      return;
    }
    n[n.length - 1] += this._lines[e.lineNumber - 1].substring(e.column - 1), this._setLineText(e.lineNumber - 1, this._lines[e.lineNumber - 1].substring(0, e.column - 1) + n[0]);
    const s = new Uint32Array(n.length - 1);
    for (let i = 1; i < n.length; i++)
      this._lines.splice(e.lineNumber + i - 1, 0, n[i]), s[i - 1] = n[i].length + this._eol.length;
    this._lineStarts && this._lineStarts.insertValues(e.lineNumber, s);
  }
}
class L8 {
  constructor() {
    this._models = /* @__PURE__ */ Object.create(null);
  }
  getModel(e) {
    return this._models[e];
  }
  getModels() {
    const e = [];
    return Object.keys(this._models).forEach((r) => e.push(this._models[r])), e;
  }
  $acceptNewModel(e) {
    this._models[e.url] = new M8(Jr.parse(e.url), e.lines, e.EOL, e.versionId);
  }
  $acceptModelChanged(e, r) {
    if (!this._models[e])
      return;
    this._models[e].onEvents(r);
  }
  $acceptRemovedModel(e) {
    this._models[e] && delete this._models[e];
  }
}
class M8 extends A8 {
  get uri() {
    return this._uri;
  }
  get eol() {
    return this._eol;
  }
  getValue() {
    return this.getText();
  }
  findMatches(e) {
    const r = [];
    for (let n = 0; n < this._lines.length; n++) {
      const s = this._lines[n], i = this.offsetAt(new st(n + 1, 1)), u = s.matchAll(e);
      for (const l of u)
        (l.index || l.index === 0) && (l.index = l.index + i), r.push(l);
    }
    return r;
  }
  getLinesContent() {
    return this._lines.slice(0);
  }
  getLineCount() {
    return this._lines.length;
  }
  getLineContent(e) {
    return this._lines[e - 1];
  }
  getWordAtPosition(e, r) {
    const n = eh(e.column, r_(r), this._lines[e.lineNumber - 1], 0);
    return n ? new xe(e.lineNumber, n.startColumn, e.lineNumber, n.endColumn) : null;
  }
  words(e) {
    const r = this._lines, n = this._wordenize.bind(this);
    let s = 0, i = "", u = 0, l = [];
    return {
      *[Symbol.iterator]() {
        for (; ; )
          if (u < l.length) {
            const c = i.substring(l[u].start, l[u].end);
            u += 1, yield c;
          } else if (s < r.length)
            i = r[s], l = n(i, e), u = 0, s += 1;
          else
            break;
      }
    };
  }
  getLineWords(e, r) {
    const n = this._lines[e - 1], s = this._wordenize(n, r), i = [];
    for (const u of s)
      i.push({
        word: n.substring(u.start, u.end),
        startColumn: u.start + 1,
        endColumn: u.end + 1
      });
    return i;
  }
  _wordenize(e, r) {
    const n = [];
    let s;
    for (r.lastIndex = 0; (s = r.exec(e)) && s[0].length !== 0; )
      n.push({ start: s.index, end: s.index + s[0].length });
    return n;
  }
  getValueInRange(e) {
    if (e = this._validateRange(e), e.startLineNumber === e.endLineNumber)
      return this._lines[e.startLineNumber - 1].substring(e.startColumn - 1, e.endColumn - 1);
    const r = this._eol, n = e.startLineNumber - 1, s = e.endLineNumber - 1, i = [];
    i.push(this._lines[n].substring(e.startColumn - 1));
    for (let u = n + 1; u < s; u++)
      i.push(this._lines[u]);
    return i.push(this._lines[s].substring(0, e.endColumn - 1)), i.join(r);
  }
  offsetAt(e) {
    return e = this._validatePosition(e), this._ensureLineStarts(), this._lineStarts.getPrefixSum(e.lineNumber - 2) + (e.column - 1);
  }
  positionAt(e) {
    e = Math.floor(e), e = Math.max(0, e), this._ensureLineStarts();
    const r = this._lineStarts.getIndexOf(e), n = this._lines[r.index].length;
    return {
      lineNumber: 1 + r.index,
      column: 1 + Math.min(r.remainder, n)
    };
  }
  _validateRange(e) {
    const r = this._validatePosition({ lineNumber: e.startLineNumber, column: e.startColumn }), n = this._validatePosition({ lineNumber: e.endLineNumber, column: e.endColumn });
    return r.lineNumber !== e.startLineNumber || r.column !== e.startColumn || n.lineNumber !== e.endLineNumber || n.column !== e.endColumn ? {
      startLineNumber: r.lineNumber,
      startColumn: r.column,
      endLineNumber: n.lineNumber,
      endColumn: n.column
    } : e;
  }
  _validatePosition(e) {
    if (!st.isIPosition(e))
      throw new Error("bad position");
    let { lineNumber: r, column: n } = e, s = !1;
    if (r < 1)
      r = 1, n = 1, s = !0;
    else if (r > this._lines.length)
      r = this._lines.length, n = this._lines[r - 1].length + 1, s = !0;
    else {
      const i = this._lines[r - 1].length + 1;
      n < 1 ? (n = 1, s = !0) : n > i && (n = i, s = !0);
    }
    return s ? { lineNumber: r, column: n } : e;
  }
}
class O8 {
  constructor() {
    this._workerTextModelSyncServer = new L8();
  }
  dispose() {
  }
  _getModel(e) {
    return this._workerTextModelSyncServer.getModel(e);
  }
  _getModels() {
    return this._workerTextModelSyncServer.getModels();
  }
  $acceptNewModel(e) {
    this._workerTextModelSyncServer.$acceptNewModel(e);
  }
  $acceptModelChanged(e, r) {
    this._workerTextModelSyncServer.$acceptModelChanged(e, r);
  }
  $acceptRemovedModel(e) {
    this._workerTextModelSyncServer.$acceptRemovedModel(e);
  }
  async $computeUnicodeHighlights(e, r, n) {
    const s = this._getModel(e);
    return s ? D5.computeUnicodeHighlights(s, r, n) : { ranges: [], hasMore: !1, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };
  }
  async $findSectionHeaders(e, r) {
    const n = this._getModel(e);
    return n ? S8(n, r) : [];
  }
  // ---- BEGIN diff --------------------------------------------------------------------------
  async $computeDiff(e, r, n, s) {
    const i = this._getModel(e), u = this._getModel(r);
    return !i || !u ? null : Jo.computeDiff(i, u, n, s);
  }
  static computeDiff(e, r, n, s) {
    const i = s === "advanced" ? Zm.getDefault() : Zm.getLegacy(), u = e.getLinesContent(), l = r.getLinesContent(), c = i.computeDiff(u, l, n), m = c.changes.length > 0 ? !1 : this._modelsAreIdentical(e, r);
    function _(y) {
      return y.map((v) => [v.original.startLineNumber, v.original.endLineNumberExclusive, v.modified.startLineNumber, v.modified.endLineNumberExclusive, v.innerChanges?.map((S) => [
        S.originalRange.startLineNumber,
        S.originalRange.startColumn,
        S.originalRange.endLineNumber,
        S.originalRange.endColumn,
        S.modifiedRange.startLineNumber,
        S.modifiedRange.startColumn,
        S.modifiedRange.endLineNumber,
        S.modifiedRange.endColumn
      ])]);
    }
    return {
      identical: m,
      quitEarly: c.hitTimeout,
      changes: _(c.changes),
      moves: c.moves.map((y) => [
        y.lineRangeMapping.original.startLineNumber,
        y.lineRangeMapping.original.endLineNumberExclusive,
        y.lineRangeMapping.modified.startLineNumber,
        y.lineRangeMapping.modified.endLineNumberExclusive,
        _(y.changes)
      ])
    };
  }
  static _modelsAreIdentical(e, r) {
    const n = e.getLineCount(), s = r.getLineCount();
    if (n !== s)
      return !1;
    for (let i = 1; i <= n; i++) {
      const u = e.getLineContent(i), l = r.getLineContent(i);
      if (u !== l)
        return !1;
    }
    return !0;
  }
  static {
    this._diffLimit = 1e5;
  }
  async $computeMoreMinimalEdits(e, r, n) {
    const s = this._getModel(e);
    if (!s)
      return r;
    const i = [];
    let u;
    r = r.slice(0).sort((c, m) => {
      if (c.range && m.range)
        return xe.compareRangesUsingStarts(c.range, m.range);
      const _ = c.range ? 0 : 1, y = m.range ? 0 : 1;
      return _ - y;
    });
    let l = 0;
    for (let c = 1; c < r.length; c++)
      xe.getEndPosition(r[l].range).equals(xe.getStartPosition(r[c].range)) ? (r[l].range = xe.fromPositions(xe.getStartPosition(r[l].range), xe.getEndPosition(r[c].range)), r[l].text += r[c].text) : (l++, r[l] = r[c]);
    r.length = l + 1;
    for (let { range: c, text: m, eol: _ } of r) {
      if (typeof _ == "number" && (u = _), xe.isEmpty(c) && !m)
        continue;
      const y = s.getValueInRange(c);
      if (m = m.replace(/\r\n|\n|\r/g, s.eol), y === m)
        continue;
      if (Math.max(m.length, y.length) > Jo._diffLimit) {
        i.push({ range: c, text: m });
        continue;
      }
      const v = s5(y, m, n), S = s.offsetAt(xe.lift(c).getStartPosition());
      for (const T of v) {
        const L = s.positionAt(S + T.originalStart), D = s.positionAt(S + T.originalStart + T.originalLength), V = {
          text: m.substr(T.modifiedStart, T.modifiedLength),
          range: { startLineNumber: L.lineNumber, startColumn: L.column, endLineNumber: D.lineNumber, endColumn: D.column }
        };
        s.getValueInRange(V.range) !== V.text && i.push(V);
      }
    }
    return typeof u == "number" && i.push({ eol: u, text: "", range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } }), i;
  }
  // ---- END minimal edits ---------------------------------------------------------------
  async $computeLinks(e) {
    const r = this._getModel(e);
    return r ? l5(r) : null;
  }
  // --- BEGIN default document colors -----------------------------------------------------------
  async $computeDefaultDocumentColors(e) {
    const r = this._getModel(e);
    return r ? w8(r) : null;
  }
  static {
    this._suggestionsLimit = 1e4;
  }
  async $textualSuggest(e, r, n, s) {
    const i = new Ya(), u = new RegExp(n, s), l = /* @__PURE__ */ new Set();
    e: for (const c of e) {
      const m = this._getModel(c);
      if (m) {
        for (const _ of m.words(u))
          if (!(_ === r || !isNaN(Number(_))) && (l.add(_), l.size > Jo._suggestionsLimit))
            break e;
      }
    }
    return { words: Array.from(l), duration: i.elapsed() };
  }
  // ---- END suggest --------------------------------------------------------------------------
  //#region -- word ranges --
  async $computeWordRanges(e, r, n, s) {
    const i = this._getModel(e);
    if (!i)
      return /* @__PURE__ */ Object.create(null);
    const u = new RegExp(n, s), l = /* @__PURE__ */ Object.create(null);
    for (let c = r.startLineNumber; c < r.endLineNumber; c++) {
      const m = i.getLineWords(c, u);
      for (const _ of m) {
        if (!isNaN(Number(_.word)))
          continue;
        let y = l[_.word];
        y || (y = [], l[_.word] = y), y.push({
          startLineNumber: c,
          startColumn: _.startColumn,
          endLineNumber: c,
          endColumn: _.endColumn
        });
      }
    }
    return l;
  }
  //#endregion
  async $navigateValueSet(e, r, n, s, i) {
    const u = this._getModel(e);
    if (!u)
      return null;
    const l = new RegExp(s, i);
    r.startColumn === r.endColumn && (r = {
      startLineNumber: r.startLineNumber,
      startColumn: r.startColumn,
      endLineNumber: r.endLineNumber,
      endColumn: r.endColumn + 1
    });
    const c = u.getValueInRange(r), m = u.getWordAtPosition({ lineNumber: r.startLineNumber, column: r.startColumn }, l);
    if (!m)
      return null;
    const _ = u.getValueInRange(m);
    return Q0.INSTANCE.navigateValueSet(r, c, m, _, n);
  }
}
class Jo extends O8 {
  constructor(e, r) {
    super(), this._host = e, this._foreignModuleFactory = r, this._foreignModule = null;
  }
  async $ping() {
    return "pong";
  }
  // ---- BEGIN foreign module support --------------------------------------------------------------------------
  $loadForeignModule(e, r, n) {
    const u = {
      host: P5(n, (l, c) => this._host.$fhr(l, c)),
      getMirrorModels: () => this._getModels()
    };
    return this._foreignModuleFactory ? (this._foreignModule = this._foreignModuleFactory(u, r), Promise.resolve(Mm(this._foreignModule))) : new Promise((l, c) => {
      const m = (_) => {
        this._foreignModule = _.create(u, r), l(Mm(this._foreignModule));
      };
      import(`${Z2.asBrowserUri(`${e}.js`).toString(!0)}`).then(m).catch(c);
    });
  }
  // foreign method request
  $fmr(e, r) {
    if (!this._foreignModule || typeof this._foreignModule[e] != "function")
      return Promise.reject(new Error("Missing requestHandler or method: " + e));
    try {
      return Promise.resolve(this._foreignModule[e].apply(this._foreignModule, r));
    } catch (n) {
      return Promise.reject(n);
    }
  }
}
typeof importScripts == "function" && (globalThis.monaco = v5());
let Y1 = !1;
function u_(t) {
  if (Y1)
    return;
  Y1 = !0;
  const e = new r5((r) => {
    globalThis.postMessage(r);
  }, (r) => new Jo(Sa.getChannel(r), t));
  globalThis.onmessage = (r) => {
    e.onmessage(r.data);
  };
}
globalThis.onmessage = (t) => {
  Y1 || u_(null);
};
let ep = class Z1 {
  constructor(e, r, n, s) {
    this._uri = e, this._languageId = r, this._version = n, this._content = s, this._lineOffsets = void 0;
  }
  get uri() {
    return this._uri;
  }
  get languageId() {
    return this._languageId;
  }
  get version() {
    return this._version;
  }
  getText(e) {
    if (e) {
      const r = this.offsetAt(e.start), n = this.offsetAt(e.end);
      return this._content.substring(r, n);
    }
    return this._content;
  }
  update(e, r) {
    for (const n of e)
      if (Z1.isIncremental(n)) {
        const s = c_(n.range), i = this.offsetAt(s.start), u = this.offsetAt(s.end);
        this._content = this._content.substring(0, i) + n.text + this._content.substring(u, this._content.length);
        const l = Math.max(s.start.line, 0), c = Math.max(s.end.line, 0);
        let m = this._lineOffsets;
        const _ = tp(n.text, !1, i);
        if (c - l === _.length)
          for (let v = 0, S = _.length; v < S; v++)
            m[v + l + 1] = _[v];
        else
          _.length < 1e4 ? m.splice(l + 1, c - l, ..._) : this._lineOffsets = m = m.slice(0, l + 1).concat(_, m.slice(c + 1));
        const y = n.text.length - (u - i);
        if (y !== 0)
          for (let v = l + 1 + _.length, S = m.length; v < S; v++)
            m[v] = m[v] + y;
      } else if (Z1.isFull(n))
        this._content = n.text, this._lineOffsets = void 0;
      else
        throw new Error("Unknown change event received");
    this._version = r;
  }
  getLineOffsets() {
    return this._lineOffsets === void 0 && (this._lineOffsets = tp(this._content, !0)), this._lineOffsets;
  }
  positionAt(e) {
    e = Math.max(Math.min(e, this._content.length), 0);
    const r = this.getLineOffsets();
    let n = 0, s = r.length;
    if (s === 0)
      return { line: 0, character: e };
    for (; n < s; ) {
      const u = Math.floor((n + s) / 2);
      r[u] > e ? s = u : n = u + 1;
    }
    const i = n - 1;
    return e = this.ensureBeforeEOL(e, r[i]), { line: i, character: e - r[i] };
  }
  offsetAt(e) {
    const r = this.getLineOffsets();
    if (e.line >= r.length)
      return this._content.length;
    if (e.line < 0)
      return 0;
    const n = r[e.line];
    if (e.character <= 0)
      return n;
    const s = e.line + 1 < r.length ? r[e.line + 1] : this._content.length, i = Math.min(n + e.character, s);
    return this.ensureBeforeEOL(i, n);
  }
  ensureBeforeEOL(e, r) {
    for (; e > r && l_(this._content.charCodeAt(e - 1)); )
      e--;
    return e;
  }
  get lineCount() {
    return this.getLineOffsets().length;
  }
  static isIncremental(e) {
    const r = e;
    return r != null && typeof r.text == "string" && r.range !== void 0 && (r.rangeLength === void 0 || typeof r.rangeLength == "number");
  }
  static isFull(e) {
    const r = e;
    return r != null && typeof r.text == "string" && r.range === void 0 && r.rangeLength === void 0;
  }
};
var X1;
(function(t) {
  function e(s, i, u, l) {
    return new ep(s, i, u, l);
  }
  t.create = e;
  function r(s, i, u) {
    if (s instanceof ep)
      return s.update(i, u), s;
    throw new Error("TextDocument.update: document must be created by TextDocument.create");
  }
  t.update = r;
  function n(s, i) {
    const u = s.getText(), l = J1(i.map(C8), (_, y) => {
      const v = _.range.start.line - y.range.start.line;
      return v === 0 ? _.range.start.character - y.range.start.character : v;
    });
    let c = 0;
    const m = [];
    for (const _ of l) {
      const y = s.offsetAt(_.range.start);
      if (y < c)
        throw new Error("Overlapping edit");
      y > c && m.push(u.substring(c, y)), _.newText.length && m.push(_.newText), c = s.offsetAt(_.range.end);
    }
    return m.push(u.substr(c)), m.join("");
  }
  t.applyEdits = n;
})(X1 || (X1 = {}));
function J1(t, e) {
  if (t.length <= 1)
    return t;
  const r = t.length / 2 | 0, n = t.slice(0, r), s = t.slice(r);
  J1(n, e), J1(s, e);
  let i = 0, u = 0, l = 0;
  for (; i < n.length && u < s.length; )
    e(n[i], s[u]) <= 0 ? t[l++] = n[i++] : t[l++] = s[u++];
  for (; i < n.length; )
    t[l++] = n[i++];
  for (; u < s.length; )
    t[l++] = s[u++];
  return t;
}
function tp(t, e, r = 0) {
  const n = e ? [r] : [];
  for (let s = 0; s < t.length; s++) {
    const i = t.charCodeAt(s);
    l_(i) && (i === 13 && s + 1 < t.length && t.charCodeAt(s + 1) === 10 && s++, n.push(r + s + 1));
  }
  return n;
}
function l_(t) {
  return t === 13 || t === 10;
}
function c_(t) {
  const e = t.start, r = t.end;
  return e.line > r.line || e.line === r.line && e.character > r.character ? { start: r, end: e } : t;
}
function C8(t) {
  const e = c_(t.range);
  return e !== t.range ? { newText: t.newText, range: e } : t;
}
var rp;
(function(t) {
  function e(r) {
    return typeof r == "string";
  }
  t.is = e;
})(rp || (rp = {}));
var Q1;
(function(t) {
  function e(r) {
    return typeof r == "string";
  }
  t.is = e;
})(Q1 || (Q1 = {}));
var np;
(function(t) {
  t.MIN_VALUE = -2147483648, t.MAX_VALUE = 2147483647;
  function e(r) {
    return typeof r == "number" && t.MIN_VALUE <= r && r <= t.MAX_VALUE;
  }
  t.is = e;
})(np || (np = {}));
var Ta;
(function(t) {
  t.MIN_VALUE = 0, t.MAX_VALUE = 2147483647;
  function e(r) {
    return typeof r == "number" && t.MIN_VALUE <= r && r <= t.MAX_VALUE;
  }
  t.is = e;
})(Ta || (Ta = {}));
var Ur;
(function(t) {
  function e(n, s) {
    return n === Number.MAX_VALUE && (n = Ta.MAX_VALUE), s === Number.MAX_VALUE && (s = Ta.MAX_VALUE), { line: n, character: s };
  }
  t.create = e;
  function r(n) {
    let s = n;
    return O.objectLiteral(s) && O.uinteger(s.line) && O.uinteger(s.character);
  }
  t.is = r;
})(Ur || (Ur = {}));
var ut;
(function(t) {
  function e(n, s, i, u) {
    if (O.uinteger(n) && O.uinteger(s) && O.uinteger(i) && O.uinteger(u))
      return { start: Ur.create(n, s), end: Ur.create(i, u) };
    if (Ur.is(n) && Ur.is(s))
      return { start: n, end: s };
    throw new Error(`Range#create called with invalid arguments[${n}, ${s}, ${i}, ${u}]`);
  }
  t.create = e;
  function r(n) {
    let s = n;
    return O.objectLiteral(s) && Ur.is(s.start) && Ur.is(s.end);
  }
  t.is = r;
})(ut || (ut = {}));
var Pa;
(function(t) {
  function e(n, s) {
    return { uri: n, range: s };
  }
  t.create = e;
  function r(n) {
    let s = n;
    return O.objectLiteral(s) && ut.is(s.range) && (O.string(s.uri) || O.undefined(s.uri));
  }
  t.is = r;
})(Pa || (Pa = {}));
var sp;
(function(t) {
  function e(n, s, i, u) {
    return { targetUri: n, targetRange: s, targetSelectionRange: i, originSelectionRange: u };
  }
  t.create = e;
  function r(n) {
    let s = n;
    return O.objectLiteral(s) && ut.is(s.targetRange) && O.string(s.targetUri) && ut.is(s.targetSelectionRange) && (ut.is(s.originSelectionRange) || O.undefined(s.originSelectionRange));
  }
  t.is = r;
})(sp || (sp = {}));
var K1;
(function(t) {
  function e(n, s, i, u) {
    return {
      red: n,
      green: s,
      blue: i,
      alpha: u
    };
  }
  t.create = e;
  function r(n) {
    const s = n;
    return O.objectLiteral(s) && O.numberRange(s.red, 0, 1) && O.numberRange(s.green, 0, 1) && O.numberRange(s.blue, 0, 1) && O.numberRange(s.alpha, 0, 1);
  }
  t.is = r;
})(K1 || (K1 = {}));
var ip;
(function(t) {
  function e(n, s) {
    return {
      range: n,
      color: s
    };
  }
  t.create = e;
  function r(n) {
    const s = n;
    return O.objectLiteral(s) && ut.is(s.range) && K1.is(s.color);
  }
  t.is = r;
})(ip || (ip = {}));
var op;
(function(t) {
  function e(n, s, i) {
    return {
      label: n,
      textEdit: s,
      additionalTextEdits: i
    };
  }
  t.create = e;
  function r(n) {
    const s = n;
    return O.objectLiteral(s) && O.string(s.label) && (O.undefined(s.textEdit) || Us.is(s)) && (O.undefined(s.additionalTextEdits) || O.typedArray(s.additionalTextEdits, Us.is));
  }
  t.is = r;
})(op || (op = {}));
var ap;
(function(t) {
  t.Comment = "comment", t.Imports = "imports", t.Region = "region";
})(ap || (ap = {}));
var up;
(function(t) {
  function e(n, s, i, u, l, c) {
    const m = {
      startLine: n,
      endLine: s
    };
    return O.defined(i) && (m.startCharacter = i), O.defined(u) && (m.endCharacter = u), O.defined(l) && (m.kind = l), O.defined(c) && (m.collapsedText = c), m;
  }
  t.create = e;
  function r(n) {
    const s = n;
    return O.objectLiteral(s) && O.uinteger(s.startLine) && O.uinteger(s.startLine) && (O.undefined(s.startCharacter) || O.uinteger(s.startCharacter)) && (O.undefined(s.endCharacter) || O.uinteger(s.endCharacter)) && (O.undefined(s.kind) || O.string(s.kind));
  }
  t.is = r;
})(up || (up = {}));
var e0;
(function(t) {
  function e(n, s) {
    return {
      location: n,
      message: s
    };
  }
  t.create = e;
  function r(n) {
    let s = n;
    return O.defined(s) && Pa.is(s.location) && O.string(s.message);
  }
  t.is = r;
})(e0 || (e0 = {}));
var lp;
(function(t) {
  t.Error = 1, t.Warning = 2, t.Information = 3, t.Hint = 4;
})(lp || (lp = {}));
var cp;
(function(t) {
  t.Unnecessary = 1, t.Deprecated = 2;
})(cp || (cp = {}));
var fp;
(function(t) {
  function e(r) {
    const n = r;
    return O.objectLiteral(n) && O.string(n.href);
  }
  t.is = e;
})(fp || (fp = {}));
var Aa;
(function(t) {
  function e(n, s, i, u, l, c) {
    let m = { range: n, message: s };
    return O.defined(i) && (m.severity = i), O.defined(u) && (m.code = u), O.defined(l) && (m.source = l), O.defined(c) && (m.relatedInformation = c), m;
  }
  t.create = e;
  function r(n) {
    var s;
    let i = n;
    return O.defined(i) && ut.is(i.range) && O.string(i.message) && (O.number(i.severity) || O.undefined(i.severity)) && (O.integer(i.code) || O.string(i.code) || O.undefined(i.code)) && (O.undefined(i.codeDescription) || O.string((s = i.codeDescription) === null || s === void 0 ? void 0 : s.href)) && (O.string(i.source) || O.undefined(i.source)) && (O.undefined(i.relatedInformation) || O.typedArray(i.relatedInformation, e0.is));
  }
  t.is = r;
})(Aa || (Aa = {}));
var Fs;
(function(t) {
  function e(n, s, ...i) {
    let u = { title: n, command: s };
    return O.defined(i) && i.length > 0 && (u.arguments = i), u;
  }
  t.create = e;
  function r(n) {
    let s = n;
    return O.defined(s) && O.string(s.title) && O.string(s.command);
  }
  t.is = r;
})(Fs || (Fs = {}));
var Us;
(function(t) {
  function e(i, u) {
    return { range: i, newText: u };
  }
  t.replace = e;
  function r(i, u) {
    return { range: { start: i, end: i }, newText: u };
  }
  t.insert = r;
  function n(i) {
    return { range: i, newText: "" };
  }
  t.del = n;
  function s(i) {
    const u = i;
    return O.objectLiteral(u) && O.string(u.newText) && ut.is(u.range);
  }
  t.is = s;
})(Us || (Us = {}));
var t0;
(function(t) {
  function e(n, s, i) {
    const u = { label: n };
    return s !== void 0 && (u.needsConfirmation = s), i !== void 0 && (u.description = i), u;
  }
  t.create = e;
  function r(n) {
    const s = n;
    return O.objectLiteral(s) && O.string(s.label) && (O.boolean(s.needsConfirmation) || s.needsConfirmation === void 0) && (O.string(s.description) || s.description === void 0);
  }
  t.is = r;
})(t0 || (t0 = {}));
var Vs;
(function(t) {
  function e(r) {
    const n = r;
    return O.string(n);
  }
  t.is = e;
})(Vs || (Vs = {}));
var hp;
(function(t) {
  function e(i, u, l) {
    return { range: i, newText: u, annotationId: l };
  }
  t.replace = e;
  function r(i, u, l) {
    return { range: { start: i, end: i }, newText: u, annotationId: l };
  }
  t.insert = r;
  function n(i, u) {
    return { range: i, newText: "", annotationId: u };
  }
  t.del = n;
  function s(i) {
    const u = i;
    return Us.is(u) && (t0.is(u.annotationId) || Vs.is(u.annotationId));
  }
  t.is = s;
})(hp || (hp = {}));
var r0;
(function(t) {
  function e(n, s) {
    return { textDocument: n, edits: s };
  }
  t.create = e;
  function r(n) {
    let s = n;
    return O.defined(s) && a0.is(s.textDocument) && Array.isArray(s.edits);
  }
  t.is = r;
})(r0 || (r0 = {}));
var n0;
(function(t) {
  function e(n, s, i) {
    let u = {
      kind: "create",
      uri: n
    };
    return s !== void 0 && (s.overwrite !== void 0 || s.ignoreIfExists !== void 0) && (u.options = s), i !== void 0 && (u.annotationId = i), u;
  }
  t.create = e;
  function r(n) {
    let s = n;
    return s && s.kind === "create" && O.string(s.uri) && (s.options === void 0 || (s.options.overwrite === void 0 || O.boolean(s.options.overwrite)) && (s.options.ignoreIfExists === void 0 || O.boolean(s.options.ignoreIfExists))) && (s.annotationId === void 0 || Vs.is(s.annotationId));
  }
  t.is = r;
})(n0 || (n0 = {}));
var s0;
(function(t) {
  function e(n, s, i, u) {
    let l = {
      kind: "rename",
      oldUri: n,
      newUri: s
    };
    return i !== void 0 && (i.overwrite !== void 0 || i.ignoreIfExists !== void 0) && (l.options = i), u !== void 0 && (l.annotationId = u), l;
  }
  t.create = e;
  function r(n) {
    let s = n;
    return s && s.kind === "rename" && O.string(s.oldUri) && O.string(s.newUri) && (s.options === void 0 || (s.options.overwrite === void 0 || O.boolean(s.options.overwrite)) && (s.options.ignoreIfExists === void 0 || O.boolean(s.options.ignoreIfExists))) && (s.annotationId === void 0 || Vs.is(s.annotationId));
  }
  t.is = r;
})(s0 || (s0 = {}));
var i0;
(function(t) {
  function e(n, s, i) {
    let u = {
      kind: "delete",
      uri: n
    };
    return s !== void 0 && (s.recursive !== void 0 || s.ignoreIfNotExists !== void 0) && (u.options = s), i !== void 0 && (u.annotationId = i), u;
  }
  t.create = e;
  function r(n) {
    let s = n;
    return s && s.kind === "delete" && O.string(s.uri) && (s.options === void 0 || (s.options.recursive === void 0 || O.boolean(s.options.recursive)) && (s.options.ignoreIfNotExists === void 0 || O.boolean(s.options.ignoreIfNotExists))) && (s.annotationId === void 0 || Vs.is(s.annotationId));
  }
  t.is = r;
})(i0 || (i0 = {}));
var o0;
(function(t) {
  function e(r) {
    let n = r;
    return n && (n.changes !== void 0 || n.documentChanges !== void 0) && (n.documentChanges === void 0 || n.documentChanges.every((s) => O.string(s.kind) ? n0.is(s) || s0.is(s) || i0.is(s) : r0.is(s)));
  }
  t.is = e;
})(o0 || (o0 = {}));
var dp;
(function(t) {
  function e(n) {
    return { uri: n };
  }
  t.create = e;
  function r(n) {
    let s = n;
    return O.defined(s) && O.string(s.uri);
  }
  t.is = r;
})(dp || (dp = {}));
var mp;
(function(t) {
  function e(n, s) {
    return { uri: n, version: s };
  }
  t.create = e;
  function r(n) {
    let s = n;
    return O.defined(s) && O.string(s.uri) && O.integer(s.version);
  }
  t.is = r;
})(mp || (mp = {}));
var a0;
(function(t) {
  function e(n, s) {
    return { uri: n, version: s };
  }
  t.create = e;
  function r(n) {
    let s = n;
    return O.defined(s) && O.string(s.uri) && (s.version === null || O.integer(s.version));
  }
  t.is = r;
})(a0 || (a0 = {}));
var pp;
(function(t) {
  function e(n, s, i, u) {
    return { uri: n, languageId: s, version: i, text: u };
  }
  t.create = e;
  function r(n) {
    let s = n;
    return O.defined(s) && O.string(s.uri) && O.string(s.languageId) && O.integer(s.version) && O.string(s.text);
  }
  t.is = r;
})(pp || (pp = {}));
var La;
(function(t) {
  t.PlainText = "plaintext", t.Markdown = "markdown";
  function e(r) {
    const n = r;
    return n === t.PlainText || n === t.Markdown;
  }
  t.is = e;
})(La || (La = {}));
var Mi;
(function(t) {
  function e(r) {
    const n = r;
    return O.objectLiteral(r) && La.is(n.kind) && O.string(n.value);
  }
  t.is = e;
})(Mi || (Mi = {}));
var Ma;
(function(t) {
  t.Text = 1, t.Method = 2, t.Function = 3, t.Constructor = 4, t.Field = 5, t.Variable = 6, t.Class = 7, t.Interface = 8, t.Module = 9, t.Property = 10, t.Unit = 11, t.Value = 12, t.Enum = 13, t.Keyword = 14, t.Snippet = 15, t.Color = 16, t.File = 17, t.Reference = 18, t.Folder = 19, t.EnumMember = 20, t.Constant = 21, t.Struct = 22, t.Event = 23, t.Operator = 24, t.TypeParameter = 25;
})(Ma || (Ma = {}));
var u0;
(function(t) {
  t.PlainText = 1, t.Snippet = 2;
})(u0 || (u0 = {}));
var gp;
(function(t) {
  t.Deprecated = 1;
})(gp || (gp = {}));
var _p;
(function(t) {
  function e(n, s, i) {
    return { newText: n, insert: s, replace: i };
  }
  t.create = e;
  function r(n) {
    const s = n;
    return s && O.string(s.newText) && ut.is(s.insert) && ut.is(s.replace);
  }
  t.is = r;
})(_p || (_p = {}));
var l0;
(function(t) {
  t.asIs = 1, t.adjustIndentation = 2;
})(l0 || (l0 = {}));
var yp;
(function(t) {
  function e(r) {
    const n = r;
    return n && (O.string(n.detail) || n.detail === void 0) && (O.string(n.description) || n.description === void 0);
  }
  t.is = e;
})(yp || (yp = {}));
var bp;
(function(t) {
  function e(r) {
    return { label: r };
  }
  t.create = e;
})(bp || (bp = {}));
var wp;
(function(t) {
  function e(r, n) {
    return { items: r || [], isIncomplete: !!n };
  }
  t.create = e;
})(wp || (wp = {}));
var Oa;
(function(t) {
  function e(n) {
    return n.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
  }
  t.fromPlainText = e;
  function r(n) {
    const s = n;
    return O.string(s) || O.objectLiteral(s) && O.string(s.language) && O.string(s.value);
  }
  t.is = r;
})(Oa || (Oa = {}));
var vp;
(function(t) {
  function e(r) {
    let n = r;
    return !!n && O.objectLiteral(n) && (Mi.is(n.contents) || Oa.is(n.contents) || O.typedArray(n.contents, Oa.is)) && (r.range === void 0 || ut.is(r.range));
  }
  t.is = e;
})(vp || (vp = {}));
var Sp;
(function(t) {
  function e(r, n) {
    return n ? { label: r, documentation: n } : { label: r };
  }
  t.create = e;
})(Sp || (Sp = {}));
var Ep;
(function(t) {
  function e(r, n, ...s) {
    let i = { label: r };
    return O.defined(n) && (i.documentation = n), O.defined(s) ? i.parameters = s : i.parameters = [], i;
  }
  t.create = e;
})(Ep || (Ep = {}));
var Np;
(function(t) {
  t.Text = 1, t.Read = 2, t.Write = 3;
})(Np || (Np = {}));
var xp;
(function(t) {
  function e(r, n) {
    let s = { range: r };
    return O.number(n) && (s.kind = n), s;
  }
  t.create = e;
})(xp || (xp = {}));
var Tp;
(function(t) {
  t.File = 1, t.Module = 2, t.Namespace = 3, t.Package = 4, t.Class = 5, t.Method = 6, t.Property = 7, t.Field = 8, t.Constructor = 9, t.Enum = 10, t.Interface = 11, t.Function = 12, t.Variable = 13, t.Constant = 14, t.String = 15, t.Number = 16, t.Boolean = 17, t.Array = 18, t.Object = 19, t.Key = 20, t.Null = 21, t.EnumMember = 22, t.Struct = 23, t.Event = 24, t.Operator = 25, t.TypeParameter = 26;
})(Tp || (Tp = {}));
var Pp;
(function(t) {
  t.Deprecated = 1;
})(Pp || (Pp = {}));
var Ap;
(function(t) {
  function e(r, n, s, i, u) {
    let l = {
      name: r,
      kind: n,
      location: { uri: i, range: s }
    };
    return u && (l.containerName = u), l;
  }
  t.create = e;
})(Ap || (Ap = {}));
var Lp;
(function(t) {
  function e(r, n, s, i) {
    return i !== void 0 ? { name: r, kind: n, location: { uri: s, range: i } } : { name: r, kind: n, location: { uri: s } };
  }
  t.create = e;
})(Lp || (Lp = {}));
var Mp;
(function(t) {
  function e(n, s, i, u, l, c) {
    let m = {
      name: n,
      detail: s,
      kind: i,
      range: u,
      selectionRange: l
    };
    return c !== void 0 && (m.children = c), m;
  }
  t.create = e;
  function r(n) {
    let s = n;
    return s && O.string(s.name) && O.number(s.kind) && ut.is(s.range) && ut.is(s.selectionRange) && (s.detail === void 0 || O.string(s.detail)) && (s.deprecated === void 0 || O.boolean(s.deprecated)) && (s.children === void 0 || Array.isArray(s.children)) && (s.tags === void 0 || Array.isArray(s.tags));
  }
  t.is = r;
})(Mp || (Mp = {}));
var Op;
(function(t) {
  t.Empty = "", t.QuickFix = "quickfix", t.Refactor = "refactor", t.RefactorExtract = "refactor.extract", t.RefactorInline = "refactor.inline", t.RefactorRewrite = "refactor.rewrite", t.Source = "source", t.SourceOrganizeImports = "source.organizeImports", t.SourceFixAll = "source.fixAll";
})(Op || (Op = {}));
var Ca;
(function(t) {
  t.Invoked = 1, t.Automatic = 2;
})(Ca || (Ca = {}));
var Cp;
(function(t) {
  function e(n, s, i) {
    let u = { diagnostics: n };
    return s != null && (u.only = s), i != null && (u.triggerKind = i), u;
  }
  t.create = e;
  function r(n) {
    let s = n;
    return O.defined(s) && O.typedArray(s.diagnostics, Aa.is) && (s.only === void 0 || O.typedArray(s.only, O.string)) && (s.triggerKind === void 0 || s.triggerKind === Ca.Invoked || s.triggerKind === Ca.Automatic);
  }
  t.is = r;
})(Cp || (Cp = {}));
var Rp;
(function(t) {
  function e(n, s, i) {
    let u = { title: n }, l = !0;
    return typeof s == "string" ? (l = !1, u.kind = s) : Fs.is(s) ? u.command = s : u.edit = s, l && i !== void 0 && (u.kind = i), u;
  }
  t.create = e;
  function r(n) {
    let s = n;
    return s && O.string(s.title) && (s.diagnostics === void 0 || O.typedArray(s.diagnostics, Aa.is)) && (s.kind === void 0 || O.string(s.kind)) && (s.edit !== void 0 || s.command !== void 0) && (s.command === void 0 || Fs.is(s.command)) && (s.isPreferred === void 0 || O.boolean(s.isPreferred)) && (s.edit === void 0 || o0.is(s.edit));
  }
  t.is = r;
})(Rp || (Rp = {}));
var Ip;
(function(t) {
  function e(n, s) {
    let i = { range: n };
    return O.defined(s) && (i.data = s), i;
  }
  t.create = e;
  function r(n) {
    let s = n;
    return O.defined(s) && ut.is(s.range) && (O.undefined(s.command) || Fs.is(s.command));
  }
  t.is = r;
})(Ip || (Ip = {}));
var kp;
(function(t) {
  function e(n, s) {
    return { tabSize: n, insertSpaces: s };
  }
  t.create = e;
  function r(n) {
    let s = n;
    return O.defined(s) && O.uinteger(s.tabSize) && O.boolean(s.insertSpaces);
  }
  t.is = r;
})(kp || (kp = {}));
var Dp;
(function(t) {
  function e(n, s, i) {
    return { range: n, target: s, data: i };
  }
  t.create = e;
  function r(n) {
    let s = n;
    return O.defined(s) && ut.is(s.range) && (O.undefined(s.target) || O.string(s.target));
  }
  t.is = r;
})(Dp || (Dp = {}));
var $p;
(function(t) {
  function e(n, s) {
    return { range: n, parent: s };
  }
  t.create = e;
  function r(n) {
    let s = n;
    return O.objectLiteral(s) && ut.is(s.range) && (s.parent === void 0 || t.is(s.parent));
  }
  t.is = r;
})($p || ($p = {}));
var Fp;
(function(t) {
  t.namespace = "namespace", t.type = "type", t.class = "class", t.enum = "enum", t.interface = "interface", t.struct = "struct", t.typeParameter = "typeParameter", t.parameter = "parameter", t.variable = "variable", t.property = "property", t.enumMember = "enumMember", t.event = "event", t.function = "function", t.method = "method", t.macro = "macro", t.keyword = "keyword", t.modifier = "modifier", t.comment = "comment", t.string = "string", t.number = "number", t.regexp = "regexp", t.operator = "operator", t.decorator = "decorator";
})(Fp || (Fp = {}));
var Up;
(function(t) {
  t.declaration = "declaration", t.definition = "definition", t.readonly = "readonly", t.static = "static", t.deprecated = "deprecated", t.abstract = "abstract", t.async = "async", t.modification = "modification", t.documentation = "documentation", t.defaultLibrary = "defaultLibrary";
})(Up || (Up = {}));
var Vp;
(function(t) {
  function e(r) {
    const n = r;
    return O.objectLiteral(n) && (n.resultId === void 0 || typeof n.resultId == "string") && Array.isArray(n.data) && (n.data.length === 0 || typeof n.data[0] == "number");
  }
  t.is = e;
})(Vp || (Vp = {}));
var zp;
(function(t) {
  function e(n, s) {
    return { range: n, text: s };
  }
  t.create = e;
  function r(n) {
    const s = n;
    return s != null && ut.is(s.range) && O.string(s.text);
  }
  t.is = r;
})(zp || (zp = {}));
var jp;
(function(t) {
  function e(n, s, i) {
    return { range: n, variableName: s, caseSensitiveLookup: i };
  }
  t.create = e;
  function r(n) {
    const s = n;
    return s != null && ut.is(s.range) && O.boolean(s.caseSensitiveLookup) && (O.string(s.variableName) || s.variableName === void 0);
  }
  t.is = r;
})(jp || (jp = {}));
var Wp;
(function(t) {
  function e(n, s) {
    return { range: n, expression: s };
  }
  t.create = e;
  function r(n) {
    const s = n;
    return s != null && ut.is(s.range) && (O.string(s.expression) || s.expression === void 0);
  }
  t.is = r;
})(Wp || (Wp = {}));
var Gp;
(function(t) {
  function e(n, s) {
    return { frameId: n, stoppedLocation: s };
  }
  t.create = e;
  function r(n) {
    const s = n;
    return O.defined(s) && ut.is(n.stoppedLocation);
  }
  t.is = r;
})(Gp || (Gp = {}));
var c0;
(function(t) {
  t.Type = 1, t.Parameter = 2;
  function e(r) {
    return r === 1 || r === 2;
  }
  t.is = e;
})(c0 || (c0 = {}));
var f0;
(function(t) {
  function e(n) {
    return { value: n };
  }
  t.create = e;
  function r(n) {
    const s = n;
    return O.objectLiteral(s) && (s.tooltip === void 0 || O.string(s.tooltip) || Mi.is(s.tooltip)) && (s.location === void 0 || Pa.is(s.location)) && (s.command === void 0 || Fs.is(s.command));
  }
  t.is = r;
})(f0 || (f0 = {}));
var Bp;
(function(t) {
  function e(n, s, i) {
    const u = { position: n, label: s };
    return i !== void 0 && (u.kind = i), u;
  }
  t.create = e;
  function r(n) {
    const s = n;
    return O.objectLiteral(s) && Ur.is(s.position) && (O.string(s.label) || O.typedArray(s.label, f0.is)) && (s.kind === void 0 || c0.is(s.kind)) && s.textEdits === void 0 || O.typedArray(s.textEdits, Us.is) && (s.tooltip === void 0 || O.string(s.tooltip) || Mi.is(s.tooltip)) && (s.paddingLeft === void 0 || O.boolean(s.paddingLeft)) && (s.paddingRight === void 0 || O.boolean(s.paddingRight));
  }
  t.is = r;
})(Bp || (Bp = {}));
var qp;
(function(t) {
  function e(r) {
    return { kind: "snippet", value: r };
  }
  t.createSnippet = e;
})(qp || (qp = {}));
var Hp;
(function(t) {
  function e(r, n, s, i) {
    return { insertText: r, filterText: n, range: s, command: i };
  }
  t.create = e;
})(Hp || (Hp = {}));
var Yp;
(function(t) {
  function e(r) {
    return { items: r };
  }
  t.create = e;
})(Yp || (Yp = {}));
var Zp;
(function(t) {
  t.Invoked = 0, t.Automatic = 1;
})(Zp || (Zp = {}));
var Xp;
(function(t) {
  function e(r, n) {
    return { range: r, text: n };
  }
  t.create = e;
})(Xp || (Xp = {}));
var Jp;
(function(t) {
  function e(r, n) {
    return { triggerKind: r, selectedCompletionInfo: n };
  }
  t.create = e;
})(Jp || (Jp = {}));
var Qp;
(function(t) {
  function e(r) {
    const n = r;
    return O.objectLiteral(n) && Q1.is(n.uri) && O.string(n.name);
  }
  t.is = e;
})(Qp || (Qp = {}));
var Kp;
(function(t) {
  function e(i, u, l, c) {
    return new R8(i, u, l, c);
  }
  t.create = e;
  function r(i) {
    let u = i;
    return !!(O.defined(u) && O.string(u.uri) && (O.undefined(u.languageId) || O.string(u.languageId)) && O.uinteger(u.lineCount) && O.func(u.getText) && O.func(u.positionAt) && O.func(u.offsetAt));
  }
  t.is = r;
  function n(i, u) {
    let l = i.getText(), c = s(u, (_, y) => {
      let v = _.range.start.line - y.range.start.line;
      return v === 0 ? _.range.start.character - y.range.start.character : v;
    }), m = l.length;
    for (let _ = c.length - 1; _ >= 0; _--) {
      let y = c[_], v = i.offsetAt(y.range.start), S = i.offsetAt(y.range.end);
      if (S <= m)
        l = l.substring(0, v) + y.newText + l.substring(S, l.length);
      else
        throw new Error("Overlapping edit");
      m = v;
    }
    return l;
  }
  t.applyEdits = n;
  function s(i, u) {
    if (i.length <= 1)
      return i;
    const l = i.length / 2 | 0, c = i.slice(0, l), m = i.slice(l);
    s(c, u), s(m, u);
    let _ = 0, y = 0, v = 0;
    for (; _ < c.length && y < m.length; )
      u(c[_], m[y]) <= 0 ? i[v++] = c[_++] : i[v++] = m[y++];
    for (; _ < c.length; )
      i[v++] = c[_++];
    for (; y < m.length; )
      i[v++] = m[y++];
    return i;
  }
})(Kp || (Kp = {}));
class R8 {
  constructor(e, r, n, s) {
    this._uri = e, this._languageId = r, this._version = n, this._content = s, this._lineOffsets = void 0;
  }
  get uri() {
    return this._uri;
  }
  get languageId() {
    return this._languageId;
  }
  get version() {
    return this._version;
  }
  getText(e) {
    if (e) {
      let r = this.offsetAt(e.start), n = this.offsetAt(e.end);
      return this._content.substring(r, n);
    }
    return this._content;
  }
  update(e, r) {
    this._content = e.text, this._version = r, this._lineOffsets = void 0;
  }
  getLineOffsets() {
    if (this._lineOffsets === void 0) {
      let e = [], r = this._content, n = !0;
      for (let s = 0; s < r.length; s++) {
        n && (e.push(s), n = !1);
        let i = r.charAt(s);
        n = i === "\r" || i === `
`, i === "\r" && s + 1 < r.length && r.charAt(s + 1) === `
` && s++;
      }
      n && r.length > 0 && e.push(r.length), this._lineOffsets = e;
    }
    return this._lineOffsets;
  }
  positionAt(e) {
    e = Math.max(Math.min(e, this._content.length), 0);
    let r = this.getLineOffsets(), n = 0, s = r.length;
    if (s === 0)
      return Ur.create(0, e);
    for (; n < s; ) {
      let u = Math.floor((n + s) / 2);
      r[u] > e ? s = u : n = u + 1;
    }
    let i = n - 1;
    return Ur.create(i, e - r[i]);
  }
  offsetAt(e) {
    let r = this.getLineOffsets();
    if (e.line >= r.length)
      return this._content.length;
    if (e.line < 0)
      return 0;
    let n = r[e.line], s = e.line + 1 < r.length ? r[e.line + 1] : this._content.length;
    return Math.max(Math.min(n + e.character, s), n);
  }
  get lineCount() {
    return this.getLineOffsets().length;
  }
}
var O;
(function(t) {
  const e = Object.prototype.toString;
  function r(S) {
    return typeof S < "u";
  }
  t.defined = r;
  function n(S) {
    return typeof S > "u";
  }
  t.undefined = n;
  function s(S) {
    return S === !0 || S === !1;
  }
  t.boolean = s;
  function i(S) {
    return e.call(S) === "[object String]";
  }
  t.string = i;
  function u(S) {
    return e.call(S) === "[object Number]";
  }
  t.number = u;
  function l(S, T, L) {
    return e.call(S) === "[object Number]" && T <= S && S <= L;
  }
  t.numberRange = l;
  function c(S) {
    return e.call(S) === "[object Number]" && -2147483648 <= S && S <= 2147483647;
  }
  t.integer = c;
  function m(S) {
    return e.call(S) === "[object Number]" && 0 <= S && S <= 2147483647;
  }
  t.uinteger = m;
  function _(S) {
    return e.call(S) === "[object Function]";
  }
  t.func = _;
  function y(S) {
    return S !== null && typeof S == "object";
  }
  t.objectLiteral = y;
  function v(S, T) {
    return Array.isArray(S) && S.every(T);
  }
  t.typedArray = v;
})(O || (O = {}));
async function I8(t, e) {
  try {
    const r = await t, n = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), i = [], u = k8(e);
    return r.forEach((l) => {
      const c = [];
      l.items.forEach(
        (m) => D8(c, s, n, u, m)
      ), c.length && i.push({ ...l, items: c });
    }), { categories: i, functionDefinitions: n, constantDefinitions: s };
  } catch (r) {
    return console.error(r), { categories: [], functionDefinitions: /* @__PURE__ */ new Map(), constantDefinitions: /* @__PURE__ */ new Map() };
  }
}
function k8(t) {
  const { profile: { apiVersion: e, bundles: r, hiddenApiItems: n = [] } = {} } = t, s = f_(e), i = Array.isArray(r) && r.length > 0 ? /* @__PURE__ */ new Set(["core", ...r]) : void 0;
  return (u) => F8(s, u.sinceVersion) && (!i || i.has(u.bundle)) && !n.includes(u.name);
}
function D8(t, e, r, n, s) {
  if (Array.isArray(s)) {
    s.forEach(
      (i) => eg(t, r, n, i)
    );
    return;
  }
  s.type === "constant" ? $8(t, e, n, s) : eg(t, r, n, s);
}
function eg(t, e, r, n) {
  if (!r(n))
    return;
  n.disableDocumentation || t.push(n);
  const {
    completion: { label: s }
  } = n, i = s.toLowerCase();
  let u = e.get(i);
  u || (u = {
    type: "functionDefinition",
    key: i,
    overloads: []
  }, e.set(i, u)), u.overloads.push(n);
}
function $8(t, e, r, n) {
  if (!r(n))
    return;
  t.push(n);
  const {
    completion: { label: s }
  } = n, i = s.toLowerCase();
  e.set(i, n);
  const [u, l] = n.completion.label.split(".");
  if (!l)
    return;
  const c = u.toLowerCase();
  let m = e.get(c);
  m || (m = {
    type: "namespace",
    key: c,
    members: [],
    completion: {
      label: u,
      detail: u,
      insertText: u,
      insertTextMode: l0.adjustIndentation,
      insertTextFormat: u0.PlainText,
      kind: Ma.Enum
    }
  }, e.set(c, m));
  const _ = structuredClone(n);
  _.name = l, _.completion.label = l, _.completion.insertText = l, _.completion.kind = Ma.Constant, m.members.push(_), m.completion.documentation = m.members.reduce(
    (y, v) => (y.value = `${y.value}${y.value ? `

` : ""}**${v.completion.label}**: ${v.description}`, y),
    { kind: La.Markdown, value: "" }
  );
}
function f_(t) {
  if (!t || typeof t != "string")
    return null;
  const e = t.split(".").map((s) => Number.parseInt(s));
  if (e.some(Number.isNaN))
    return console.error("Invalid API version string", t), null;
  const [r, n] = e.slice(0, 2);
  return { major: r, minor: n };
}
function F8(t, e) {
  if (!t)
    return !0;
  const r = f_(e);
  return r ? t.major > r.major ? !1 : t.minor === void 0 || r.minor === void 0 ? !0 : r.minor <= t.minor : !0;
}
let U8 = class {
  constructor(e) {
    this._settings = e, this.localeToApiLibraryPromiseMap = /* @__PURE__ */ new Map();
  }
  /**
   * Returns the API definitions for the given settings: definitions, constant definitions, and function definitions
   */
  async getApiDatabase(e) {
    const { locale: r = "en" } = e;
    let n = this.localeToApiLibraryPromiseMap.get(r);
    return n || (n = this._settings.getApiLibrary(r), this.localeToApiLibraryPromiseMap.set(r, n)), await I8(n, e);
  }
  /**
   * Returns the API definitions
   */
  async getApiLibrary(e) {
    const { categories: r } = await this.getApiDatabase(e);
    return r;
  }
};
var Vt = /* @__PURE__ */ ((t) => (t.ARGS = "args", t.CLAUSES = "clauses", t.ELSE = "else", t.END = "end", t.EXPR = "expr", t.LEFT = "left", t.OPERAND = "operand", t.QUALIFIER = "qualifier", t.RIGHT = "right", t.START = "start", t.VALUE = "value", t))(Vt || {}), We = /* @__PURE__ */ ((t) => (t.CASE_EXPRESSION = "case-expression", t.EXPRESSION_LIST = "expression-list", t.FUNCTION = "function", t.INTERVAL = "interval", t.INTERVAL_QUALIFIER = "interval-qualifier", t.WHEN_CLAUSE = "when-clause", t.UNARY_EXPRESSION = "unary-expression", t.BINARY_EXPRESSION = "binary-expression", t))(We || {});
const zt = {
  "case-expression": [
    "clauses",
    "operand",
    "else"
    /* ELSE */
  ],
  "when-clause": [
    "operand",
    "value"
    /* VALUE */
  ],
  "expression-list": [
    "value"
    /* VALUE */
  ],
  "unary-expression": [
    "expr"
    /* EXPR */
  ],
  "binary-expression": [
    "left",
    "right"
    /* RIGHT */
  ],
  function: [
    "args"
    /* ARGS */
  ],
  interval: [
    "value",
    "qualifier"
    /* QUALIFIER */
  ],
  "interval-qualifier": [
    "start",
    "end"
    /* END */
  ]
}, tg = {
  Error: 8
}, Oo = {
  InsertAsSnippet: 4
}, Dt = {
  Function: 1,
  Field: 3,
  Keyword: 17,
  Operator: 11
}, V8 = {
  date: "DATE",
  float: "FLOAT",
  integer: "INTEGER",
  real: "REAL",
  smallint: "SMALLINT",
  time: "TIME",
  timestamp: "TIMESTAMP",
  varchar: "VARCHAR"
}, h_ = Object.values(V8), h0 = ["YEAR", "MONTH", "DAY", "HOUR", "MINUTE", "SECOND"], z8 = [
  "DOW",
  // day of week 1-7 (Monday-Sunday)
  "DOY",
  // day of year 1-366
  "WEEK"
  // week of year, ISO 8601 week of year
], j8 = ["DATE", "TIME", "TIMESTAMP"], d_ = ["LEADING", "TRAILING", "BOTH"], W8 = [
  "AND",
  "AS",
  "BOTH",
  "CASE",
  "CAST",
  "CURRENT_DATE",
  "CURRENT_TIME",
  "CURRENT_TIMESTAMP",
  "DATE",
  "DAY",
  "DOY",
  "DOW",
  "ELSE",
  "END",
  "ESCAPE",
  "FALSE",
  "FLOAT",
  "FOR",
  "FROM",
  "HOUR",
  "IN",
  "INT",
  "INTEGER",
  "INTERVAL",
  "LEADING",
  "LIKE",
  "MINUTE",
  "MONTH",
  "POSITION",
  "REAL",
  "SECOND",
  "SMALLINT",
  "THEN",
  "TIME",
  "TIMESTAMP",
  "TIMEZONE_HOUR",
  "TIMEZONE_MINUTE",
  "TO",
  "TRAILING",
  "TRIM",
  "TRUE",
  "VARCHAR",
  "WEEK",
  "WHEN",
  "WITH",
  "YEAR",
  "ZONE"
], G8 = [
  // Logical
  "AND",
  "BETWEEN",
  "LIKE",
  "NOT",
  "OR",
  // Predicates
  "IS",
  "NULL"
], B8 = [
  // Conversion
  "CAST",
  // Datetime
  "EXTRACT",
  "CURRENT_DATE",
  "CURRENT_TIME",
  "CURRENT_TIMESTAMP",
  "CURRENT_USER",
  // Mathematical
  "ABS",
  "ACOS",
  "ASIN",
  "ATAN",
  "CEILING",
  "COS",
  "FLOOR",
  "LOG",
  "LOG10",
  "MOD",
  "NULLIF",
  "POWER",
  "ROUND",
  "SIGN",
  "SIN",
  "TAN",
  "TRUNCATE",
  // String
  "CHAR_LENGTH",
  "COALESCE",
  "CONCAT",
  "LOWER",
  "POSITION",
  "SUBSTRING",
  "TRIM",
  "UPPER"
], q8 = (t, e) => t === e ? `${t}` : e === -1 ? `${t}+` : `${t}-${e}`;
var Yt = /* @__PURE__ */ ((t) => (t.ExpectedDateTimeValue = "ExpectedDateTimeValue", t.ExpectedNumericalLiteral = "ExpectedNumericalLiteral", t.ExpectedToken = "ExpectedToken", t.FunctionNotSupported = "FunctionNotSupported", t.IncompatibleListDataType = "IncompatibleListDataType", t.IncorrectArgumentLength = "IncorrectArgumentLength", t.IncorrectCastParameters = "IncorrectCastParameters", t.InvalidDateArithmetic = "InvalidDateArithmetic", t.IncorrectExtractParameters = "IncorrectExtractParameters", t.IncorrectSubstringParameters = "IncorrectSubstringParameters", t.IncorrectTrimParameters = "IncorrectTrimParameters", t.InvalidElseClause = "InvalidElseClause", t.InvalidThenClause = "InvalidThenClause", t.InvalidEndOnWhen = "InvalidEndOnWhen", t.InvalidTrimCharacter = "InvalidTrimCharacter", t.MismatchedTypes = "MismatchedTypes", t.MissingValueInCaseClause = "MissingValueInCaseClause", t.NotCallable = "NotCallable", t.TypeNotAssignable = "TypeNotAssignable", t.UnexpectedEnd = "UnexpectedEnd.", t.UnexpectedIdentifier = "UnexpectedIdentifier", t.UnexpectedNumber = "UnexpectedNumber", t.UnexpectedTextLiteral = "UnexpectedTextLiteral", t.UnexpectedToken = "UnexpectedToken", t.UnknownField = "UnknownField", t.UnsupportedOperator = "UnsupportedOperator", t.UnsupportedSyntax = "UnsupportedSyntax", t.InvalidIntervalQualifier = "InvalidIntervalQualifier", t.EmptyCaseExpression = "EmptyCaseExpression", t))(Yt || {});
const H8 = {
  ExpectedDateTimeValue: `Expected ${h0.join(" | ")}.`,
  ExpectedNumericalLiteral: "Expected a numerical literal.",
  ExpectedToken: "Expected token ${token}.",
  // TODO: list supported functions?
  FunctionNotSupported: 'Function "${function}" not supported.',
  IncompatibleListDataType: `Incompatible data types in expression list found. All data items should have the same type.

Types found: \${types}.`,
  IncorrectArgumentLength: "Expected ${formatMinMaxParams} arguments, but got ${numArgs}.",
  IncorrectCastParameters: `Expected usage:
- CAST(<VALUE> AS <${h_.join(
    " | "
  )}>)`,
  IncorrectExtractParameters: `Expected usage:
- EXTRACT(<${h0.join(
    " | "
  )}> FROM <Datetime>)`,
  IncorrectSubstringParameters: `Expected usage:
- SUBSTRING(<VALUE> FROM <START> FOR <LENGTH>)
- SUBSTRING(<VALUE>, <START>, <LENGTH>)`,
  IncorrectTrimParameters: `Expected usage:
- TRIM(<${d_.join(
    " | "
  )}> ' ' FROM <STRING>)`,
  InvalidThenClause: "THEN clause can only follow after a WHEN clause.",
  InvalidDateArithmetic: "Invalid date arithmetic. Expected [DATE, INTERVAL] or [INTERVAL, INTERVAL].",
  InvalidElseClause: "ELSE clause cannot be used without a WHEN clause.",
  InvalidEndOnWhen: "Cannot end a CASE expression with a WHEN clause. Requires a following THEN clause.",
  InvalidTrimCharacter: "Trim character must be the space character ' '.",
  MismatchedTypes: 'Invalid type mismatch between ${leftValue} (type: "${providedType}") and ${rightValue} (type: "${expectedType}").',
  MissingValueInCaseClause: "Missing value after ${clause} clause in CASE expression.",
  NotCallable: "${expression} is not callable.",
  TypeNotAssignable: "Type ${providedType} is not assignable to type ${expectedType}.",
  "UnexpectedEnd.": "Unexpected end of SQL expression.",
  UnexpectedIdentifier: "Unexpected identifier.",
  UnexpectedNumber: "Unexpected number.",
  UnexpectedTextLiteral: "Unexpected text literal.",
  UnexpectedToken: "Unexpected token ${token}.",
  UnknownField: 'No fields with name "${field}" exists.',
  UnsupportedOperator: "Unsupported SQL operator ${operator}.",
  UnsupportedSyntax: "Unsupported SQL syntax ${syntax}.",
  // TODO: validate message with PE
  InvalidIntervalQualifier: "Invalid interval qualifier. Expected 'YEAR', 'MONTH', 'DAY', 'HOUR', 'MINUTE', 'SECOND'.",
  EmptyCaseExpression: "The CASE expression cannot be empty. Please provide valid conditions and results within the CASE block."
}, tr = (t, e) => {
  const r = H8[t];
  return e && "minParams" in e && "maxParams" in e && (e.formatMinMaxParams = q8(
    e.minParams,
    e.maxParams
  )), e ? r.replace(/\${(.*?)}/g, (n, s) => e[s]?.toString() ?? "") : r;
};
var Ei = /* @__PURE__ */ ((t) => (t.CASE = "CASE", t.CASE_ELSE = "ELSE", t.CASE_THEN = "THEN", t.CASE_WHEN = "WHEN", t.COMMA = ",", t.DOUBLE_QUOTE = '"', t.EMPTY = "", t.END = "END", t.INTERVAL = "INTERVAL", t.LEFT_PARENTHESES = "(", t.NEW_LINE = `
`, t.RIGHT_PARENTHESES = ")", t.SINGLE_QUOTE = "'", t.WHITE_SPACE = " ", t))(Ei || {}), Nn = /* @__PURE__ */ ((t) => (t.BOOLEAN = "BOOLEAN", t.DOUBLE = "DOUBLE", t.EXPRESSION_LIST = "EXPRESSION-LIST", t.FLOAT = "FLOAT", t.INTEGER = "INTEGER", t.NULL = "NULL", t.NUMBER = "NUMBER", t.REAL = "REAL", t.STRING = "STRING", t.SMALL_INT = "SMALLINT", t.UNKNOWN_FUNCTION = "UNKNOWN_FUNCTION", t))(Nn || {});
const Y8 = /\d+/u, rg = [
  "string",
  "number",
  "integer",
  "smallint",
  "float",
  "real",
  "date",
  "time",
  "timestamp",
  "current-time",
  "column-reference"
];
function Z8(t, e) {
  return Object.values(t).includes(e) ? e : void 0;
}
const X8 = (t) => {
  switch (t.operator) {
    case "AND":
    case "OR":
    case "IS":
    case "ISNOT":
    case "IN":
    case "NOT IN":
    case "BETWEEN":
    case "NOTBETWEEN":
    case "LIKE":
    case "NOT LIKE":
    case "<>":
    case "<":
    case ">":
    case ">=":
    case "<=":
    case "=":
      return "boolean";
    case "*":
    case "-":
    case "+":
    case "/":
      return "number";
    case "||":
      return "string";
  }
}, J8 = (t) => {
  switch (t.type) {
    case "number":
      return "number";
    case "text":
      return "string";
    case "dateOnly":
    case "date":
      return "date";
    case "time":
      return "time";
    case "boolean":
      return "boolean";
    default:
      return console.error(`sql-expr validator experienced an unexpected variable type: ${t.type}`), "null";
  }
}, Jn = (t, e) => {
  if (t.type === "function" && t.name.toLowerCase() === "nullif")
    return t.args?.value?.[0] ? Jn(t.args.value[0], e) : "null";
  switch (t.type) {
    case "interval":
    case "interval-period":
    case "interval-qualifier":
    case "when-clause":
    case "case-expression":
    /* Currently no support for parameter type (@) */
    // eslint-disable-next-line no-fallthrough
    case "parameter":
    case "expression-list":
      return t.type;
    case "unary-expression":
      return "boolean";
    case "binary-expression":
      return X8(t);
    case "null":
    case "boolean":
    case "string":
    case "timestamp":
    case "date":
    case "time":
    case "number":
    case "current-time":
    case "data-type":
      return t.type;
    case "column-reference":
      {
        const r = e.find((n) => n.name === t.column);
        if (r)
          return J8(r);
      }
      return t.type;
    case "current-user":
      return "string";
    case "function":
      switch (t.name.toLowerCase()) {
        case "cast": {
          if (t.args?.value?.[1]?.type !== "data-type")
            throw Error("Invalid cast function");
          switch (t.args?.value?.[1]?.value?.type) {
            case "integer":
            case "smallint":
              return "integer";
            case "real":
            case "float":
              return "float";
            case "date":
            case "timestamp":
              return "timestamp";
            case "time":
              return "time-only";
            case "varchar":
              return "string";
          }
        }
        // eslint-disable-next-line no-fallthrough
        case "position":
        case "extract":
        case "char_length":
        case "mod":
          return "integer";
        case "round":
          return "float";
        case "sign":
          return "integer";
        case "ceiling":
        case "floor":
        case "abs":
          return "float";
        case "area":
        case "length":
        case "log":
        case "log10":
        case "sin":
        case "cos":
        case "tan":
        case "asin":
        case "acos":
        case "atan":
        case "cosh":
        case "sinh":
        case "tanh":
        case "power":
        case "truncate":
          return "float";
        case "substring":
        case "trim":
        case "concat":
        case "lower":
        case "upper":
          return "string";
        case "current_date":
        case "current_time":
        case "current_timestamp":
          return "date";
        default:
          return "unknown_function";
      }
  }
}, Co = (t) => {
  switch (t.toLowerCase()) {
    case "integer":
    case "double":
    case "number":
    case "smallint":
    case "float":
    case "real":
    case "timestamp":
    case "date":
    case "time":
    case "current-time":
    case "date-only":
    case "interval":
      return !0;
    default:
      return !1;
  }
}, ng = (t, e, r) => {
  const n = Jn(t, r), s = Jn(e, r), i = [
    "date",
    "timestamp",
    "time",
    "current-time",
    "number",
    "integer",
    "float",
    "real"
  ], u = /* @__PURE__ */ new Set([n, s]);
  return !!(u.size === 2 && u.has("interval") && i.some((l) => u.has(l)));
}, m_ = (t) => {
  switch (t.toLowerCase()) {
    case "integer":
    case "double":
    case "number":
    /* These three may not even be required */
    // eslint-disable-next-line no-fallthrough
    case "smallint":
    case "float":
    case "real":
      return !0;
    default:
      return !1;
  }
}, sg = (t, e) => {
  const r = Z8(Ei, e) === "," ? ", " : " | ";
  return t.map((n) => `"${n.toLowerCase()}"`).sort().join(r);
}, Zr = (t) => (
  /*
      When we display our validation markers for type suggestions, we want
      to let users know when we are referring to a type when we use double quotes.
      We could also utilize single quotes if we prefer.
  
      e.g. 'Type "string"' instead of 'Type string'
    */
  `"${t}"`
), ms = (t) => {
  switch (t.type) {
    case "interval-qualifier":
    case "interval":
      return "INTERVAL";
    case "when-clause":
      return "WHEN_CLAUSE";
    case "case-expression":
      return "CASE_EXPRESSION";
    case "unary-expression":
      return "UNARY_EXPRESSION";
    case "expression-list":
      return "EXPRESSION_LIST";
    case "binary-expression":
      return "BINARY_EXPRESSION";
    case "current-user":
      return "CURRENT_USER";
    case "current-time":
      return Zr(t.mode);
    case "interval-period":
      return Zr(t.period);
    case "null":
      return Zr("null");
    case "column-reference":
      return Zr(t.column);
    case "number":
      return t.value;
    case "function":
      return Zr(`${t.name}()`);
    case "data-type":
      return Zr(t.type);
    case "boolean":
    case "date":
    case "parameter":
    case "time":
    case "timestamp":
    case "string":
      return Zr(String(t.value));
  }
}, Ut = (t, e, r, n) => {
  if (n) {
    const s = e, i = {
      startColumn: s.start.column,
      endColumn: s.end.column,
      startLineNumber: s.start.line,
      endLineNumber: s.end.line
    };
    r.some(
      (l) => l.message === t && l.startColumn === i.startColumn && l.startLineNumber === i.startLineNumber && l.endColumn === i.endColumn && l.endLineNumber === i.endLineNumber
    ) || r.push({ message: t, severity: tg.Error, ...i });
  } else {
    const s = e;
    r.some(
      (u) => u.message === t && u.startColumn === s.startColumn && u.startLineNumber === s.startLineNumber && u.endColumn === s.endColumn && u.endLineNumber === s.endLineNumber
    ) || r.push({ message: t, severity: tg.Error, ...s });
  }
}, Gn = (t, e, r, n) => {
  const s = Jn(t, n);
  let i = s.toUpperCase() === e;
  if (e === "NUMBER" && (i = m_(s)), !i) {
    const u = tr(Yt.TypeNotAssignable, {
      providedType: Zr(s),
      expectedType: Zr(e.toLowerCase())
    });
    Ut(u, t.location, r, !0);
  }
}, p_ = (t) => t.variables ? t.variables.find(
  (r) => r.name === "$layer" && r.type === "dictionary"
)?.properties ?? [] : [];
let Jf;
async function Q8() {
  return Jf == null && (Jf = Promise.resolve().then(function() {
    return rT;
  }).then((t) => new t.WhereClauseCache(500, 500))), Jf;
}
async function g_(t, e) {
  const r = await Q8(), n = r.get(t, e);
  if (n == null) throw r.getError(t, e);
  return n;
}
const ig = {
  "[ \\t\\n\\r]": "WHITESPACE",
  "[*/]": "MULTIPLICATION (*) OR DIVISION (/)",
  "[+\\-]": "ADDITION (+) OR SUBTRACTION (-)",
  "[<-=]": "LESS THAN (<) OR LESS THAN OR EQUAL TO (<=)",
  "[A-Za-z0-9_.\\\\x80-￿]": "ALPHANUMERIC, UNDERSCORE, DOT, OR EXTENDED ASCII",
  "[A-Za-z0-9_]": "ALPHANUMERIC OR UNDERSCORE"
}, __ = /* @__PURE__ */ new Set([
  // returned in EXTRACT suggestions but not supported in field calc
  "TIMEZONE_HOUR",
  // returned in EXTRACT suggestions but not supported in field calc
  "TIMEZONE_MINUTE",
  // determined to be a unhelpful suggestion
  "WHITESPACE",
  // INT is supported in CAST due to legacy support, but we don't want to suggest it
  "INT"
]);
function y_(t) {
  return !(t instanceof Error && (!("location" in t) || !("format" in t)));
}
function K8(t) {
  return /^Expected "\S+"/u.test(t.message);
}
function e7(t) {
  return t.message.match(/Expected (?<expectedToken>.*) but/u)?.groups?.expectedToken?.split(", ").reduce((e, r, n, s) => (n === s.length - 1 && r.startsWith("or ") && (r = r.slice(3)), r = r.replace(/^"|"$/gu, ""), r in ig && (r = ig[r]), __.has(r) || e.push(r), e), []);
}
function t7(t) {
  if (t.message.match(/but end of input found/u))
    return "Invalid syntax: unexpected end of SQL Expression.";
  const r = t.message.match(/but (?<unexpectedToken>.*) found/u)?.groups?.unexpectedToken, n = e7(t)?.map((s) => `• ${s}`).join(`
`);
  return r ? `Invalid syntax: unexpected token ${r}.${n ? `
Expected one of the following:
${n}` : ""}` : "Invalid syntax.";
}
function r7(t) {
  if ("expected" in t && Array.isArray(t.expected)) {
    const e = t, r = /* @__PURE__ */ new Set();
    return e.expected.filter((s) => s.type === "literal").reduce((s, i) => (!r.has(i.text) && !__.has(i.text) && (r.add(i.text), W8.includes(i.text) ? s.push({ category: "keywords", text: i.text }) : G8.includes(i.text) ? s.push({ category: "operators", text: i.text }) : B8.includes(i.text) && s.push({ category: "functions", text: i.text })), s), []);
  }
  return [];
}
const b_ = -2;
function n7(t, e) {
  if (!Object.values(We).includes(e.type))
    return -1;
  switch (e.type) {
    case We.CASE_EXPRESSION:
      return Vt.ELSE;
    case We.WHEN_CLAUSE:
      return t === e.operand ? Vt.OPERAND : t === e.value ? Vt.VALUE : -1;
    case We.UNARY_EXPRESSION:
      return Vt.EXPR;
    case We.BINARY_EXPRESSION:
      return t === e.left ? Vt.LEFT : t === e.right ? Vt.RIGHT : -1;
    case We.FUNCTION:
      return e.args.value.findIndex((r) => r === t);
    case We.INTERVAL:
      return t === e.value ? Vt.VALUE : t === e.qualifier ? Vt.QUALIFIER : -1;
    case We.INTERVAL_QUALIFIER:
      return t === e.start ? Vt.START : t === e.end ? Vt.END : -1;
    case We.EXPRESSION_LIST:
      return Vt.VALUE;
    default:
      return -1;
  }
}
const s7 = [
  "boolean",
  "column-reference",
  "current-time",
  "data-type",
  "date",
  // I know expression-list is not like the others here, but it is indeed terminal in our context
  "expression-list",
  "interval-period",
  "interval-qualifier",
  "null",
  "number",
  "parameter",
  "string",
  "time",
  "timestamp"
];
function w_(t, e) {
  let r = t;
  return s7.includes(r.type) && e.length > 1 ? (r = e.at(b_), e.pop(), w_(r, e)) : r;
}
function i7(t) {
  const e = [];
  for (let r = 0; r < t.length; r++)
    t[r] === "(" ? e.push(r) : t[r] === ")" && e.length > 0 && e.pop();
  for (; e.length > 0; )
    t += ")", e.pop();
  return t;
}
const o7 = ["+", "-", "*", "/", "||"], a7 = [
  // [(string or number), data-type]
  "cast",
  // [interval-period, date]
  "extract",
  // [string, number, number]
  "substring",
  // [null, string, string]
  "coalesce"
];
class u7 {
  // #endregion
  constructor(e, r) {
    this.callStack = [], this._fields = [], this.markers = [], this._sdkFunctions = e.flatMap((n) => n.items), this._fields = r.profile ? p_(r.profile) : [];
  }
  // #region Public Methods
  /**
   * validates the SQL Expression by generating an AST and traversing it
   * @param modelContent The SQL Expression to validate
   */
  async validateModel(e) {
    try {
      const { parseTree: r } = await g_(e, void 0);
      this.traverse(r);
    } catch (r) {
      this._handleParserFailure(r, e);
    }
  }
  /**
   * a DFS traversal of the SQL Expression AST
   * @param node The node to traverse, start with the root node
   */
  traverse(e) {
    this.callStack.push(e), this._validateNode(e), this._traverseChildren(e), this.callStack.pop();
  }
  // #endregion
  // #region Private Methods
  /**
   * Validates a nodes syntax and types
   * @param node The node to validate
   */
  _validateNode(e) {
    if (e)
      switch (e.type) {
        // example: INTERVAL '1' DAY
        case "interval": {
          const r = e.value.value;
          if (!Y8.test(r) || e.value.type !== "string") {
            const n = tr(Yt.ExpectedNumericalLiteral), s = this._getRange(e.value);
            Ut(n, s, this.markers);
            return;
          }
          return;
        }
        // example: DAY
        case "interval-period":
          return;
        // example: INTERVAL '1' DAY TO SECOND
        case "interval-qualifier":
          return;
        // example: CASE WHEN 1 = 1 THEN 1 ELSE 2 END
        case "case-expression":
          if (e.clauses.length === 0) {
            if (e.else) {
              const s = tr(Yt.InvalidElseClause), i = {
                startLineNumber: e.elseLocation?.start.line ?? e.else.location.start.line,
                endLineNumber: e.elseLocation?.end.line ?? e.else.location.end.line,
                startColumn: e.elseLocation?.start.column ?? e.else.location.start.column,
                endColumn: e.elseLocation?.end.column ?? e.else.location.end.column
              };
              Ut(s, i, this.markers);
              return;
            }
            const r = tr(Yt.EmptyCaseExpression), n = {
              startLineNumber: e.location.start.line,
              endLineNumber: e.location.end.line,
              startColumn: e.location.start.column,
              endColumn: e.location.end.column
            };
            Ut(r, n, this.markers);
            return;
          }
          return;
        case "parameter":
          return;
        // example: CAST("Address" AS VARCHAR(255)), where "Address" is the column-reference
        case "column-reference": {
          if (Object.values(Ei).map((n) => n.toLowerCase()).includes(e.column.toLowerCase()))
            return;
          if (!this._fields.find((n) => n.name === e.column)) {
            const n = tr(Yt.UnknownField, {
              field: e.column
            });
            Ut(n, e.location, this.markers, !0);
          }
          return;
        }
        // example: COALESCE('1', '2','3'), where '1', '2', '3' are the expression-list
        case "expression-list": {
          const r = e.value, n = /* @__PURE__ */ new Set(), s = this.callStack.at(b_);
          if (s?.type === "function" && a7.includes(s?.name?.toLowerCase()))
            return;
          if (r.forEach((i) => {
            let u = Jn(i, this._fields);
            if (u !== "column-reference" && u !== "time-only") {
              if (u === "unknown_function") {
                const l = tr(Yt.FunctionNotSupported, {
                  function: i.name
                });
                Ut(l, i.location, this.markers, !0);
                return;
              }
              m_(u) && (u = "number"), n.has(u) || n.add(u);
            }
          }), n.size > 1) {
            const i = Array.from(n), u = tr(Yt.IncompatibleListDataType, {
              types: sg(i, Ei.COMMA)
            });
            Ut(u, e.location, this.markers, !0);
          }
          return;
        }
        // example: 2 + 2
        case "binary-expression": {
          const r = this.callStack.length === 1, n = e.left, s = e.right, i = Jn(n, this._fields), u = Jn(s, this._fields);
          if (r && !o7.includes(e.operator)) {
            const l = `Cannot perform binary operation '${e.operator}' at root node.`;
            Ut(l, e.location, this.markers, !0);
            return;
          }
          switch (e.operator) {
            // we use "as" here to satisfy the switch statements typing
            // logical operators
            case "AND":
            case "OR":
              Gn(n, Nn.BOOLEAN, this.markers, this._fields), Gn(s, Nn.BOOLEAN, this.markers, this._fields);
              break;
            // null comparison operators
            case "IS":
            case "ISNOT":
              Gn(s, Nn.NULL, this.markers, this._fields);
              break;
            // set comparison operators
            case "IN":
            case "NOT IN":
            case "BETWEEN":
            case "NOTBETWEEN":
              Gn(s, Nn.EXPRESSION_LIST, this.markers, this._fields);
              break;
            // string comparison operators
            case "LIKE":
            case "NOT LIKE":
              Gn(s, Nn.STRING, this.markers, this._fields);
              break;
            // Comparison operators
            case "<>":
            case "<":
            case ">":
            case ">=":
            case "<=":
            case "=": {
              if (!rg.includes(u)) {
                const c = tr(Yt.TypeNotAssignable, {
                  providedType: Zr(u),
                  expectedType: sg(rg, Ei.COMMA)
                });
                Ut(c, s.location, this.markers, !0);
              }
              const l = Co(i) && Co(u);
              if (i !== u && !l) {
                const c = tr(Yt.MismatchedTypes, {
                  leftValue: ms(n),
                  providedType: i,
                  rightValue: ms(s),
                  expectedType: u
                });
                Ut(c, e.location, this.markers, !0);
              }
              break;
            }
            // arithmetic operations
            case "*":
            case "-":
            case "+":
            case "/":
              if (!Co(i) || !Co(u)) {
                const l = tr(Yt.MismatchedTypes, {
                  leftValue: ms(n),
                  providedType: i,
                  rightValue: ms(s),
                  expectedType: u
                });
                Ut(l, e.location, this.markers, !0);
              }
              if (i !== u && !ng(n, s, this._fields)) {
                const l = tr(Yt.MismatchedTypes, {
                  leftValue: ms(n),
                  providedType: i,
                  rightValue: ms(s),
                  expectedType: u
                });
                Ut(l, e.location, this.markers, !0);
              }
              if ([i, u].every((l) => l === "date") && !ng(n, s, this._fields)) {
                const l = tr(Yt.InvalidDateArithmetic);
                Ut(l, e.location, this.markers, !0);
              }
              break;
            // string concatenation
            case "||":
              Gn(n, Nn.STRING, this.markers, this._fields), Gn(s, Nn.STRING, this.markers, this._fields);
              break;
          }
          return;
        }
        // example: CAST(2 AS INTEGER)
        case "function":
          {
            const r = this._getFunction(e.name);
            if (!r || // these keywords are not valid as "functions" in SQL expressions
            // they are still parsed in the AST, so we invalidate them here.
            ["CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER"].includes(e.name.toUpperCase())) {
              const n = tr(Yt.FunctionNotSupported, {
                function: e.name
              });
              Ut(n, e.location, this.markers, !0);
              return;
            }
            if (r.type === "function") {
              const { min: n, max: s } = r.parametersInfo, {
                args: { value: i }
              } = e, u = i.length;
              if (u < n || s !== -1 && u > s) {
                const l = tr(Yt.IncorrectArgumentLength, {
                  minParams: n,
                  maxParams: s,
                  numArgs: u
                });
                Ut(l, e.location, this.markers);
              }
            }
          }
          return;
        case "null":
        case "boolean":
        case "string":
        case "timestamp":
        case "date":
        case "time":
        case "number":
        case "current-time":
          return;
        case "data-type":
          return;
        case "unary-expression":
          console.warn("Unexpected unary expression found.");
          return;
        case "when-clause":
          return;
      }
  }
  _handleParserFailure(e, r) {
    if (!y_(e))
      throw e;
    if (r.trim() === "") {
      this.markers = [];
      return;
    }
    const n = e;
    let s = n.message;
    K8(n) && (s = t7(n));
    const i = {
      startLineNumber: n.location.start.line,
      endLineNumber: n.location.end.line,
      startColumn: n.location.start.column,
      endColumn: n.location.end.column
    };
    Ut(s, i, this.markers);
  }
  /**
   * Formats a node's range into a Monaco IRange object.
   * @param node
   */
  _getRange(e) {
    return {
      startLineNumber: e.location.start.line,
      endLineNumber: e.location.end.line,
      startColumn: e.location.start.column,
      endColumn: e.location.end.column
    };
  }
  /**
   * finds the function in the SDK library.
   * @param name name of the function
   */
  _getFunction(e) {
    return this._sdkFunctions.find((r) => r.name.toLowerCase() === e.toLowerCase());
  }
  /**
   * looks at the node and finds any children attached to it. If there are children, it will traverse them.
   * @param node The current node to traverse
   */
  _traverseChildren(e) {
    if (e)
      switch (e.type) {
        case We.CASE_EXPRESSION:
          {
            const r = zt[e.type];
            e.format === "simple" ? r.forEach((n) => {
              const s = e[n];
              s && (Array.isArray(s) ? s.forEach((i) => {
                this.traverse(i);
              }) : this.traverse(s));
            }) : e.format === "searched" && r.forEach((n) => {
              if (n === Vt.OPERAND)
                return;
              const s = e[n];
              s && (Array.isArray(s) ? s.forEach((i) => {
                this.traverse(i);
              }) : this.traverse(s));
            });
          }
          break;
        case We.WHEN_CLAUSE:
          zt[e.type].forEach((n) => {
            const s = e[n];
            this.traverse(s);
          });
          break;
        case We.EXPRESSION_LIST:
          zt[e.type].forEach((n) => {
            const s = e[n];
            Array.isArray(s) ? s.forEach((i) => {
              this.traverse(i);
            }) : this.traverse(s);
          });
          break;
        case We.UNARY_EXPRESSION:
          zt[e.type].forEach((n) => {
            const s = e[n];
            Array.isArray(s) && this.traverse(s);
          });
          break;
        case We.BINARY_EXPRESSION:
          zt[e.type].forEach((n) => {
            const s = e[n];
            this.traverse(s);
          });
          break;
        case We.FUNCTION:
          zt[e.type].forEach((n) => {
            const s = e[n];
            this.traverse(s);
          });
          break;
        case We.INTERVAL:
          zt[e.type].forEach((n) => {
            const s = e[n];
            this.traverse(s);
          });
          break;
        case We.INTERVAL_QUALIFIER:
          zt[e.type].forEach((n) => {
            const s = e[n];
            this.traverse(s);
          });
          break;
      }
  }
  // #endregion
}
const Kt = {
  identifiers: "a",
  profileVariables: "aa",
  constants: "ab",
  literals: "ab",
  functions: "ac",
  operators: "ad",
  snippets: "b",
  keywords: "c"
};
function l7(t) {
  switch (t) {
    case "functions":
      return Dt.Function;
    case "keywords":
      return Dt.Keyword;
    case "operators":
      return Dt.Operator;
  }
}
class c7 {
  // #endregion
  constructor(e, r) {
    this._fields = [], this._sdkFunctions = e, this._fields = r;
  }
  // #region public methods
  /**
   * gets completions for the sql expression.
   * @param {Object} params - The parameters for the completion.
   * @param {IRange} params.range - The range of the current position.
   * @param {string} params.modelContent - The content of the model.
   * @param {Position} params.position - The current position of the cursor in the model.
   * @param {ICompletionContext} params.completionContext - The completion context.
   * @param {boolean} params.terminateOnError - Whether to terminate the completion when it fails to parse.
   * @returns {Promise<languages.CompletionItem[]>} The completion items.
   */
  async getCompletions({
    range: e,
    modelContent: r,
    position: n,
    completionContext: s,
    terminateOnError: i = !1
  }) {
    if (s ??= {
      range: e,
      modelContent: r,
      position: n,
      lowestNode: void 0,
      subTree: [],
      completionItems: []
    }, r.length === 0 || r.trim().length === 0)
      return this._suggestFields(s), this._suggestFunctions(s), this._suggestExpressions(s), this._suggestDateLiterals(s), s.completionItems;
    try {
      const { parseTree: u } = await g_(r, void 0);
      return this.traverse(u, s), this._getCompletions(s), s.completionItems;
    } catch (u) {
      return i ? [] : await this.handleParserFailure(u, n, e, s);
    }
  }
  /**
   * traverses the tree to find the node that contains the current position
   * @param node The current node to traverse
   * @param position The current position
   */
  traverse(e, r) {
    const { position: n, subTree: s } = r;
    this._isPositionWithinNode(e, n) && (s.push(e), r.lowestNode = e, this._traverseChildren(e, r));
  }
  // #endregion
  // #region private methods
  /**
   * gets completions by finding the context of the current node and suggesting completions based on that context
   */
  _getCompletions(e) {
    const { range: r, lowestNode: n, subTree: s } = e;
    if (!n)
      return [];
    const i = w_(n, s);
    if (!i)
      return [];
    const u = n7(n, i);
    switch (i.type) {
      case "case-expression":
        i.else || e.completionItems.push({
          label: "ELSE",
          kind: Dt.Keyword,
          insertText: "ELSE",
          sortText: "a",
          range: r
        });
        break;
      case "column-reference":
        this._suggestFields(e), this._suggestFunctions(e), this._suggestExpressions(e), this._suggestDateLiterals(e);
        break;
      case "function":
        this._getCompletionsFromFunction(i, u, e);
        break;
      case "interval":
        if (u === Vt.QUALIFIER) {
          this._suggestDatePeriods(e);
          break;
        } else if (u === Vt.VALUE)
          break;
        break;
      case "binary-expression":
        this._suggestFields(e), this._suggestFunctions(e);
        break;
    }
    return e.completionItems;
  }
  /**
   * utilizes peggy's error handling to provide suggestions for the user.
   */
  async handleParserFailure(e, r, n, s) {
    if (!y_(e))
      return s.completionItems;
    if (!this._isPositionWithinSQLSourcePosition(r, e.location)) {
      const u = this._sliceToPosition(r, s.modelContent), l = i7(u);
      return await this.getCompletions({
        range: n,
        modelContent: l,
        position: r,
        completionContext: s,
        // we will try parsing again, but if it fails, we will terminate the completion and return an empty array
        terminateOnError: !0
      });
    }
    return r7(e).forEach((u) => {
      s.completionItems.push({
        label: u.text,
        kind: l7(u.category),
        insertText: u.text,
        sortText: Kt[u.category],
        range: n
      });
    }), s.completionItems;
  }
  /**
   * gets completions based on the function node
   * @param context the context root of the current node, see {@link identifyContextRoot}
   * @param slotPosition the position of the current node in the context root, see {@link getSlotPosition}
   * @param completionContext the completion context
   */
  _getCompletionsFromFunction(e, r, n) {
    const { range: s } = n;
    switch (e.name.toUpperCase()) {
      case "CAST":
        r === 0 ? (this._suggestFields(n), this._suggestDateFunctions(n)) : r === 1 ? this._suggestDataTypes(n) : e.args.value.length && r === -1 ? n.completionItems.push({
          label: "AS",
          kind: Dt.Keyword,
          insertText: "AS",
          sortText: Kt.keywords,
          range: s
        }) : this._suggestFields(n);
        break;
      case "EXTRACT":
        r === 0 ? this._suggestDatePeriods(n, !0) : r === 1 ? (this._suggestFields(n), this._suggestDateLiterals(n), this._suggestDateFunctions(n)) : e.args.value.length && r === -1 ? n.completionItems.push({
          label: "FROM",
          kind: Dt.Keyword,
          insertText: "FROM",
          sortText: Kt.keywords,
          range: s
        }) : this._suggestDatePeriods(n, !0);
        break;
      case "TRIM":
        r === 0 ? this._suggestTrimParts(n) : r === 1 ? this._suggestTrimParts(n) : r === 2 ? this._suggestFields(n) : e.args.value.length && r === -1 ? n.completionItems.push({
          label: "FROM",
          kind: Dt.Keyword,
          insertText: "FROM",
          sortText: Kt.keywords,
          range: s
        }) : this._suggestTrimParts(n);
        break;
      case "COALESCE":
        this._suggestFields(n), this._suggestNull(n);
        break;
      case "CONCAT":
        this._suggestFields(n), this._suggestCurrentUser(n);
        break;
      case "POSITION":
        r === 1 && this._suggestFields(n);
        break;
      // simple string and numeric functions, suggest fields
      case "ABS":
      case "ACOS":
      case "ASIN":
      case "ATAN":
      case "CEILING":
      case "CHAR_LENGTH":
      case "COS":
      case "FLOOR":
      case "LOG":
      case "LOG10":
      case "MOD":
      case "NULLIF":
      case "POWER":
      case "ROUND":
      case "SIGN":
      case "SIN":
      case "SUBSTRING":
      case "TAN":
      case "TRUNCATE":
      case "LOWER":
      case "UPPER":
        this._suggestFields(n);
        break;
    }
  }
  /**
   * checks if the position is within the current node
   * @param node The current node to check
   * @param position The current position
   * @returns boolean
   */
  _isPositionWithinNode(e, r) {
    if (!e)
      return !1;
    const { start: n, end: s } = e.location;
    return !(r.lineNumber < n.line || r.lineNumber > s.line || r.lineNumber === n.line && r.column < n.column || r.lineNumber === s.line && r.column > s.column);
  }
  _isPositionWithinSQLSourcePosition(e, r) {
    const { start: n, end: s } = r;
    return !(e.lineNumber < n.line || e.lineNumber > s.line || e.lineNumber === n.line && e.column < n.column || e.lineNumber === s.line && e.column > s.column);
  }
  _suggestFields(e) {
    const { range: r } = e;
    this._fields.forEach((n) => {
      e.completionItems.push({
        label: n.name,
        kind: Dt.Field,
        insertText: n.name,
        documentation: n.completion?.documentation,
        detail: n.completion?.detail,
        sortText: Kt.profileVariables,
        range: r
      });
    });
  }
  _suggestFunctions(e) {
    const { range: r } = e;
    this._sdkFunctions.functionDefinitions.forEach((n) => {
      const { overloads: s } = n;
      s.forEach((i) => {
        e.completionItems.push({
          label: i.completion.label,
          kind: Dt.Function,
          insertText: i.completion.insertText || i.completion.label,
          insertTextRules: Oo.InsertAsSnippet,
          documentation: i.completion.documentation,
          detail: i.completion.detail,
          sortText: Kt.functions,
          range: r
        });
      });
    });
  }
  _suggestDataTypes(e) {
    const { range: r } = e;
    h_.forEach((n) => {
      e.completionItems.push({
        label: n,
        kind: Dt.Keyword,
        insertText: n,
        sortText: Kt.keywords,
        range: r
      });
    });
  }
  _suggestDatePeriods(e, r = !1) {
    const { range: n } = e;
    [...h0, ...r ? z8 : []].forEach((s) => {
      e.completionItems.push({
        label: s,
        kind: Dt.Keyword,
        insertText: s,
        sortText: Kt.keywords,
        range: n
      });
    });
  }
  _suggestTrimParts(e) {
    const { range: r } = e;
    d_.forEach((n) => {
      e.completionItems.push({
        label: n,
        kind: Dt.Keyword,
        insertText: n,
        sortText: Kt.keywords,
        range: r
      });
    });
  }
  _suggestDateLiterals(e) {
    const { range: r } = e;
    j8.forEach((n) => {
      e.completionItems.push({
        label: n,
        kind: Dt.Keyword,
        insertText: n,
        sortText: Kt.keywords,
        range: r
      });
    });
  }
  _suggestDateFunctions(e) {
    const { range: r } = e;
    this._sdkFunctions.categories.find((s) => s.id === "date_functions")?.items.forEach((s) => {
      const i = s.name, u = this._sdkFunctions.functionDefinitions.get(i);
      if (!u)
        return;
      const { overloads: l } = u;
      l.forEach((c) => {
        e.completionItems.push({
          label: c.completion.label,
          kind: Dt.Function,
          insertText: c.completion.insertText || c.completion.label,
          insertTextRules: Oo.InsertAsSnippet,
          documentation: c.completion.documentation,
          detail: c.completion.detail,
          sortText: Kt.functions,
          range: r
        });
      });
    });
  }
  _suggestExpressions(e) {
    const { range: r } = e;
    e.completionItems.push({
      label: "CASE",
      kind: Dt.Keyword,
      insertText: "CASE\n	WHEN ${1:condition_1_} THEN ${2:result_1_} \n	ELSE ${3:result_2_}\nEND${0}",
      insertTextRules: Oo.InsertAsSnippet,
      sortText: Kt.keywords,
      range: r
    });
  }
  _suggestNull(e) {
    const { range: r } = e;
    e.completionItems.push({
      label: "NULL",
      kind: Dt.Keyword,
      insertText: "NULL",
      sortText: Kt.keywords,
      range: r
    });
  }
  _suggestCurrentUser(e) {
    const { range: r } = e, n = this._sdkFunctions.functionDefinitions.get("current_user");
    if (!n)
      return;
    const { overloads: s } = n;
    s?.forEach((i) => {
      e.completionItems.push({
        label: i.completion.label,
        kind: Dt.Function,
        insertText: i.completion.insertText || i.completion.label,
        insertTextRules: Oo.InsertAsSnippet,
        documentation: i.completion.documentation,
        detail: i.completion.detail,
        sortText: Kt.functions,
        range: r
      });
    });
  }
  /**
   * looks at the node and finds any children attached to it. If there are children, it will traverse them.
   * @param node The current node to traverse
   */
  // TODO refactor traversal to common utils to use in both validation and completion
  _traverseChildren(e, r) {
    if (e)
      switch (e.type) {
        case We.CASE_EXPRESSION:
          {
            const n = zt[e.type];
            e.format === "simple" ? n.forEach((s) => {
              const i = e[s];
              i && (Array.isArray(i) ? i.forEach((u) => {
                this.traverse(u, r);
              }) : this.traverse(i, r));
            }) : e.format === "searched" && n.forEach((s) => {
              if (s === Vt.OPERAND)
                return;
              const i = e[s];
              i && (Array.isArray(i) ? i.forEach((u) => {
                this.traverse(u, r);
              }) : this.traverse(i, r));
            });
          }
          break;
        case We.WHEN_CLAUSE:
          zt[e.type].forEach((s) => {
            const i = e[s];
            this.traverse(i, r);
          });
          break;
        case We.EXPRESSION_LIST:
          zt[e.type].forEach((s) => {
            e[s].forEach((u) => {
              this.traverse(u, r);
            });
          });
          break;
        case We.UNARY_EXPRESSION:
          zt[e.type].forEach((s) => {
            const i = e[s];
            Array.isArray(i) && this.traverse(i, r);
          });
          break;
        case We.BINARY_EXPRESSION:
          zt[e.type].forEach((s) => {
            const i = e[s];
            this.traverse(i, r);
          });
          break;
        case We.FUNCTION:
          zt[e.type].forEach((s) => {
            const i = e[s];
            this.traverse(i, r);
          });
          break;
        case We.INTERVAL:
          zt[e.type].forEach((s) => {
            const i = e[s];
            this.traverse(i, r);
          });
          break;
        case We.INTERVAL_QUALIFIER:
          zt[e.type].forEach((s) => {
            const i = e[s];
            this.traverse(i, r);
          });
          break;
      }
  }
  _sliceToPosition(e, r) {
    const n = r.split(`
`), { lineNumber: s, column: i } = e;
    if (s < 1 || s > n.length)
      throw new Error("Line number out of bounds");
    const u = n[s - 1];
    if (u === void 0)
      throw new Error("Line is undefined");
    if (i < 1 || i > u.length + 1)
      throw new Error("Column out of bounds");
    const l = n.slice(0, s);
    return l[l.length - 1] = u.slice(0, i - 1), l.join(`
`);
  }
  // #endregion
}
globalThis.onmessage = () => {
  u_((t, e) => new f7(t, e));
};
class f7 {
  constructor(e, { languageId: r }) {
    this._ctx = e, this._languageId = r, this._apiService = new U8({ getApiLibrary: this._ctx.host.getApiLibrary });
  }
  async doValidation(e, r) {
    const n = this._getTextDocument(e);
    if (!n)
      return await Promise.resolve([]);
    const s = await this.getApiLibrary(r), i = new u7(s, r);
    return await i.validateModel(n.getText()), await Promise.resolve(i.markers);
  }
  // Note: the return type deviates from arcade. here were turn languages.completionList instead of CompletionList from "vscode-languageserver-types"
  async doComplete(e, r, n, s) {
    const i = this._getTextDocument(e);
    if (!i)
      return await Promise.resolve({ suggestions: [] });
    const u = i.getText(), l = await this.getApiDatabase(s), c = s.profile ? p_(s.profile) : [], _ = await new c7(l, c).getCompletions({ range: r, modelContent: u, position: n });
    return await Promise.resolve({ suggestions: _ });
  }
  // async doFormat(modelId: string /*context: ApiContext*/): Promise<TextEdit[]> {
  //   const document = this._getTextDocument(modelId);
  //   if (!document) {
  //     return await Promise.resolve([]);
  //   }
  //   // const edits = arcadeFormat(document, context);
  //   return await Promise.resolve([document]);
  // }
  async getApiLibrary(e) {
    return await this._apiService.getApiLibrary(e);
  }
  async getApiDatabase(e) {
    return await this._apiService.getApiDatabase(e);
  }
  _getTextDocument(e) {
    const r = this._ctx.getMirrorModels();
    for (const n of r)
      if (n.uri.toString() === e)
        return X1.create(e, this._languageId, n.version, n.getValue());
    return null;
  }
}
let Mn;
const kt = globalThis;
function F(t) {
  return typeof Mn[t] == "function" ? Mn[t] = Mn[t](kt) : Mn[t];
}
Mn = kt.dojoConfig?.has || kt.esriConfig?.has ? { ...kt.dojoConfig?.has, ...kt.esriConfig?.has } : {}, F.add = (t, e, r, n) => {
  (n || Mn[t] === void 0) && (Mn[t] = e), r && F(t);
}, F.cache = Mn, F.add("big-integer-warning-enabled", !0), F.add("esri-deprecation-warnings", !0), F.add("esri-tests-disable-screenshots", !1), F.add("esri-tests-use-full-window", !1), F.add("esri-tests-post-to-influx", !0), F.add("esri-cim-animations-enable-status", "enabled"), F.add("esri-cim-animations-spotlight", !1), F.add("esri-cim-animations-freeze-time", !1), (() => {
  F.add("host-webworker", kt.WorkerGlobalScope !== void 0 && self instanceof kt.WorkerGlobalScope);
  const t = typeof window < "u" && typeof location < "u" && typeof document < "u" && window.location === location && window.document === document;
  if (F.add("host-browser", t), F.add("host-node", !(typeof kt.process != "object" || !kt.process.versions?.node || !kt.process.versions.v8)), F.add("dom", t), F("host-browser")) {
    const e = navigator, r = e.userAgent, n = e.appVersion, s = parseFloat(n);
    if (F.add("wp", parseFloat(r.split("Windows Phone")[1]) || void 0), F.add("msapp", parseFloat(r.split("MSAppHost/")[1]) || void 0), F.add("khtml", n.includes("Konqueror") ? s : void 0), F.add("edge", parseFloat(r.split("Edge/")[1]) || void 0), F.add("opr", parseFloat(r.split("OPR/")[1]) || void 0), F.add("webkit", !F("wp") && !F("edge") && parseFloat(r.split("WebKit/")[1]) || void 0), F.add("chrome", !F("edge") && !F("opr") && parseFloat(r.split("Chrome/")[1]) || void 0), F.add("android", !F("wp") && parseFloat(r.split("Android ")[1]) || void 0), F.add("safari", !n.includes("Safari") || F("wp") || F("chrome") || F("android") || F("edge") || F("opr") ? void 0 : parseFloat(n.split("Version/")[1])), F.add("mac", n.includes("Macintosh")), !F("wp") && /(iPhone|iPod|iPad)/.test(r)) {
      const i = RegExp.$1.replace(/P/, "p"), u = /OS ([\d_]+)/.test(r) ? RegExp.$1 : "1", l = parseFloat(u.replace(/_/, ".").replaceAll("_", ""));
      F.add(i, l), F.add("ios", l);
    }
    F("webkit") || (!r.includes("Gecko") || F("wp") || F("khtml") || F("edge") || F.add("mozilla", s), F("mozilla") && F.add("ff", parseFloat(r.split("Firefox/")[1] || r.split("Minefield/")[1]) || void 0));
  }
})(), (() => {
  if (kt.navigator) {
    const t = navigator.userAgent, e = /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini|IEMobile/i.test(t), r = /iPhone/i.test(t);
    e && F.add("esri-mobile", e), r && F.add("esri-iPhone", r), F.add("esri-geolocation", !!navigator.geolocation);
  }
  F.add("esri-wasm", "WebAssembly" in kt), F.add("esri-performance-mode-frames-between-render", 20), F.add("esri-force-performance-mode", !1), F.add("esri-shared-array-buffer", () => {
    const t = "SharedArrayBuffer" in kt, e = kt.crossOriginIsolated === !1;
    return t && !e;
  }), F.add("wasm-simd", () => {
    const t = [0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11];
    return WebAssembly.validate(new Uint8Array(t));
  }), F.add("esri-atomics", "Atomics" in kt), F.add("esri-workers", "Worker" in kt), F.add("web-feat:cache", "caches" in kt), F.add("esri-workers-arraybuffer-transfer", !F("safari") || Number(F("safari")) >= 12), F.add("workers-pool-size", 8), F.add("featurelayer-simplify-thresholds", [0.5, 0.5, 0.5, 0.5]), F.add("featurelayer-simplify-payload-size-factors", [1, 1, 4]), F.add("featurelayer-fast-triangulation-enabled", !0), F.add("featurelayer-animation-enabled", !0), F.add("featurelayer-snapshot-enabled", !0), F.add("featurelayer-snapshot-initial-tolerance", 0), F.add("featurelayer-snapshot-point-min-threshold", 8e4), F.add("featurelayer-snapshot-point-max-threshold", 4e5), F.add("featurelayer-snapshot-multipoint-min-threshold", 2e4), F.add("featurelayer-snapshot-multipoint-max-threshold", 1e5), F.add("featurelayer-snapshot-polygon-min-threshold", 2e3), F.add("featurelayer-snapshot-polygon-max-threshold", 2e3), F.add("featurelayer-snapshot-polyline-min-threshold", 2e3), F.add("featurelayer-snapshot-polyline-max-threshold", 2e3), F.add("featurelayer-snapshot-max-vertex-count", 25e4), F.add("featurelayer-snapshot-non-hosted-exceedslimit-enabled", !0), F.add("featurelayer-snapshot-concurrency", 4), F.add("featurelayer-snapshot-coverage", 0.1), F.add("featurelayer-query-max-depth", 4), F.add("featurelayer-query-pausing-enabled", !1), F.add("featurelayer-query-tile-concurrency", 4), F.add("featurelayer-query-tile-max-features", 6e5), F.add("featurelayer-advanced-symbols", !1), F.add("featurelayer-pbf", !0), F.add("featurelayer-pbf-statistics", !1), F.add("feature-layers-workers", !0), F.add("feature-polyline-generalization-factor", 1), F.add("parquetlayer-full-query-feature-count", 2e4), F.add("parquetlayer-hittest-max-feature-count", 1), F.add("mapview-transitions-duration", 200), F.add("mapview-essential-goto-duration", 200), F.add("mapview-srswitch-adjust-rotation-scale-threshold", 24e6), F.add("mapserver-pbf-version-support", 10.81), F.add("mapservice-popup-identify-max-tolerance", 20), F.add("request-queue-concurrency-hosted", 16), F.add("request-queue-concurrency-non-hosted", 4), F.add("curve-densification-coarse-segments", 128), F.add("curve-densification-max-segments", 2e3), F.add("curve-densification-min-segments", 3), F.add("curve-densification-pixel-deviation", 0.5), F.add("view-readyState-waiting-delay", 1e3), F.add("gradient-depth-bias", 0.01), F.add("gradient-depth-epsilon", 1e-8), F.add("enable-feature:esri-compress-textures", !0), F("host-webworker") || F("host-browser") && (F.add("esri-csp-restrictions", () => {
    try {
      new Function();
    } catch {
      return !0;
    }
    return !1;
  }), F.add("esri-url-encodes-apostrophe", () => {
    const t = window.document.createElement("a");
    return t.href = "?'", t.href.includes("?%27");
  }));
})();
const d0 = -3, h7 = d0 - 1, d7 = !!F("esri-tests-disable-gpu-memory-measurements");
let m7 = class {
  get size() {
    return this._size;
  }
  constructor(e = 10485760) {
    this._maxSize = e, this._db = /* @__PURE__ */ new Map(), this._size = 0, this._hit = 0, this._miss = 0, this._users = /* @__PURE__ */ new Map(), this._sizeLimits = /* @__PURE__ */ new Map();
  }
  destroy() {
    this.clearAll(), this._sizeLimits.clear(), this._users.clear(), this._db = null;
  }
  register(e) {
    this._users.set(e.id.slice(0, -1), e);
  }
  deregister(e) {
    this.clear(e), this._sizeLimits.delete(e), this._users.delete(e.id.slice(0, -1));
  }
  get maxSize() {
    return this._maxSize;
  }
  set maxSize(e) {
    this._maxSize = Math.max(e, -1), this._checkSize();
  }
  getSize(e, r) {
    return this._db.get(e.id + r)?.size ?? 0;
  }
  put(e, r, n, s, i) {
    r = e.id + r;
    const u = this._db.get(r);
    if (u && (this._size -= u.size, e.size -= u.size, this._db.delete(r), u.entry !== n && this._notifyRemove(r, u.entry, u.size, 0)), s > this._maxSize) return void this._notifyRemove(r, n, s, 0);
    if (n === void 0) return void console.warn("Refusing to cache undefined entry ");
    if (!s || s < 0) return d7 || console.warn(`Refusing to cache entry with size ${s} for key ${r}`), void this._notifyRemove(r, n, 0, 0);
    const l = 1 + Math.max(i, h7) - d0;
    this._db.set(r, new p7(n, s, l)), this._size += s, e.size += s, this._checkSize();
  }
  updateSize(e, r) {
    r = e.id + r;
    const n = this._db.get(r);
    if (!n) return;
    this._size -= n.size, e.size -= n.size;
    let s = n.entry.usedMemory;
    for (; s > this._maxSize; ) {
      const i = this._notifyRemove(r, n.entry, s, 1);
      if (!(i != null && i > 0)) return void this._db.delete(r);
      s = i;
    }
    n.size = s, this._size += s, e.size += s, this._checkSize();
  }
  pop(e, r) {
    r = e.id + r;
    const n = this._db.get(r);
    if (n) return this._size -= n.size, e.size -= n.size, this._db.delete(r), ++this._hit, n.entry;
    ++this._miss;
  }
  get(e, r) {
    r = e.id + r;
    const n = this._db.get(r);
    if (n !== void 0) return this._db.delete(r), n.lives = n.lifetime, this._db.set(r, n), ++this._hit, n.entry;
    ++this._miss;
  }
  peek(e, r) {
    const n = this._db.get(e.id + r);
    return n ? ++this._hit : ++this._miss, n?.entry;
  }
  get performanceInfo() {
    const e = { Size: Math.round(this._size / 1048576) + "/" + Math.round(this._maxSize / 1048576) + "MB", "Hit rate": Math.round(100 * this._getHitRate()) + "%", Entries: this._db.size.toString() }, r = {}, n = new Array();
    this._db.forEach((u, l) => {
      const c = u.lifetime;
      n[c] = (n[c] || 0) + u.size, this._users.forEach((m) => {
        const { id: _, name: y } = m;
        if (l.startsWith(_)) {
          const v = r[y] || 0;
          r[y] = v + u.size;
        }
      });
    });
    const s = {};
    this._users.forEach((u) => {
      const l = u.name;
      if ("hitRate" in u && typeof u.hitRate == "number" && !isNaN(u.hitRate) && u.hitRate > 0) {
        const c = r[l] || 0;
        r[l] = c, s[l] = Math.round(100 * u.hitRate) + "%";
      } else s[l] = "0%";
    });
    const i = Object.keys(r);
    i.sort((u, l) => r[l] - r[u]), i.forEach((u) => e[u] = Math.round(r[u] / 2 ** 20) + "MB / " + s[u]);
    for (let u = n.length - 1; u >= 0; --u) {
      const l = n[u];
      l && (e["Priority " + (u + d0 - 1)] = Math.round(l / this._size * 100) + "%");
    }
    return e;
  }
  resetStats() {
    this._hit = this._miss = 0, this._users.forEach((e) => e.resetHitRate());
  }
  clear(e) {
    const r = e.id;
    this._db.forEach((n, s) => {
      s.startsWith(r) && (this._size -= n.size, this._db.delete(s), this._notifyRemove(s, n.entry, n.size, 0));
    }), e.size = 0;
  }
  clearAll() {
    this._db.forEach((e, r) => this._notifyRemove(r, e.entry, e.size, 0)), this._users.forEach((e) => e.size = 0), this._size = 0, this._db.clear();
  }
  *values(e) {
    for (const [r, n] of this._db) r.startsWith(e.id) && (yield n.entry);
  }
  _getHitRate() {
    return this._hit / (this._hit + this._miss);
  }
  _notifyRemove(e, r, n, s) {
    const i = this._users.get(e.split(Qf)[0])?.removeFunc, u = i?.(r, s, n);
    return typeof u == "number" ? u : null;
  }
  _checkSize() {
    this._sizeLimits.forEach((e, r) => this._checkSizeLimits(e, r)), this._checkSizeLimits(this.maxSize);
  }
  setMaxSize(e, r) {
    r == null || r <= 0 ? this._sizeLimits.delete(e) : this._sizeLimits.set(e, r);
  }
  _checkSizeLimits(e, r) {
    const n = r ?? this;
    if (n.size <= e) return;
    const s = r?.id;
    let i = !0;
    for (; i; ) {
      i = !1;
      for (const [u, l] of this._db) if (l.lifetime === 0 && (!s || u.startsWith(s))) {
        const c = r ?? this._users.get(u.split(Qf)[0]);
        if (this._purgeItem(u, l, c), n.size <= 0.9 * e) return;
        i ||= this._db.has(u);
      }
    }
    for (const [u, l] of this._db) if (!s || u.startsWith(s)) {
      const c = r ?? this._users.get(u.split(Qf)[0]);
      if (this._purgeItem(u, l, c), n.size <= 0.9 * e) return;
    }
  }
  _purgeItem(e, r, n) {
    if (this._db.delete(e), r.lives <= 1) {
      this._size -= r.size, n && (n.size -= r.size);
      const s = this._notifyRemove(e, r.entry, r.size, 1);
      s != null && s > 0 && (this._size += s, n && (n.size += s), r.lives = r.lifetime, r.size = s, this._db.set(e, r));
    } else --r.lives, this._db.set(e, r);
  }
}, p7 = class {
  constructor(e, r, n) {
    this.entry = e, this.size = r, this.lifetime = n, this.lives = n;
  }
};
const Qf = ":";
let og = class {
  constructor(e, r) {
    this.removeFunc = r, this._storage = new m7(), this.id = "", this.name = "", this.size = 0, this._storage.maxSize = e, this._storage.register(this);
  }
  destroy() {
    this._storage.deregister(this), this._storage.destroy(), this._storage = null;
  }
  put(e, r, n = 1) {
    this._storage.put(this, e, r, n, 1);
  }
  pop(e) {
    return this._storage.pop(this, e);
  }
  get(e) {
    return this._storage.get(this, e);
  }
  clear() {
    this._storage.clearAll();
  }
  get maxSize() {
    return this._storage.maxSize;
  }
  set maxSize(e) {
    this._storage.maxSize = e;
  }
  resetHitRate() {
  }
};
function g7(t, e, r, n, s, i, u) {
  if (t == null && n == null) return !0;
  e = Math.max(0, e), s = Math.max(0, s), r = Math.max(0, r < 0 ? (t?.length ?? 0) + r : r), i = Math.max(0, i < 0 ? (n?.length ?? 0) + i : i);
  const l = r - e;
  if (t == null || n == null || l !== i - s) return !1;
  for (let c = 0; c < l; c++) if (t[e + c] !== n[s + c]) return !1;
  return !0;
}
function _7(t, e, r) {
  return g7(t, 0, t?.length ?? 0, e, 0, e?.length ?? 0);
}
function y7(t, e) {
  const r = t.indexOf(e);
  return r !== -1 ? (t.splice(r, 1), e) : null;
}
function b7(t, e) {
  return t != null;
}
function w7(t) {
  return t?.constructor?.name === "Int8Array";
}
function v7(t) {
  return t?.constructor?.name === "Uint8Array";
}
function S7(t) {
  return t?.constructor?.name === "Uint8ClampedArray";
}
function E7(t) {
  return t?.constructor?.name === "Int16Array";
}
function N7(t) {
  return t?.constructor?.name === "Uint16Array";
}
function x7(t) {
  return t?.constructor?.name === "Int32Array";
}
function T7(t) {
  return t?.constructor?.name === "Uint32Array";
}
function P7(t) {
  return t?.constructor?.name === "Float32Array";
}
function A7(t) {
  return t?.constructor?.name === "Float64Array";
}
function pr(t) {
  if (!t || typeof t != "object" || typeof t == "function") return t;
  const e = C7(t);
  if (e != null) return e;
  if (L7(t)) return t.clone();
  if (M7(t)) return t.map(pr);
  if (O7(t)) throw new Error("Trying to clone an unclonable Accessor instance");
  const r = {};
  for (const n of Object.getOwnPropertyNames(t)) r[n] = pr(t[n]);
  return r;
}
function L7(t) {
  return typeof t.clone == "function";
}
function M7(t) {
  return typeof t.map == "function" && typeof t.forEach == "function";
}
function O7(t) {
  return typeof t.notifyChange == "function" && typeof t.watch == "function";
}
function C7(t) {
  if (w7(t) || v7(t) || S7(t) || E7(t) || N7(t) || x7(t) || T7(t) || P7(t) || A7(t)) return t.slice();
  if (t instanceof Date) return new Date(t);
  if (t instanceof ArrayBuffer)
    return t.slice(0, t.byteLength);
  if (t instanceof Map) {
    const e = /* @__PURE__ */ new Map();
    for (const [r, n] of t) e.set(r, pr(n));
    return e;
  }
  if (t instanceof Set) {
    const e = /* @__PURE__ */ new Set();
    for (const r of t) e.add(pr(r));
    return e;
  }
  return null;
}
function rh(t, e) {
  return t === e || typeof t == "number" && isNaN(t) && typeof e == "number" && isNaN(e) || typeof t?.getTime == "function" && typeof e?.getTime == "function" && t.getTime() === e.getTime() || !1;
}
function R7(t, e, r = !1) {
  return E_(t, e, r);
}
function v_(t, e) {
  if (e != null) return e[t] || S_(t.split("."), !1, e);
}
function Fi(t, e, r) {
  const n = t.split("."), s = n.pop(), i = S_(n, !0, r);
  i && s && (i[s] = e);
}
function S_(t, e, r) {
  let n = r;
  for (const s of t) {
    if (n == null) return;
    if (!(s in n)) {
      if (!e) return;
      n[s] = {};
    }
    n = n[s];
  }
  return n;
}
function E_(t, e, r) {
  return e ? Object.keys(e).reduce((n, s) => {
    if (s === "__proto__") return n;
    let i = n[s], u = e[s];
    return i === u ? n : i === void 0 ? (n[s] = pr(u), n) : (Array.isArray(u) || Array.isArray(n) ? (i = i ? Array.isArray(i) ? n[s] = i.slice() : n[s] = [i] : n[s] = [], u && (Array.isArray(u) || (u = [u]), r ? u.forEach((l) => {
      i.includes(l) || i.push(l);
    }) : n[s] = u.slice())) : u && typeof u == "object" ? n[s] = E_(i, u, r) : n.hasOwnProperty(s) && !e.hasOwnProperty(s) || (n[s] = u), n);
  }, t || {}) : t;
}
const I7 = /\{([^}]+)\}/g;
function ag(t) {
  return t ?? "";
}
function Xa(t, e) {
  return e ? t.replaceAll(I7, typeof e == "object" ? (r, n) => ag(v_(n, e)) : (r, n) => ag(e(n))) : t;
}
function k7(t, e) {
  return t.replaceAll(/([.$?*|{}()[\]\\/+\-^])/g, (r) => `\\${r}`);
}
function D7(t) {
  let e = 0;
  for (let r = 0; r < t.length; r++) e = (e << 5) - e + t.charCodeAt(r), e |= 0;
  return e;
}
function $7(t) {
  return t.toLowerCase().replaceAll(/[\s-]+/g, "");
}
class ss extends Error {
}
class F7 extends ss {
  constructor(e) {
    super(`Invalid DateTime: ${e.toMessage()}`);
  }
}
class U7 extends ss {
  constructor(e) {
    super(`Invalid Interval: ${e.toMessage()}`);
  }
}
class V7 extends ss {
  constructor(e) {
    super(`Invalid Duration: ${e.toMessage()}`);
  }
}
class Ls extends ss {
}
class N_ extends ss {
  constructor(e) {
    super(`Invalid unit ${e}`);
  }
}
class jt extends ss {
}
class _n extends ss {
  constructor() {
    super("Zone is an abstract class");
  }
}
const Q = "numeric", Wr = "short", dr = "long", Ra = {
  year: Q,
  month: Q,
  day: Q
}, x_ = {
  year: Q,
  month: Wr,
  day: Q
}, z7 = {
  year: Q,
  month: Wr,
  day: Q,
  weekday: Wr
}, T_ = {
  year: Q,
  month: dr,
  day: Q
}, P_ = {
  year: Q,
  month: dr,
  day: Q,
  weekday: dr
}, A_ = {
  hour: Q,
  minute: Q
}, L_ = {
  hour: Q,
  minute: Q,
  second: Q
}, M_ = {
  hour: Q,
  minute: Q,
  second: Q,
  timeZoneName: Wr
}, O_ = {
  hour: Q,
  minute: Q,
  second: Q,
  timeZoneName: dr
}, C_ = {
  hour: Q,
  minute: Q,
  hourCycle: "h23"
}, R_ = {
  hour: Q,
  minute: Q,
  second: Q,
  hourCycle: "h23"
}, I_ = {
  hour: Q,
  minute: Q,
  second: Q,
  hourCycle: "h23",
  timeZoneName: Wr
}, k_ = {
  hour: Q,
  minute: Q,
  second: Q,
  hourCycle: "h23",
  timeZoneName: dr
}, D_ = {
  year: Q,
  month: Q,
  day: Q,
  hour: Q,
  minute: Q
}, $_ = {
  year: Q,
  month: Q,
  day: Q,
  hour: Q,
  minute: Q,
  second: Q
}, F_ = {
  year: Q,
  month: Wr,
  day: Q,
  hour: Q,
  minute: Q
}, U_ = {
  year: Q,
  month: Wr,
  day: Q,
  hour: Q,
  minute: Q,
  second: Q
}, j7 = {
  year: Q,
  month: Wr,
  day: Q,
  weekday: Wr,
  hour: Q,
  minute: Q
}, V_ = {
  year: Q,
  month: dr,
  day: Q,
  hour: Q,
  minute: Q,
  timeZoneName: Wr
}, z_ = {
  year: Q,
  month: dr,
  day: Q,
  hour: Q,
  minute: Q,
  second: Q,
  timeZoneName: Wr
}, j_ = {
  year: Q,
  month: dr,
  day: Q,
  weekday: dr,
  hour: Q,
  minute: Q,
  timeZoneName: dr
}, W_ = {
  year: Q,
  month: dr,
  day: Q,
  weekday: dr,
  hour: Q,
  minute: Q,
  second: Q,
  timeZoneName: dr
};
class Fn {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new _n();
  }
  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new _n();
  }
  /**
   * The IANA name of this zone.
   * Defaults to `name` if not overwritten by a subclass.
   * @abstract
   * @type {string}
   */
  get ianaName() {
    return this.name;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new _n();
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(e, r) {
    throw new _n();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(e, r) {
    throw new _n();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(e) {
    throw new _n();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(e) {
    throw new _n();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new _n();
  }
}
let Kf = null;
class Ja extends Fn {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    return Kf === null && (Kf = new Ja()), Kf;
  }
  /** @override **/
  get type() {
    return "system";
  }
  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName(e, { format: r, locale: n }) {
    return ey(e, r, n);
  }
  /** @override **/
  formatOffset(e, r) {
    return Ni(this.offset(e), r);
  }
  /** @override **/
  offset(e) {
    return -new Date(e).getTimezoneOffset();
  }
  /** @override **/
  equals(e) {
    return e.type === "system";
  }
  /** @override **/
  get isValid() {
    return !0;
  }
}
const m0 = /* @__PURE__ */ new Map();
function W7(t) {
  let e = m0.get(t);
  return e === void 0 && (e = new Intl.DateTimeFormat("en-US", {
    hour12: !1,
    timeZone: t,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    era: "short"
  }), m0.set(t, e)), e;
}
const G7 = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function B7(t, e) {
  const r = t.format(e).replace(/\u200E/g, ""), n = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(r), [, s, i, u, l, c, m, _] = n;
  return [u, s, i, l, c, m, _];
}
function q7(t, e) {
  const r = t.formatToParts(e), n = [];
  for (let s = 0; s < r.length; s++) {
    const { type: i, value: u } = r[s], l = G7[i];
    i === "era" ? n[l] = u : pe(l) || (n[l] = parseInt(u, 10));
  }
  return n;
}
const e1 = /* @__PURE__ */ new Map();
class Gr extends Fn {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(e) {
    let r = e1.get(e);
    return r === void 0 && e1.set(e, r = new Gr(e)), r;
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    e1.clear(), m0.clear();
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated For backward compatibility, this forwards to isValidZone, better use `isValidZone()` directly instead.
   * @return {boolean}
   */
  static isValidSpecifier(e) {
    return this.isValidZone(e);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(e) {
    if (!e)
      return !1;
    try {
      return new Intl.DateTimeFormat("en-US", { timeZone: e }).format(), !0;
    } catch {
      return !1;
    }
  }
  constructor(e) {
    super(), this.zoneName = e, this.valid = Gr.isValidZone(e);
  }
  /**
   * The type of zone. `iana` for all instances of `IANAZone`.
   * @override
   * @type {string}
   */
  get type() {
    return "iana";
  }
  /**
   * The name of this zone (i.e. the IANA zone name).
   * @override
   * @type {string}
   */
  get name() {
    return this.zoneName;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year:
   * Always returns false for all IANA zones.
   * @override
   * @type {boolean}
   */
  get isUniversal() {
    return !1;
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(e, { format: r, locale: n }) {
    return ey(e, r, n, this.name);
  }
  /**
   * Returns the offset's value as a string
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(e, r) {
    return Ni(this.offset(e), r);
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @override
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(e) {
    if (!this.valid) return NaN;
    const r = new Date(e);
    if (isNaN(r)) return NaN;
    const n = W7(this.name);
    let [s, i, u, l, c, m, _] = n.formatToParts ? q7(n, r) : B7(n, r);
    l === "BC" && (s = -Math.abs(s) + 1);
    const v = Ka({
      year: s,
      month: i,
      day: u,
      hour: c === 24 ? 0 : c,
      minute: m,
      second: _,
      millisecond: 0
    });
    let S = +r;
    const T = S % 1e3;
    return S -= T >= 0 ? T : 1e3 + T, (v - S) / (60 * 1e3);
  }
  /**
   * Return whether this Zone is equal to another zone
   * @override
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(e) {
    return e.type === "iana" && e.name === this.name;
  }
  /**
   * Return whether this Zone is valid.
   * @override
   * @type {boolean}
   */
  get isValid() {
    return this.valid;
  }
}
let ug = {};
function H7(t, e = {}) {
  const r = JSON.stringify([t, e]);
  let n = ug[r];
  return n || (n = new Intl.ListFormat(t, e), ug[r] = n), n;
}
const p0 = /* @__PURE__ */ new Map();
function g0(t, e = {}) {
  const r = JSON.stringify([t, e]);
  let n = p0.get(r);
  return n === void 0 && (n = new Intl.DateTimeFormat(t, e), p0.set(r, n)), n;
}
const _0 = /* @__PURE__ */ new Map();
function Y7(t, e = {}) {
  const r = JSON.stringify([t, e]);
  let n = _0.get(r);
  return n === void 0 && (n = new Intl.NumberFormat(t, e), _0.set(r, n)), n;
}
const y0 = /* @__PURE__ */ new Map();
function Z7(t, e = {}) {
  const { base: r, ...n } = e, s = JSON.stringify([t, n]);
  let i = y0.get(s);
  return i === void 0 && (i = new Intl.RelativeTimeFormat(t, e), y0.set(s, i)), i;
}
let gi = null;
function X7() {
  return gi || (gi = new Intl.DateTimeFormat().resolvedOptions().locale, gi);
}
const b0 = /* @__PURE__ */ new Map();
function G_(t) {
  let e = b0.get(t);
  return e === void 0 && (e = new Intl.DateTimeFormat(t).resolvedOptions(), b0.set(t, e)), e;
}
const w0 = /* @__PURE__ */ new Map();
function J7(t) {
  let e = w0.get(t);
  if (!e) {
    const r = new Intl.Locale(t);
    e = "getWeekInfo" in r ? r.getWeekInfo() : r.weekInfo, "minimalDays" in e || (e = { ...B_, ...e }), w0.set(t, e);
  }
  return e;
}
function Q7(t) {
  const e = t.indexOf("-x-");
  e !== -1 && (t = t.substring(0, e));
  const r = t.indexOf("-u-");
  if (r === -1)
    return [t];
  {
    let n, s;
    try {
      n = g0(t).resolvedOptions(), s = t;
    } catch {
      const c = t.substring(0, r);
      n = g0(c).resolvedOptions(), s = c;
    }
    const { numberingSystem: i, calendar: u } = n;
    return [s, i, u];
  }
}
function K7(t, e, r) {
  return (r || e) && (t.includes("-u-") || (t += "-u"), r && (t += `-ca-${r}`), e && (t += `-nu-${e}`)), t;
}
function ew(t) {
  const e = [];
  for (let r = 1; r <= 12; r++) {
    const n = H.utc(2009, r, 1);
    e.push(t(n));
  }
  return e;
}
function tw(t) {
  const e = [];
  for (let r = 1; r <= 7; r++) {
    const n = H.utc(2016, 11, 13 + r);
    e.push(t(n));
  }
  return e;
}
function Ro(t, e, r, n) {
  const s = t.listingMode();
  return s === "error" ? null : s === "en" ? r(e) : n(e);
}
function rw(t) {
  return t.numberingSystem && t.numberingSystem !== "latn" ? !1 : t.numberingSystem === "latn" || !t.locale || t.locale.startsWith("en") || G_(t.locale).numberingSystem === "latn";
}
class nw {
  constructor(e, r, n) {
    this.padTo = n.padTo || 0, this.floor = n.floor || !1;
    const { padTo: s, floor: i, ...u } = n;
    if (!r || Object.keys(u).length > 0) {
      const l = { useGrouping: !1, ...n };
      n.padTo > 0 && (l.minimumIntegerDigits = n.padTo), this.inf = Y7(e, l);
    }
  }
  format(e) {
    if (this.inf) {
      const r = this.floor ? Math.floor(e) : e;
      return this.inf.format(r);
    } else {
      const r = this.floor ? Math.floor(e) : ah(e, 3);
      return dt(r, this.padTo);
    }
  }
}
class sw {
  constructor(e, r, n) {
    this.opts = n, this.originalZone = void 0;
    let s;
    if (this.opts.timeZone)
      this.dt = e;
    else if (e.zone.type === "fixed") {
      const u = -1 * (e.offset / 60), l = u >= 0 ? `Etc/GMT+${u}` : `Etc/GMT${u}`;
      e.offset !== 0 && Gr.create(l).valid ? (s = l, this.dt = e) : (s = "UTC", this.dt = e.offset === 0 ? e : e.setZone("UTC").plus({ minutes: e.offset }), this.originalZone = e.zone);
    } else e.zone.type === "system" ? this.dt = e : e.zone.type === "iana" ? (this.dt = e, s = e.zone.name) : (s = "UTC", this.dt = e.setZone("UTC").plus({ minutes: e.offset }), this.originalZone = e.zone);
    const i = { ...this.opts };
    i.timeZone = i.timeZone || s, this.dtf = g0(r, i);
  }
  format() {
    return this.originalZone ? this.formatToParts().map(({ value: e }) => e).join("") : this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const e = this.dtf.formatToParts(this.dt.toJSDate());
    return this.originalZone ? e.map((r) => {
      if (r.type === "timeZoneName") {
        const n = this.originalZone.offsetName(this.dt.ts, {
          locale: this.dt.locale,
          format: this.opts.timeZoneName
        });
        return {
          ...r,
          value: n
        };
      } else
        return r;
    }) : e;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}
class iw {
  constructor(e, r, n) {
    this.opts = { style: "long", ...n }, !r && Q_() && (this.rtf = Z7(e, n));
  }
  format(e, r) {
    return this.rtf ? this.rtf.format(e, r) : Pw(r, e, this.opts.numeric, this.opts.style !== "long");
  }
  formatToParts(e, r) {
    return this.rtf ? this.rtf.formatToParts(e, r) : [];
  }
}
const B_ = {
  firstDay: 1,
  minimalDays: 4,
  weekend: [6, 7]
};
class Re {
  static fromOpts(e) {
    return Re.create(
      e.locale,
      e.numberingSystem,
      e.outputCalendar,
      e.weekSettings,
      e.defaultToEN
    );
  }
  static create(e, r, n, s, i = !1) {
    const u = e || nt.defaultLocale, l = u || (i ? "en-US" : X7()), c = r || nt.defaultNumberingSystem, m = n || nt.defaultOutputCalendar, _ = S0(s) || nt.defaultWeekSettings;
    return new Re(l, c, m, _, u);
  }
  static resetCache() {
    gi = null, p0.clear(), _0.clear(), y0.clear(), b0.clear(), w0.clear();
  }
  static fromObject({ locale: e, numberingSystem: r, outputCalendar: n, weekSettings: s } = {}) {
    return Re.create(e, r, n, s);
  }
  constructor(e, r, n, s, i) {
    const [u, l, c] = Q7(e);
    this.locale = u, this.numberingSystem = r || l || null, this.outputCalendar = n || c || null, this.weekSettings = s, this.intl = K7(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = { format: {}, standalone: {} }, this.monthsCache = { format: {}, standalone: {} }, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = i, this.fastNumbersCached = null;
  }
  get fastNumbers() {
    return this.fastNumbersCached == null && (this.fastNumbersCached = rw(this)), this.fastNumbersCached;
  }
  listingMode() {
    const e = this.isEnglish(), r = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return e && r ? "en" : "intl";
  }
  clone(e) {
    return !e || Object.getOwnPropertyNames(e).length === 0 ? this : Re.create(
      e.locale || this.specifiedLocale,
      e.numberingSystem || this.numberingSystem,
      e.outputCalendar || this.outputCalendar,
      S0(e.weekSettings) || this.weekSettings,
      e.defaultToEN || !1
    );
  }
  redefaultToEN(e = {}) {
    return this.clone({ ...e, defaultToEN: !0 });
  }
  redefaultToSystem(e = {}) {
    return this.clone({ ...e, defaultToEN: !1 });
  }
  months(e, r = !1) {
    return Ro(this, e, ny, () => {
      const n = this.intl === "ja" || this.intl.startsWith("ja-");
      r &= !n;
      const s = r ? { month: e, day: "numeric" } : { month: e }, i = r ? "format" : "standalone";
      if (!this.monthsCache[i][e]) {
        const u = n ? (l) => this.dtFormatter(l, s).format() : (l) => this.extract(l, s, "month");
        this.monthsCache[i][e] = ew(u);
      }
      return this.monthsCache[i][e];
    });
  }
  weekdays(e, r = !1) {
    return Ro(this, e, oy, () => {
      const n = r ? { weekday: e, year: "numeric", month: "long", day: "numeric" } : { weekday: e }, s = r ? "format" : "standalone";
      return this.weekdaysCache[s][e] || (this.weekdaysCache[s][e] = tw(
        (i) => this.extract(i, n, "weekday")
      )), this.weekdaysCache[s][e];
    });
  }
  meridiems() {
    return Ro(
      this,
      void 0,
      () => ay,
      () => {
        if (!this.meridiemCache) {
          const e = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [H.utc(2016, 11, 13, 9), H.utc(2016, 11, 13, 19)].map(
            (r) => this.extract(r, e, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(e) {
    return Ro(this, e, uy, () => {
      const r = { era: e };
      return this.eraCache[e] || (this.eraCache[e] = [H.utc(-40, 1, 1), H.utc(2017, 1, 1)].map(
        (n) => this.extract(n, r, "era")
      )), this.eraCache[e];
    });
  }
  extract(e, r, n) {
    const s = this.dtFormatter(e, r), i = s.formatToParts(), u = i.find((l) => l.type.toLowerCase() === n);
    return u ? u.value : null;
  }
  numberFormatter(e = {}) {
    return new nw(this.intl, e.forceSimple || this.fastNumbers, e);
  }
  dtFormatter(e, r = {}) {
    return new sw(e, this.intl, r);
  }
  relFormatter(e = {}) {
    return new iw(this.intl, this.isEnglish(), e);
  }
  listFormatter(e = {}) {
    return H7(this.intl, e);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || G_(this.intl).locale.startsWith("en-us");
  }
  getWeekSettings() {
    return this.weekSettings ? this.weekSettings : K_() ? J7(this.locale) : B_;
  }
  getStartOfWeek() {
    return this.getWeekSettings().firstDay;
  }
  getMinDaysInFirstWeek() {
    return this.getWeekSettings().minimalDays;
  }
  getWeekendDays() {
    return this.getWeekSettings().weekend;
  }
  equals(e) {
    return this.locale === e.locale && this.numberingSystem === e.numberingSystem && this.outputCalendar === e.outputCalendar;
  }
  toString() {
    return `Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})`;
  }
}
let t1 = null;
class xt extends Fn {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    return t1 === null && (t1 = new xt(0)), t1;
  }
  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(e) {
    return e === 0 ? xt.utcInstance : new xt(e);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(e) {
    if (e) {
      const r = e.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r)
        return new xt(eu(r[1], r[2]));
    }
    return null;
  }
  constructor(e) {
    super(), this.fixed = e;
  }
  /**
   * The type of zone. `fixed` for all instances of `FixedOffsetZone`.
   * @override
   * @type {string}
   */
  get type() {
    return "fixed";
  }
  /**
   * The name of this zone.
   * All fixed zones' names always start with "UTC" (plus optional offset)
   * @override
   * @type {string}
   */
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${Ni(this.fixed, "narrow")}`;
  }
  /**
   * The IANA name of this zone, i.e. `Etc/UTC` or `Etc/GMT+/-nn`
   *
   * @override
   * @type {string}
   */
  get ianaName() {
    return this.fixed === 0 ? "Etc/UTC" : `Etc/GMT${Ni(-this.fixed, "narrow")}`;
  }
  /**
   * Returns the offset's common name at the specified timestamp.
   *
   * For fixed offset zones this equals to the zone name.
   * @override
   */
  offsetName() {
    return this.name;
  }
  /**
   * Returns the offset's value as a string
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(e, r) {
    return Ni(this.fixed, r);
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year:
   * Always returns true for all fixed offset zones.
   * @override
   * @type {boolean}
   */
  get isUniversal() {
    return !0;
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   *
   * For fixed offset zones, this is constant and does not depend on a timestamp.
   * @override
   * @return {number}
   */
  offset() {
    return this.fixed;
  }
  /**
   * Return whether this Zone is equal to another zone (i.e. also fixed and same offset)
   * @override
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(e) {
    return e.type === "fixed" && e.fixed === this.fixed;
  }
  /**
   * Return whether this Zone is valid:
   * All fixed offset zones are valid.
   * @override
   * @type {boolean}
   */
  get isValid() {
    return !0;
  }
}
class ow extends Fn {
  constructor(e) {
    super(), this.zoneName = e;
  }
  /** @override **/
  get type() {
    return "invalid";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName() {
    return null;
  }
  /** @override **/
  formatOffset() {
    return "";
  }
  /** @override **/
  offset() {
    return NaN;
  }
  /** @override **/
  equals() {
    return !1;
  }
  /** @override **/
  get isValid() {
    return !1;
  }
}
function Pn(t, e) {
  if (pe(t) || t === null)
    return e;
  if (t instanceof Fn)
    return t;
  if (hw(t)) {
    const r = t.toLowerCase();
    return r === "default" ? e : r === "local" || r === "system" ? Ja.instance : r === "utc" || r === "gmt" ? xt.utcInstance : xt.parseSpecifier(r) || Gr.create(t);
  } else return Rn(t) ? xt.instance(t) : typeof t == "object" && "offset" in t && typeof t.offset == "function" ? t : new ow(t);
}
const nh = {
  arab: "[٠-٩]",
  arabext: "[۰-۹]",
  bali: "[᭐-᭙]",
  beng: "[০-৯]",
  deva: "[०-९]",
  fullwide: "[０-９]",
  gujr: "[૦-૯]",
  hanidec: "[〇|一|二|三|四|五|六|七|八|九]",
  khmr: "[០-៩]",
  knda: "[೦-೯]",
  laoo: "[໐-໙]",
  limb: "[᥆-᥏]",
  mlym: "[൦-൯]",
  mong: "[᠐-᠙]",
  mymr: "[၀-၉]",
  orya: "[୦-୯]",
  tamldec: "[௦-௯]",
  telu: "[౦-౯]",
  thai: "[๐-๙]",
  tibt: "[༠-༩]",
  latn: "\\d"
}, lg = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
}, aw = nh.hanidec.replace(/[\[|\]]/g, "").split("");
function uw(t) {
  let e = parseInt(t, 10);
  if (isNaN(e)) {
    e = "";
    for (let r = 0; r < t.length; r++) {
      const n = t.charCodeAt(r);
      if (t[r].search(nh.hanidec) !== -1)
        e += aw.indexOf(t[r]);
      else
        for (const s in lg) {
          const [i, u] = lg[s];
          n >= i && n <= u && (e += n - i);
        }
    }
    return parseInt(e, 10);
  } else
    return e;
}
const v0 = /* @__PURE__ */ new Map();
function lw() {
  v0.clear();
}
function Or({ numberingSystem: t }, e = "") {
  const r = t || "latn";
  let n = v0.get(r);
  n === void 0 && (n = /* @__PURE__ */ new Map(), v0.set(r, n));
  let s = n.get(e);
  return s === void 0 && (s = new RegExp(`${nh[r]}${e}`), n.set(e, s)), s;
}
let cg = () => Date.now(), fg = "system", hg = null, dg = null, mg = null, pg = 60, gg, _g = null;
class nt {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return cg;
  }
  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(e) {
    cg = e;
  }
  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(e) {
    fg = e;
  }
  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return Pn(fg, Ja.instance);
  }
  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return hg;
  }
  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(e) {
    hg = e;
  }
  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return dg;
  }
  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(e) {
    dg = e;
  }
  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return mg;
  }
  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(e) {
    mg = e;
  }
  /**
   * @typedef {Object} WeekSettings
   * @property {number} firstDay
   * @property {number} minimalDays
   * @property {number[]} weekend
   */
  /**
   * @return {WeekSettings|null}
   */
  static get defaultWeekSettings() {
    return _g;
  }
  /**
   * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and
   * how many days are required in the first week of a year.
   * Does not affect existing instances.
   *
   * @param {WeekSettings|null} weekSettings
   */
  static set defaultWeekSettings(e) {
    _g = S0(e);
  }
  /**
   * Get the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
   * @type {number}
   */
  static get twoDigitCutoffYear() {
    return pg;
  }
  /**
   * Set the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
   * @type {number}
   * @example Settings.twoDigitCutoffYear = 0 // all 'yy' are interpreted as 20th century
   * @example Settings.twoDigitCutoffYear = 99 // all 'yy' are interpreted as 21st century
   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 2049; '50' -> 1950
   * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
   */
  static set twoDigitCutoffYear(e) {
    pg = e % 100;
  }
  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return gg;
  }
  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(e) {
    gg = e;
  }
  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    Re.resetCache(), Gr.resetCache(), H.resetCache(), lw();
  }
}
class jr {
  constructor(e, r) {
    this.reason = e, this.explanation = r;
  }
  toMessage() {
    return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason;
  }
}
const q_ = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], H_ = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function xr(t, e) {
  return new jr(
    "unit out of range",
    `you specified ${e} (of type ${typeof e}) as a ${t}, which is invalid`
  );
}
function sh(t, e, r) {
  const n = new Date(Date.UTC(t, e - 1, r));
  t < 100 && t >= 0 && n.setUTCFullYear(n.getUTCFullYear() - 1900);
  const s = n.getUTCDay();
  return s === 0 ? 7 : s;
}
function Y_(t, e, r) {
  return r + (Ui(t) ? H_ : q_)[e - 1];
}
function Z_(t, e) {
  const r = Ui(t) ? H_ : q_, n = r.findIndex((i) => i < e), s = e - r[n];
  return { month: n + 1, day: s };
}
function ih(t, e) {
  return (t - e + 7) % 7 + 1;
}
function Ia(t, e = 4, r = 1) {
  const { year: n, month: s, day: i } = t, u = Y_(n, s, i), l = ih(sh(n, s, i), r);
  let c = Math.floor((u - l + 14 - e) / 7), m;
  return c < 1 ? (m = n - 1, c = Oi(m, e, r)) : c > Oi(n, e, r) ? (m = n + 1, c = 1) : m = n, { weekYear: m, weekNumber: c, weekday: l, ...tu(t) };
}
function yg(t, e = 4, r = 1) {
  const { weekYear: n, weekNumber: s, weekday: i } = t, u = ih(sh(n, 1, e), r), l = Rs(n);
  let c = s * 7 + i - u - 7 + e, m;
  c < 1 ? (m = n - 1, c += Rs(m)) : c > l ? (m = n + 1, c -= Rs(n)) : m = n;
  const { month: _, day: y } = Z_(m, c);
  return { year: m, month: _, day: y, ...tu(t) };
}
function r1(t) {
  const { year: e, month: r, day: n } = t, s = Y_(e, r, n);
  return { year: e, ordinal: s, ...tu(t) };
}
function bg(t) {
  const { year: e, ordinal: r } = t, { month: n, day: s } = Z_(e, r);
  return { year: e, month: n, day: s, ...tu(t) };
}
function wg(t, e) {
  if (!pe(t.localWeekday) || !pe(t.localWeekNumber) || !pe(t.localWeekYear)) {
    if (!pe(t.weekday) || !pe(t.weekNumber) || !pe(t.weekYear))
      throw new Ls(
        "Cannot mix locale-based week fields with ISO-based week fields"
      );
    return pe(t.localWeekday) || (t.weekday = t.localWeekday), pe(t.localWeekNumber) || (t.weekNumber = t.localWeekNumber), pe(t.localWeekYear) || (t.weekYear = t.localWeekYear), delete t.localWeekday, delete t.localWeekNumber, delete t.localWeekYear, {
      minDaysInFirstWeek: e.getMinDaysInFirstWeek(),
      startOfWeek: e.getStartOfWeek()
    };
  } else
    return { minDaysInFirstWeek: 4, startOfWeek: 1 };
}
function cw(t, e = 4, r = 1) {
  const n = Qa(t.weekYear), s = Tr(
    t.weekNumber,
    1,
    Oi(t.weekYear, e, r)
  ), i = Tr(t.weekday, 1, 7);
  return n ? s ? i ? !1 : xr("weekday", t.weekday) : xr("week", t.weekNumber) : xr("weekYear", t.weekYear);
}
function fw(t) {
  const e = Qa(t.year), r = Tr(t.ordinal, 1, Rs(t.year));
  return e ? r ? !1 : xr("ordinal", t.ordinal) : xr("year", t.year);
}
function X_(t) {
  const e = Qa(t.year), r = Tr(t.month, 1, 12), n = Tr(t.day, 1, ka(t.year, t.month));
  return e ? r ? n ? !1 : xr("day", t.day) : xr("month", t.month) : xr("year", t.year);
}
function J_(t) {
  const { hour: e, minute: r, second: n, millisecond: s } = t, i = Tr(e, 0, 23) || e === 24 && r === 0 && n === 0 && s === 0, u = Tr(r, 0, 59), l = Tr(n, 0, 59), c = Tr(s, 0, 999);
  return i ? u ? l ? c ? !1 : xr("millisecond", s) : xr("second", n) : xr("minute", r) : xr("hour", e);
}
function pe(t) {
  return typeof t > "u";
}
function Rn(t) {
  return typeof t == "number";
}
function Qa(t) {
  return typeof t == "number" && t % 1 === 0;
}
function hw(t) {
  return typeof t == "string";
}
function dw(t) {
  return Object.prototype.toString.call(t) === "[object Date]";
}
function Q_() {
  try {
    return typeof Intl < "u" && !!Intl.RelativeTimeFormat;
  } catch {
    return !1;
  }
}
function K_() {
  try {
    return typeof Intl < "u" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
  } catch {
    return !1;
  }
}
function mw(t) {
  return Array.isArray(t) ? t : [t];
}
function vg(t, e, r) {
  if (t.length !== 0)
    return t.reduce((n, s) => {
      const i = [e(s), s];
      return n && r(n[0], i[0]) === n[0] ? n : i;
    }, null)[1];
}
function pw(t, e) {
  return e.reduce((r, n) => (r[n] = t[n], r), {});
}
function zs(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
function S0(t) {
  if (t == null)
    return null;
  if (typeof t != "object")
    throw new jt("Week settings must be an object");
  if (!Tr(t.firstDay, 1, 7) || !Tr(t.minimalDays, 1, 7) || !Array.isArray(t.weekend) || t.weekend.some((e) => !Tr(e, 1, 7)))
    throw new jt("Invalid week settings");
  return {
    firstDay: t.firstDay,
    minimalDays: t.minimalDays,
    weekend: Array.from(t.weekend)
  };
}
function Tr(t, e, r) {
  return Qa(t) && t >= e && t <= r;
}
function gw(t, e) {
  return t - e * Math.floor(t / e);
}
function dt(t, e = 2) {
  const r = t < 0;
  let n;
  return r ? n = "-" + ("" + -t).padStart(e, "0") : n = ("" + t).padStart(e, "0"), n;
}
function xn(t) {
  if (!(pe(t) || t === null || t === ""))
    return parseInt(t, 10);
}
function Bn(t) {
  if (!(pe(t) || t === null || t === ""))
    return parseFloat(t);
}
function oh(t) {
  if (!(pe(t) || t === null || t === "")) {
    const e = parseFloat("0." + t) * 1e3;
    return Math.floor(e);
  }
}
function ah(t, e, r = "round") {
  const n = 10 ** e;
  switch (r) {
    case "expand":
      return t > 0 ? Math.ceil(t * n) / n : Math.floor(t * n) / n;
    case "trunc":
      return Math.trunc(t * n) / n;
    case "round":
      return Math.round(t * n) / n;
    case "floor":
      return Math.floor(t * n) / n;
    case "ceil":
      return Math.ceil(t * n) / n;
    default:
      throw new RangeError(`Value rounding ${r} is out of range`);
  }
}
function Ui(t) {
  return t % 4 === 0 && (t % 100 !== 0 || t % 400 === 0);
}
function Rs(t) {
  return Ui(t) ? 366 : 365;
}
function ka(t, e) {
  const r = gw(e - 1, 12) + 1, n = t + (e - r) / 12;
  return r === 2 ? Ui(n) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][r - 1];
}
function Ka(t) {
  let e = Date.UTC(
    t.year,
    t.month - 1,
    t.day,
    t.hour,
    t.minute,
    t.second,
    t.millisecond
  );
  return t.year < 100 && t.year >= 0 && (e = new Date(e), e.setUTCFullYear(t.year, t.month - 1, t.day)), +e;
}
function Sg(t, e, r) {
  return -ih(sh(t, 1, e), r) + e - 1;
}
function Oi(t, e = 4, r = 1) {
  const n = Sg(t, e, r), s = Sg(t + 1, e, r);
  return (Rs(t) - n + s) / 7;
}
function E0(t) {
  return t > 99 ? t : t > nt.twoDigitCutoffYear ? 1900 + t : 2e3 + t;
}
function ey(t, e, r, n = null) {
  const s = new Date(t), i = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  n && (i.timeZone = n);
  const u = { timeZoneName: e, ...i }, l = new Intl.DateTimeFormat(r, u).formatToParts(s).find((c) => c.type.toLowerCase() === "timezonename");
  return l ? l.value : null;
}
function eu(t, e) {
  let r = parseInt(t, 10);
  Number.isNaN(r) && (r = 0);
  const n = parseInt(e, 10) || 0, s = r < 0 || Object.is(r, -0) ? -n : n;
  return r * 60 + s;
}
function ty(t) {
  const e = Number(t);
  if (typeof t == "boolean" || t === "" || !Number.isFinite(e))
    throw new jt(`Invalid unit value ${t}`);
  return e;
}
function Da(t, e) {
  const r = {};
  for (const n in t)
    if (zs(t, n)) {
      const s = t[n];
      if (s == null) continue;
      r[e(n)] = ty(s);
    }
  return r;
}
function Ni(t, e) {
  const r = Math.trunc(Math.abs(t / 60)), n = Math.trunc(Math.abs(t % 60)), s = t >= 0 ? "+" : "-";
  switch (e) {
    case "short":
      return `${s}${dt(r, 2)}:${dt(n, 2)}`;
    case "narrow":
      return `${s}${r}${n > 0 ? `:${n}` : ""}`;
    case "techie":
      return `${s}${dt(r, 2)}${dt(n, 2)}`;
    default:
      throw new RangeError(`Value format ${e} is out of range for property format`);
  }
}
function tu(t) {
  return pw(t, ["hour", "minute", "second", "millisecond"]);
}
const _w = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
], ry = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
], yw = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function ny(t) {
  switch (t) {
    case "narrow":
      return [...yw];
    case "short":
      return [...ry];
    case "long":
      return [..._w];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
const sy = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
], iy = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], bw = ["M", "T", "W", "T", "F", "S", "S"];
function oy(t) {
  switch (t) {
    case "narrow":
      return [...bw];
    case "short":
      return [...iy];
    case "long":
      return [...sy];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
const ay = ["AM", "PM"], ww = ["Before Christ", "Anno Domini"], vw = ["BC", "AD"], Sw = ["B", "A"];
function uy(t) {
  switch (t) {
    case "narrow":
      return [...Sw];
    case "short":
      return [...vw];
    case "long":
      return [...ww];
    default:
      return null;
  }
}
function Ew(t) {
  return ay[t.hour < 12 ? 0 : 1];
}
function Nw(t, e) {
  return oy(e)[t.weekday - 1];
}
function xw(t, e) {
  return ny(e)[t.month - 1];
}
function Tw(t, e) {
  return uy(e)[t.year < 0 ? 0 : 1];
}
function Pw(t, e, r = "always", n = !1) {
  const s = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  }, i = ["hours", "minutes", "seconds"].indexOf(t) === -1;
  if (r === "auto" && i) {
    const y = t === "days";
    switch (e) {
      case 1:
        return y ? "tomorrow" : `next ${s[t][0]}`;
      case -1:
        return y ? "yesterday" : `last ${s[t][0]}`;
      case 0:
        return y ? "today" : `this ${s[t][0]}`;
    }
  }
  const u = Object.is(e, -0) || e < 0, l = Math.abs(e), c = l === 1, m = s[t], _ = n ? c ? m[1] : m[2] || m[1] : c ? s[t][0] : t;
  return u ? `${l} ${_} ago` : `in ${l} ${_}`;
}
function Eg(t, e) {
  let r = "";
  for (const n of t)
    n.literal ? r += n.val : r += e(n.val);
  return r;
}
const Aw = {
  D: Ra,
  DD: x_,
  DDD: T_,
  DDDD: P_,
  t: A_,
  tt: L_,
  ttt: M_,
  tttt: O_,
  T: C_,
  TT: R_,
  TTT: I_,
  TTTT: k_,
  f: D_,
  ff: F_,
  fff: V_,
  ffff: j_,
  F: $_,
  FF: U_,
  FFF: z_,
  FFFF: W_
};
class Wt {
  static create(e, r = {}) {
    return new Wt(e, r);
  }
  static parseFormat(e) {
    let r = null, n = "", s = !1;
    const i = [];
    for (let u = 0; u < e.length; u++) {
      const l = e.charAt(u);
      l === "'" ? ((n.length > 0 || s) && i.push({
        literal: s || /^\s+$/.test(n),
        val: n === "" ? "'" : n
      }), r = null, n = "", s = !s) : s || l === r ? n += l : (n.length > 0 && i.push({ literal: /^\s+$/.test(n), val: n }), n = l, r = l);
    }
    return n.length > 0 && i.push({ literal: s || /^\s+$/.test(n), val: n }), i;
  }
  static macroTokenToFormatOpts(e) {
    return Aw[e];
  }
  constructor(e, r) {
    this.opts = r, this.loc = e, this.systemLoc = null;
  }
  formatWithSystemDefault(e, r) {
    return this.systemLoc === null && (this.systemLoc = this.loc.redefaultToSystem()), this.systemLoc.dtFormatter(e, { ...this.opts, ...r }).format();
  }
  dtFormatter(e, r = {}) {
    return this.loc.dtFormatter(e, { ...this.opts, ...r });
  }
  formatDateTime(e, r) {
    return this.dtFormatter(e, r).format();
  }
  formatDateTimeParts(e, r) {
    return this.dtFormatter(e, r).formatToParts();
  }
  formatInterval(e, r) {
    return this.dtFormatter(e.start, r).dtf.formatRange(e.start.toJSDate(), e.end.toJSDate());
  }
  resolvedOptions(e, r) {
    return this.dtFormatter(e, r).resolvedOptions();
  }
  num(e, r = 0, n = void 0) {
    if (this.opts.forceSimple)
      return dt(e, r);
    const s = { ...this.opts };
    return r > 0 && (s.padTo = r), n && (s.signDisplay = n), this.loc.numberFormatter(s).format(e);
  }
  formatDateTimeFromString(e, r) {
    const n = this.loc.listingMode() === "en", s = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", i = (S, T) => this.loc.extract(e, S, T), u = (S) => e.isOffsetFixed && e.offset === 0 && S.allowZ ? "Z" : e.isValid ? e.zone.formatOffset(e.ts, S.format) : "", l = () => n ? Ew(e) : i({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), c = (S, T) => n ? xw(e, S) : i(T ? { month: S } : { month: S, day: "numeric" }, "month"), m = (S, T) => n ? Nw(e, S) : i(
      T ? { weekday: S } : { weekday: S, month: "long", day: "numeric" },
      "weekday"
    ), _ = (S) => {
      const T = Wt.macroTokenToFormatOpts(S);
      return T ? this.formatWithSystemDefault(e, T) : S;
    }, y = (S) => n ? Tw(e, S) : i({ era: S }, "era"), v = (S) => {
      switch (S) {
        // ms
        case "S":
          return this.num(e.millisecond);
        case "u":
        // falls through
        case "SSS":
          return this.num(e.millisecond, 3);
        // seconds
        case "s":
          return this.num(e.second);
        case "ss":
          return this.num(e.second, 2);
        // fractional seconds
        case "uu":
          return this.num(Math.floor(e.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(e.millisecond / 100));
        // minutes
        case "m":
          return this.num(e.minute);
        case "mm":
          return this.num(e.minute, 2);
        // hours
        case "h":
          return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12);
        case "hh":
          return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12, 2);
        case "H":
          return this.num(e.hour);
        case "HH":
          return this.num(e.hour, 2);
        // offset
        case "Z":
          return u({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return u({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return u({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return e.zone.offsetName(e.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return e.zone.offsetName(e.ts, { format: "long", locale: this.loc.locale });
        // zone
        case "z":
          return e.zoneName;
        // meridiems
        case "a":
          return l();
        // dates
        case "d":
          return s ? i({ day: "numeric" }, "day") : this.num(e.day);
        case "dd":
          return s ? i({ day: "2-digit" }, "day") : this.num(e.day, 2);
        // weekdays - standalone
        case "c":
          return this.num(e.weekday);
        case "ccc":
          return m("short", !0);
        case "cccc":
          return m("long", !0);
        case "ccccc":
          return m("narrow", !0);
        // weekdays - format
        case "E":
          return this.num(e.weekday);
        case "EEE":
          return m("short", !1);
        case "EEEE":
          return m("long", !1);
        case "EEEEE":
          return m("narrow", !1);
        // months - standalone
        case "L":
          return s ? i({ month: "numeric", day: "numeric" }, "month") : this.num(e.month);
        case "LL":
          return s ? i({ month: "2-digit", day: "numeric" }, "month") : this.num(e.month, 2);
        case "LLL":
          return c("short", !0);
        case "LLLL":
          return c("long", !0);
        case "LLLLL":
          return c("narrow", !0);
        // months - format
        case "M":
          return s ? i({ month: "numeric" }, "month") : this.num(e.month);
        case "MM":
          return s ? i({ month: "2-digit" }, "month") : this.num(e.month, 2);
        case "MMM":
          return c("short", !1);
        case "MMMM":
          return c("long", !1);
        case "MMMMM":
          return c("narrow", !1);
        // years
        case "y":
          return s ? i({ year: "numeric" }, "year") : this.num(e.year);
        case "yy":
          return s ? i({ year: "2-digit" }, "year") : this.num(e.year.toString().slice(-2), 2);
        case "yyyy":
          return s ? i({ year: "numeric" }, "year") : this.num(e.year, 4);
        case "yyyyyy":
          return s ? i({ year: "numeric" }, "year") : this.num(e.year, 6);
        // eras
        case "G":
          return y("short");
        case "GG":
          return y("long");
        case "GGGGG":
          return y("narrow");
        case "kk":
          return this.num(e.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(e.weekYear, 4);
        case "W":
          return this.num(e.weekNumber);
        case "WW":
          return this.num(e.weekNumber, 2);
        case "n":
          return this.num(e.localWeekNumber);
        case "nn":
          return this.num(e.localWeekNumber, 2);
        case "ii":
          return this.num(e.localWeekYear.toString().slice(-2), 2);
        case "iiii":
          return this.num(e.localWeekYear, 4);
        case "o":
          return this.num(e.ordinal);
        case "ooo":
          return this.num(e.ordinal, 3);
        case "q":
          return this.num(e.quarter);
        case "qq":
          return this.num(e.quarter, 2);
        case "X":
          return this.num(Math.floor(e.ts / 1e3));
        case "x":
          return this.num(e.ts);
        default:
          return _(S);
      }
    };
    return Eg(Wt.parseFormat(r), v);
  }
  formatDurationFromString(e, r) {
    const n = this.opts.signMode === "negativeLargestOnly" ? -1 : 1, s = (_) => {
      switch (_[0]) {
        case "S":
          return "milliseconds";
        case "s":
          return "seconds";
        case "m":
          return "minutes";
        case "h":
          return "hours";
        case "d":
          return "days";
        case "w":
          return "weeks";
        case "M":
          return "months";
        case "y":
          return "years";
        default:
          return null;
      }
    }, i = (_, y) => (v) => {
      const S = s(v);
      if (S) {
        const T = y.isNegativeDuration && S !== y.largestUnit ? n : 1;
        let L;
        return this.opts.signMode === "negativeLargestOnly" && S !== y.largestUnit ? L = "never" : this.opts.signMode === "all" ? L = "always" : L = "auto", this.num(_.get(S) * T, v.length, L);
      } else
        return v;
    }, u = Wt.parseFormat(r), l = u.reduce(
      (_, { literal: y, val: v }) => y ? _ : _.concat(v),
      []
    ), c = e.shiftTo(...l.map(s).filter((_) => _)), m = {
      isNegativeDuration: c < 0,
      // this relies on "collapsed" being based on "shiftTo", which builds up the object
      // in order
      largestUnit: Object.keys(c.values)[0]
    };
    return Eg(u, i(c, m));
  }
}
const ly = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function qs(...t) {
  const e = t.reduce((r, n) => r + n.source, "");
  return RegExp(`^${e}$`);
}
function Hs(...t) {
  return (e) => t.reduce(
    ([r, n, s], i) => {
      const [u, l, c] = i(e, s);
      return [{ ...r, ...u }, l || n, c];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function Ys(t, ...e) {
  if (t == null)
    return [null, null];
  for (const [r, n] of e) {
    const s = r.exec(t);
    if (s)
      return n(s);
  }
  return [null, null];
}
function cy(...t) {
  return (e, r) => {
    const n = {};
    let s;
    for (s = 0; s < t.length; s++)
      n[t[s]] = xn(e[r + s]);
    return [n, null, r + s];
  };
}
const fy = /(?:([Zz])|([+-]\d\d)(?::?(\d\d))?)/, Lw = `(?:${fy.source}?(?:\\[(${ly.source})\\])?)?`, uh = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/, hy = RegExp(`${uh.source}${Lw}`), lh = RegExp(`(?:[Tt]${hy.source})?`), Mw = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, Ow = /(\d{4})-?W(\d\d)(?:-?(\d))?/, Cw = /(\d{4})-?(\d{3})/, Rw = cy("weekYear", "weekNumber", "weekDay"), Iw = cy("year", "ordinal"), kw = /(\d{4})-(\d\d)-(\d\d)/, dy = RegExp(
  `${uh.source} ?(?:${fy.source}|(${ly.source}))?`
), Dw = RegExp(`(?: ${dy.source})?`);
function Is(t, e, r) {
  const n = t[e];
  return pe(n) ? r : xn(n);
}
function $w(t, e) {
  return [{
    year: Is(t, e),
    month: Is(t, e + 1, 1),
    day: Is(t, e + 2, 1)
  }, null, e + 3];
}
function Zs(t, e) {
  return [{
    hours: Is(t, e, 0),
    minutes: Is(t, e + 1, 0),
    seconds: Is(t, e + 2, 0),
    milliseconds: oh(t[e + 3])
  }, null, e + 4];
}
function Vi(t, e) {
  const r = !t[e] && !t[e + 1], n = eu(t[e + 1], t[e + 2]), s = r ? null : xt.instance(n);
  return [{}, s, e + 3];
}
function zi(t, e) {
  const r = t[e] ? Gr.create(t[e]) : null;
  return [{}, r, e + 1];
}
const Fw = RegExp(`^T?${uh.source}$`), Uw = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function Vw(t) {
  const [e, r, n, s, i, u, l, c, m] = t, _ = e[0] === "-", y = c && c[0] === "-", v = (S, T = !1) => S !== void 0 && (T || S && _) ? -S : S;
  return [
    {
      years: v(Bn(r)),
      months: v(Bn(n)),
      weeks: v(Bn(s)),
      days: v(Bn(i)),
      hours: v(Bn(u)),
      minutes: v(Bn(l)),
      seconds: v(Bn(c), c === "-0"),
      milliseconds: v(oh(m), y)
    }
  ];
}
const zw = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function ch(t, e, r, n, s, i, u) {
  const l = {
    year: e.length === 2 ? E0(xn(e)) : xn(e),
    month: ry.indexOf(r) + 1,
    day: xn(n),
    hour: xn(s),
    minute: xn(i)
  };
  return u && (l.second = xn(u)), t && (l.weekday = t.length > 3 ? sy.indexOf(t) + 1 : iy.indexOf(t) + 1), l;
}
const jw = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function Ww(t) {
  const [
    ,
    e,
    r,
    n,
    s,
    i,
    u,
    l,
    c,
    m,
    _,
    y
  ] = t, v = ch(e, s, n, r, i, u, l);
  let S;
  return c ? S = zw[c] : m ? S = 0 : S = eu(_, y), [v, new xt(S)];
}
function Gw(t) {
  return t.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
const Bw = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, qw = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, Hw = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function Ng(t) {
  const [, e, r, n, s, i, u, l] = t;
  return [ch(e, s, n, r, i, u, l), xt.utcInstance];
}
function Yw(t) {
  const [, e, r, n, s, i, u, l] = t;
  return [ch(e, l, r, n, s, i, u), xt.utcInstance];
}
const Zw = qs(Mw, lh), Xw = qs(Ow, lh), Jw = qs(Cw, lh), Qw = qs(hy), my = Hs(
  $w,
  Zs,
  Vi,
  zi
), Kw = Hs(
  Rw,
  Zs,
  Vi,
  zi
), e4 = Hs(
  Iw,
  Zs,
  Vi,
  zi
), t4 = Hs(
  Zs,
  Vi,
  zi
);
function r4(t) {
  return Ys(
    t,
    [Zw, my],
    [Xw, Kw],
    [Jw, e4],
    [Qw, t4]
  );
}
function n4(t) {
  return Ys(Gw(t), [jw, Ww]);
}
function s4(t) {
  return Ys(
    t,
    [Bw, Ng],
    [qw, Ng],
    [Hw, Yw]
  );
}
function i4(t) {
  return Ys(t, [Uw, Vw]);
}
const o4 = Hs(Zs);
function a4(t) {
  return Ys(t, [Fw, o4]);
}
const u4 = qs(kw, Dw), l4 = qs(dy), c4 = Hs(
  Zs,
  Vi,
  zi
);
function f4(t) {
  return Ys(
    t,
    [u4, my],
    [l4, c4]
  );
}
const xg = "Invalid Duration", py = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
}, h4 = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...py
}, br = 146097 / 400, ps = 146097 / 4800, d4 = {
  years: {
    quarters: 4,
    months: 12,
    weeks: br / 7,
    days: br,
    hours: br * 24,
    minutes: br * 24 * 60,
    seconds: br * 24 * 60 * 60,
    milliseconds: br * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: br / 28,
    days: br / 4,
    hours: br * 24 / 4,
    minutes: br * 24 * 60 / 4,
    seconds: br * 24 * 60 * 60 / 4,
    milliseconds: br * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: ps / 7,
    days: ps,
    hours: ps * 24,
    minutes: ps * 24 * 60,
    seconds: ps * 24 * 60 * 60,
    milliseconds: ps * 24 * 60 * 60 * 1e3
  },
  ...py
}, Yn = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
], m4 = Yn.slice(0).reverse();
function nn(t, e, r = !1) {
  const n = {
    values: r ? e.values : { ...t.values, ...e.values || {} },
    loc: t.loc.clone(e.loc),
    conversionAccuracy: e.conversionAccuracy || t.conversionAccuracy,
    matrix: e.matrix || t.matrix
  };
  return new Le(n);
}
function gy(t, e) {
  let r = e.milliseconds ?? 0;
  for (const n of m4.slice(1))
    e[n] && (r += e[n] * t[n].milliseconds);
  return r;
}
function Tg(t, e) {
  const r = gy(t, e) < 0 ? -1 : 1;
  Yn.reduceRight((n, s) => {
    if (pe(e[s]))
      return n;
    if (n) {
      const i = e[n] * r, u = t[s][n], l = Math.floor(i / u);
      e[s] += l * r, e[n] -= l * u * r;
    }
    return s;
  }, null), Yn.reduce((n, s) => {
    if (pe(e[s]))
      return n;
    if (n) {
      const i = e[n] % 1;
      e[n] -= i, e[s] += i * t[n][s];
    }
    return s;
  }, null);
}
function Pg(t) {
  const e = {};
  for (const [r, n] of Object.entries(t))
    n !== 0 && (e[r] = n);
  return e;
}
class Le {
  /**
   * @private
   */
  constructor(e) {
    const r = e.conversionAccuracy === "longterm" || !1;
    let n = r ? d4 : h4;
    e.matrix && (n = e.matrix), this.values = e.values, this.loc = e.loc || Re.create(), this.conversionAccuracy = r ? "longterm" : "casual", this.invalid = e.invalid || null, this.matrix = n, this.isLuxonDuration = !0;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(e, r) {
    return Le.fromObject({ milliseconds: e }, r);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(e, r = {}) {
    if (e == null || typeof e != "object")
      throw new jt(
        `Duration.fromObject: argument expected to be an object, got ${e === null ? "null" : typeof e}`
      );
    return new Le({
      values: Da(e, Le.normalizeUnit),
      loc: Re.fromObject(r),
      conversionAccuracy: r.conversionAccuracy,
      matrix: r.matrix
    });
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(e) {
    if (Rn(e))
      return Le.fromMillis(e);
    if (Le.isDuration(e))
      return e;
    if (typeof e == "object")
      return Le.fromObject(e);
    throw new jt(
      `Unknown duration argument ${e} of type ${typeof e}`
    );
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(e, r) {
    const [n] = i4(e);
    return n ? Le.fromObject(n, r) : Le.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(e, r) {
    const [n] = a4(e);
    return n ? Le.fromObject(n, r) : Le.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(e, r = null) {
    if (!e)
      throw new jt("need to specify a reason the Duration is invalid");
    const n = e instanceof jr ? e : new jr(e, r);
    if (nt.throwOnInvalid)
      throw new V7(n);
    return new Le({ invalid: n });
  }
  /**
   * @private
   */
  static normalizeUnit(e) {
    const r = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[e && e.toLowerCase()];
    if (!r) throw new N_(e);
    return r;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(e) {
    return e && e.isLuxonDuration || !1;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @param {'negative'|'all'|'negativeLargestOnly'} [opts.signMode=negative] - How to handle signs
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @example Duration.fromObject({ days: 6, seconds: 2 }).toFormat("d s", { signMode: "all" }) //=> "+6 +2"
   * @example Duration.fromObject({ days: -6, seconds: -2 }).toFormat("d s", { signMode: "all" }) //=> "-6 -2"
   * @example Duration.fromObject({ days: -6, seconds: -2 }).toFormat("d s", { signMode: "negativeLargestOnly" }) //=> "-6 2"
   * @return {string}
   */
  toFormat(e, r = {}) {
    const n = {
      ...r,
      floor: r.round !== !1 && r.floor !== !1
    };
    return this.isValid ? Wt.create(this.loc, n).formatDurationFromString(this, e) : xg;
  }
  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
   * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.
   * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.
   * @param {boolean} [opts.showZeros=true] - Show all units previously used by the duration even if they are zero
   * @example
   * ```js
   * var dur = Duration.fromObject({ months: 1, weeks: 0, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 month, 0 weeks, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 month, 0 weeks, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 mth, 0 wks, 5 hr, 6 min'
   * dur.toHuman({ showZeros: false }) //=> '1 month, 5 hours, 6 minutes'
   * ```
   */
  toHuman(e = {}) {
    if (!this.isValid) return xg;
    const r = e.showZeros !== !1, n = Yn.map((s) => {
      const i = this.values[s];
      return pe(i) || i === 0 && !r ? null : this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...e, unit: s.slice(0, -1) }).format(i);
    }).filter((s) => s);
    return this.loc.listFormatter({ type: "conjunction", style: e.listStyle || "narrow", ...e }).format(n);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    return this.isValid ? { ...this.values } : {};
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid) return null;
    let e = "P";
    return this.years !== 0 && (e += this.years + "Y"), (this.months !== 0 || this.quarters !== 0) && (e += this.months + this.quarters * 3 + "M"), this.weeks !== 0 && (e += this.weeks + "W"), this.days !== 0 && (e += this.days + "D"), (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) && (e += "T"), this.hours !== 0 && (e += this.hours + "H"), this.minutes !== 0 && (e += this.minutes + "M"), (this.seconds !== 0 || this.milliseconds !== 0) && (e += ah(this.seconds + this.milliseconds / 1e3, 3) + "S"), e === "P" && (e += "T0S"), e;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(e = {}) {
    if (!this.isValid) return null;
    const r = this.toMillis();
    return r < 0 || r >= 864e5 ? null : (e = {
      suppressMilliseconds: !1,
      suppressSeconds: !1,
      includePrefix: !1,
      format: "extended",
      ...e,
      includeOffset: !1
    }, H.fromMillis(r, { zone: "UTC" }).toISOTime(e));
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns a string representation of this Duration appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid ? `Duration { values: ${JSON.stringify(this.values)} }` : `Duration { Invalid, reason: ${this.invalidReason} }`;
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? gy(this.matrix, this.values) : NaN;
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(e) {
    if (!this.isValid) return this;
    const r = Le.fromDurationLike(e), n = {};
    for (const s of Yn)
      (zs(r.values, s) || zs(this.values, s)) && (n[s] = r.get(s) + this.get(s));
    return nn(this, { values: n }, !0);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(e) {
    if (!this.isValid) return this;
    const r = Le.fromDurationLike(e);
    return this.plus(r.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(e) {
    if (!this.isValid) return this;
    const r = {};
    for (const n of Object.keys(this.values))
      r[n] = ty(e(this.values[n], n));
    return nn(this, { values: r }, !0);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(e) {
    return this[Le.normalizeUnit(e)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(e) {
    if (!this.isValid) return this;
    const r = { ...this.values, ...Da(e, Le.normalizeUnit) };
    return nn(this, { values: r });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale: e, numberingSystem: r, conversionAccuracy: n, matrix: s } = {}) {
    const u = { loc: this.loc.clone({ locale: e, numberingSystem: r }), matrix: s, conversionAccuracy: n };
    return nn(this, u);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(e) {
    return this.isValid ? this.shiftTo(e).get(e) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * Assuming the overall value of the Duration is positive, this means:
   * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
   * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
   *   the overall value would be negative, see third example)
   * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
   *
   * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid) return this;
    const e = this.toObject();
    return Tg(this.matrix, e), nn(this, { values: e }, !0);
  }
  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid) return this;
    const e = Pg(this.normalize().shiftToAll().toObject());
    return nn(this, { values: e }, !0);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...e) {
    if (!this.isValid) return this;
    if (e.length === 0)
      return this;
    e = e.map((u) => Le.normalizeUnit(u));
    const r = {}, n = {}, s = this.toObject();
    let i;
    for (const u of Yn)
      if (e.indexOf(u) >= 0) {
        i = u;
        let l = 0;
        for (const m in n)
          l += this.matrix[m][u] * n[m], n[m] = 0;
        Rn(s[u]) && (l += s[u]);
        const c = Math.trunc(l);
        r[u] = c, n[u] = (l * 1e3 - c * 1e3) / 1e3;
      } else Rn(s[u]) && (n[u] = s[u]);
    for (const u in n)
      n[u] !== 0 && (r[i] += u === i ? n[u] : n[u] / this.matrix[i][u]);
    return Tg(this.matrix, r), nn(this, { values: r }, !0);
  }
  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    return this.isValid ? this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    ) : this;
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid) return this;
    const e = {};
    for (const r of Object.keys(this.values))
      e[r] = this.values[r] === 0 ? 0 : -this.values[r];
    return nn(this, { values: e }, !0);
  }
  /**
   * Removes all units with values equal to 0 from this Duration.
   * @example Duration.fromObject({ years: 2, days: 0, hours: 0, minutes: 0 }).removeZeros().toObject() //=> { years: 2 }
   * @return {Duration}
   */
  removeZeros() {
    if (!this.isValid) return this;
    const e = Pg(this.values);
    return nn(this, { values: e }, !0);
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(e) {
    if (!this.isValid || !e.isValid || !this.loc.equals(e.loc))
      return !1;
    function r(n, s) {
      return n === void 0 || n === 0 ? s === void 0 || s === 0 : n === s;
    }
    for (const n of Yn)
      if (!r(this.values[n], e.values[n]))
        return !1;
    return !0;
  }
}
const gs = "Invalid Interval";
function p4(t, e) {
  return !t || !t.isValid ? tt.invalid("missing or invalid start") : !e || !e.isValid ? tt.invalid("missing or invalid end") : e < t ? tt.invalid(
    "end before start",
    `The end of an interval must be after its start, but you had start=${t.toISO()} and end=${e.toISO()}`
  ) : null;
}
class tt {
  /**
   * @private
   */
  constructor(e) {
    this.s = e.start, this.e = e.end, this.invalid = e.invalid || null, this.isLuxonInterval = !0;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(e, r = null) {
    if (!e)
      throw new jt("need to specify a reason the Interval is invalid");
    const n = e instanceof jr ? e : new jr(e, r);
    if (nt.throwOnInvalid)
      throw new U7(n);
    return new tt({ invalid: n });
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(e, r) {
    const n = hi(e), s = hi(r), i = p4(n, s);
    return i ?? new tt({
      start: n,
      end: s
    });
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(e, r) {
    const n = Le.fromDurationLike(r), s = hi(e);
    return tt.fromDateTimes(s, s.plus(n));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(e, r) {
    const n = Le.fromDurationLike(r), s = hi(e);
    return tt.fromDateTimes(s.minus(n), s);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(e, r) {
    const [n, s] = (e || "").split("/", 2);
    if (n && s) {
      let i, u;
      try {
        i = H.fromISO(n, r), u = i.isValid;
      } catch {
        u = !1;
      }
      let l, c;
      try {
        l = H.fromISO(s, r), c = l.isValid;
      } catch {
        c = !1;
      }
      if (u && c)
        return tt.fromDateTimes(i, l);
      if (u) {
        const m = Le.fromISO(s, r);
        if (m.isValid)
          return tt.after(i, m);
      } else if (c) {
        const m = Le.fromISO(n, r);
        if (m.isValid)
          return tt.before(l, m);
      }
    }
    return tt.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(e) {
    return e && e.isLuxonInterval || !1;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }
  /**
   * Returns the end of the Interval. This is the first instant which is not part of the interval
   * (Interval is half-open).
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }
  /**
   * Returns the last DateTime included in the interval (since end is not part of the interval)
   * @type {DateTime}
   */
  get lastDateTime() {
    return this.isValid && this.e ? this.e.minus(1) : null;
  }
  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }
  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(e = "milliseconds") {
    return this.isValid ? this.toDuration(e).get(e) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime
   * @return {number}
   */
  count(e = "milliseconds", r) {
    if (!this.isValid) return NaN;
    const n = this.start.startOf(e, r);
    let s;
    return r?.useLocaleWeeks ? s = this.end.reconfigure({ locale: n.locale }) : s = this.end, s = s.startOf(e, r), Math.floor(s.diff(n, e).get(e)) + (s.valueOf() !== this.end.valueOf());
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(e) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, e) : !1;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(e) {
    return this.isValid ? this.s > e : !1;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(e) {
    return this.isValid ? this.e <= e : !1;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(e) {
    return this.isValid ? this.s <= e && this.e > e : !1;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start: e, end: r } = {}) {
    return this.isValid ? tt.fromDateTimes(e || this.s, r || this.e) : this;
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...e) {
    if (!this.isValid) return [];
    const r = e.map(hi).filter((u) => this.contains(u)).sort((u, l) => u.toMillis() - l.toMillis()), n = [];
    let { s } = this, i = 0;
    for (; s < this.e; ) {
      const u = r[i] || this.e, l = +u > +this.e ? this.e : u;
      n.push(tt.fromDateTimes(s, l)), s = l, i += 1;
    }
    return n;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(e) {
    const r = Le.fromDurationLike(e);
    if (!this.isValid || !r.isValid || r.as("milliseconds") === 0)
      return [];
    let { s: n } = this, s = 1, i;
    const u = [];
    for (; n < this.e; ) {
      const l = this.start.plus(r.mapUnits((c) => c * s));
      i = +l > +this.e ? this.e : l, u.push(tt.fromDateTimes(n, i)), n = i, s += 1;
    }
    return u;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(e) {
    return this.isValid ? this.splitBy(this.length() / e).slice(0, e) : [];
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(e) {
    return this.e > e.s && this.s < e.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(e) {
    return this.isValid ? +this.e == +e.s : !1;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(e) {
    return this.isValid ? +e.e == +this.s : !1;
  }
  /**
   * Returns true if this Interval fully contains the specified Interval, specifically if the intersect (of this Interval and the other Interval) is equal to the other Interval; false otherwise.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(e) {
    return this.isValid ? this.s <= e.s && this.e >= e.e : !1;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(e) {
    return !this.isValid || !e.isValid ? !1 : this.s.equals(e.s) && this.e.equals(e.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(e) {
    if (!this.isValid) return this;
    const r = this.s > e.s ? this.s : e.s, n = this.e < e.e ? this.e : e.e;
    return r >= n ? null : tt.fromDateTimes(r, n);
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(e) {
    if (!this.isValid) return this;
    const r = this.s < e.s ? this.s : e.s, n = this.e > e.e ? this.e : e.e;
    return tt.fromDateTimes(r, n);
  }
  /**
   * Merge an array of Intervals into an equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * The resulting array will contain the Intervals in ascending order, that is, starting with the earliest Interval
   * and ending with the latest.
   *
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(e) {
    const [r, n] = e.sort((s, i) => s.s - i.s).reduce(
      ([s, i], u) => i ? i.overlaps(u) || i.abutsStart(u) ? [s, i.union(u)] : [s.concat([i]), u] : [s, u],
      [[], null]
    );
    return n && r.push(n), r;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(e) {
    let r = null, n = 0;
    const s = [], i = e.map((c) => [
      { time: c.s, type: "s" },
      { time: c.e, type: "e" }
    ]), u = Array.prototype.concat(...i), l = u.sort((c, m) => c.time - m.time);
    for (const c of l)
      n += c.type === "s" ? 1 : -1, n === 1 ? r = c.time : (r && +r != +c.time && s.push(tt.fromDateTimes(r, c.time)), r = null);
    return tt.merge(s);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...e) {
    return tt.xor([this].concat(e)).map((r) => this.intersection(r)).filter((r) => r && !r.isEmpty());
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    return this.isValid ? `[${this.s.toISO()} – ${this.e.toISO()})` : gs;
  }
  /**
   * Returns a string representation of this Interval appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid ? `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }` : `Interval { Invalid, reason: ${this.invalidReason} }`;
  }
  /**
   * Returns a localized string representing this Interval. Accepts the same options as the
   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
   * is browser-specific, but in general it will return an appropriate representation of the
   * Interval in the assigned locale. Defaults to the system's locale if no locale has been
   * specified.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
   * Intl.DateTimeFormat constructor options.
   * @param {Object} opts - Options to override the configuration of the start DateTime.
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022 – 11/8/2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7 – 8, 2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 7–8 novembre 2022
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00 – 8:00 PM
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00 – 8:00 p
   * @return {string}
   */
  toLocaleString(e = Ra, r = {}) {
    return this.isValid ? Wt.create(this.s.loc.clone(r), e).formatInterval(this) : gs;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(e) {
    return this.isValid ? `${this.s.toISO(e)}/${this.e.toISO(e)}` : gs;
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : gs;
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(e) {
    return this.isValid ? `${this.s.toISOTime(e)}/${this.e.toISOTime(e)}` : gs;
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format
   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
   * formatting tool.
   * @param {string} dateFormat - The format string. This string formats the start and end time.
   * See {@link DateTime#toFormat} for details.
   * @param {Object} opts - Options.
   * @param {string} [opts.separator =  ' – '] - A separator to place between the start and end
   * representations.
   * @return {string}
   */
  toFormat(e, { separator: r = " – " } = {}) {
    return this.isValid ? `${this.s.toFormat(e)}${r}${this.e.toFormat(e)}` : gs;
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(e, r) {
    return this.isValid ? this.e.diff(this.s, e, r) : Le.invalid(this.invalidReason);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(e) {
    return tt.fromDateTimes(e(this.s), e(this.e));
  }
}
class Io {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(e = nt.defaultZone) {
    const r = H.now().setZone(e).set({ month: 12 });
    return !e.isUniversal && r.offset !== r.set({ month: 6 }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(e) {
    return Gr.isValidZone(e);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(e) {
    return Pn(e, nt.defaultZone);
  }
  /**
   * Get the weekday on which the week starts according to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number} the start of the week, 1 for Monday through 7 for Sunday
   */
  static getStartOfWeek({ locale: e = null, locObj: r = null } = {}) {
    return (r || Re.create(e)).getStartOfWeek();
  }
  /**
   * Get the minimum number of days necessary in a week before it is considered part of the next year according
   * to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number}
   */
  static getMinimumDaysInFirstWeek({ locale: e = null, locObj: r = null } = {}) {
    return (r || Re.create(e)).getMinDaysInFirstWeek();
  }
  /**
   * Get the weekdays, which are considered the weekend according to the given locale
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday
   */
  static getWeekendWeekdays({ locale: e = null, locObj: r = null } = {}) {
    return (r || Re.create(e)).getWeekendDays().slice();
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
   * @return {Array}
   */
  static months(e = "long", { locale: r = null, numberingSystem: n = null, locObj: s = null, outputCalendar: i = "gregory" } = {}) {
    return (s || Re.create(r, n, i)).months(e);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(e = "long", { locale: r = null, numberingSystem: n = null, locObj: s = null, outputCalendar: i = "gregory" } = {}) {
    return (s || Re.create(r, n, i)).months(e, !0);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
   * @return {Array}
   */
  static weekdays(e = "long", { locale: r = null, numberingSystem: n = null, locObj: s = null } = {}) {
    return (s || Re.create(r, n, null)).weekdays(e);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(e = "long", { locale: r = null, numberingSystem: n = null, locObj: s = null } = {}) {
    return (s || Re.create(r, n, null)).weekdays(e, !0);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
   * @return {Array}
   */
  static meridiems({ locale: e = null } = {}) {
    return Re.create(e).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
   * @return {Array}
   */
  static eras(e = "short", { locale: r = null } = {}) {
    return Re.create(r, null, "gregory").eras(e);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale
   * @example Info.features() //=> { relative: false, localeWeek: true }
   * @return {Object}
   */
  static features() {
    return { relative: Q_(), localeWeek: K_() };
  }
}
function Ag(t, e) {
  const r = (s) => s.toUTC(0, { keepLocalTime: !0 }).startOf("day").valueOf(), n = r(e) - r(t);
  return Math.floor(Le.fromMillis(n).as("days"));
}
function g4(t, e, r) {
  const n = [
    ["years", (c, m) => m.year - c.year],
    ["quarters", (c, m) => m.quarter - c.quarter + (m.year - c.year) * 4],
    ["months", (c, m) => m.month - c.month + (m.year - c.year) * 12],
    [
      "weeks",
      (c, m) => {
        const _ = Ag(c, m);
        return (_ - _ % 7) / 7;
      }
    ],
    ["days", Ag]
  ], s = {}, i = t;
  let u, l;
  for (const [c, m] of n)
    r.indexOf(c) >= 0 && (u = c, s[c] = m(t, e), l = i.plus(s), l > e ? (s[c]--, t = i.plus(s), t > e && (l = t, s[c]--, t = i.plus(s))) : t = l);
  return [t, s, l, u];
}
function _4(t, e, r, n) {
  let [s, i, u, l] = g4(t, e, r);
  const c = e - s, m = r.filter(
    (y) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(y) >= 0
  );
  m.length === 0 && (u < e && (u = s.plus({ [l]: 1 })), u !== s && (i[l] = (i[l] || 0) + c / (u - s)));
  const _ = Le.fromObject(i, n);
  return m.length > 0 ? Le.fromMillis(c, n).shiftTo(...m).plus(_) : _;
}
const y4 = "missing Intl.DateTimeFormat.formatToParts support";
function Ce(t, e = (r) => r) {
  return { regex: t, deser: ([r]) => e(uw(r)) };
}
const b4 = " ", _y = `[ ${b4}]`, yy = new RegExp(_y, "g");
function w4(t) {
  return t.replace(/\./g, "\\.?").replace(yy, _y);
}
function Lg(t) {
  return t.replace(/\./g, "").replace(yy, " ").toLowerCase();
}
function Cr(t, e) {
  return t === null ? null : {
    regex: RegExp(t.map(w4).join("|")),
    deser: ([r]) => t.findIndex((n) => Lg(r) === Lg(n)) + e
  };
}
function Mg(t, e) {
  return { regex: t, deser: ([, r, n]) => eu(r, n), groups: e };
}
function ko(t) {
  return { regex: t, deser: ([e]) => e };
}
function v4(t) {
  return t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function S4(t, e) {
  const r = Or(e), n = Or(e, "{2}"), s = Or(e, "{3}"), i = Or(e, "{4}"), u = Or(e, "{6}"), l = Or(e, "{1,2}"), c = Or(e, "{1,3}"), m = Or(e, "{1,6}"), _ = Or(e, "{1,9}"), y = Or(e, "{2,4}"), v = Or(e, "{4,6}"), S = (D) => ({ regex: RegExp(v4(D.val)), deser: ([V]) => V, literal: !0 }), L = ((D) => {
    if (t.literal)
      return S(D);
    switch (D.val) {
      // era
      case "G":
        return Cr(e.eras("short"), 0);
      case "GG":
        return Cr(e.eras("long"), 0);
      // years
      case "y":
        return Ce(m);
      case "yy":
        return Ce(y, E0);
      case "yyyy":
        return Ce(i);
      case "yyyyy":
        return Ce(v);
      case "yyyyyy":
        return Ce(u);
      // months
      case "M":
        return Ce(l);
      case "MM":
        return Ce(n);
      case "MMM":
        return Cr(e.months("short", !0), 1);
      case "MMMM":
        return Cr(e.months("long", !0), 1);
      case "L":
        return Ce(l);
      case "LL":
        return Ce(n);
      case "LLL":
        return Cr(e.months("short", !1), 1);
      case "LLLL":
        return Cr(e.months("long", !1), 1);
      // dates
      case "d":
        return Ce(l);
      case "dd":
        return Ce(n);
      // ordinals
      case "o":
        return Ce(c);
      case "ooo":
        return Ce(s);
      // time
      case "HH":
        return Ce(n);
      case "H":
        return Ce(l);
      case "hh":
        return Ce(n);
      case "h":
        return Ce(l);
      case "mm":
        return Ce(n);
      case "m":
        return Ce(l);
      case "q":
        return Ce(l);
      case "qq":
        return Ce(n);
      case "s":
        return Ce(l);
      case "ss":
        return Ce(n);
      case "S":
        return Ce(c);
      case "SSS":
        return Ce(s);
      case "u":
        return ko(_);
      case "uu":
        return ko(l);
      case "uuu":
        return Ce(r);
      // meridiem
      case "a":
        return Cr(e.meridiems(), 0);
      // weekYear (k)
      case "kkkk":
        return Ce(i);
      case "kk":
        return Ce(y, E0);
      // weekNumber (W)
      case "W":
        return Ce(l);
      case "WW":
        return Ce(n);
      // weekdays
      case "E":
      case "c":
        return Ce(r);
      case "EEE":
        return Cr(e.weekdays("short", !1), 1);
      case "EEEE":
        return Cr(e.weekdays("long", !1), 1);
      case "ccc":
        return Cr(e.weekdays("short", !0), 1);
      case "cccc":
        return Cr(e.weekdays("long", !0), 1);
      // offset/zone
      case "Z":
      case "ZZ":
        return Mg(new RegExp(`([+-]${l.source})(?::(${n.source}))?`), 2);
      case "ZZZ":
        return Mg(new RegExp(`([+-]${l.source})(${n.source})?`), 2);
      // we don't support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing
      // because we don't have any way to figure out what they are
      case "z":
        return ko(/[a-z_+-/]{1,256}?/i);
      // this special-case "token" represents a place where a macro-token expanded into a white-space literal
      // in this case we accept any non-newline white-space
      case " ":
        return ko(/[^\S\n\r]/);
      default:
        return S(D);
    }
  })(t) || {
    invalidReason: y4
  };
  return L.token = t, L;
}
const E4 = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh"
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function N4(t, e, r) {
  const { type: n, value: s } = t;
  if (n === "literal") {
    const c = /^\s+$/.test(s);
    return {
      literal: !c,
      val: c ? " " : s
    };
  }
  const i = e[n];
  let u = n;
  n === "hour" && (e.hour12 != null ? u = e.hour12 ? "hour12" : "hour24" : e.hourCycle != null ? e.hourCycle === "h11" || e.hourCycle === "h12" ? u = "hour12" : u = "hour24" : u = r.hour12 ? "hour12" : "hour24");
  let l = E4[u];
  if (typeof l == "object" && (l = l[i]), l)
    return {
      literal: !1,
      val: l
    };
}
function x4(t) {
  return [`^${t.map((r) => r.regex).reduce((r, n) => `${r}(${n.source})`, "")}$`, t];
}
function T4(t, e, r) {
  const n = t.match(e);
  if (n) {
    const s = {};
    let i = 1;
    for (const u in r)
      if (zs(r, u)) {
        const l = r[u], c = l.groups ? l.groups + 1 : 1;
        !l.literal && l.token && (s[l.token.val[0]] = l.deser(n.slice(i, i + c))), i += c;
      }
    return [n, s];
  } else
    return [n, {}];
}
function P4(t) {
  const e = (i) => {
    switch (i) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let r = null, n;
  return pe(t.z) || (r = Gr.create(t.z)), pe(t.Z) || (r || (r = new xt(t.Z)), n = t.Z), pe(t.q) || (t.M = (t.q - 1) * 3 + 1), pe(t.h) || (t.h < 12 && t.a === 1 ? t.h += 12 : t.h === 12 && t.a === 0 && (t.h = 0)), t.G === 0 && t.y && (t.y = -t.y), pe(t.u) || (t.S = oh(t.u)), [Object.keys(t).reduce((i, u) => {
    const l = e(u);
    return l && (i[l] = t[u]), i;
  }, {}), r, n];
}
let n1 = null;
function A4() {
  return n1 || (n1 = H.fromMillis(1555555555555)), n1;
}
function L4(t, e) {
  if (t.literal)
    return t;
  const r = Wt.macroTokenToFormatOpts(t.val), n = Sy(r, e);
  return n == null || n.includes(void 0) ? t : n;
}
function by(t, e) {
  return Array.prototype.concat(...t.map((r) => L4(r, e)));
}
class wy {
  constructor(e, r) {
    if (this.locale = e, this.format = r, this.tokens = by(Wt.parseFormat(r), e), this.units = this.tokens.map((n) => S4(n, e)), this.disqualifyingUnit = this.units.find((n) => n.invalidReason), !this.disqualifyingUnit) {
      const [n, s] = x4(this.units);
      this.regex = RegExp(n, "i"), this.handlers = s;
    }
  }
  explainFromTokens(e) {
    if (this.isValid) {
      const [r, n] = T4(e, this.regex, this.handlers), [s, i, u] = n ? P4(n) : [null, null, void 0];
      if (zs(n, "a") && zs(n, "H"))
        throw new Ls(
          "Can't include meridiem when specifying 24-hour format"
        );
      return {
        input: e,
        tokens: this.tokens,
        regex: this.regex,
        rawMatches: r,
        matches: n,
        result: s,
        zone: i,
        specificOffset: u
      };
    } else
      return { input: e, tokens: this.tokens, invalidReason: this.invalidReason };
  }
  get isValid() {
    return !this.disqualifyingUnit;
  }
  get invalidReason() {
    return this.disqualifyingUnit ? this.disqualifyingUnit.invalidReason : null;
  }
}
function vy(t, e, r) {
  return new wy(t, r).explainFromTokens(e);
}
function M4(t, e, r) {
  const { result: n, zone: s, specificOffset: i, invalidReason: u } = vy(t, e, r);
  return [n, s, i, u];
}
function Sy(t, e) {
  if (!t)
    return null;
  const n = Wt.create(e, t).dtFormatter(A4()), s = n.formatToParts(), i = n.resolvedOptions();
  return s.map((u) => N4(u, t, i));
}
const s1 = "Invalid DateTime", Og = 864e13;
function _i(t) {
  return new jr("unsupported zone", `the zone "${t.name}" is not supported`);
}
function i1(t) {
  return t.weekData === null && (t.weekData = Ia(t.c)), t.weekData;
}
function o1(t) {
  return t.localWeekData === null && (t.localWeekData = Ia(
    t.c,
    t.loc.getMinDaysInFirstWeek(),
    t.loc.getStartOfWeek()
  )), t.localWeekData;
}
function qn(t, e) {
  const r = {
    ts: t.ts,
    zone: t.zone,
    c: t.c,
    o: t.o,
    loc: t.loc,
    invalid: t.invalid
  };
  return new H({ ...r, ...e, old: r });
}
function Ey(t, e, r) {
  let n = t - e * 60 * 1e3;
  const s = r.offset(n);
  if (e === s)
    return [n, e];
  n -= (s - e) * 60 * 1e3;
  const i = r.offset(n);
  return s === i ? [n, s] : [t - Math.min(s, i) * 60 * 1e3, Math.max(s, i)];
}
function Do(t, e) {
  t += e * 60 * 1e3;
  const r = new Date(t);
  return {
    year: r.getUTCFullYear(),
    month: r.getUTCMonth() + 1,
    day: r.getUTCDate(),
    hour: r.getUTCHours(),
    minute: r.getUTCMinutes(),
    second: r.getUTCSeconds(),
    millisecond: r.getUTCMilliseconds()
  };
}
function Qo(t, e, r) {
  return Ey(Ka(t), e, r);
}
function Cg(t, e) {
  const r = t.o, n = t.c.year + Math.trunc(e.years), s = t.c.month + Math.trunc(e.months) + Math.trunc(e.quarters) * 3, i = {
    ...t.c,
    year: n,
    month: s,
    day: Math.min(t.c.day, ka(n, s)) + Math.trunc(e.days) + Math.trunc(e.weeks) * 7
  }, u = Le.fromObject({
    years: e.years - Math.trunc(e.years),
    quarters: e.quarters - Math.trunc(e.quarters),
    months: e.months - Math.trunc(e.months),
    weeks: e.weeks - Math.trunc(e.weeks),
    days: e.days - Math.trunc(e.days),
    hours: e.hours,
    minutes: e.minutes,
    seconds: e.seconds,
    milliseconds: e.milliseconds
  }).as("milliseconds"), l = Ka(i);
  let [c, m] = Ey(l, r, t.zone);
  return u !== 0 && (c += u, m = t.zone.offset(c)), { ts: c, o: m };
}
function _s(t, e, r, n, s, i) {
  const { setZone: u, zone: l } = r;
  if (t && Object.keys(t).length !== 0 || e) {
    const c = e || l, m = H.fromObject(t, {
      ...r,
      zone: c,
      specificOffset: i
    });
    return u ? m : m.setZone(l);
  } else
    return H.invalid(
      new jr("unparsable", `the input "${s}" can't be parsed as ${n}`)
    );
}
function $o(t, e, r = !0) {
  return t.isValid ? Wt.create(Re.create("en-US"), {
    allowZ: r,
    forceSimple: !0
  }).formatDateTimeFromString(t, e) : null;
}
function a1(t, e, r) {
  const n = t.c.year > 9999 || t.c.year < 0;
  let s = "";
  if (n && t.c.year >= 0 && (s += "+"), s += dt(t.c.year, n ? 6 : 4), r === "year") return s;
  if (e) {
    if (s += "-", s += dt(t.c.month), r === "month") return s;
    s += "-";
  } else if (s += dt(t.c.month), r === "month") return s;
  return s += dt(t.c.day), s;
}
function Rg(t, e, r, n, s, i, u) {
  let l = !r || t.c.millisecond !== 0 || t.c.second !== 0, c = "";
  switch (u) {
    case "day":
    case "month":
    case "year":
      break;
    default:
      if (c += dt(t.c.hour), u === "hour") break;
      if (e) {
        if (c += ":", c += dt(t.c.minute), u === "minute") break;
        l && (c += ":", c += dt(t.c.second));
      } else {
        if (c += dt(t.c.minute), u === "minute") break;
        l && (c += dt(t.c.second));
      }
      if (u === "second") break;
      l && (!n || t.c.millisecond !== 0) && (c += ".", c += dt(t.c.millisecond, 3));
  }
  return s && (t.isOffsetFixed && t.offset === 0 && !i ? c += "Z" : t.o < 0 ? (c += "-", c += dt(Math.trunc(-t.o / 60)), c += ":", c += dt(Math.trunc(-t.o % 60))) : (c += "+", c += dt(Math.trunc(t.o / 60)), c += ":", c += dt(Math.trunc(t.o % 60)))), i && (c += "[" + t.zone.ianaName + "]"), c;
}
const Ny = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, O4 = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, C4 = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, Ko = ["year", "month", "day", "hour", "minute", "second", "millisecond"], R4 = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
], I4 = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function ea(t) {
  const e = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[t.toLowerCase()];
  if (!e) throw new N_(t);
  return e;
}
function Ig(t) {
  switch (t.toLowerCase()) {
    case "localweekday":
    case "localweekdays":
      return "localWeekday";
    case "localweeknumber":
    case "localweeknumbers":
      return "localWeekNumber";
    case "localweekyear":
    case "localweekyears":
      return "localWeekYear";
    default:
      return ea(t);
  }
}
function k4(t) {
  if (yi === void 0 && (yi = nt.now()), t.type !== "iana")
    return t.offset(yi);
  const e = t.name;
  let r = N0.get(e);
  return r === void 0 && (r = t.offset(yi), N0.set(e, r)), r;
}
function kg(t, e) {
  const r = Pn(e.zone, nt.defaultZone);
  if (!r.isValid)
    return H.invalid(_i(r));
  const n = Re.fromObject(e);
  let s, i;
  if (pe(t.year))
    s = nt.now();
  else {
    for (const c of Ko)
      pe(t[c]) && (t[c] = Ny[c]);
    const u = X_(t) || J_(t);
    if (u)
      return H.invalid(u);
    const l = k4(r);
    [s, i] = Qo(t, l, r);
  }
  return new H({ ts: s, zone: r, loc: n, o: i });
}
function Dg(t, e, r) {
  const n = pe(r.round) ? !0 : r.round, s = pe(r.rounding) ? "trunc" : r.rounding, i = (l, c) => (l = ah(l, n || r.calendary ? 0 : 2, r.calendary ? "round" : s), e.loc.clone(r).relFormatter(r).format(l, c)), u = (l) => r.calendary ? e.hasSame(t, l) ? 0 : e.startOf(l).diff(t.startOf(l), l).get(l) : e.diff(t, l).get(l);
  if (r.unit)
    return i(u(r.unit), r.unit);
  for (const l of r.units) {
    const c = u(l);
    if (Math.abs(c) >= 1)
      return i(c, l);
  }
  return i(t > e ? -0 : 0, r.units[r.units.length - 1]);
}
function $g(t) {
  let e = {}, r;
  return t.length > 0 && typeof t[t.length - 1] == "object" ? (e = t[t.length - 1], r = Array.from(t).slice(0, t.length - 1)) : r = Array.from(t), [e, r];
}
let yi;
const N0 = /* @__PURE__ */ new Map();
class H {
  /**
   * @access private
   */
  constructor(e) {
    const r = e.zone || nt.defaultZone;
    let n = e.invalid || (Number.isNaN(e.ts) ? new jr("invalid input") : null) || (r.isValid ? null : _i(r));
    this.ts = pe(e.ts) ? nt.now() : e.ts;
    let s = null, i = null;
    if (!n)
      if (e.old && e.old.ts === this.ts && e.old.zone.equals(r))
        [s, i] = [e.old.c, e.old.o];
      else {
        const l = Rn(e.o) && !e.old ? e.o : r.offset(this.ts);
        s = Do(this.ts, l), n = Number.isNaN(s.year) ? new jr("invalid input") : null, s = n ? null : s, i = n ? null : l;
      }
    this._zone = r, this.loc = e.loc || Re.create(), this.invalid = n, this.weekData = null, this.localWeekData = null, this.c = s, this.o = i, this.isLuxonDateTime = !0;
  }
  // CONSTRUCT
  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new H({});
  }
  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [e, r] = $g(arguments), [n, s, i, u, l, c, m] = r;
    return kg({ year: n, month: s, day: i, hour: u, minute: l, second: c, millisecond: m }, e);
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @param {string} [options.weekSettings] - the week settings to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [e, r] = $g(arguments), [n, s, i, u, l, c, m] = r;
    return e.zone = xt.utcInstance, kg({ year: n, month: s, day: i, hour: u, minute: l, second: c, millisecond: m }, e);
  }
  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(e, r = {}) {
    const n = dw(e) ? e.valueOf() : NaN;
    if (Number.isNaN(n))
      return H.invalid("invalid input");
    const s = Pn(r.zone, nt.defaultZone);
    return s.isValid ? new H({
      ts: n,
      zone: s,
      loc: Re.fromObject(r)
    }) : H.invalid(_i(s));
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(e, r = {}) {
    if (Rn(e))
      return e < -Og || e > Og ? H.invalid("Timestamp out of range") : new H({
        ts: e,
        zone: Pn(r.zone, nt.defaultZone),
        loc: Re.fromObject(r)
      });
    throw new jt(
      `fromMillis requires a numerical input, but received a ${typeof e} with value ${e}`
    );
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(e, r = {}) {
    if (Rn(e))
      return new H({
        ts: e * 1e3,
        zone: Pn(r.zone, nt.defaultZone),
        loc: Re.fromObject(r)
      });
    throw new jt("fromSeconds requires a numerical input");
  }
  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.localWeekYear - a week year, according to the locale
   * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale
   * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system\'s locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: "en-US" }).toISODate() //=> '2021-12-26'
   * @return {DateTime}
   */
  static fromObject(e, r = {}) {
    e = e || {};
    const n = Pn(r.zone, nt.defaultZone);
    if (!n.isValid)
      return H.invalid(_i(n));
    const s = Re.fromObject(r), i = Da(e, Ig), { minDaysInFirstWeek: u, startOfWeek: l } = wg(i, s), c = nt.now(), m = pe(r.specificOffset) ? n.offset(c) : r.specificOffset, _ = !pe(i.ordinal), y = !pe(i.year), v = !pe(i.month) || !pe(i.day), S = y || v, T = i.weekYear || i.weekNumber;
    if ((S || _) && T)
      throw new Ls(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (v && _)
      throw new Ls("Can't mix ordinal dates with month/day");
    const L = T || i.weekday && !S;
    let D, V, W = Do(c, m);
    L ? (D = R4, V = O4, W = Ia(W, u, l)) : _ ? (D = I4, V = C4, W = r1(W)) : (D = Ko, V = Ny);
    let j = !1;
    for (const Ie of D) {
      const ve = i[Ie];
      pe(ve) ? j ? i[Ie] = V[Ie] : i[Ie] = W[Ie] : j = !0;
    }
    const U = L ? cw(i, u, l) : _ ? fw(i) : X_(i), $ = U || J_(i);
    if ($)
      return H.invalid($);
    const B = L ? yg(i, u, l) : _ ? bg(i) : i, [Z, ee] = Qo(B, m, n), ye = new H({
      ts: Z,
      zone: n,
      o: ee,
      loc: s
    });
    return i.weekday && S && e.weekday !== ye.weekday ? H.invalid(
      "mismatched weekday",
      `you can't specify both a weekday of ${i.weekday} and a date of ${ye.toISO()}`
    ) : ye.isValid ? ye : H.invalid(ye.invalid);
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @param {string} [opts.weekSettings] - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(e, r = {}) {
    const [n, s] = r4(e);
    return _s(n, s, r, "ISO 8601", e);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(e, r = {}) {
    const [n, s] = n4(e);
    return _s(n, s, r, "RFC 2822", e);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(e, r = {}) {
    const [n, s] = s4(e);
    return _s(n, s, r, "HTTP", r);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(e, r, n = {}) {
    if (pe(e) || pe(r))
      throw new jt("fromFormat requires an input string and a format");
    const { locale: s = null, numberingSystem: i = null } = n, u = Re.fromOpts({
      locale: s,
      numberingSystem: i,
      defaultToEN: !0
    }), [l, c, m, _] = M4(u, e, r);
    return _ ? H.invalid(_) : _s(l, c, n, `format ${r}`, e, m);
  }
  /**
   * @deprecated use fromFormat instead
   */
  static fromString(e, r, n = {}) {
    return H.fromFormat(e, r, n);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(e, r = {}) {
    const [n, s] = f4(e);
    return _s(n, s, r, "SQL", e);
  }
  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(e, r = null) {
    if (!e)
      throw new jt("need to specify a reason the DateTime is invalid");
    const n = e instanceof jr ? e : new jr(e, r);
    if (nt.throwOnInvalid)
      throw new F7(n);
    return new H({ invalid: n });
  }
  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(e) {
    return e && e.isLuxonDateTime || !1;
  }
  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(e, r = {}) {
    const n = Sy(e, Re.fromObject(r));
    return n ? n.map((s) => s ? s.val : null).join("") : null;
  }
  /**
   * Produce the the fully expanded format token for the locale
   * Does NOT quote characters, so quoted tokens will not round trip correctly
   * @param fmt
   * @param localeOpts
   * @returns {string}
   */
  static expandFormat(e, r = {}) {
    return by(Wt.parseFormat(e), Re.fromObject(r)).map((s) => s.val).join("");
  }
  static resetCache() {
    yi = void 0, N0.clear();
  }
  // INFO
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(e) {
    return this[e];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }
  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? i1(this).weekYear : NaN;
  }
  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? i1(this).weekNumber : NaN;
  }
  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? i1(this).weekday : NaN;
  }
  /**
   * Returns true if this date is on a weekend according to the locale, false otherwise
   * @returns {boolean}
   */
  get isWeekend() {
    return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
  }
  /**
   * Get the day of the week according to the locale.
   * 1 is the first day of the week and 7 is the last day of the week.
   * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,
   * @returns {number}
   */
  get localWeekday() {
    return this.isValid ? o1(this).weekday : NaN;
  }
  /**
   * Get the week number of the week year according to the locale. Different locales assign week numbers differently,
   * because the week can start on different days of the week (see localWeekday) and because a different number of days
   * is required for a week to count as the first week of a year.
   * @returns {number}
   */
  get localWeekNumber() {
    return this.isValid ? o1(this).weekNumber : NaN;
  }
  /**
   * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)
   * differently, see localWeekNumber.
   * @returns {number}
   */
  get localWeekYear() {
    return this.isValid ? o1(this).weekYear : NaN;
  }
  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? r1(this.c).ordinal : NaN;
  }
  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? Io.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? Io.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? Io.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? Io.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "short",
      locale: this.locale
    }) : null;
  }
  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "long",
      locale: this.locale
    }) : null;
  }
  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    return this.isOffsetFixed ? !1 : this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
  }
  /**
   * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
   * in this DateTime's zone. During DST changes local time can be ambiguous, for example
   * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
   * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
   * @returns {DateTime[]}
   */
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed)
      return [this];
    const e = 864e5, r = 6e4, n = Ka(this.c), s = this.zone.offset(n - e), i = this.zone.offset(n + e), u = this.zone.offset(n - s * r), l = this.zone.offset(n - i * r);
    if (u === l)
      return [this];
    const c = n - u * r, m = n - l * r, _ = Do(c, u), y = Do(m, l);
    return _.hour === y.hour && _.minute === y.minute && _.second === y.second && _.millisecond === y.millisecond ? [qn(this, { ts: c }), qn(this, { ts: m })] : [this];
  }
  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return Ui(this.year);
  }
  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return ka(this.year, this.month);
  }
  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? Rs(this.year) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? Oi(this.weekYear) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's local week year
   * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52
   * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53
   * @type {number}
   */
  get weeksInLocalWeekYear() {
    return this.isValid ? Oi(
      this.localWeekYear,
      this.loc.getMinDaysInFirstWeek(),
      this.loc.getStartOfWeek()
    ) : NaN;
  }
  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(e = {}) {
    const { locale: r, numberingSystem: n, calendar: s } = Wt.create(
      this.loc.clone(e),
      e
    ).resolvedOptions(this);
    return { locale: r, numberingSystem: n, outputCalendar: s };
  }
  // TRANSFORM
  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(e = 0, r = {}) {
    return this.setZone(xt.instance(e), r);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(nt.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(e, { keepLocalTime: r = !1, keepCalendarTime: n = !1 } = {}) {
    if (e = Pn(e, nt.defaultZone), e.equals(this.zone))
      return this;
    if (e.isValid) {
      let s = this.ts;
      if (r || n) {
        const i = e.offset(this.ts), u = this.toObject();
        [s] = Qo(u, i, e);
      }
      return qn(this, { ts: s, zone: e });
    } else
      return H.invalid(_i(e));
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale: e, numberingSystem: r, outputCalendar: n } = {}) {
    const s = this.loc.clone({ locale: e, numberingSystem: r, outputCalendar: n });
    return qn(this, { loc: s });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(e) {
    return this.reconfigure({ locale: e });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   *
   * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.
   * They cannot be mixed with ISO-week units like `weekday`.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(e) {
    if (!this.isValid) return this;
    const r = Da(e, Ig), { minDaysInFirstWeek: n, startOfWeek: s } = wg(r, this.loc), i = !pe(r.weekYear) || !pe(r.weekNumber) || !pe(r.weekday), u = !pe(r.ordinal), l = !pe(r.year), c = !pe(r.month) || !pe(r.day), m = l || c, _ = r.weekYear || r.weekNumber;
    if ((m || u) && _)
      throw new Ls(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (c && u)
      throw new Ls("Can't mix ordinal dates with month/day");
    let y;
    i ? y = yg(
      { ...Ia(this.c, n, s), ...r },
      n,
      s
    ) : pe(r.ordinal) ? (y = { ...this.toObject(), ...r }, pe(r.day) && (y.day = Math.min(ka(y.year, y.month), y.day))) : y = bg({ ...r1(this.c), ...r });
    const [v, S] = Qo(y, this.o, this.zone);
    return qn(this, { ts: v, o: S });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(e) {
    if (!this.isValid) return this;
    const r = Le.fromDurationLike(e);
    return qn(this, Cg(this, r));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(e) {
    if (!this.isValid) return this;
    const r = Le.fromDurationLike(e).negate();
    return qn(this, Cg(this, r));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(e, { useLocaleWeeks: r = !1 } = {}) {
    if (!this.isValid) return this;
    const n = {}, s = Le.normalizeUnit(e);
    switch (s) {
      case "years":
        n.month = 1;
      // falls through
      case "quarters":
      case "months":
        n.day = 1;
      // falls through
      case "weeks":
      case "days":
        n.hour = 0;
      // falls through
      case "hours":
        n.minute = 0;
      // falls through
      case "minutes":
        n.second = 0;
      // falls through
      case "seconds":
        n.millisecond = 0;
        break;
    }
    if (s === "weeks")
      if (r) {
        const i = this.loc.getStartOfWeek(), { weekday: u } = this;
        u < i && (n.weekNumber = this.weekNumber - 1), n.weekday = i;
      } else
        n.weekday = 1;
    if (s === "quarters") {
      const i = Math.ceil(this.month / 3);
      n.month = (i - 1) * 3 + 1;
    }
    return this.set(n);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(e, r) {
    return this.isValid ? this.plus({ [e]: 1 }).startOf(e, r).minus(1) : this;
  }
  // OUTPUT
  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(e, r = {}) {
    return this.isValid ? Wt.create(this.loc.redefaultToEN(r)).formatDateTimeFromString(this, e) : s1;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 août 2022'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(e = Ra, r = {}) {
    return this.isValid ? Wt.create(this.loc.clone(r), e).formatDateTime(this) : s1;
  }
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(e = {}) {
    return this.isValid ? Wt.create(this.loc.clone(e), e).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @param {string} [opts.precision='milliseconds'] - truncate output to desired presicion: 'years', 'months', 'days', 'hours', 'minutes', 'seconds' or 'milliseconds'. When precision and suppressSeconds or suppressMilliseconds are used together, precision sets the maximum unit shown in the output, however seconds or milliseconds will still be suppressed if they are 0.
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @example DateTime.now().toISO({ precision: 'day' }) //=> '2017-04-22Z'
   * @example DateTime.now().toISO({ precision: 'minute' }) //=> '2017-04-22T20:47Z'
   * @return {string|null}
   */
  toISO({
    format: e = "extended",
    suppressSeconds: r = !1,
    suppressMilliseconds: n = !1,
    includeOffset: s = !0,
    extendedZone: i = !1,
    precision: u = "milliseconds"
  } = {}) {
    if (!this.isValid)
      return null;
    u = ea(u);
    const l = e === "extended";
    let c = a1(this, l, u);
    return Ko.indexOf(u) >= 3 && (c += "T"), c += Rg(
      this,
      l,
      r,
      n,
      s,
      i,
      u
    ), c;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @param {string} [opts.precision='day'] - truncate output to desired precision: 'years', 'months', or 'days'.
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @example DateTime.utc(1982, 5, 25).toISODate({ precision: 'month' }) //=> '1982-05'
   * @return {string|null}
   */
  toISODate({ format: e = "extended", precision: r = "day" } = {}) {
    return this.isValid ? a1(this, e === "extended", ea(r)) : null;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return $o(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @param {string} [opts.precision='milliseconds'] - truncate output to desired presicion: 'hours', 'minutes', 'seconds' or 'milliseconds'. When precision and suppressSeconds or suppressMilliseconds are used together, precision sets the maximum unit shown in the output, however seconds or milliseconds will still be suppressed if they are 0.
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, second: 56 }).toISOTime({ precision: 'minute' }) //=> '07:34Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds: e = !1,
    suppressSeconds: r = !1,
    includeOffset: n = !0,
    includePrefix: s = !1,
    extendedZone: i = !1,
    format: u = "extended",
    precision: l = "milliseconds"
  } = {}) {
    return this.isValid ? (l = ea(l), (s && Ko.indexOf(l) >= 3 ? "T" : "") + Rg(
      this,
      u === "extended",
      r,
      e,
      n,
      i,
      l
    )) : null;
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return $o(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return $o(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string|null}
   */
  toSQLDate() {
    return this.isValid ? a1(this, !0) : null;
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset: e = !0, includeZone: r = !1, includeOffsetSpace: n = !0 } = {}) {
    let s = "HH:mm:ss.SSS";
    return (r || e) && (n && (s += " "), r ? s += "z" : e && (s += "ZZ")), $o(this, s, !0);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(e = {}) {
    return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(e)}` : null;
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : s1;
  }
  /**
   * Returns a string representation of this DateTime appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid ? `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }` : `DateTime { Invalid, reason: ${this.invalidReason} }`;
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds (including milliseconds in the fractional part) of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(e = {}) {
    if (!this.isValid) return {};
    const r = { ...this.c };
    return e.includeConfig && (r.outputCalendar = this.outputCalendar, r.numberingSystem = this.loc.numberingSystem, r.locale = this.loc.locale), r;
  }
  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  // COMPARE
  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(e, r = "milliseconds", n = {}) {
    if (!this.isValid || !e.isValid)
      return Le.invalid("created by diffing an invalid DateTime");
    const s = { locale: this.locale, numberingSystem: this.numberingSystem, ...n }, i = mw(r).map(Le.normalizeUnit), u = e.valueOf() > this.valueOf(), l = u ? this : e, c = u ? e : this, m = _4(l, c, i, s);
    return u ? m.negate() : m;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(e = "milliseconds", r = {}) {
    return this.diff(H.now(), e, r);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval|DateTime}
   */
  until(e) {
    return this.isValid ? tt.fromDateTimes(this, e) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(e, r, n) {
    if (!this.isValid) return !1;
    const s = e.valueOf(), i = this.setZone(e.zone, { keepLocalTime: !0 });
    return i.startOf(r, n) <= s && s <= i.endOf(r, n);
  }
  /**
   * Equality check
   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(e) {
    return this.isValid && e.isValid && this.valueOf() === e.valueOf() && this.zone.equals(e.zone) && this.loc.equals(e.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds towards zero by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {string} [options.rounding="trunc"] - rounding method to use when rounding the numbers in the output. Can be "trunc" (toward zero), "expand" (away from zero), "round", "floor", or "ceil".
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(e = {}) {
    if (!this.isValid) return null;
    const r = e.base || H.fromObject({}, { zone: this.zone }), n = e.padding ? this < r ? -e.padding : e.padding : 0;
    let s = ["years", "months", "days", "hours", "minutes", "seconds"], i = e.unit;
    return Array.isArray(e.unit) && (s = e.unit, i = void 0), Dg(r, this.plus(n), {
      ...e,
      numeric: "always",
      units: s,
      unit: i
    });
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(e = {}) {
    return this.isValid ? Dg(e.base || H.fromObject({}, { zone: this.zone }), this, {
      ...e,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: !0
    }) : null;
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...e) {
    if (!e.every(H.isDateTime))
      throw new jt("min requires all arguments be DateTimes");
    return vg(e, (r) => r.valueOf(), Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...e) {
    if (!e.every(H.isDateTime))
      throw new jt("max requires all arguments be DateTimes");
    return vg(e, (r) => r.valueOf(), Math.max);
  }
  // MISC
  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(e, r, n = {}) {
    const { locale: s = null, numberingSystem: i = null } = n, u = Re.fromOpts({
      locale: s,
      numberingSystem: i,
      defaultToEN: !0
    });
    return vy(u, e, r);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(e, r, n = {}) {
    return H.fromFormatExplain(e, r, n);
  }
  /**
   * Build a parser for `fmt` using the given locale. This parser can be passed
   * to {@link DateTime.fromFormatParser} to a parse a date in this format. This
   * can be used to optimize cases where many dates need to be parsed in a
   * specific format.
   *
   * @param {String} fmt - the format the string is expected to be in (see
   * description)
   * @param {Object} options - options used to set locale and numberingSystem
   * for parser
   * @returns {TokenParser} - opaque object to be used
   */
  static buildFormatParser(e, r = {}) {
    const { locale: n = null, numberingSystem: s = null } = r, i = Re.fromOpts({
      locale: n,
      numberingSystem: s,
      defaultToEN: !0
    });
    return new wy(i, e);
  }
  /**
   * Create a DateTime from an input string and format parser.
   *
   * The format parser must have been created with the same locale as this call.
   *
   * @param {String} text - the string to parse
   * @param {TokenParser} formatParser - parser from {@link DateTime.buildFormatParser}
   * @param {Object} opts - options taken by fromFormat()
   * @returns {DateTime}
   */
  static fromFormatParser(e, r, n = {}) {
    if (pe(e) || pe(r))
      throw new jt(
        "fromFormatParser requires an input string and a format parser"
      );
    const { locale: s = null, numberingSystem: i = null } = n, u = Re.fromOpts({
      locale: s,
      numberingSystem: i,
      defaultToEN: !0
    });
    if (!u.equals(r.locale))
      throw new jt(
        `fromFormatParser called with a locale of ${u}, but the format parser was created for ${r.locale}`
      );
    const { result: l, zone: c, specificOffset: m, invalidReason: _ } = r.explainFromTokens(e);
    return _ ? H.invalid(_) : _s(
      l,
      c,
      n,
      `format ${r.format}`,
      e,
      m
    );
  }
  // FORMAT PRESETS
  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return Ra;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return x_;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return z7;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return T_;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return P_;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return A_;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return L_;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return M_;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return O_;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return C_;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return R_;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return I_;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return k_;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return D_;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return $_;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return F_;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return U_;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return j7;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return V_;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return z_;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return j_;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return W_;
  }
}
function hi(t) {
  if (H.isDateTime(t))
    return t;
  if (t && t.valueOf && Rn(t.valueOf()))
    return H.fromJSDate(t);
  if (t && typeof t == "object")
    return H.fromObject(t);
  throw new jt(
    `Unknown datetime argument: ${t}, of type ${typeof t}`
  );
}
let Sr = class {
  static {
    this.instance = new Gr("Etc/UTC");
  }
};
function Es(t) {
  return t instanceof Fn ? t === Sr.instance : t?.toString().toLowerCase() === "unknown";
}
function u1(t) {
  return Es(t) ? Sr.instance : t;
}
const D4 = { TimeZoneNotRecognized: "Timezone identifier has not been recognized." };
let $4 = class xy extends Error {
  constructor(e, r) {
    super(Xa(D4[e], r)), this.declaredRootClass = "esri.arcade.arcadedate.dateerror", Error.captureStackTrace && Error.captureStackTrace(this, xy);
  }
};
function ys(t, e, r) {
  return t < e ? t - e : t > r ? t - r : 0;
}
function bs(t, e, r) {
  return t < e ? e : t > r ? r : t;
}
let Fg = class at {
  constructor(e) {
    this._date = e, this.declaredRootClass = "esri.arcade.arcadedate";
  }
  static fromParts(e = 0, r = 1, n = 1, s = 0, i = 0, u = 0, l = 0, c) {
    if (isNaN(e) || isNaN(r) || isNaN(n) || isNaN(s) || isNaN(i) || isNaN(u) || isNaN(l)) return null;
    const m = H.local(e, r).daysInMonth;
    let _ = H.fromObject({ day: bs(n, 1, m), year: e, month: bs(r, 1, 12), hour: bs(s, 0, 23), minute: bs(i, 0, 59), second: bs(u, 0, 59), millisecond: bs(l, 0, 999) }, { zone: Xr(c) });
    return _ = _.plus({ months: ys(r, 1, 12), days: ys(n, 1, m), hours: ys(s, 0, 23), minutes: ys(i, 0, 59), seconds: ys(u, 0, 59), milliseconds: ys(l, 0, 999) }), new at(_);
  }
  static get systemTimeZoneCanonicalName() {
    return Intl.DateTimeFormat().resolvedOptions().timeZone ?? "system";
  }
  static arcadeDateAndZoneToArcadeDate(e, r) {
    const n = Xr(r);
    return e.isUnknownTimeZone || n === Sr.instance ? at.fromParts(e.year, e.monthJS + 1, e.day, e.hour, e.minute, e.second, e.millisecond, n) : new at(e._date.setZone(n));
  }
  static dateJSToArcadeDate(e) {
    return new at(H.fromJSDate(e, { zone: "system" }));
  }
  static dateJSAndZoneToArcadeDate(e, r = "system") {
    const n = Xr(r);
    return new at(H.fromJSDate(e, { zone: n }));
  }
  static unknownEpochToArcadeDate(e) {
    return new at(H.fromMillis(e, { zone: Sr.instance }));
  }
  static unknownDateJSToArcadeDate(e) {
    return new at(H.fromMillis(e.getTime(), { zone: Sr.instance }));
  }
  static epochToArcadeDate(e, r = "system") {
    const n = Xr(r);
    return new at(H.fromMillis(e, { zone: n }));
  }
  static dateTimeToArcadeDate(e) {
    return new at(e);
  }
  clone() {
    return new at(this._date);
  }
  changeTimeZone(e) {
    const r = Xr(e);
    return at.dateTimeToArcadeDate(this._date.setZone(r));
  }
  static dateTimeAndZoneToArcadeDate(e, r) {
    const n = Xr(r);
    return e.zone === Sr.instance || n === Sr.instance ? at.fromParts(e.year, e.month, e.day, e.hour, e.minute, e.second, e.millisecond, n) : new at(e.setZone(n));
  }
  static nowToArcadeDate(e) {
    const r = Xr(e);
    return new at(H.fromJSDate(/* @__PURE__ */ new Date(), { zone: r }));
  }
  static nowUTCToArcadeDate() {
    return new at(H.utc());
  }
  get isSystem() {
    return this.timeZone === "system" || this.timeZone === at.systemTimeZoneCanonicalName;
  }
  equals(e) {
    return this.isSystem && e.isSystem ? this.toNumber() === e.toNumber() : this.isUnknownTimeZone === e.isUnknownTimeZone && this._date.equals(e._date);
  }
  get isUnknownTimeZone() {
    return this._date.zone === Sr.instance;
  }
  get isValid() {
    return this._date.isValid;
  }
  get hour() {
    return this._date.hour;
  }
  get second() {
    return this._date.second;
  }
  get day() {
    return this._date.day;
  }
  get dayOfWeekISO() {
    return this._date.weekday;
  }
  get dayOfWeekJS() {
    let e = this._date.weekday;
    return e > 6 && (e = 0), e;
  }
  get millisecond() {
    return this._date.millisecond;
  }
  get monthISO() {
    return this._date.month;
  }
  get weekISO() {
    return this._date.weekNumber;
  }
  get yearISO() {
    return this._date.weekYear;
  }
  get monthJS() {
    return this._date.month - 1;
  }
  get year() {
    return this._date.year;
  }
  get minute() {
    return this._date.minute;
  }
  get zone() {
    return this._date.zone;
  }
  get timeZoneOffset() {
    return this.isUnknownTimeZone ? 0 : this._date.offset;
  }
  get timeZone() {
    if (this.isUnknownTimeZone) return "unknown";
    if (this._date.zone.type === "system") return "system";
    const e = this.zone;
    return e.type === "fixed" ? e.fixed === 0 ? "UTC" : e.formatOffset(0, "short") : e.name;
  }
  stringify() {
    return JSON.stringify(this.toJSDate());
  }
  plus(e) {
    return new at(this._date.plus(e));
  }
  diff(e, r) {
    return this._date.diff(e._date, r)[r];
  }
  toISODate() {
    return this._date.toISODate();
  }
  toISOString(e) {
    return e ? this._date.toISO({ suppressMilliseconds: !0, includeOffset: !this.isUnknownTimeZone }) : this._date.toISO({ includeOffset: !this.isUnknownTimeZone });
  }
  toISOTime(e, r) {
    return this._date.toISOTime({ suppressMilliseconds: e, includeOffset: r && !this.isUnknownTimeZone });
  }
  toFormat(e, r) {
    return this.isUnknownTimeZone && (e = e.replaceAll("Z", "")), this._date.toFormat(e, r);
  }
  toJSDate() {
    return this._date.toJSDate();
  }
  toSQLValue() {
    return this._date.toFormat("yyyy-LL-dd HH:mm:ss");
  }
  toSQLWithKeyword() {
    return `timestamp '${this.toSQLValue()}'`;
  }
  toDateTime() {
    return this._date;
  }
  toNumber() {
    return this._date.toMillis();
  }
  getTime() {
    return this._date.toMillis();
  }
  toUTC() {
    return new at(this._date.toUTC());
  }
  toLocal() {
    return new at(this._date.toLocal());
  }
  toString() {
    return this.toISOString(!0);
  }
  static fromReaderAsTimeStampOffset(e) {
    if (!e) return null;
    const r = H.fromISO(e, { setZone: !0 });
    return new at(r);
  }
};
function Xr(t, e = !0) {
  if (t instanceof Fn) return t;
  switch ($7(t)) {
    case "system":
      return "system";
    case "utc":
      return "UTC";
    case "unknown":
      return Sr.instance;
  }
  if (/^[+-]?[0-9]{1,2}(:[0-9]{2})?$/.test(t)) {
    const n = xt.parseSpecifier("UTC" + (t.startsWith("+") || t.startsWith("-") ? "" : "+") + t);
    if (n) return n;
  }
  const r = Gr.create(t);
  if (!r.isValid) {
    if (e) throw new $4("TimeZoneNotRecognized");
    return null;
  }
  return r;
}
const F4 = { remove: () => {
} };
function Xs(t) {
  return t ? { remove() {
    t && (t(), t = void 0);
  } } : F4;
}
function U4(t) {
  t.forEach((e) => e?.remove());
}
function V4(t) {
  return Xs(() => U4(t));
}
let xi;
const z4 = globalThis.esriConfig?.locale ?? globalThis.dojoConfig?.locale, x0 = globalThis.document?.documentElement;
function Ty() {
  const t = x0?.getAttribute("lang"), e = globalThis.navigator?.language;
  return z4 ?? t ?? e ?? "en";
}
function Py() {
  return xi === void 0 && (xi = Ty()), xi;
}
const j4 = [], W4 = [];
function Ug() {
  const t = Ty();
  xi !== t && ([...W4].forEach((e) => e(t)), xi = t, [...j4].forEach((e) => e(t)));
}
globalThis.addEventListener?.("languagechange", Ug), x0 && new MutationObserver(() => {
  Ug();
}).observe(x0, { attributeFilter: ["lang"] });
function Vg(t) {
  t = t.replaceAll(/LTS|LT|L{1,4}|l{1,4}/g, "[$&]");
  let e = "";
  const r = /(\[[^[]*\])|(\\)?([Hh]mm(ss)?|Mo|M{1,4}|Do|DDDo|D{1,4}|d{2,4}|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
  for (const n of t.match(r) || []) switch (n) {
    case "D":
      e += "d";
      break;
    case "DD":
      e += "dd";
      break;
    case "DDD":
      e += "o";
      break;
    case "d":
      e += "c";
      break;
    case "ddd":
      e += "ccc";
      break;
    case "dddd":
      e += "cccc";
      break;
    case "M":
      e += "L";
      break;
    case "MM":
      e += "LL";
      break;
    case "MMM":
      e += "LLL";
      break;
    case "MMMM":
      e += "LLLL";
      break;
    case "YY":
      e += "yy";
      break;
    case "Y":
    case "YYYY":
      e += "yyyy";
      break;
    case "Q":
      e += "q";
      break;
    case "X":
    case "x":
      e += n;
      break;
    default:
      n.length >= 2 && n.startsWith("[") && n.endsWith("]") ? e += `'${n.slice(1, -1)}'` : e += `'${n}'`;
  }
  return e;
}
const zg = "esri.core.sql.dateonly";
let Pr = class ir {
  constructor(e, r, n) {
    this._year = e, this._month = r, this._day = n, this.declaredRootClass = zg;
  }
  static isDateOnly(e) {
    return typeof e == "object" && e != null && "declaredRootClass" in e && e.declaredRootClass === zg;
  }
  get month() {
    return this._month;
  }
  get monthJS() {
    return this._month - 1;
  }
  get year() {
    return this._year;
  }
  get day() {
    return this._day;
  }
  get isValid() {
    return this.toDateTime("unknown").isValid;
  }
  equals(e) {
    return ir.isDateOnly(e) && e.day === this.day && e.month === this.month && e.year === this.year;
  }
  clone() {
    return new ir(this._year, this._month, this._day);
  }
  toDateTime(e) {
    return H.fromObject({ day: this.day, month: this.month, year: this.year }, { zone: Xr(e) });
  }
  toDateTimeLuxon(e) {
    return H.fromObject({ day: this.day, month: this.month, year: this.year }, { zone: Xr(e) });
  }
  toString() {
    return `${this.year.toString().padStart(4, "0")}-${this.month.toString().padStart(2, "0")}-${this.day.toString().padStart(2, "0")}`;
  }
  toFormat(e = null, r = !0) {
    if (e === null || e === "") return this.toString();
    if (r && (e = Vg(e)), !e) return "";
    const n = this.toDateTime("unknown");
    return Fg.dateTimeToArcadeDate(n).toFormat(e, { locale: Py(), numberingSystem: "latn" });
  }
  toArcadeDate() {
    const e = this.toDateTime("unknown");
    return Fg.dateTimeToArcadeDate(e);
  }
  toNumber() {
    return this.toDateTime("unknown").toMillis();
  }
  toJSDate() {
    return this.toDateTime("unknown").toJSDate();
  }
  toStorageFormat() {
    return this.toFormat("yyyy-LL-dd", !1);
  }
  toSQLValue() {
    return this.toFormat("yyyy-LL-dd", !1);
  }
  toSQLWithKeyword() {
    return "date '" + this.toFormat("yyyy-LL-dd", !1) + "'";
  }
  plus(e, r) {
    return ir.fromDateTime(this.toUTCDateTime().plus({ [e]: r }));
  }
  toUTCDateTime() {
    return H.utc(this.year, this.month, this.day, 0, 0, 0, 0);
  }
  difference(e, r) {
    switch (r.toLowerCase()) {
      case "days":
      case "day":
      case "d":
        return this.toUTCDateTime().diff(e.toUTCDateTime(), "days").days;
      case "months":
      case "month":
        return this.toUTCDateTime().diff(e.toUTCDateTime(), "months").months;
      case "minutes":
      case "minute":
      case "m":
        return r === "M" ? this.toUTCDateTime().diff(e.toUTCDateTime(), "months").months : this.toUTCDateTime().diff(e.toUTCDateTime(), "minutes").minutes;
      case "seconds":
      case "second":
      case "s":
        return this.toUTCDateTime().diff(e.toUTCDateTime(), "seconds").seconds;
      case "milliseconds":
      case "millisecond":
      case "ms":
      default:
        return this.toUTCDateTime().diff(e.toUTCDateTime(), "milliseconds").milliseconds;
      case "hours":
      case "hour":
      case "h":
        return this.toUTCDateTime().diff(e.toUTCDateTime(), "hours").hours;
      case "years":
      case "year":
      case "y":
        return this.toUTCDateTime().diff(e.toUTCDateTime(), "years").years;
    }
  }
  static fromMilliseconds(e) {
    const r = H.fromMillis(e, { zone: xt.utcInstance });
    return r.isValid ? ir.fromParts(r.year, r.month, r.day) : null;
  }
  static fromSeconds(e) {
    const r = H.fromSeconds(e, { zone: xt.utcInstance });
    return r.isValid ? ir.fromParts(r.year, r.month, r.day) : null;
  }
  static fromReader(e) {
    if (!e) return null;
    const r = e.split("-");
    return r.length !== 3 ? null : new ir(parseInt(r[0], 10), parseInt(r[1], 10), parseInt(r[2], 10));
  }
  static fromParts(e, r, n) {
    const s = new ir(e, r, n);
    return s.isValid === !1 ? null : s;
  }
  static fromDateJS(e) {
    return ir.fromParts(e.getFullYear(), e.getMonth() + 1, e.getDay());
  }
  static fromDateTime(e) {
    return ir.fromParts(e.year, e.month, e.day);
  }
  static fromSqlTimeStampOffset(e) {
    return this.fromDateTime(e.toDateTime());
  }
  static fromString(e, r = null) {
    if (e === "" || e === null) return null;
    const n = [];
    if (r) (r = Vg(r)) && n.push(r);
    else if (r === null || r === "") {
      const s = H.fromISO(e, { setZone: !0 });
      return s.isValid ? ir.fromParts(s.year, s.month, s.day) : null;
    }
    for (const s of n) {
      const i = H.fromFormat(e, r ?? s);
      if (i.isValid) return new ir(i.year, i.month, i.day);
    }
    return null;
  }
  static fromNow(e = "system") {
    const r = H.fromJSDate(/* @__PURE__ */ new Date()).setZone(Xr(e));
    return new ir(r.year, r.month, r.day);
  }
};
const G4 = { InvalidValueForAggregateFunction: "Invalid value used in aggregate function", MissingStatisticParameters: "Statistic does not have 1 or 0 Parameters", InvalidFunctionParameters: "Invalid parameters for call to {function}", UnsupportedIsLhs: "Unsupported left hand expression in is statement", UnsupportedIsRhs: "Unsupported right hand expression in is statement", UnsupportedOperator: "Unsupported operator - {operator}", UnsupportedSyntax: "Unsupported syntax - {node}", UnsupportedSqlFunction: "Sql function not found = {function}", InvalidDataType: "Invalid sql data type", InvalidDate: "Invalid date encountered", InvalidOperator: "Invalid operator encountered", InvalidTime: "Invalid time encountered", IllegalInterval: "Illegal interval", FunctionNotRecognized: "Function not recognized", InvalidTimeStamp: "Invalid timestamp encountered", InvalidParameterCount: "Invalid parameter count for call to {name}", PrimarySecondaryQualifiers: "Primary and Secondary SqlInterval qualifiers not supported", YearMonthIntervals: "Year-Month Intervals not supported", CannotCastValue: "Cannot cast value to the required data type" };
let R = class Ay extends Error {
  constructor(e, r) {
    super(Xa(G4[e], r)), this.declaredRootClass = "esri.arcade.featureset.support.sqlerror", Error.captureStackTrace && Error.captureStackTrace(this, Ay);
  }
};
function jg(t) {
  return Number.isNaN(t) || t === 0 ? t : Math.trunc(t);
}
const Wg = "esri.core.sql.SqlTimeStampOffset";
let Br = class Ns {
  constructor(e) {
    this._timeStampOffset = e, this.declaredRootClass = Wg, this._date = null;
  }
  static isTimestampOffset(e) {
    return typeof e == "object" && e != null && "declaredRootClass" in e && e.declaredRootClass === Wg;
  }
  toDateTime() {
    return this._date ??= H.fromISO(this._timeStampOffset, { setZone: !0 }), this._date;
  }
  get isValid() {
    return this.toDateTime().isValid;
  }
  get timezoneOffsetHour() {
    return jg(this.toDateTime().offset / 60);
  }
  get timezoneOffsetMinutes() {
    return jg(this.toDateTime().offset % 60);
  }
  toMilliseconds() {
    return this.toDateTime().toMillis();
  }
  get hour() {
    return this.toDateTime().hour;
  }
  get minute() {
    return this.toDateTime().minute;
  }
  get second() {
    return this.toDateTime().second;
  }
  get day() {
    return this.toDateTime().day;
  }
  get month() {
    return this.toDateTime().month;
  }
  get year() {
    return this.toDateTime().year;
  }
  startOfDay() {
    return Ns.fromDateTime(this.toDateTime().startOf("day"));
  }
  static fromJSDate(e) {
    return new Ns(H.fromJSDate(e).toISO({ includeOffset: !0 }));
  }
  static fromDateTime(e) {
    return new Ns(e.toISO({ includeOffset: !0 }));
  }
  static fromParts(e, r, n = 0, s = 0, i = 0, u = 0, l = 0, c = !1, m = 0, _ = 0) {
    const y = `${e.toString().padStart(4, "0")}-${r.toString().padStart(2, "0")}-${n.toString().padStart(2, "0")}`;
    let v = "";
    u < 10 && (v = "0");
    let S = `${s.toString().padStart(2, "0")}:${i.toString().padStart(2, "0")}:${v + u.toString()}`;
    l !== 0 && (S += "." + l.toString().padStart(3, "0"));
    const T = `${c ? "-" : "+"}${m.toString().padStart(2, "0")}:${_.toString().padStart(2, "0")}`;
    return new Ns(y + "T" + S + T);
  }
  toStorageFormat() {
    return this._timeStampOffset;
  }
  toString() {
    return this._timeStampOffset;
  }
  toSQLValue() {
    let e = this.toDateTime().toSQL({ includeOffset: !0, includeOffsetSpace: !0 });
    return e && (e = e.replace(".000", "")), e;
  }
  toSQLWithKeyword() {
    return `timestamp '${this.toSQLValue()}'`;
  }
  addMilliseconds(e) {
    const r = this.toDateTime().plus(e);
    return Ns.fromDateTime(r);
  }
};
function fe(t, e, r, n) {
  var s = arguments.length, i = s < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, r) : n, u;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") i = Reflect.decorate(t, e, r, n);
  else for (var l = t.length - 1; l >= 0; l--) (u = t[l]) && (i = (s < 3 ? u(i) : s > 3 ? u(e, r, i) : u(e, r)) || i);
  return s > 3 && i && Object.defineProperty(e, r, i), i;
}
const lr = { apiKey: void 0, apiKeys: { scopes: [] }, applicationName: "", applicationUrl: globalThis.location?.href, assetsPath: "", fontsUrl: "https://static.arcgis.com/fonts", geometryServiceUrl: "https://utility.arcgisonline.com/arcgis/rest/services/Geometry/GeometryServer", geoRSSServiceUrl: "https://utility.arcgis.com/sharing/rss", kmlServiceUrl: "https://utility.arcgis.com/sharing/kml", userPrivilegesApplied: !0, portalUrl: "https://www.arcgis.com", respectPrefersReducedMotion: !0, routeServiceUrl: "https://route-api.arcgis.com/arcgis/rest/services/World/Route/NAServer/Route_World", workers: { loaderConfig: { has: {}, paths: {}, map: {}, packages: [] } }, request: { crossOriginNoCorsDomains: null, httpsDomains: ["arcgis.com", "arcgisonline.com", "esrikr.com", "premiumservices.blackbridge.com", "esripremium.accuweather.com", "gbm.digitalglobe.com", "firstlook.digitalglobe.com", "msi.digitalglobe.com"], interceptors: [], internalInterceptors: [], maxUrlLength: 2e3, priority: "high", proxyRules: [], proxyUrl: null, timeout: 62e3, trustedServers: [], useIdentity: !0 }, log: { interceptors: [], level: null } };
if (globalThis.esriConfig && (R7(lr, globalThis.esriConfig, !0), delete lr.has), !lr.assetsPath) {
  {
    const t = "4.34";
    lr.assetsPath = `https://js.arcgis.com/${t}/@arcgis/core/assets`;
  }
  lr.defaultAssetsPath = lr.assetsPath;
}
const Gg = { info: 0, warn: 1, error: 2, none: 3 };
let nr = class or {
  constructor(e) {
    this.level = null, this._module = "", this._parent = null, this.writer = null, this._loggedMessages = { error: /* @__PURE__ */ new Map(), warn: /* @__PURE__ */ new Map(), info: /* @__PURE__ */ new Map() }, e.level != null && (this.level = e.level), e.writer != null && (this.writer = e.writer), this._module = e.module, or._loggers.set(this.module, this);
    const r = this.module.lastIndexOf(".");
    r !== -1 && (this._parent = or.getLogger(this.module.slice(0, r)));
  }
  get module() {
    return this._module;
  }
  get parent() {
    return this._parent;
  }
  error(...e) {
    this._log("error", "always", ...e);
  }
  warn(...e) {
    this._log("warn", "always", ...e);
  }
  info(...e) {
    this._log("info", "always", ...e);
  }
  errorOnce(...e) {
    this._log("error", "once", ...e);
  }
  warnOnce(...e) {
    this._log("warn", "once", ...e);
  }
  infoOnce(...e) {
    this._log("info", "once", ...e);
  }
  errorOncePerTick(...e) {
    this._log("error", "oncePerTick", ...e);
  }
  warnOncePerTick(...e) {
    this._log("warn", "oncePerTick", ...e);
  }
  infoOncePerTick(...e) {
    this._log("info", "oncePerTick", ...e);
  }
  get test() {
  }
  static get test() {
  }
  static getLogger(e) {
    return e = typeof e != "string" ? e.declaredClass : e, or._loggers.get(e) || new or({ module: e });
  }
  static {
    this._loggers = /* @__PURE__ */ new Map();
  }
  static {
    this._tickCounter = 0;
  }
  static {
    this._tickCounterScheduled = !1;
  }
  static {
    this._throttlingDisabled = !1;
  }
  _log(e, r, ...n) {
    if (this._matchLevel(e)) {
      if (r !== "always" && !or._throttlingDisabled) {
        const s = q4(n), i = this._loggedMessages[e].get(s);
        if (r === "once" && i != null || r === "oncePerTick" && i && i >= or._tickCounter) return;
        this._loggedMessages[e].set(s, or._tickCounter), or._scheduleTickCounterIncrement();
      }
      for (const s of lr.log.interceptors) if (s(e, this.module, ...n)) return;
      this._inheritedWriter()(e, this.module, ...n);
    }
  }
  _parentWithMember(e, r) {
    let n = this;
    for (; n != null; ) {
      const s = n[e];
      if (s != null) return s;
      n = n.parent;
    }
    return r;
  }
  _inheritedWriter() {
    return this._parentWithMember("writer", B4);
  }
  _matchLevel(e) {
    const r = lr.log.level || "warn";
    return Gg[this._parentWithMember("level", r)] <= Gg[e];
  }
  static _scheduleTickCounterIncrement() {
    or._tickCounterScheduled || (or._tickCounterScheduled = !0, Promise.resolve().then(() => {
      or._tickCounter++, or._tickCounterScheduled = !1;
    }));
  }
};
function B4(t, e, ...r) {
  console[t](`[${e}]`, ...r);
}
function q4(...t) {
  return D7(JSON.stringify(t, (r, n) => typeof n != "object" || Array.isArray(n) ? n : "[Object]"));
}
function H4(t, e, r) {
  const n = t.get(e);
  if (n !== void 0) return n;
  const s = r();
  return t.set(e, s), s;
}
const Qn = () => nr.getLogger("esri.core.accessorSupport.ensureTypes");
function Y4(t) {
  if (t == null) return t;
  const e = new Date(t);
  return isNaN(e.getTime()) ? (Qn().error("Accessor#set", `Invalid date value: '${t}', falling back to current date`), /* @__PURE__ */ new Date()) : e;
}
function Z4(t) {
  return t == null ? t : !!t;
}
function X4(t) {
  return t == null ? t : t.toString();
}
function Ly(t, e = 0) {
  return t == null ? t : (t = parseFloat(t), isNaN(t) ? e : t);
}
function J4(t) {
  return t == null ? t : Math.round(parseFloat(t));
}
function Q4(t) {
  return null;
}
function K4(t, e) {
  return (r) => {
    let n = t(r);
    return e.step != null && (n = Math.round(n / e.step) * e.step), e.min != null && (n = Math.max(e.min, n)), e.max != null && (n = Math.min(e.max, n)), n;
  };
}
function My(t) {
  return t?.constructor && t.constructor.__accessorMetadata__ !== void 0;
}
function $a(t, e) {
  return e != null && t && !(e instanceof t);
}
function Oy(t) {
  return t && "isCollection" in t;
}
function Bg(t) {
  return t?.Type ? typeof t.Type == "function" ? t.Type : t.Type.base : null;
}
function ev(t, e) {
  if (!e?.constructor || !Oy(e.constructor)) return T0(t, e) ? e : new t(e);
  const r = Bg(t.prototype.itemType), n = Bg(e.constructor.prototype.itemType);
  return r ? n ? r === n ? e : r.prototype.isPrototypeOf(n.prototype) ? new t(e) : (T0(t, e), e) : new t(e) : e;
}
function T0(t, e) {
  return !!My(e) && (Qn().error("Accessor#set", "Assigning an instance of '" + (e.declaredClass || "unknown") + "' which is not a subclass of '" + ru(t) + "'"), !0);
}
function tv(t, e) {
  return e == null ? e : Oy(t) ? ev(t, e) : $a(t, e) ? T0(t, e) ? e : new t(e) : e;
}
function ru(t) {
  return t?.prototype?.declaredClass || "unknown";
}
const rv = /* @__PURE__ */ new WeakMap();
function nv(t) {
  switch (t) {
    case Number:
      return (e) => Ly(e);
    case Zn:
      return J4;
    case Boolean:
      return Z4;
    case String:
      return X4;
    case Date:
      return Y4;
    case fh:
      return Q4;
    default:
      return H4(rv, t, () => tv.bind(null, t));
  }
}
function kn(t, e) {
  const r = nv(t);
  return arguments.length === 1 ? r : r(e);
}
function Ci(t, e, r) {
  return arguments.length === 1 ? Ci.bind(null, t) : e && (Array.isArray(e) ? e.map((n) => t(n, r)) : [t(e, r)]);
}
function sv(t, e) {
  return arguments.length === 1 ? Ci((r) => kn(t, r)) : Ci((r) => kn(t, r), e);
}
function Cy(t, e, r) {
  return e !== 0 && Array.isArray(r) ? r.map((n) => Cy(t, e - 1, n)) : t(r);
}
function Fa(t, e, r) {
  if (arguments.length === 2) return (i) => Fa(t, e, i);
  if (!r) return r;
  r = Cy(t, e, r);
  let n = e, s = r;
  for (; n > 0 && Array.isArray(s); ) n--, s = s[0];
  if (s !== void 0) for (let i = 0; i < n; i++) r = [r];
  return r;
}
function iv(t, e, r) {
  return arguments.length === 2 ? Fa((n) => kn(t, n), e) : Fa((n) => kn(t, n), e, r);
}
function Ry(t) {
  return !!Array.isArray(t) && !t.some((e) => {
    const r = typeof e;
    return !(r === "string" || r === "number" || r === "function" && t.length > 1);
  });
}
function P0(t, e) {
  if (arguments.length === 2) return P0(t).call(null, e);
  const r = /* @__PURE__ */ new Set(), n = t.filter((l) => typeof l != "function"), s = t.filter((l) => typeof l == "function");
  for (const l of t) typeof l != "string" && typeof l != "number" || r.add(l);
  let i = null, u = null;
  return (l, c) => {
    if (l == null) return l;
    const m = typeof l, _ = m === "string" || m === "number";
    return _ && (r.has(l) || s.some((y) => m === "string" && y === String || m === "number" && y === Number)) || m === "object" && s.some((y) => !$a(y, l)) ? l : (_ && n.length ? (i || (i = n.map((y) => typeof y == "string" ? `'${y}'` : `${y}`).join(", ")), Qn().error("Accessor#set", `'${l}' is not a valid value for this property, only the following values are valid: ${i}`)) : typeof l == "object" && s.length ? (u || (u = s.map((y) => ru(y)).join(", ")), Qn().error("Accessor#set", `'${l}' is not a valid value for this property, value must be one of ${u}`)) : Qn().error("Accessor#set", `'${l}' is not a valid value for this property`), c && (c.valid = !1), null);
  };
}
function A0(t, e) {
  if (arguments.length === 2) return A0(t).call(null, e);
  const r = {}, n = [], s = [];
  for (const c in t.typeMap) {
    const m = t.typeMap[c];
    r[c] = kn(m), n.push(ru(m)), s.push(c);
  }
  const i = () => `'${n.join("', '")}'`, u = () => `'${s.join("', '")}'`, l = typeof t.key == "string" ? (c) => c[t.key] : t.key;
  return (c) => {
    if (t.base && !$a(t.base, c) || c == null) return c;
    const m = l(c) || t.defaultKeyValue, _ = r[m];
    if (!_) return Qn().error("Accessor#set", `Invalid property value, value needs to be one of ${i()}, or a plain object that can autocast (having .type = ${u()})`), null;
    if (!$a(t.typeMap[m], c)) return c;
    if (typeof t.key == "string" && !My(c)) {
      const y = {};
      for (const v in c) v !== t.key && (y[v] = c[v]);
      return _(y);
    }
    return _(c);
  };
}
let Zn = class {
}, fh = class {
};
function ov(t) {
  if (!t || !("type" in t)) return !1;
  switch (t.type) {
    case "native":
    case "array":
    case "one-of":
      return !0;
  }
  return !1;
}
function Iy(t) {
  switch (t.type) {
    case "native":
      return kn(t.value);
    case "array":
      return Ci(Iy(t.value));
    case "one-of":
      return av(t);
    default:
      return null;
  }
}
function av(t) {
  let e = null;
  return (r, n) => M0(r, t) ? r : (e == null && (e = L0(t)), Qn().error("Accessor#set", `Invalid property value, value needs to be of type ${e}`), n && (n.valid = !1), null);
}
function L0(t) {
  switch (t.type) {
    case "native":
      switch (t.value) {
        case Number:
          return "number";
        case String:
          return "string";
        case Boolean:
          return "boolean";
        case Zn:
          return "integer";
        case Date:
          return "date";
        case fh:
          return "null";
        default:
          return ru(t.value);
      }
    case "array":
      return `array of ${L0(t.value)}`;
    case "one-of": {
      const e = t.values.map((r) => L0(r));
      return `one of ${e.slice(0, -1)} or ${e[e.length - 1]}`;
    }
  }
  return "unknown";
}
function M0(t, e) {
  if (t == null) return !0;
  switch (e.type) {
    case "native":
      switch (e.value) {
        case Number:
        case Zn:
          return typeof t == "number";
        case Boolean:
          return typeof t == "boolean";
        case String:
          return typeof t == "string";
        case fh:
          return t === null;
      }
      return t instanceof e.value;
    case "array":
      return !!Array.isArray(t) && !t.some((r) => !M0(r, e.value));
    case "one-of":
      return e.values.some((r) => M0(t, r));
  }
}
function ji(t) {
  return t.__accessor__ ?? null;
}
function uv(t, e) {
  return t?.metadata?.[e] != null;
}
function ta(t, e, r) {
  return r ? Ua(t, e, { policy: r, path: "" }) : Ua(t, e, null);
}
function Ua(t, e, r) {
  return e ? Object.keys(e).reduce((n, s) => {
    const i = s;
    if (i === "__proto__") return n;
    let u = null, l = "merge";
    if (r && (u = r.path ? `${r.path}.${s}` : s, l = r.policy(u)), l === "replace" || l === "replace-arrays" && Array.isArray(n[i])) return n[i] = e[i], n;
    if (n[i] === void 0) return n[i] = pr(e[i]), n;
    let c = n[i], m = e[i];
    if (c === m) return n;
    if (Array.isArray(m) || Array.isArray(n)) c = c ? Array.isArray(c) ? n[i] = c.slice() : n[i] = [c] : n[i] = [], m && (Array.isArray(m) || (m = [m]), m.forEach((_) => {
      c.includes(_) || c.push(_);
    }));
    else if (m && typeof m == "object") if (r) {
      const _ = r.path;
      r.path = u, n[i] = Ua(c, m, r), r.path = _;
    } else n[i] = Ua(c, m, null);
    else n.hasOwnProperty(s) && !e.hasOwnProperty(s) || (n[i] = m);
    return n;
  }, t || {}) : t;
}
function ky(t) {
  return Array.isArray(t) ? t : t.split(".");
}
function qg(t) {
  return t.includes(",") ? t.split(",").map((e) => e.trim()) : [t.trim()];
}
function lv(t) {
  if (Array.isArray(t)) {
    const e = [];
    for (const r of t) e.push(...qg(r));
    return e;
  }
  return qg(t);
}
function Dy(t, e, r, n) {
  const s = lv(e);
  if (s.length !== 1) {
    const i = s.map((u) => n(t, u, r));
    return V4(i);
  }
  return n(t, s[0], r);
}
function $y(t, e) {
  const r = t.endsWith("?") ? t.slice(0, -1) : t;
  if (e.getItemAt != null || Array.isArray(e)) {
    const s = parseInt(r, 10);
    if (!isNaN(s)) return Array.isArray(e) ? e[s] : e.at(s);
  }
  const n = ji(e);
  return uv(n, r) ? n.get(r) : e[r];
}
function Fy(t, e, r) {
  if (t == null) return t;
  const n = $y(e[r], t);
  return !n && r < e.length - 1 ? void 0 : r === e.length - 1 ? n : Fy(n, e, r + 1);
}
function Wi(t, e, r = 0) {
  return typeof e != "string" || e.includes(".") ? Fy(t, ky(e), r) : $y(e, t);
}
function js(t, e) {
  return Wi(t, e);
}
function Hg(t, e) {
  return Wi(e, t) !== void 0;
}
function Js(t) {
  let e = t.constructor.__accessorMetadata__;
  const r = Object.prototype.hasOwnProperty.call(t.constructor, "__accessorMetadata__");
  if (e) {
    if (!r) {
      e = Object.create(e);
      for (const n in e) e[n] = pr(e[n]);
      Object.defineProperty(t.constructor, "__accessorMetadata__", { value: e, enumerable: !1, configurable: !0, writable: !0 });
    }
  } else e = {}, Object.defineProperty(t.constructor, "__accessorMetadata__", { value: e, enumerable: !1, configurable: !0, writable: !0 });
  return t.constructor.__accessorMetadata__;
}
function nu(t, e) {
  const r = Js(t);
  let n = r[e];
  return n || (n = r[e] = {}), n;
}
function cv(t, e) {
  return ta(t, e, hv);
}
const fv = /^(?:[^.]+\.)?(?:value|type|(?:json\.type|json\.origins\.[^.]\.type))$/;
function hv(t) {
  return fv.test(t) ? "replace" : "merge";
}
function dv(t, e) {
  return t.replaceAll(/\$\{([^\s:}]*)(?::([^\s:}]+))?\}/g, (r, n) => n === "" ? "$" : (v_(n, e) ?? "").toString());
}
let Uy = class {
  constructor(e, r, n = void 0) {
    this.name = e, this.details = n, this.message = (r && dv(r, n)) ?? "";
  }
  toString() {
    return "[" + this.name + "]: " + this.message;
  }
}, Qs = class Vy extends Uy {
  constructor(e, r, n) {
    super(e, r, n);
  }
  toJSON() {
    if (this.details != null) try {
      return { name: this.name, message: this.message, details: JSON.parse(JSON.stringify(this.details, (e, r) => {
        if (r && typeof r == "object" && typeof r.toJSON == "function") return r;
        try {
          return pr(r);
        } catch {
          return "[object]";
        }
      })) };
    } catch (e) {
      throw nr.getLogger("esri.core.Error").error(e), e;
    }
    return { name: this.name, message: this.message, details: this.details };
  }
  static fromJSON(e) {
    return new Vy(e.name, e.message, e.details);
  }
};
Qs.prototype.type = "error";
function Va(t, e, r) {
  if (t && e) if (typeof e == "object") for (const n of Object.getOwnPropertyNames(e)) Va(t, n, e[n]);
  else {
    if (e.includes(".")) {
      const s = e.split("."), i = s.splice(-1, 1)[0];
      return void Va(js(t, s), i, r);
    }
    const n = t.__accessor__;
    n != null && mv(e, n), t[e] = r;
  }
}
function mv(t, e) {
  if (F("esri-unknown-property-errors") && !pv(t, e)) throw new Qs("set:unknown-property", gv(t, e));
}
function pv(t, e) {
  return e.metadata[t] != null;
}
function gv(t, e) {
  return "setting unknown property '" + t + "' on instance of " + e.host.declaredClass;
}
function _e(t = {}) {
  return (e, r) => {
    if (e === Function.prototype) throw new Error(`Inappropriate use of @property() on a static field: ${e.name}.${r}. Accessor does not support static properties.`);
    const n = Object.getOwnPropertyDescriptor(e, r), s = nu(e, r);
    n && (n.get || n.set ? (s.get = n.get || s.get, s.set = n.set || s.set) : "value" in n && ("value" in t && nr.getLogger("esri.core.accessorSupport.decorators.property").warn(`@property() will redefine the value of "${r}" on "${e.constructor.name}" already defined in the metadata`, t), s.value = t.value = n.value)), t.readOnly != null && (s.readOnly = t.readOnly);
    const i = t.aliasOf;
    if (i) {
      const c = typeof i == "string" ? i : i.source, m = typeof i == "string" ? null : i.overridable === !0;
      let _;
      s.dependsOn = [c], s.get = function() {
        let y = js(this, c);
        if (typeof y == "function") {
          _ || (_ = c.split(".").slice(0, -1).join("."));
          const v = js(this, _);
          v && (y = y.bind(v));
        }
        return y;
      }, s.readOnly || (s.set = m ? function(y) {
        this._override(r, y);
      } : function(y) {
        Va(this, c, y);
      });
    }
    const u = t.type, l = t.types;
    if (!s.cast) {
      let c;
      u ? c = _v(u) : l && (c = Array.isArray(l) ? Ci(A0(l[0])) : A0(l)), t.cast = yv(t.cast, c);
    }
    cv(s, t), t.range && (s.cast = K4(s.cast, t.range));
  };
}
function zy(t, e, r) {
  const n = nu(t, r);
  n.json || (n.json = {});
  let s = n.json;
  return e !== void 0 && (s.origins || (s.origins = {}), s.origins[e] || (s.origins[e] = {}), s = s.origins[e]), s;
}
function _v(t) {
  let e = 0, r = t;
  if (ov(t)) return Iy(t);
  for (; Array.isArray(r) && r.length === 1 && typeof r[0] != "string" && typeof r[0] != "number"; ) r = r[0], e++;
  const n = r;
  if (Ry(n)) return e === 0 ? P0(n) : Fa(P0(n), e);
  if (e === 1) return sv(n);
  if (e > 1) return iv(n, e);
  const s = t;
  return s.from ? s.from : kn(s);
}
function yv(t, e) {
  if (t || e) return t ? e ? (r, n) => e(t(r, n), n) : t : e;
}
const jy = Symbol("Accessor-beforeDestroy"), cr = { INITIALIZING: 0, CONSTRUCTING: 1, CONSTRUCTED: 2, DESTROYING: 3, DESTROYED: 4 }, qe = { Dirty: 1, Overridden: 2, Computing: 4, NonNullable: 8, HasDefaultValue: 16, DepTrackingInitialized: 32, AutoTracked: 64, ExplicitlyTracking: 128 };
let su = class {
  constructor(e) {
    this.accessed = void 0, this._handles = void 0, this._observer = e;
  }
  destroy() {
    this.accessed?.clear(), this.clear();
  }
  onAccessed(e) {
    this._observer != null && e !== this._observer && (this.accessed == null && (this.accessed = /* @__PURE__ */ new Set()), this.accessed.add(e));
  }
  onTrackingEnd() {
    this._observer != null && (this.clear(), this.accessed != null && (this._handles == null && (this._handles = []), this.accessed.forEach((e) => {
      this._handles.push(e.observe(this._observer));
    }), this.accessed.clear()));
  }
  clear() {
    if (this._handles != null) {
      for (let e = 0; e < this._handles.length; ++e) this._handles[e].remove();
      this._handles.length = 0;
    }
  }
};
const za = new su(), bi = [];
let Ti = za;
function iu(t) {
  Ti.onAccessed(t);
}
let ra = !1, na = !1;
function Ws(t, e, r) {
  if (ra) return hh(t, e, r);
  let n = null;
  return Wy(t), n = e.call(r), Gy(), n;
}
function bv(t, e) {
  return Ws(za, t, e);
}
function hh(t, e, r) {
  const n = ra;
  ra = !0, Wy(t);
  let s = null;
  try {
    s = e.call(r);
  } catch (i) {
    na && nr.getLogger("esri.core.accessorSupport.tracking").error(i);
  }
  return Gy(), ra = n, s;
}
function Wy(t) {
  Ti = t, bi.push(t);
}
function Gy() {
  const t = bi.length;
  if (t > 1) {
    const e = bi.pop();
    Ti = bi[t - 2], e.onTrackingEnd();
  } else if (t === 1) {
    const e = bi.pop();
    Ti = za, e.onTrackingEnd();
  } else Ti = za;
}
function By(t, e) {
  if (e.flags & qe.DepTrackingInitialized) return;
  e.flags |= qe.DepTrackingInitialized;
  const r = na;
  na = !1, e.flags & qe.AutoTracked ? hh(e.trackingTarget, e.metadata.get, t) : qy(t, e), na = r;
}
const wv = [];
function qy(t, e) {
  e.flags & qe.ExplicitlyTracking || (e.flags |= qe.ExplicitlyTracking, hh(e.trackingTarget, () => {
    const r = e.metadata.dependsOn || wv;
    for (const n of r) if (typeof n != "string" || n.includes(".")) {
      const s = ky(n);
      for (let i = 0, u = t; i < s.length && u != null && typeof u == "object"; ++i) u = Yg(u, s[i], i !== s.length - 1);
    } else Yg(t, n, !1);
  }), e.flags &= -129);
}
function Yg(t, e, r) {
  const n = e.endsWith("?") ? e.slice(0, -1) : e;
  if (t.getItemAt != null || Array.isArray(t)) {
    const i = parseInt(n, 10);
    if (!isNaN(i)) return Array.isArray(t) ? t[i] : t.at(i);
  }
  const s = ji(t);
  if (s) {
    const i = s.propertiesByName.get(n);
    i && (iu(i), By(t, i));
  }
  return r ? t[n] : void 0;
}
function vv(t) {
  if (t.json && t.json.origins) {
    const e = t.json.origins, r = { "web-document": ["web-scene", "web-map"] };
    for (const n in r) if (e[n]) {
      const s = e[n];
      r[n].forEach((i) => {
        e[i] = s;
      }), delete e[n];
    }
  }
}
let Hy = class extends Uy {
  constructor(e, r, n) {
    super(e, r, n);
  }
};
Hy.prototype.type = "warning";
function Yy(t) {
  return !!t && t.prototype?.declaredClass && t.prototype.declaredClass.indexOf("esri.core.Collection") === 0;
}
function Sv(t, e) {
  return dh(t, "any", e?.origin);
}
function ja(t, e) {
  return dh(t, "read", e?.origin);
}
function Ev(t, e) {
  return dh(t, "write", e?.origin);
}
function dh(t, e, r) {
  let n = t?.json;
  if (n?.origins && r) {
    let s;
    s = r === "link-chart" ? n.origins[r] && (e === "any" || e in n.origins[r]) ? n.origins[r] : n.origins["web-map"] : n.origins[r], s && (e === "any" || e in s) && (n = s);
  }
  return n;
}
const O0 = () => nr.getLogger("esri.core.accessorSupport.extensions.serializableProperty.reader");
function Zg(t, e, r) {
  t && (!r && !e.read || e.read?.reader || e.read?.enabled === !1 || Pv(t) && Fi("read.reader", Nv(t), e));
}
function Nv(t) {
  const e = t.ndimArray ?? 0;
  if (e > 1) return Tv(t);
  if (e === 1) return Xg(t);
  if ("type" in t && Xy(t.type)) {
    const r = t.type.prototype?.itemType?.Type, n = Xg(typeof r == "function" ? { type: r } : { types: r });
    return (s, i, u) => {
      const l = n(s, i, u);
      return l && new t.type(l);
    };
  }
  return mh(t);
}
function mh(t) {
  return "type" in t ? xv(t.type) : Av(t.types);
}
function xv(t) {
  return t.prototype.read ? (e, r, n) => {
    if (e == null) return e;
    const s = typeof e;
    if (s !== "object") return void O0().error(`Expected JSON value of type 'object' to deserialize type '${t.prototype.declaredClass}', but got '${s}'`);
    const i = new t();
    return i.read(e, n), i;
  } : t.fromJSON;
}
function Zy(t, e, r, n) {
  return n !== 0 && Array.isArray(e) ? e.map((s) => Zy(t, s, r, n - 1)) : t(e, void 0, r);
}
function Tv(t) {
  const e = mh(t), r = Zy.bind(null, e), n = t.ndimArray ?? 0;
  return (s, i, u) => {
    if (s == null) return s;
    s = r(s, u, n);
    let l = n, c = s;
    for (; l > 0 && Array.isArray(c); ) l--, c = c[0];
    if (c !== void 0) for (let m = 0; m < l; m++) s = [s];
    return s;
  };
}
function Xg(t) {
  const e = mh(t);
  return (r, n, s) => {
    if (r == null) return r;
    if (Array.isArray(r)) {
      const u = [];
      for (const l of r) {
        const c = e(l, void 0, s);
        c !== void 0 && u.push(c);
      }
      return u;
    }
    const i = e(r, void 0, s);
    return i !== void 0 ? [i] : void 0;
  };
}
function Xy(t) {
  if (!Yy(t)) return !1;
  const e = t.prototype.itemType;
  return !(!e || !e.Type) && (typeof e.Type == "function" ? ph(e.Type) : Jy(e.Type));
}
function Pv(t) {
  return "types" in t ? Jy(t.types) : ph(t.type);
}
function ph(t) {
  return !Array.isArray(t) && !!t && t.prototype && ("read" in t.prototype || "fromJSON" in t || Xy(t));
}
function Jy(t) {
  for (const e in t.typeMap)
    if (!ph(t.typeMap[e])) return !1;
  return !0;
}
function Av(t) {
  let e = null;
  const r = t.errorContext ?? "type", n = t.validate;
  return (s, i, u) => {
    if (s == null) return s;
    const l = typeof s;
    if (l !== "object") return void O0().error(`Expected JSON value of type 'object' to deserialize, but got '${l}'`);
    e || (e = Mv(t));
    const c = t.key;
    if (typeof c != "string") return;
    const m = s[Lv(c, e, u)], _ = m ? e[m] : t.defaultKeyValue ? t.typeMap[t.defaultKeyValue] : void 0;
    if (!_) {
      const v = `Type '${m || "unknown"}' is not supported`;
      return u?.messages && s && u.messages.push(new Hy(`${r}:unsupported`, v, { definition: s, context: u })), void O0().error(v);
    }
    const y = new _();
    return y.read(s, u), n ? n(y) : y;
  };
}
function Lv(t, e, r) {
  const n = Object.values(e)[0], s = Js(n.prototype)[t], i = ja(s, r), u = i?.read?.source;
  return u && typeof u == "string" ? u : t;
}
function Mv(t) {
  const e = {};
  for (const r in t.typeMap) {
    const n = t.typeMap[r], s = Js(n.prototype);
    if (typeof t.key == "function") continue;
    const i = s[t.key];
    if (!i) continue;
    if (i.json?.type && Array.isArray(i.json.type) && i.json.type.length === 1 && typeof i.json.type[0] == "string") {
      e[i.json.type[0]] = n;
      continue;
    }
    const u = i.json?.write;
    if (!u?.writer) {
      e[r] = n;
      continue;
    }
    const l = u.target, c = typeof l == "string" ? l : t.key, m = {};
    u.writer(r, m, c), m[c] && (e[m[c]] = n);
  }
  return e;
}
function Ov(t) {
  if (t.json || (t.json = {}), Qg(t.json), Kg(t.json), Jg(t.json), t.json.origins) for (const e in t.json.origins) Qg(t.json.origins[e]), Kg(t.json.origins[e]), Jg(t.json.origins[e]);
  return !0;
}
function Jg(t) {
  t.name && (t.read && typeof t.read == "object" ? t.read.source === void 0 && (t.read.source = t.name) : t.read = { source: t.name }, t.write && typeof t.write == "object" ? t.write.target === void 0 && (t.write.target = t.name) : t.write = { target: t.name });
}
function Qg(t) {
  typeof t.read == "boolean" ? t.read = { enabled: t.read } : typeof t.read == "function" ? t.read = { enabled: !0, reader: t.read } : t.read && typeof t.read == "object" && t.read.enabled === void 0 && (t.read.enabled = !0);
}
function Kg(t) {
  typeof t.write == "boolean" ? t.write = { enabled: t.write } : typeof t.write == "function" ? t.write = { enabled: !0, writer: t.write } : t.write && typeof t.write == "object" && t.write.enabled === void 0 && (t.write.enabled = !0);
}
function e2(t, e) {
  if (!e.write || e.write.writer || e.write.enabled === !1 && !e.write.overridePolicy) return;
  const r = t?.ndimArray ?? 0;
  t && (r === 1 || "type" in t && Yy(t.type)) ? e.write.writer = kv : r > 1 ? e.write.writer = Dv(r) : e.types ? Array.isArray(e.types) ? e.write.writer = Rv(e.types[0]) : e.write.writer = Cv(e.types) : e.write.writer = Ri;
}
function Cv(t) {
  return (e, r, n, s) => e ? Qy(e, t, s) ? Ri(e, r, n, s) : void 0 : Ri(e, r, n, s);
}
function Qy(t, e, r) {
  for (const n in e.typeMap) if (t instanceof e.typeMap[n]) return !0;
  if (r?.messages) {
    const n = e.errorContext ?? "type", s = `Values of type '${(typeof e.key != "function" ? t[e.key] : t.declaredClass) ?? "Unknown"}' cannot be written`;
    r && r.messages && t && r.messages.push(new Qs(`${n}:unsupported`, s, { definition: t, context: r })), nr.getLogger("esri.core.accessorSupport.extensions.serializableProperty.writer").error(s);
  }
  return !1;
}
function Rv(t) {
  return (e, r, n, s) => !e || !Array.isArray(e) ? Ri(e, r, n, s) : Ri(e.filter((i) => Qy(i, t, s)), r, n, s);
}
function Ri(t, e, r, n) {
  Fi(r, Wa(t, n), e);
}
function Wa(t, e) {
  return t && typeof t.write == "function" ? t.write({}, e) : t && typeof t.toJSON == "function" ? t.toJSON() : typeof t == "number" ? Iv(t) : t;
}
function Iv(t) {
  return t === -1 / 0 ? -Number.MAX_VALUE : t === 1 / 0 ? Number.MAX_VALUE : isNaN(t) ? null : t;
}
function kv(t, e, r, n) {
  let s;
  t === null ? s = null : t && typeof t.map == "function" ? (s = t.map((i) => Wa(i, n)), typeof s.toArray == "function" && (s = s.toArray())) : s = [Wa(t, n)], Fi(r, s, e);
}
function Ky(t, e, r) {
  return r !== 0 && Array.isArray(t) ? t.map((n) => Ky(n, e, r - 1)) : Wa(t, e);
}
function Dv(t) {
  return (e, r, n, s) => {
    let i;
    if (e === null) i = null;
    else {
      i = Ky(e, s, t);
      let u = t, l = i;
      for (; u > 0 && Array.isArray(l); ) u--, l = l[0];
      if (l !== void 0) for (let c = 0; c < u; c++) i = [i];
    }
    Fi(n, i, r);
  };
}
function $v(t) {
  const e = Fv(t);
  if (t.json.origins) for (const r in t.json.origins) {
    const n = t.json.origins[r], s = n.types ? Uv(n) : e;
    Zg(s, n, !1), n.types && !n.write && t.json.write?.enabled && (n.write = { ...t.json.write }), e2(s, n);
  }
  Zg(e, t.json, !0), e2(e, t.json);
}
function Fv(t) {
  return t.json.types ? C0(t.json) : t.type ? e3(t) : C0(t);
}
function Uv(t) {
  return t.type ? e3(t) : C0(t);
}
function e3(t) {
  if (!t.type) return;
  let e = 0, r = t.type;
  for (; Array.isArray(r) && !Ry(r); ) r = r[0], e++;
  return { type: r, ndimArray: e };
}
function C0(t) {
  if (!t.types) return;
  let e = 0, r = t.types;
  for (; Array.isArray(r); ) r = r[0], e++;
  return { types: r, ndimArray: e };
}
function Vv(t) {
  Ov(t) && (vv(t), $v(t));
}
const l1 = /* @__PURE__ */ new Set(), c1 = /* @__PURE__ */ new Set();
function Ks(t) {
  return (e) => {
    t ??= "esri.core.Accessor", e.prototype.declaredClass = t, jv(e);
    const r = [], n = [];
    let s = e.prototype;
    for (; s; ) s.hasOwnProperty("initialize") && !l1.has(s.initialize) && (l1.add(s.initialize), r.push(s.initialize)), s.hasOwnProperty("destroy") && !c1.has(s.destroy) && (c1.add(s.destroy), n.push(s.destroy)), s = Object.getPrototypeOf(s);
    l1.clear(), c1.clear();
    const i = class extends e {
      constructor(...l) {
        if (super(...l), this.constructor === i && typeof this.postscript == "function") {
          if (r.length && Object.defineProperty(this, "initialize", { enumerable: !1, configurable: !0, value() {
            for (let c = r.length - 1; c >= 0; c--) r[c].call(this);
          } }), n.length) {
            let c = !1;
            const m = this[jy];
            Object.defineProperty(this, "destroy", { enumerable: !1, configurable: !0, value() {
              if (!c) {
                this.__accessor__.lifecycle = cr.DESTROYING, c = !0, m.call(this);
                for (let _ = 0; _ < n.length; _++) n[_].call(this);
              }
            } });
          }
          Object.defineProperty(this, Symbol.dispose, { enumerable: !1, configurable: !0, value() {
            this.destroy();
          } }), this.postscript();
        }
      }
    };
    i.__accessorMetadata__ = Js(e.prototype), i.prototype.declaredClass = t;
    const u = (t || "AccessorSubclass").split(".").slice(-1)[0];
    return Object.defineProperty(i, "name", { value: u, configurable: !0 }), i;
  };
}
function zv(t, e) {
  return e.get == null ? function() {
    const r = this.__accessor__, n = r.propertiesByName.get(t);
    if (n === void 0) return;
    r.mutable && iu(n);
    const s = r.store;
    return s.has(t) ? s.get(t) : n.metadata.value;
  } : function() {
    const r = this.__accessor__, n = r.propertiesByName.get(t);
    if (n !== void 0) return n.getComputed(r);
  };
}
function jv(t) {
  const e = t.prototype, r = Js(e), n = {};
  for (const s of Object.getOwnPropertyNames(r)) {
    const i = r[s];
    Vv(i), n[s] = { enumerable: !0, configurable: !0, get: zv(s, i), set(u) {
      const l = this.__accessor__;
      if (l !== void 0) {
        if (l.mutable) return l.initialized && i.readOnly ? t2("read-only", s) : l.lifecycle === cr.CONSTRUCTED && i.constructOnly ? t2("construct-only", s) : void l.set(s, u);
      } else Object.defineProperty(this, s, { enumerable: !0, configurable: !0, writable: !0, value: u });
    } };
  }
  Object.defineProperties(t.prototype, n);
}
const t2 = (t, e) => {
  nr.getLogger("esri.core.Accessor").error(`cannot assign to ${t} property '${e}'`);
}, r2 = /* @__PURE__ */ new WeakMap();
function Wv(t, e, r = !1) {
  const n = `🛑 DEPRECATED - ${e}`;
  if (!r) return void t.warn(n);
  let s = r2.get(t);
  s || (s = /* @__PURE__ */ new Set(), r2.set(t, s)), s.has(e) || (s.add(e), t.warn(n));
}
function Gv(t, e, r = {}) {
  if (F("esri-deprecation-warnings")) {
    const { moduleName: n } = r;
    Bv(t, `Function: ${(n ? n + "::" : "") + e + "()"}`, r);
  }
}
function Bv(t, e, r = {}) {
  if (F("esri-deprecation-warnings")) {
    const { replacement: n, version: s, see: i, warnOnce: u } = r;
    let l = e;
    if (n && (l += `
	🛠️ Replacement: ${n}`), s && (l += `
	⚙️ Version: ${s}`), i) if (Array.isArray(i)) {
      l += `
	🔗 See for more details:`;
      for (const c of i) l += `
		${c}`;
    } else l += `
	🔗 See ${i} for more details.`;
    Wv(t, l, u);
  }
}
function n2(t) {
  return t != null && typeof t[Symbol.iterator] == "function";
}
let gh = class {
  constructor() {
    this._groups = /* @__PURE__ */ new Map();
  }
  destroy() {
    this.removeAll();
  }
  get size() {
    let e = 0;
    return this._groups.forEach((r) => {
      e += r.length;
    }), e;
  }
  add(e, r) {
    if (n2(e)) {
      const n = this._getOrCreateGroup(r);
      for (const s of e) i2(s) && n.push(s);
    } else i2(e) && this._getOrCreateGroup(r).push(e);
    return this;
  }
  forEach(e, r) {
    if (typeof e == "function") this._groups.forEach((n) => n.forEach(e));
    else {
      const n = this._getGroup(e);
      n && r && n.forEach(r);
    }
  }
  has(e) {
    return this._groups.has(Fo(e));
  }
  remove(e) {
    if (typeof e != "string" && n2(e)) {
      for (const r of e) this.remove(r);
      return this;
    }
    return this.has(e) ? (s2(this._getGroup(e)), this._groups.delete(Fo(e)), this) : this;
  }
  removeAll() {
    return this._groups.forEach(s2), this._groups.clear(), this;
  }
  removeReference(e) {
    return this._groups.delete(e), this;
  }
  _getOrCreateGroup(e) {
    if (this.has(e)) return this._getGroup(e);
    const r = [];
    return this._groups.set(Fo(e), r), r;
  }
  _getGroup(e) {
    return this._groups.get(Fo(e));
  }
};
function Fo(t) {
  return t || "_default_";
}
function s2(t) {
  for (const e of t) e instanceof gh ? e.removeAll() : e.remove();
}
function i2(t) {
  return t != null && (!!t.remove || t instanceof gh);
}
function qv(t) {
  return t?.destroy(), null;
}
function Hv(t) {
  return t?.release && typeof t.release == "function";
}
function Yv(t) {
  return t?.acquire && typeof t.acquire == "function";
}
let _h = class R0 {
  constructor(e, r, n, s = 1, i = 0) {
    this._creator = e, this._acquireFunction = r, this._releaseFunction = n, this.allocationSize = s, this._pool = new Array(i), this._initialSize = i;
    for (let u = 0; u < i; u++) this._pool[u] = this._creator();
    this.allocationSize = Math.max(s, 1);
  }
  destroy() {
    this.prune(0);
  }
  acquire(...e) {
    let r;
    if (R0.test.disabled) r = this._creator();
    else {
      if (this._pool.length === 0) {
        const n = this.allocationSize;
        for (let s = 0; s < n; s++) this._pool[s] = this._creator();
      }
      r = this._pool.pop();
    }
    return this._acquireFunction ? this._acquireFunction(r, ...e) : Yv(r) && r.acquire(...e), r;
  }
  release(e) {
    e && !R0.test.disabled && (this._releaseFunction ? this._releaseFunction(e) : Hv(e) && e.release(), this._pool.push(e));
  }
  prune(e = this._initialSize) {
    if (!(e >= this._pool.length)) {
      for (let r = e; r < this._pool.length; ++r) {
        const n = this._pool[r];
        this._dispose(n);
      }
      this._pool.length = e;
    }
  }
  _dispose(e) {
    e.dispose && typeof e.dispose == "function" && e.dispose();
  }
  static {
    this.test = { disabled: !!F("esri-tests-disable-memory-pools") };
  }
}, Zv = class {
  constructor(e, r) {
    this._observers = e, this._observer = r;
  }
  remove() {
    y7(this._observers, this._observer);
  }
}, Xv = class {
  constructor() {
    this._observers = null, this.destroyed = !1;
  }
  observe(e) {
    if (this.destroyed || e.destroyed) return Jv;
    this._observers == null && (this._observers = []);
    const r = this._observers;
    let n = !1, s = !1;
    const i = r.length;
    for (let u = 0; u < i; ++u) {
      const l = r[u];
      if (l.destroyed) s = !0;
      else if (l === e) {
        n = !0;
        break;
      }
    }
    return n || (r.push(e), s && this._removeDestroyedObservers()), new Zv(r, e);
  }
  _removeDestroyedObservers() {
    const e = this._observers;
    if (!e || e.length === 0) return;
    const r = e.length;
    let n = 0;
    for (let s = 0; s < r; ++s) {
      for (; s + n < r && e[s + n].destroyed; )
        ++n;
      if (n > 0) {
        if (!(s + n < r)) break;
        e[s] = e[s + n];
      }
    }
    e.length = r - n;
  }
  destroy() {
    if (this.destroyed) return;
    this.destroyed = !0;
    const e = this._observers;
    if (e != null) {
      for (const r of e) r.onCommitted();
      this._observers = null;
    }
  }
};
const Jv = Xs();
let o2 = class extends Xv {
  constructor(e, r) {
    super(), this.propertyName = e, this.metadata = r, this.trackingTarget = new su(this), this.flags = 0, this.flags = qe.Dirty | (r.nonNullable ? qe.NonNullable : 0) | (r.hasOwnProperty("value") ? qe.HasDefaultValue : 0) | (r.get === void 0 ? qe.DepTrackingInitialized : 0) | (r.dependsOn === void 0 ? qe.AutoTracked : 0);
  }
  destroy() {
    this.flags & qe.Dirty && this.onCommitted(), super.destroy(), this.trackingTarget.destroy();
  }
  getComputed(e) {
    e.mutable && iu(this);
    const r = e.store, n = this.propertyName, s = this.flags, i = r.get(n);
    if (s & qe.Computing || ~s & qe.Dirty && r.has(n)) return i;
    this.flags |= qe.Computing;
    const u = e.host;
    let l;
    s & qe.AutoTracked ? l = Ws(this.trackingTarget, this.metadata.get, u) : (qy(u, this), l = this.metadata.get.call(u)), this.flags |= qe.DepTrackingInitialized, r.set(n, l, 1);
    const c = r.get(n);
    return c === i ? this.flags &= -2 : bv(this.commit, this), this.flags &= -5, c;
  }
  notifyChange() {
    this.onInvalidated(), this.onCommitted();
  }
  invalidate() {
    this.onInvalidated();
  }
  commit() {
    this.flags &= -2, this.onCommitted();
  }
  onInvalidated() {
    ~this.flags & qe.Overridden && (this.flags |= qe.Dirty);
    const e = this._observers;
    if (e && e.length > 0) for (const r of e) r.onInvalidated();
  }
  onCommitted() {
    const e = this._observers;
    if (e && e.length > 0) {
      const r = e.slice();
      for (const n of r) n.onCommitted();
    }
  }
};
function t3(t) {
  switch (t) {
    case "defaults":
      return 0;
    case "service":
      return 2;
    case "portal-item":
      return 3;
    case "web-scene":
      return 4;
    case "web-map":
      return 5;
    case "link-chart":
      return 6;
    case "user":
      return 7;
    default:
      return null;
  }
}
function I0(t) {
  switch (t) {
    case 0:
      return "defaults";
    case 2:
      return "service";
    case 3:
      return "portal-item";
    case 4:
      return "web-scene";
    case 5:
      return "web-map";
    case 6:
      return "link-chart";
    case 7:
      return "user";
  }
}
function Qv(t) {
  return I0(t);
}
let Kv = class r3 {
  constructor() {
    this._values = /* @__PURE__ */ new Map(), this.multipleOriginsSupported = !1;
  }
  clone(e) {
    const r = new r3();
    return this._values.forEach((n, s) => {
      e && e.has(s) || r.set(s, pr(n));
    }), r;
  }
  get(e) {
    return this._values.get(e);
  }
  originOf() {
    return 7;
  }
  keys() {
    return [...this._values.keys()];
  }
  set(e, r) {
    this._values.set(e, r);
  }
  delete(e) {
    this._values.delete(e);
  }
  has(e) {
    return this._values.has(e);
  }
  isAtOrigin(e, r) {
    return this.has(e);
  }
  isBelowOrigin(e, r) {
    return !this.has(e);
  }
  forEach(e) {
    this._values.forEach(e);
  }
};
function ws(t, e, r) {
  return t !== void 0;
}
function a2(t, e, r, n) {
  return t !== void 0 && (!(r == null && t.flags & qe.NonNullable) || (n.lifecycle, !1));
}
let eS = class {
  constructor(e) {
    this.host = e, this.propertiesByName = /* @__PURE__ */ new Map(), this.ctorArgs = null, this.lifecycle = cr.INITIALIZING, this.store = new Kv(), this.mutable = !0, this._origin = 7;
    const r = this.host.constructor.__accessorMetadata__;
    for (const n in r) {
      const s = new o2(n, r[n]);
      this.propertiesByName.set(n, s);
    }
    this.metadata = r;
  }
  initialize() {
    this.lifecycle = cr.CONSTRUCTING;
  }
  constructed() {
    this.lifecycle = cr.CONSTRUCTED;
  }
  destroy() {
    this.lifecycle = cr.DESTROYED, this.propertiesByName.forEach((e) => e.destroy());
  }
  get initialized() {
    return this.lifecycle !== cr.INITIALIZING;
  }
  get(e) {
    const r = this.propertiesByName.get(e);
    if (!ws(r)) return;
    if (r.metadata.get) return r.getComputed(this);
    this.mutable && iu(r);
    const n = this.store;
    return n.has(e) ? n.get(e) : r.metadata.value;
  }
  originOf(e) {
    const r = this.store.originOf(e);
    if (r === void 0) {
      const n = this.propertiesByName.get(e);
      if (n !== void 0 && n.flags & qe.HasDefaultValue) return "defaults";
    }
    return I0(r);
  }
  has(e) {
    return this.propertiesByName.has(e) && this.store.has(e);
  }
  keys() {
    return [...this.propertiesByName.keys()];
  }
  internalGet(e) {
    const r = this.propertiesByName.get(e);
    if (ws(r)) return this.store.has(e) ? this.store.get(e) : r.metadata.value;
  }
  internalSet(e, r) {
    const n = this.propertiesByName.get(e);
    ws(n) && this._internalSet(n, r);
  }
  getDependsInfo(e, r, n) {
    const s = this.propertiesByName.get(r);
    if (!ws(s)) return "";
    const i = new su(), u = Ws(i, () => s.metadata.get?.call(e));
    let l = `${n}${e.declaredClass.split(".").pop()}.${r}: ${u}
`;
    const c = i.accessed ?? /* @__PURE__ */ new Set();
    if (c.size === 0) return l;
    n += "  ";
    for (const m of c)
      m instanceof o2 && (l += `${n}${m.propertyName}: undefined
`);
    return l;
  }
  setAtOrigin(e, r, n) {
    const s = this.propertiesByName.get(e);
    if (ws(s)) return this._setAtOrigin(s, r, n);
  }
  isOverridden(e) {
    const r = this.propertiesByName.get(e);
    return r !== void 0 && !!(r.flags & qe.Overridden);
  }
  clearOrigin(e, r) {
    const n = this.store, s = this.propertiesByName.get(e);
    if (!ws(s)) return;
    const i = n.isAtOrigin(e, r) && !(s.flags & qe.Overridden);
    n.delete(e, r), i && s.notifyChange();
  }
  clearOverride(e) {
    const r = this.propertiesByName.get(e);
    r && r.flags & qe.Overridden && (r.flags &= -3, r.notifyChange());
  }
  override(e, r) {
    const n = this.propertiesByName.get(e);
    if (!a2(n, e, r, this)) return;
    const s = n.metadata.cast;
    if (s) {
      const i = this._cast(s, r), { valid: u, value: l } = i;
      if (f1.release(i), !u) return;
      r = l;
    }
    n.flags |= qe.Overridden, this._internalSet(n, r);
  }
  set(e, r) {
    const n = this.propertiesByName.get(e);
    if (!a2(n, e, r, this)) return;
    const s = n.metadata.cast;
    if (s) {
      const u = this._cast(s, r), { valid: l, value: c } = u;
      if (f1.release(u), !l) return;
      r = c;
    }
    const i = n.metadata.set;
    i ? i.call(this.host, r) : this._internalSet(n, r);
  }
  setDefaultOrigin(e) {
    this._origin = t3(e);
  }
  getDefaultOrigin() {
    return I0(this._origin);
  }
  notifyChange(e) {
    const r = this.propertiesByName.get(e);
    r !== void 0 && r.notifyChange();
  }
  invalidate(e) {
    const r = this.propertiesByName.get(e);
    r !== void 0 && r.invalidate();
  }
  commit(e) {
    const r = this.propertiesByName.get(e);
    r !== void 0 && r.commit();
  }
  _internalSet(e, r) {
    const n = this.lifecycle !== cr.INITIALIZING ? this._origin : 0;
    this._setAtOrigin(e, r, n);
  }
  _setAtOrigin(e, r, n) {
    const s = this.store, i = e.propertyName;
    if (s.isAtOrigin(i, n) && rh(r, s.get(i)) && ~e.flags & qe.Overridden) return;
    const u = s.isBelowOrigin(i, n) || s.isAtOrigin(i, n);
    u && e.invalidate(), s.set(i, r, n), u && e.commit(), By(this.host, e);
  }
  _cast(e, r) {
    const n = f1.acquire();
    return n.valid = !0, n.value = r, e && (n.value = e.call(this.host, r, n)), n;
  }
}, tS = class {
  constructor() {
    this.value = null, this.valid = !0;
  }
  acquire() {
    this.valid = !0;
  }
  release() {
    this.value = null;
  }
};
const f1 = new _h(() => new tS());
let rS;
function nS() {
  return rS;
}
function sS(t) {
  t.length = 0;
}
let n3 = class {
  constructor(e = 50, r = 50) {
    this._pool = new _h(() => [], void 0, sS, r, e);
  }
  acquire() {
    return this._pool.acquire();
  }
  release(e) {
    this._pool.release(e);
  }
  prune() {
    this._pool.prune(0);
  }
  static acquire() {
    return h1.acquire();
  }
  static release(e) {
    return h1.release(e);
  }
  static prune() {
    h1.prune();
  }
};
const h1 = new n3(100);
let iS = class extends _h {
  constructor() {
    super(...arguments), this._set = /* @__PURE__ */ new Set();
  }
  destroy() {
    super.destroy(), this._set = null;
  }
  acquire(...e) {
    const r = super.acquire(...e);
    return this._set.delete(r), r;
  }
  release(e) {
    e && !this._set.has(e) && (super.release(e), this._set.add(e));
  }
  _dispose(e) {
    this._set.delete(e), super._dispose(e);
  }
};
const Uo = [];
function oS(t) {
  Uo.push(t), Uo.length === 1 && queueMicrotask(() => {
    const e = Uo.slice();
    Uo.length = 0;
    for (const r of e) r();
  });
}
let s3 = class {
  constructor(e, r = 30) {
    this.name = e, this._counter = 0, this._samples = new Array(r);
  }
  push(e) {
    e != null && (this._samples[++this._counter % this._samples.length] = e);
  }
  set(e) {
    e != null && (this._samples[this._counter % this._samples.length] = e);
  }
  get median() {
    return this._samples.slice().sort((e, r) => e - r)[Math.floor(this._samples.length / 2)];
  }
  get average() {
    return this._samples.reduce((e, r) => e + r, 0) / this._samples.length;
  }
  get last() {
    return this._samples[this._counter % this._samples.length];
  }
}, aS = class {
  constructor(e) {
    this.callback = e, this.isActive = !0;
  }
  remove() {
    this.isActive = !1;
  }
};
const uS = ["prepare", "preRender", "render", "postRender", "update", "finish"], k0 = [], D0 = { willDispatch: !1 };
function lS(t) {
  const e = new aS(t);
  return k0.push(e), D0.willDispatch || (D0.willDispatch = !0, oS(cS)), e;
}
function cS() {
  for (; k0.length; ) {
    const t = k0.shift();
    t.isActive && t.callback();
  }
  D0.willDispatch = !1;
}
uS.map((t) => new s3(t));
new s3("total");
let fS = 0;
function d1() {
  return ++fS;
}
let i3 = class extends su {
  constructor(e) {
    super(new hS(e)), this._observer && u2.register(this, new WeakRef(this._observer), this);
  }
  destroy() {
    this._observer && u2.unregister(this._observer), this.accessed?.clear(), this.clear(), this._observer?.destroy();
  }
}, hS = class {
  constructor(e) {
    this._notify = e, this._invalidCount = 0, this.destroyed = !1;
  }
  onInvalidated() {
    this._invalidCount++;
  }
  onCommitted() {
    if (this.destroyed) return;
    const e = this._invalidCount;
    if (e === 1) return this._invalidCount = 0, void this._notify();
    this._invalidCount = e > 0 ? e - 1 : 0;
  }
  destroy() {
    this.destroyed = !0, this._notify = dS;
  }
};
const u2 = new FinalizationRegistry((t) => {
  t.deref()?.destroy();
});
function dS() {
}
let m1 = !1;
const Ga = [];
function mS(t, e) {
  let r = new i3(i), n = null, s = !1;
  function i() {
    if (!r || s) return;
    if (m1) return void gS(i);
    const l = n;
    r.clear(), m1 = !0, s = !0, n = Ws(r, t), s = !1, m1 = !1, e(n, l), _S();
  }
  function u() {
    r && (r.destroy(), r = null, n = null);
  }
  return s = !0, n = Ws(r, t), s = !1, Xs(u);
}
function pS(t, e) {
  let r = new i3(s), n = null;
  function s() {
    e(n, u);
  }
  function i() {
    r && (r.destroy(), r = null), n = null;
  }
  function u() {
    return r ? (r.clear(), n = Ws(r, t), n) : null;
  }
  return u(), Xs(i);
}
function gS(t) {
  Ga.includes(t) || Ga.unshift(t);
}
function _S() {
  for (; Ga.length; ) Ga.pop()();
}
let o3 = class a3 {
  constructor() {
    this.uid = d1(), this.removed = !1, this.type = null, this.oldValue = null, this.callback = null, this.getValue = null, this.target = null, this.path = null, this.equals = null;
  }
  static {
    this.pool = new iS(() => new a3());
  }
  static acquireUntracked(e, r, n, s, i) {
    return this.pool.acquire(0, e, r, n, s, i, rh);
  }
  static acquireTracked(e, r, n, s) {
    return this.pool.acquire(1, e, r, n, null, null, s);
  }
  notify(e, r) {
    this.type === 0 ? this.callback.call(this.target, e, r, this.path, this.target) : this.callback.call(null, e, r, void 0, void 0);
  }
  acquire(e, r, n, s, i, u, l) {
    this.uid = d1(), this.removed = !1, this.type = e, this.oldValue = r, this.callback = n, this.getValue = s, this.target = i, this.path = u, this.equals = l;
  }
  release() {
    this.target = this.path = this.oldValue = this.callback = this.getValue = null, this.uid = d1(), this.removed = !0;
  }
};
const sa = new n3(), In = /* @__PURE__ */ new Set();
let Ba;
function l2(t) {
  In.delete(t), In.add(t), yS();
}
function yS() {
  Ba || (Ba = lS(vS));
}
function bS(t) {
  if (t.removed) return;
  const e = t.oldValue, r = t.getValue();
  t.equals(e, r) || (t.oldValue = r, t.notify(r, e));
}
function wS(t) {
  for (const e of In.values()) e.target === t && (e.removed = !0);
}
function vS() {
  let t = 10;
  for (; Ba && t--; ) {
    Ba = null;
    const e = SS(), r = sa.acquire();
    for (const n of e) {
      const s = n.uid;
      bS(n), s === n.uid && n.removed && r.push(n);
    }
    for (const n of In) n.removed && (r.push(n), In.delete(n));
    for (const n of r) o3.pool.release(n);
    sa.release(r), sa.release(e), ES.forEach((n) => n());
  }
}
function SS() {
  const t = sa.acquire();
  t.length = In.size;
  let e = 0;
  for (const r of In) t[e] = r, ++e;
  return In.clear(), t;
}
const ES = /* @__PURE__ */ new Set();
function NS(t, e, r) {
  let n = Dy(t, e, r, (s, i, u) => {
    let l, c, m = pS(() => Wi(s, i), (_, y) => {
      s.__accessor__?.lifecycle === cr.DESTROYED || l && l.uid !== c ? n.remove() : (l || (l = o3.acquireUntracked(_, u, y, s, i), c = l.uid), l2(l));
    });
    return Xs(() => {
      m.remove(), l && (l.uid !== c || l.removed || (l.removed = !0, l2(l)), l = null), n = m = null;
    });
  });
  return n;
}
function xS(t, e, r) {
  const n = Dy(t, e, r, (s, i, u) => {
    let l = !1;
    return mS(() => Wi(s, i), (c, m) => {
      s.__accessor__.lifecycle !== cr.DESTROYED ? l || (l = !0, rh(m, c) || u.call(s, c, m, i, s), l = !1) : n.remove();
    });
  });
  return n;
}
function TS(t, e, r, n = !1) {
  return t.__accessor__ && t.__accessor__.lifecycle !== cr.DESTROYED ? n ? xS(t, e, r) : NS(t, e, r) : Xs();
}
var c2, f2;
function PS(t) {
  if (t == null) return { value: t };
  if (Array.isArray(t)) return { type: [t[0]], value: null };
  switch (typeof t) {
    case "object":
      return t.constructor?.__accessorMetadata__ || t instanceof Date ? { type: t.constructor, value: t } : t;
    case "boolean":
      return { type: Boolean, value: t };
    case "string":
      return { type: String, value: t };
    case "number":
      return { type: Number, value: t };
    case "function":
      return { type: t, value: null };
    default:
      return;
  }
}
const yn = Symbol("Accessor-Handles"), p1 = Symbol("Accessor-Initialized");
let Ms = class ia {
  static {
    c2 = yn, f2 = p1;
  }
  static createSubclass(e = {}) {
    if (Array.isArray(e)) throw new Error("Multi-inheritance unsupported since 4.16");
    const { properties: r, declaredClass: n, constructor: s } = e;
    delete e.declaredClass, delete e.properties, delete e.constructor;
    const i = this;
    class u extends i {
      constructor(...c) {
        super(...c), this.inherited = null, s && s.apply(this, c);
      }
    }
    Js(u.prototype);
    for (const l in e) {
      const c = e[l];
      u.prototype[l] = typeof c == "function" ? function(...m) {
        const _ = this.inherited;
        let y;
        this.inherited = function(...v) {
          if (i.prototype[l]) return i.prototype[l].apply(this, v);
        };
        try {
          y = c.apply(this, m);
        } catch (v) {
          throw this.inherited = _, v;
        }
        return this.inherited = _, y;
      } : e[l];
    }
    for (const l in r) {
      const c = PS(r[l]);
      _e(c)(u.prototype, l);
    }
    return Ks(n)(u);
  }
  static freeze(e) {
    return e instanceof ia ? e.__accessor__.mutable = !1 : Object.freeze(e), e;
  }
  static isFrozen(e) {
    return e instanceof ia ? !e.__accessor__.mutable : Object.isFrozen(e);
  }
  constructor(...e) {
    if (this[c2] = null, this[f2] = !1, this.constructor === ia) throw new Error("[accessor] cannot instantiate Accessor. This can be fixed by creating a subclass of Accessor");
    const r = new eS(this);
    Object.defineProperty(this, "__accessor__", { enumerable: !1, value: r }), e.length > 0 && (r.ctorArgs = this.normalizeCtorArgs?.apply(this, e) ?? e[0]);
  }
  postscript() {
    const e = this.__accessor__, r = e.ctorArgs;
    e.initialize(), r && (this.set(r), e.ctorArgs = null), e.constructed(), this.initialize(), this[p1] = !0;
  }
  initialize() {
  }
  [jy]() {
    this[yn] = qv(this[yn]);
  }
  destroy() {
    this.destroyed || (wS(this), this.__accessor__.destroy(), nS()?.onInstanceDestroy(this));
  }
  [Symbol.dispose]() {
    this.destroy();
  }
  get constructed() {
    return this.__accessor__ && this.__accessor__.initialized || !1;
  }
  get initialized() {
    return this[p1];
  }
  get destroyed() {
    return this.__accessor__?.lifecycle === cr.DESTROYED || !1;
  }
  get destroying() {
    return this.__accessor__?.lifecycle === cr.DESTROYING || !1;
  }
  commitProperty(e) {
    js(this, e);
  }
  hasOwnProperty(e) {
    return this.__accessor__ ? this.__accessor__.has(e) : Object.prototype.hasOwnProperty.call(this, e);
  }
  keys() {
    return this.__accessor__ ? this.__accessor__.keys() : [];
  }
  set(e, r) {
    return Va(this, e, r), this;
  }
  watch(e, r, n) {
    return Gv(nr.getLogger(this), "`watch` is deprecated in favor of reactiveUtils.watch", { replacement: "reactiveUtils.watch", version: "4.32", see: "https://arcg.is/1vaqf42#watch", warnOnce: !0 }), TS(this, e, r, n);
  }
  addHandles(e, r) {
    if (this.destroyed) {
      const n = Array.isArray(e) ? e : [e];
      for (const s of n) s.remove();
      return;
    }
    (this[yn] ??= new gh()).add(e, r);
  }
  removeHandles(e) {
    this[yn]?.remove(e);
  }
  removeAllHandles() {
    this[yn]?.removeAll();
  }
  removeHandlesReference(e) {
    this[yn]?.removeReference(e);
  }
  hasHandles(e) {
    return this[yn]?.has(e) === !0;
  }
  _override(e, r) {
    r === void 0 ? this.__accessor__.clearOverride(e) : this.__accessor__.override(e, r);
  }
  _clearOverride(e) {
    return this.__accessor__.clearOverride(e);
  }
  _overrideIfSome(e, r) {
    r == null ? this.__accessor__.clearOverride(e) : this.__accessor__.override(e, r);
  }
  _isOverridden(e) {
    return this.__accessor__.isOverridden(e);
  }
  notifyChange(e) {
    this.__accessor__.notifyChange(e);
  }
  _get(e) {
    return this.__accessor__.internalGet(e);
  }
  _set(e, r) {
    return this.__accessor__.internalSet(e, r), this;
  }
}, AS = class u3 {
  constructor() {
    this._values = /* @__PURE__ */ new Map(), this.multipleOriginsSupported = !1;
  }
  clone(e) {
    const r = new u3();
    return this._values.forEach((n, s) => {
      e && e.has(s) || r.set(s, pr(n.value), n.origin);
    }), r;
  }
  get(e, r) {
    r = this._normalizeOrigin(r);
    const n = this._values.get(e);
    return r == null || n?.origin === r ? n?.value : void 0;
  }
  originOf(e) {
    return this._values.get(e)?.origin ?? 7;
  }
  keys(e) {
    e = this._normalizeOrigin(e);
    const r = [...this._values.keys()];
    return e == null ? r : r.filter((n) => this._values.get(n)?.origin === e);
  }
  set(e, r, n) {
    if ((n = this._normalizeOrigin(n)) === 0) {
      const s = this._values.get(e);
      if (s?.origin != null && s.origin > n) return;
    }
    this._values.set(e, new LS(r, n));
  }
  delete(e, r) {
    (r = this._normalizeOrigin(r)) != null && this._values.get(e)?.origin !== r || this._values.delete(e);
  }
  has(e, r) {
    return (r = this._normalizeOrigin(r)) != null ? this._values.get(e)?.origin === r : this._values.has(e);
  }
  isAtOrigin(e, r) {
    return r = this._normalizeOrigin(r), this.has(e, r) && this.originOf(e) === r;
  }
  isBelowOrigin(e, r) {
    return r = this._normalizeOrigin(r), !this.has(e) || this.originOf(e) < r;
  }
  forEach(e) {
    this._values.forEach(({ value: r }, n) => e(r, n));
  }
  _normalizeOrigin(e) {
    if (e != null) return e === 0 ? e : 7;
  }
}, LS = class {
  constructor(e, r) {
    this.value = e, this.origin = r;
  }
};
function MS(t, e, r) {
  e.keys().forEach((s) => {
    r.set(s, e.get(s), 0);
  });
  const n = t.metadata;
  Object.keys(n).forEach((s) => {
    t.internalGet(s) && r.set(s, t.internalGet(s), 0);
  });
}
function OS(t, e, r) {
  if (!t?.read || t.read.enabled === !1 || !t.read.source) return !1;
  const n = t.read.source;
  if (typeof n == "string") {
    if (n === e || n.includes(".") && n.startsWith(e) && Hg(n, r)) return !0;
  } else for (const s of n)
    if (s === e || s.includes(".") && s.startsWith(e) && Hg(s, r)) return !0;
  return !1;
}
function CS(t) {
  return t && (!t.read || t.read.enabled !== !1 && !t.read.source);
}
function RS(t, e, r, n, s) {
  let i = ja(e[r], s);
  CS(i) && (t[r] = !0);
  for (const u of Object.getOwnPropertyNames(e)) i = ja(e[u], s), OS(i, r, n) && (t[u] = !0);
}
function IS(t, e, r, n) {
  const s = r.metadata, i = Sv(s[e], n), u = i?.default;
  if (u === void 0) return;
  const l = typeof u == "function" ? u.call(t, e, n) : u;
  l !== void 0 && r.set(e, l);
}
const kS = { origin: "service" };
function DS(t, e, r = kS) {
  if (!e || typeof e != "object") return;
  const n = ji(t), s = n.metadata, i = {};
  for (const u of Object.getOwnPropertyNames(e)) RS(i, s, u, e, r);
  n.setDefaultOrigin(r.origin);
  for (const u of Object.getOwnPropertyNames(i)) {
    const l = ja(s[u], r).read, c = l?.source;
    let m;
    m = c && typeof c == "string" ? Wi(e, c) : e[u], l?.reader && (m = l.reader.call(t, m, e, r)), m !== void 0 && n.set(u, m);
  }
  if (!r || !r.ignoreDefaults) {
    n.setDefaultOrigin("defaults");
    for (const u of Object.getOwnPropertyNames(s)) i[u] || IS(t, u, n, r);
  }
  n.setDefaultOrigin("user");
}
function $S(t, e, r, n, s) {
  const i = {};
  return e.write?.writer?.call(t, n, i, r, s), i;
}
function FS(t, e, r, n, s, i) {
  if (!n?.write) return !1;
  const u = js(t, r);
  if (!s && n.write.overridePolicy) {
    const l = n.write.overridePolicy.call(t, u, r, i ?? void 0);
    l !== void 0 && (s = l);
  }
  if (s || (s = n.write), !s || s.enabled === !1 || s.layerContainerTypes && i?.layerContainerType && !s.layerContainerTypes.includes(i.layerContainerType)) return !1;
  if ((u === null && !s.allowNull && !s.writerEnsuresNonNull || u === void 0) && s.isRequired) {
    const l = new Qs("web-document-write:property-required", `Missing value for required property '${r}' on '${t.declaredClass}'`, { propertyName: r, target: t });
    return l && i?.messages ? i.messages.push(l) : l && !i && nr.getLogger("esri.core.accessorSupport.write").error(l.name, l.message), !1;
  }
  return !(u === void 0 || u === null && !s.allowNull && !s.writerEnsuresNonNull || !s.alwaysWriteDefaults && (!e.store.multipleOriginsSupported || e.store.originOf(r) === 0) && US(t, r, i, n, u) || !s.ignoreOrigin && i?.origin && e.store.multipleOriginsSupported && e.store.originOf(r) < t3(i.origin));
}
function US(t, e, r, n, s) {
  const i = n.default;
  if (i === void 0) return !1;
  if (n.defaultEquals != null) return n.defaultEquals(s);
  if (typeof i == "function") {
    if (Array.isArray(s)) {
      const u = i.call(t, e, r ?? void 0);
      return _7(u, s);
    }
    return !1;
  }
  return i === s;
}
function VS(t, e, r) {
  if (t && typeof t.toJSON == "function" && (!t.toJSON.isDefaultToJSON || !t.write)) return ta(e, t.toJSON(r));
  const n = ji(t), s = n.metadata;
  for (const i in s) {
    const u = Ev(s[i], r);
    if (!FS(t, n, i, u, void 0, r)) continue;
    const l = js(t, i), c = $S(t, u, u.write && typeof u.write.target == "string" ? u.write.target : i, l, r);
    Object.keys(c).length > 0 && (e = ta(e, c), r?.resources?.pendingOperations?.length && r.resources.pendingOperations.push(Promise.all(r.resources.pendingOperations).then(() => ta(e, c, () => "replace-arrays"))), r?.writtenProperties && r.writtenProperties.push({ target: t, propName: i, oldOrigin: Qv(n.store.originOf(i)), newOrigin: r.origin }));
  }
  return e;
}
const zS = (t) => {
  const e = t;
  let r = class extends e {
    constructor(...n) {
      super(...n);
      const s = ji(this), i = s.store, u = new AS();
      s.store = u, MS(s, i, u);
    }
    read(n, s) {
      DS(this, n, s);
    }
    write(n, s) {
      return VS(this, n ?? {}, s);
    }
    toJSON(n) {
      return this.write({}, n);
    }
    static fromJSON(n, s) {
      return jS.call(this, n, s);
    }
  };
  return r = fe([Ks("esri.core.JSONSupport")], r), r.prototype.toJSON.isDefaultToJSON = !0, r;
};
function jS(t, e) {
  if (!t) return null;
  if (t.declaredClass) throw new Error("JSON object is already hydrated");
  const r = new this();
  return r.read(t, e), r;
}
const l3 = zS(Ms);
function c3(t, e, r) {
  let n, s;
  return s = t, r = e, n = [void 0], (i, u) => {
    const l = i.constructor.prototype;
    n.forEach((c) => {
      const m = zy(i, c, s);
      m.read && typeof m.read == "object" || (m.read = {}), m.read.reader = l[u], r && (m.read.source = (m.read.source || []).concat(r));
    });
  };
}
let WS = class {
  constructor(e, r = { ignoreUnknown: !1, useNumericKeys: !1 }) {
    this._jsonToAPI = e, this._options = r, this.apiValues = [], this.jsonValues = [], this._apiToJSON = GS(e), this.apiValues = h2(this._apiToJSON), this.jsonValues = h2(this._jsonToAPI), this.read = (n) => this.fromJSON(n), this.write = (n, s, i) => {
      const u = this.toJSON(n);
      u !== void 0 && Fi(i, u, s);
    }, this.write.isJSONMapWriter = !0;
  }
  toJSON(e) {
    if (e == null) return null;
    if (this._apiToJSON.hasOwnProperty(e)) {
      const r = this._apiToJSON[e];
      return this._options.useNumericKeys ? +r : r;
    }
    return this._options.ignoreUnknown ? null : e;
  }
  fromJSON(e) {
    return e != null && this._jsonToAPI.hasOwnProperty(e) ? this._jsonToAPI[e] : this._options.ignoreUnknown ? void 0 : e;
  }
};
function GS(t) {
  const e = {};
  for (const r in t) e[t[r]] = r;
  return e;
}
function h2(t) {
  const e = [];
  for (const r in t) e.push(r);
  return e.sort(), e;
}
function ou() {
  return function(t, e) {
    return new WS(t, { ignoreUnknown: !0, ...e });
  };
}
let yh = class {
  constructor(e, r, n, s, i, u) {
    this.semiMajorAxis = e, this.flattening = r, this.outerAtmosphereRimWidth = n, this.atmosphereHeight = s, this.scaleHeight = i;
    const l = 1 - this.flattening;
    this.semiMinorAxis = this.semiMajorAxis * l, this.halfSemiMajorAxis = this.semiMajorAxis / 2, this.halfCircumference = Math.PI * this.semiMajorAxis, this.metersPerDegree = this.halfCircumference / 180, this.inverseFlattening = 1 / (1 - this.flattening) - 1, this.eccentricitySquared = u || 2 * this.flattening - this.flattening * this.flattening, this.meanRadiusSemiAxes = (2 * this.semiMajorAxis + this.semiMinorAxis) / 3;
  }
  get radius() {
    return this.semiMajorAxis;
  }
};
const Dn = new yh(6378137, 1 / 298.257223563, 3e5, 1e5, 0.085, 0.006694379990137799), f3 = new yh(3396190, 1 / 169.8944472236118, 23e4, 6e4, 0.111), h3 = new yh(1737400, 0, 0, 0, 0), d3 = lr.request, m3 = /^\s*[a-z][a-z0-9-+.]*:(?![0-9])/i, p3 = /^\s*http:/i, BS = /^\s*file:/i, qS = /:\d+$/, HS = /^https?:\/\/[^/]+\.arcgis.com\/sharing(\/|$)/i, YS = new RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$"), ZS = new RegExp("^((([^[:]+):)?([^@]+)@)?(\\[([^\\]]+)\\]|([^[:]*))(:([0-9]+))?$");
let g3 = class {
  constructor(e = "") {
    this.uri = e, this.scheme = null, this.authority = null, this.path = null, this.query = null, this.fragment = null, this.user = null, this.password = null, this.host = null, this.port = null;
    let r = this.uri.match(YS);
    this.scheme = r[2] || (r[1] ? "" : null), this.authority = r[4] || (r[3] ? "" : null), this.path = r[5], this.query = r[7] || (r[6] ? "" : null), this.fragment = r[9] || (r[8] ? "" : null), this.authority != null && (r = this.authority.match(ZS), this.user = r[3] || null, this.password = r[4] || null, this.host = r[6] || r[7], this.port = r[9] || null);
  }
  toString() {
    return this.uri;
  }
};
const XS = new g3(lr.applicationUrl);
let rr = XS;
const JS = KS();
let _3 = JS;
const QS = () => rr;
function KS() {
  const t = rr.path, e = t.slice(0, t.lastIndexOf("/") + 1);
  return `${`${rr.scheme}://${rr.host}${rr.port != null ? `:${rr.port}` : ""}`}${e}`;
}
const di = { path: "", query: "" };
function y3(t) {
  const e = t.indexOf("?");
  return e !== -1 ? (di.path = t.slice(0, e), di.query = t.slice(e + 1)) : (di.path = t, di.query = null), di;
}
function eE(t) {
  return t = (t = E3(t = cE(t = y3(t).path), !0)).toLowerCase();
}
function tE(t) {
  const e = d3.proxyRules, r = eE(t);
  for (let n = 0; n < e.length; n++) if (r.startsWith(e[n].urlPrefix)) return e[n];
}
function rE(t, e, r = !1) {
  if (!t || !e) return !1;
  const n = m2(t), s = m2(e);
  return !(!r && n.scheme !== s.scheme) && n.host != null && s.host != null && n.host.toLowerCase() === s.host.toLowerCase() && n.port === s.port;
}
function au(t, e = _3, r) {
  return ei(t) ? r?.preserveProtocolRelative ? t : rr.scheme === "http" && rr.authority === nE(t).slice(2) ? `http:${t}` : `https:${t}` : S3(t) ? t : w3(t.startsWith("/") ? lE(e) : e, t);
}
function b3(t, e = _3, r) {
  if (t == null || !ks(t)) return t;
  const n = oa(t), s = n.toLowerCase(), i = oa(e).toLowerCase().replace(/\/+$/, ""), u = r ? oa(r).toLowerCase().replace(/\/+$/, "") : null;
  if (u && !i.startsWith(u)) return t;
  const l = (y, v, S) => (S = y.indexOf(v, S)) === -1 ? y.length : S;
  let c = l(s, "/", s.indexOf("//") + 2), m = -1;
  for (; s.slice(0, c + 1) === i.slice(0, c) + "/" && (m = c + 1, c !== s.length); ) c = l(s, "/", c + 1);
  if (m === -1 || u && m < u.length) return t;
  t = n.slice(m);
  const _ = i.slice(m - 1).replaceAll(/[^/]+/g, "").length;
  if (_ > 0) for (let y = 0; y < _; y++) t = `../${t}`;
  else t = `./${t}`;
  return t;
}
function oa(t) {
  return t = dE(t = hE(t = fE(t = au(t = t.trim()))));
}
function w3(...t) {
  const e = t.filter(b7);
  if (!e?.length) return;
  const r = [];
  if (ks(e[0])) {
    const s = e[0], i = s.indexOf("//");
    i !== -1 && (r.push(s.slice(0, i + 1)), oE(e[0]) && (r[0] += "/"), e[0] = s.slice(i + 2));
  } else e[0].startsWith("/") && r.push("");
  const n = e.reduce((s, i) => i ? s.concat(i.split("/")) : s, []);
  for (let s = 0; s < n.length; s++) {
    const i = n[s];
    i === ".." && r.length > 0 && r[r.length - 1] !== ".." ? r.pop() : (!i && s === n.length - 1 || i && (i !== "." || r.length === 0)) && r.push(i);
  }
  return r.join("/");
}
function nE(t, e = !1) {
  if (t == null || sE(t) || v3(t)) return null;
  let r = t.indexOf("://");
  if (r === -1 && ei(t)) r = 2;
  else {
    if (r === -1) return null;
    r += 3;
  }
  const n = t.indexOf("/", r);
  return n !== -1 && (t = t.slice(0, n)), e && (t = E3(t, !0)), t;
}
function ks(t) {
  return ei(t) || S3(t);
}
function sE(t) {
  return t != null && t.startsWith("blob:");
}
function v3(t) {
  return t != null && t.startsWith("data:");
}
function ei(t) {
  return t != null && t.startsWith("/") && t[1] === "/";
}
function S3(t) {
  return t != null && m3.test(t);
}
function iE(t) {
  return t != null && p3.test(t) || rr.scheme === "http" && ei(t);
}
function oE(t) {
  return t != null && BS.test(t);
}
function aE(t) {
  return ei(t) ? `https:${t}` : t.replace(p3, "https:");
}
function uE() {
  return rr.scheme === "http";
}
function d2() {
  return rr.scheme === "https";
}
function E3(t, e = !1) {
  return ei(t) ? t.slice(2) : (t = t.replace(m3, ""), e && t.length > 1 && t.startsWith("/") && t[1] === "/" && (t = t.slice(2)), t);
}
function lE(t) {
  const e = t.indexOf("//"), r = t.indexOf("/", e + 2);
  return r === -1 ? t : t.slice(0, r);
}
function cE(t) {
  return t.endsWith("/") ? t : `${t}/`;
}
function fE(t) {
  if (/^https?:\/\//i.test(t)) {
    const e = y3(t);
    t = (t = e.path.replaceAll(/\/{2,}/g, "/")).replace("/", "//"), e.query && (t += `?${e.query}`);
  }
  return t;
}
function hE(t) {
  return t.replace(/^(https?:\/\/)(arcgis\.com)/i, "$1www.$2");
}
function dE(t) {
  const e = d3.httpsDomains;
  if (!iE(t)) return t;
  const r = t.indexOf("/", 7);
  let n;
  if (n = r === -1 ? t : t.slice(0, r), n = n.toLowerCase().slice(7), qS.test(n)) {
    if (!n.endsWith(":80")) return t;
    n = n.slice(0, -3), t = t.replace(":80", "");
  }
  return uE() && n === rr.authority && !HS.test(t) || (d2() && n === rr.authority || e && e.some((s) => n === s || n.endsWith(`.${s}`)) || d2() && !tE(t)) && (t = aE(t)), t;
}
function $0(t, e, r) {
  if (!(e && r && t && ks(t))) return t;
  const n = t.indexOf("//"), s = t.indexOf("/", n + 2), i = t.indexOf(":", n + 2), u = Math.min(s < 0 ? t.length : s, i < 0 ? t.length : i);
  return t.slice(n + 2, u).toLowerCase() !== e.toLowerCase() ? t : `${t.slice(0, n + 2)}${r}${t.slice(u)}`;
}
function m2(t) {
  return typeof t == "string" ? new g3(au(t)) : (t.scheme || (t.scheme = rr.scheme), t);
}
function p2(t) {
  if (t == null) return null;
  const e = t.match(mE);
  return e ? { path: e[1], extension: e[2] } : { path: t, extension: null };
}
const mE = /([^.]*)\.([^/]*)$/;
Symbol.dispose ??= Symbol("Symbol.dispose"), Symbol.asyncDispose ??= Symbol("Symbol.asyncDispose");
F("host-webworker") || globalThis.$arcgis || Object.defineProperty(globalThis, "$arcgis", { configurable: !1, enumerable: !0, writable: !1, value: {} }), F("host-webworker");
function N3(t, e) {
  const r = e?.url?.path;
  if (t && r && (t = au(t, r, { preserveProtocolRelative: !0 }), e.portalItem && e.readResourcePaths)) {
    const n = b3(t, e.portalItem.itemUrl);
    n != null && n.startsWith(_E) && e.readResourcePaths.push(e.portalItem.resourceFromPath(n).path);
  }
  return (t = F0(t, e?.portal)) && uu.test(t) ? P3(t) : t;
}
function x3(t, e, r = 0) {
  if ((t = t && uu.test(t) ? A3(t) : t) == null) return t;
  !ks(t) && e?.blockedRelativeUrls && e.blockedRelativeUrls.push(t);
  let n = au(t);
  if (e) {
    const s = e.verifyItemRelativeUrls?.rootPath || e.url?.path;
    if (s) {
      const i = F0(s, e.portal), u = F0(n, e.portal);
      n = b3(u, i, i), n != null && n !== u && n !== t && e.verifyItemRelativeUrls && e.verifyItemRelativeUrls.writtenUrls.push(n);
    }
  }
  return n = T3(n, e?.portal), ks(n) && (n = oa(n)), e?.resources && e?.portalItem && !ks(n) && !v3(n) && r === 0 && e.resources.toKeep.push({ resource: e.portalItem.resourceFromPath(n), compress: !1 }), n;
}
function pE(t, e, r) {
  return N3(t, r);
}
function gE(t, e, r, n) {
  const s = x3(t, n);
  s !== void 0 && (e[r] = s);
}
const uu = /\/items\/([^/]+)\/resources\/(.*)/, _E = "./resources/";
function yE(t) {
  return (t?.match(uu) ?? null)?.[1] ?? null;
}
function bE(t) {
  const e = t?.match(uu) ?? null;
  if (e == null) return null;
  const r = e[2], n = r.lastIndexOf("/");
  if (n === -1) {
    const { path: u, extension: l } = p2(r);
    return { prefix: null, filename: u, extension: l };
  }
  const { path: s, extension: i } = p2(r.slice(n + 1));
  return { prefix: r.slice(0, n), filename: s, extension: i };
}
function T3(t, e) {
  return e && !e.isPortal && e.urlKey && e.customBaseUrl ? $0(t, `${e.urlKey}.${e.customBaseUrl}`, e.portalHostname) : t;
}
function F0(t, e) {
  if (!e || e.isPortal || !e.urlKey || !e.customBaseUrl) return t;
  const r = `${e.urlKey}.${e.customBaseUrl}`, n = QS();
  return rE(n, `${n.scheme}://${r}`) ? $0(t, e.portalHostname, r) : $0(t, r, e.portalHostname);
}
function P3(t) {
  return t || t || null;
}
function A3(t) {
  if (!t) return t || null;
  let e = t;
  return e = e.replace(/^https?:\/\/cdn\.arcgis\.com/, "https://www.arcgis.com"), e = e.replace(/^https?:\/\/cdndev\.arcgis\.com/, "https://devext.arcgis.com"), e = e.replace(/^https?:\/\/cdnqa\.arcgis\.com/, "https://qaext.arcgis.com"), e;
}
Object.freeze(Object.defineProperty({ __proto__: null, ensureMainOnlineDomain: T3, fromCDNUrl: A3, fromJSON: N3, itemIdFromResourceUrl: yE, prefixAndFilenameFromResourceUrl: bE, read: pE, toCDNUrl: P3, toJSON: x3, write: gE }, Symbol.toStringTag, { value: "Module" }));
const wE = { mapserver: "MapServer", imageserver: "ImageServer", featureserver: "FeatureServer", knowledgegraphserver: "KnowledgeGraphServer", sceneserver: "SceneServer", streamserver: "StreamServer", vectortileserver: "VectorTileServer", "3dtilesserver": "3DTilesServer", videoserver: "VideoServer" }, L3 = Object.values(wE);
new RegExp(`^((?:https?:)?\\/\\/\\S+?\\/rest\\/services\\/(.+?)\\/(${L3.join("|")}))(?:\\/(?:layers\\/)?(\\d+))?`, "i");
new RegExp(`^((?:https?:)?\\/\\/\\S+?\\/([^/\\n]+)\\/(${L3.join("|")}))(?:\\/(?:layers\\/)?(\\d+))?`, "i");
lr.request;
function vE(t) {
  if (!lr.assetsPath) throw nr.getLogger("esri.assets").errorOnce("The API assets location needs to be set using config.assetsPath. More information: https://arcg.is/1OzLe50"), new Qs("assets:path-not-set", "config.assetsPath is not set");
  return w3(lr.assetsPath, t);
}
let g1, N = null;
function SE() {
  return !!N;
}
function EE() {
  return !!F("esri-wasm");
}
function NE() {
  return g1 || (g1 = Promise.resolve().then(function() {
    return sT;
  }).then(({ default: t }) => t({ locateFile: (e) => vE(`esri/geometry/support/${e}`) })).then((t) => {
    k3(t);
  }), g1);
}
const aa = { geogToProj(t, e, r) {
  N.ensureCache.prepare();
  const n = Kn(r), s = r === n, i = N.ensureFloat64(n), u = N._pe_geog_to_proj(N.getPointer(t), e, i);
  return u && $n(r, e, i, s), u;
}, projGeog(t, e, r, n) {
  switch (n) {
    case Ke.PE_TRANSFORM_P_TO_G:
      return aa.projToGeog(t, e, r);
    case Ke.PE_TRANSFORM_G_TO_P:
      return aa.geogToProj(t, e, r);
  }
  return 0;
}, projToGeog: (t, e, r) => aa.projToGeogCenter(t, e, r, 0), projToGeogCenter(t, e, r, n) {
  N.ensureCache.prepare();
  const s = Kn(r), i = r === s, u = N.ensureFloat64(s), l = N._pe_proj_to_geog_center(N.getPointer(t), e, u, n);
  return l && $n(r, e, u, i), l;
} };
let Ke = class Ae {
  static init() {
    Ae.PE_BUFFER_MAX = N.PeDefs.prototype.PE_BUFFER_MAX, Ae.PE_NAME_MAX = N.PeDefs.prototype.PE_NAME_MAX, Ae.PE_MGRS_MAX = N.PeDefs.prototype.PE_MGRS_MAX, Ae.PE_USNG_MAX = N.PeDefs.prototype.PE_USNG_MAX, Ae.PE_DD_MAX = N.PeDefs.prototype.PE_DD_MAX, Ae.PE_DDM_MAX = N.PeDefs.prototype.PE_DDM_MAX, Ae.PE_DMS_MAX = N.PeDefs.prototype.PE_DMS_MAX, Ae.PE_UTM_MAX = N.PeDefs.prototype.PE_UTM_MAX, Ae.PE_PARM_MAX = N.PeDefs.prototype.PE_PARM_MAX, Ae.PE_TYPE_NONE = N.PeDefs.prototype.PE_TYPE_NONE, Ae.PE_TYPE_GEOGCS = N.PeDefs.prototype.PE_TYPE_GEOGCS, Ae.PE_TYPE_PROJCS = N.PeDefs.prototype.PE_TYPE_PROJCS, Ae.PE_TYPE_GEOGTRAN = N.PeDefs.prototype.PE_TYPE_GEOGTRAN, Ae.PE_TYPE_COORDSYS = N.PeDefs.prototype.PE_TYPE_COORDSYS, Ae.PE_TYPE_UNIT = N.PeDefs.prototype.PE_TYPE_UNIT, Ae.PE_TYPE_LINUNIT = N.PeDefs.prototype.PE_TYPE_LINUNIT, Ae.PE_STR_OPTS_NONE = N.PeDefs.prototype.PE_STR_OPTS_NONE, Ae.PE_STR_AUTH_NONE = N.PeDefs.prototype.PE_STR_AUTH_NONE, Ae.PE_STR_AUTH_TOP = N.PeDefs.prototype.PE_STR_AUTH_TOP, Ae.PE_STR_NAME_CANON = N.PeDefs.prototype.PE_STR_NAME_CANON, Ae.PE_STR_FMT_WKT = N.PeDefs.prototype.PE_STR_FMT_WKT, Ae.PE_STR_FMT_WKT2 = N.PeDefs.prototype.PE_STR_FMT_WKT2, Ae.PE_PARM_X0 = N.PeDefs.prototype.PE_PARM_X0, Ae.PE_PARM_ND = N.PeDefs.prototype.PE_PARM_ND, Ae.PE_TRANSFORM_1_TO_2 = N.PeDefs.prototype.PE_TRANSFORM_1_TO_2, Ae.PE_TRANSFORM_2_TO_1 = N.PeDefs.prototype.PE_TRANSFORM_2_TO_1, Ae.PE_TRANSFORM_P_TO_G = N.PeDefs.prototype.PE_TRANSFORM_P_TO_G, Ae.PE_TRANSFORM_G_TO_P = N.PeDefs.prototype.PE_TRANSFORM_G_TO_P, Ae.PE_HORIZON_RECT = N.PeDefs.prototype.PE_HORIZON_RECT, Ae.PE_HORIZON_POLY = N.PeDefs.prototype.PE_HORIZON_POLY, Ae.PE_HORIZON_LINE = N.PeDefs.prototype.PE_HORIZON_LINE, Ae.PE_HORIZON_DELTA = N.PeDefs.prototype.PE_HORIZON_DELTA;
  }
}, M3 = null;
const g2 = {}, _2 = {}, y2 = (t) => {
  const e = t.getType();
  switch (e) {
    case Ke.PE_TYPE_GEOGCS:
      t = N.castObject(t, N.PeGeogcs);
      break;
    case Ke.PE_TYPE_PROJCS:
      t = N.castObject(t, N.PeProjcs);
      break;
    case Ke.PE_TYPE_GEOGTRAN:
      t = N.castObject(t, N.PeGeogtran);
      break;
    default:
      e & Ke.PE_TYPE_UNIT && (t = N.castObject(t, N.PeUnit));
  }
  return t;
}, xs = { initialize() {
  N.PeFactory.prototype.initialize(null);
}, coordsys: (t) => xs.factoryByType(Ke.PE_TYPE_COORDSYS, t), factoryByType(t, e) {
  let r = null, n = g2[t];
  if (n || (n = {}, g2[t] = n), n.hasOwnProperty(String(e)) && (r = n[e], N.compare(r, N.NULL) && (r = null)), !r) {
    const s = N.PeFactory.prototype.factoryByType(t, e);
    N.compare(s, N.NULL) || (r = y2(s), n[e] = r);
  }
  return r;
}, fromString(t, e) {
  let r = null, n = _2[t];
  if (n || (n = {}, _2[t] = n), n.hasOwnProperty(e) && (r = n[e], N.compare(r, N.NULL) && (r = null)), !r) {
    const s = N.PeFactory.prototype.fromString(t, e);
    N.compare(s, N.NULL) || (r = y2(s), n[e] = r);
  }
  return r;
}, geogcs: (t) => xs.factoryByType(Ke.PE_TYPE_GEOGCS, t), geogtran: (t) => xs.factoryByType(Ke.PE_TYPE_GEOGTRAN, t), getCode: (t) => N.PeFactory.prototype.getCode(t), projcs: (t) => xs.factoryByType(Ke.PE_TYPE_PROJCS, t), unit: (t) => xs.factoryByType(Ke.PE_TYPE_UNIT, t) };
let b2, O3 = null;
const bh = { PE_GTLIST_OPTS_COMMON: 0, init() {
  bh.PE_GTLIST_OPTS_COMMON = N.PeGTlistExtended.prototype.PE_GTLIST_OPTS_COMMON, b2 = N._pe_getPeGTlistExtendedEntrySize();
}, getGTlist(t, e, r, n, s, i) {
  let u = null;
  const l = new N.PeInteger(i);
  try {
    const c = N.PeGTlistExtended.prototype.getGTlist(t, e, r, n, s, l);
    if ((i = l.val) && (u = [c], i > 1)) {
      const m = N.getPointer(c);
      for (let _ = 1; _ < i; _++) u.push(N.wrapPointer(m + b2 * _, N.PeGTlistExtendedEntry));
    }
  } finally {
    N.destroy(l);
  }
  return u;
} }, xE = { destroy(t) {
  if (t?.length) {
    for (const e of t) kr(e), e.getEntries().forEach((r) => {
      kr(r);
      const n = r.getGeogtran();
      kr(n), n.getParameters().forEach(kr), [n.getGeogcs1(), n.getGeogcs2()].forEach((s) => {
        kr(s);
        const i = s.getDatum();
        kr(i), kr(i.getSpheroid()), kr(s.getPrimem()), kr(s.getUnit());
      });
    });
    N.PeGTlistExtendedEntry.prototype.Delete(t[0]);
  }
} }, TE = { geogToGeog(t, e, r, n, s) {
  N.ensureCache.prepare();
  const i = Kn(r), u = r === i, l = N.ensureFloat64(i);
  let c = 0;
  n && (c = N.ensureFloat64(n));
  const m = N._pe_geog_to_geog(N.getPointer(t), e, l, c, s);
  return m && $n(r, e, l, u), m;
} }, PE = { geodesicCoordinate(t, e, r, n, s, i, u, l) {
  N.PeLineType.prototype.geodesic_coordinate(t, e, r, n, s, i, u, l);
}, geodeticCoordinate(t, e, r, n, s, i, u, l, c) {
  N.PeLineType.prototype.geodetic_coordinate(t, e, r, n, s, i, u, l, c);
}, geodeticDistance(t, e, r, n, s, i, u, l, c, m) {
  N.PeLineType.prototype.geodetic_distance(t, e, r, n, s, i, u, l, c, m);
}, greatEllipticDistance(t, e, r, n, s, i, u, l, c) {
  N.PeLineType.prototype.great_elliptic_distance(t, e, r, n, s, i, u, l, c);
} }, AE = { phiToEta: (t, e) => N.PeMath.prototype.phi_to_eta(t, e), etaToPhi: (t, e) => N.PeMath.prototype.eta_to_phi(t, e), phiToPhig: (t, e) => N.PeMath.prototype.phi_to_phig(t, e), q: (t, e, r) => N.PeMath.prototype.q(t, e, r), q90: (t, e) => N.PeMath.prototype.q90(t, e) }, _1 = (t, e, r, n, s, i) => {
  let u, l;
  switch (N.ensureCache.prepare(), t) {
    case "dd":
      u = N._pe_geog_to_dd, l = Ke.PE_DD_MAX;
      break;
    case "ddm":
      u = N._pe_geog_to_ddm, l = Ke.PE_DDM_MAX;
      break;
    case "dms":
      u = N._pe_geog_to_dms, l = Ke.PE_DMS_MAX;
  }
  let c = 0;
  e && (c = N.getPointer(e));
  const m = Kn(n), _ = N.ensureFloat64(m), y = lu(r, l), v = u(c, r, _, s, N.ensureInt32(y));
  if (v) for (let S = 0; S < r; S++) i[S] = N.UTF8ToString(y[S]);
  return v;
}, y1 = (t, e, r, n, s) => {
  let i;
  switch (N.ensureCache.prepare(), t) {
    case "dd":
      i = N._pe_dd_to_geog;
      break;
    case "ddm":
      i = N._pe_ddm_to_geog;
      break;
    case "dms":
      i = N._pe_dms_to_geog;
  }
  let u = 0;
  e && (u = N.getPointer(e));
  const l = n.map((y) => N.ensureString(y)), c = N.ensureInt32(l), m = N.ensureFloat64(new Array(2 * r)), _ = i(u, r, c, m);
  return _ && $n(s, r, m), _;
}, LE = { geogToDms: (t, e, r, n, s) => _1("dms", t, e, r, n, s), dmsToGeog: (t, e, r, n) => y1("dms", t, e, r, n), geogToDdm: (t, e, r, n, s) => _1("ddm", t, e, r, n, s), ddmToGeog: (t, e, r, n) => y1("ddm", t, e, r, n), geogToDd: (t, e, r, n, s) => _1("dd", t, e, r, n, s), ddToGeog: (t, e, r, n) => y1("dd", t, e, r, n) };
let C3 = class Ts {
  static init() {
    Ts.PE_MGRS_STYLE_NEW = N.PeNotationMgrs.prototype.PE_MGRS_STYLE_NEW, Ts.PE_MGRS_STYLE_OLD = N.PeNotationMgrs.prototype.PE_MGRS_STYLE_OLD, Ts.PE_MGRS_STYLE_AUTO = N.PeNotationMgrs.prototype.PE_MGRS_STYLE_AUTO, Ts.PE_MGRS_180_ZONE_1_PLUS = N.PeNotationMgrs.prototype.PE_MGRS_180_ZONE_1_PLUS, Ts.PE_MGRS_ADD_SPACES = N.PeNotationMgrs.prototype.PE_MGRS_ADD_SPACES;
  }
  static geogToMgrsExtended(e, r, n, s, i, u, l) {
    N.ensureCache.prepare();
    let c = 0;
    e && (c = N.getPointer(e));
    const m = Kn(n), _ = N.ensureFloat64(m), y = lu(r, Ke.PE_MGRS_MAX), v = N.ensureInt32(y), S = N._pe_geog_to_mgrs_extended(c, r, _, s, i, u, v);
    if (S) for (let T = 0; T < r; T++) l[T] = N.UTF8ToString(y[T]);
    return S;
  }
  static mgrsToGeogExtended(e, r, n, s, i) {
    N.ensureCache.prepare();
    let u = 0;
    e && (u = N.getPointer(e));
    const l = n.map((y) => N.ensureString(y)), c = N.ensureInt32(l), m = N.ensureFloat64(new Array(2 * r)), _ = N._pe_mgrs_to_geog_extended(u, r, c, s, m);
    return _ && $n(i, r, m), _;
  }
};
const ME = { geogToUsng(t, e, r, n, s, i, u) {
  N.ensureCache.prepare();
  let l = 0;
  t && (l = N.getPointer(t));
  const c = Kn(r), m = N.ensureFloat64(c), _ = lu(e, Ke.PE_MGRS_MAX), y = N.ensureInt32(_), v = N._pe_geog_to_usng(l, e, m, n, s, i, y);
  if (v) for (let S = 0; S < e; S++) u[S] = N.UTF8ToString(_[S]);
  return v;
}, usngToGeog(t, e, r, n) {
  N.ensureCache.prepare();
  let s = 0;
  t && (s = N.getPointer(t));
  const i = r.map((m) => N.ensureString(m)), u = N.ensureInt32(i), l = N.ensureFloat64(new Array(2 * e)), c = N._pe_usng_to_geog(s, e, u, l);
  return c && $n(n, e, l), c;
} };
let R3 = class ua {
  static init() {
    ua.PE_UTM_OPTS_NONE = N.PeNotationUtm.prototype.PE_UTM_OPTS_NONE, ua.PE_UTM_OPTS_ADD_SPACES = N.PeNotationUtm.prototype.PE_UTM_OPTS_ADD_SPACES, ua.PE_UTM_OPTS_NS = N.PeNotationUtm.prototype.PE_UTM_OPTS_NS;
  }
  static geogToUtm(e, r, n, s, i) {
    N.ensureCache.prepare();
    let u = 0;
    e && (u = N.getPointer(e));
    const l = Kn(n), c = N.ensureFloat64(l), m = lu(r, Ke.PE_UTM_MAX), _ = N.ensureInt32(m), y = N._pe_geog_to_utm(u, r, c, s, _);
    if (y) for (let v = 0; v < r; v++) i[v] = N.UTF8ToString(m[v]);
    return y;
  }
  static utmToGeog(e, r, n, s, i) {
    N.ensureCache.prepare();
    let u = 0;
    e && (u = N.getPointer(e));
    const l = n.map((y) => N.ensureString(y)), c = N.ensureInt32(l), m = N.ensureFloat64(new Array(2 * r)), _ = N._pe_utm_to_geog(u, r, c, s, m);
    return _ && $n(i, r, m), _;
  }
}, I3 = class on {
  static {
    this.cache = /* @__PURE__ */ new Map();
  }
  static init() {
    on.PE_PCSINFO_OPTION_NONE = N.PePCSInfo.prototype.PE_PCSINFO_OPTION_NONE, on.PE_PCSINFO_OPTION_DOMAIN = N.PePCSInfo.prototype.PE_PCSINFO_OPTION_DOMAIN, on.PE_POLE_OUTSIDE_BOUNDARY = N.PePCSInfo.prototype.PE_POLE_OUTSIDE_BOUNDARY, on.PE_POLE_POINT = N.PePCSInfo.prototype.PE_POLE_POINT;
  }
  static generate(e, r = on.PE_PCSINFO_OPTION_DOMAIN) {
    let n = null, s = null;
    return on.cache.has(e) && (s = on.cache.get(e), s[r] && (n = s[r])), n || (n = N.PePCSInfo.prototype.generate(e, r), s || (s = [], on.cache.set(e, s)), s[r] = n), n;
  }
};
const OE = { versionString: () => N.PeVersion.prototype.version_string() };
function k3(t) {
  function e(i, u, l) {
    i[u] = l(i[u]);
  }
  N = t, Ke.init(), bh.init(), C3.init(), R3.init(), I3.init(), M3 = class extends N.PeDouble {
    constructor(i = NaN) {
      super(i);
    }
    destroy() {
      N.destroy(this);
    }
    [Symbol.dispose]() {
      this.destroy();
    }
  }, O3 = class extends N.PeGCSExtent {
    destroy() {
      N.destroy(this);
    }
    [Symbol.dispose]() {
      this.destroy();
    }
  };
  const r = [N.PeAngunit, N.PeDatum, N.PeGeogcs, N.PeGeogtran, N.PeObject, N.PeParameter, N.PePrimem, N.PeProjcs, N.PeSpheroid, N.PeUnit];
  for (const i of r) e(i.prototype, "getName", (u) => function() {
    return u.call(this, new Array(Ke.PE_NAME_MAX));
  });
  for (const i of [N.PeGeogtran, N.PeProjcs]) e(i.prototype, "getParameters", (u) => function() {
    const l = new Array(Ke.PE_PARM_MAX);
    let c = u.call(this);
    for (let m = 0; m < l.length; m++) {
      const _ = N.getValue(c, "*");
      l[m] = _ ? N.wrapPointer(_, N.PeParameter) : null, c += Int32Array.BYTES_PER_ELEMENT;
    }
    return l;
  });
  e(N.PeHorizon.prototype, "getCoord", (i) => function(u = !1) {
    const l = this.getSize();
    if (!l) return null;
    const c = [];
    return $n(c, l, i.call(this), u), c;
  }), e(N.PeGTlistExtendedEntry.prototype, "getEntries", (i) => {
    const u = N._pe_getPeGTlistExtendedGTsSize();
    return function() {
      let l = null;
      const c = i.call(this);
      if (!N.compare(c, N.NULL)) {
        l = [c];
        const m = this.getSteps();
        if (m > 1) {
          const _ = N.getPointer(c);
          for (let y = 1; y < m; y++) l.push(N.wrapPointer(_ + u * y, N.PeGTlistExtendedGTs));
        }
      }
      return l;
    };
  });
  const n = N._pe_getPeHorizonSize(), s = (i) => function() {
    let u = this._cache;
    if (u || (u = /* @__PURE__ */ new Map(), this._cache = u), u.has(i)) return u.get(i);
    let l = null;
    const c = i.call(this);
    if (!N.compare(c, N.NULL)) {
      l = [c];
      const m = c.getNump();
      if (m > 1) {
        const _ = N.getPointer(c);
        for (let y = 1; y < m; y++) l.push(N.wrapPointer(_ + n * y, N.PeHorizon));
      }
    }
    return u.set(i, l), l;
  };
  e(N.PeProjcs.prototype, "horizonGcsGenerate", s), e(N.PeProjcs.prototype, "horizonPcsGenerate", s), N.PeObject.prototype.toString = function(i = Ke.PE_STR_OPTS_NONE) {
    N.ensureCache.prepare();
    const u = N.getPointer(this), l = N.ensureInt8(new Array(Ke.PE_BUFFER_MAX));
    return N.UTF8ToString(N._pe_object_to_string_ext(u, i, l));
  }, N.PeGeogcs.prototype.destroy = function() {
    this.Delete(), kr(this), this.ptr = 0;
  }, N.PeGeogcs.prototype[Symbol.dispose] = function() {
    this.destroy();
  }, N.PeProjcs.prototype.destroy = function() {
    this.Delete(), kr(this), this.ptr = 0;
  }, N.PeProjcs.prototype[Symbol.dispose] = function() {
    this.destroy();
  };
}
function kr(t) {
  if (!t) return;
  const e = N.getClass(t);
  if (!e) return;
  const r = N.getCache(e);
  if (!r) return;
  const n = N.getPointer(t);
  n && delete r[n];
}
function lu(t, e) {
  const r = [], n = new Array(e);
  for (let s = 0; s < t; s++) r.push(N.ensureInt8(n));
  return r;
}
function Kn(t) {
  return ArrayBuffer.isView(t) ? t : Array.isArray(t[0]) ? t.flat() : t;
}
function $n(t, e, r, n = !1) {
  if (n) for (let s = 0; s < 2 * e; s++) t[s] = N.getValue(r + s * Float64Array.BYTES_PER_ELEMENT, "double");
  else {
    const s = t.length === 0;
    for (let i = 0; i < e; i++) s && (t[i] = new Array(2)), t[i][0] = N.getValue(r, "double"), t[i][1] = N.getValue(r + Float64Array.BYTES_PER_ELEMENT, "double"), r += 2 * Float64Array.BYTES_PER_ELEMENT;
  }
}
Object.freeze(Object.defineProperty({ __proto__: null, PeCSTransformations: aa, PeDefs: Ke, get PeDouble() {
  return M3;
}, PeFactory: xs, get PeGCSExtent() {
  return O3;
}, PeGTTransformations: TE, PeGTlistExtended: bh, PeGTlistExtendedEntry: xE, PeLineType: PE, PeMath: AE, PeNotationDms: LE, PeNotationMgrs: C3, PeNotationUsng: ME, PeNotationUtm: R3, PePCSInfo: I3, PeVersion: OE, _init: k3, get _pe() {
  return N;
}, isLoaded: SE, isSupported: EE, load: NE }, Symbol.toStringTag, { value: "Module" }));
let o;
const w = { values: [1, 0.3048, 0.3048006096012192, 0.3047972654, 0.9143917962, 0.201166195164, 0.9143984146160287, 0.3047994715386762, 20.11676512155263, 20.11678249437587, 0.9143985307444408, 0.91439523, 0.3047997101815088, 20.1168, 20.116756, 5e4, 15e4], units: ["Meter", "Foot", "Foot_US", "Foot_Clarke", "Yard_Clarke", "Link_Clarke", "Yard_Sears", "Foot_Sears", "Chain_Sears", "Chain_Benoit_1895_B", "Yard_Indian", "Yard_Indian_1937", "Foot_Gold_Coast", "Chain", "Chain_Sears_1922_Truncated", "50_Kilometers", "150_Kilometers"], 2066: 5, 2136: 12, 2155: 2, 2157: 0, 2158: 0, 2159: 12, 2160: 12, 2204: 2, 2219: 0, 2220: 0, 2254: 2, 2255: 2, 2256: 1, 2265: 1, 2266: 1, 2267: 2, 2268: 2, 2269: 1, 2270: 1, 2271: 2, 2272: 2, 2273: 1, 2294: 0, 2295: 0, 2314: 3, 2899: 2, 2900: 2, 2901: 1, 2909: 1, 2910: 1, 2911: 2, 2912: 2, 2913: 1, 2914: 1, 2992: 1, 2993: 0, 2994: 1, 3080: 1, 3089: 2, 3090: 0, 3091: 2, 3102: 2, 3141: 0, 3142: 0, 3167: 14, 3359: 2, 3360: 0, 3361: 1, 3362: 0, 3363: 2, 3364: 0, 3365: 2, 3366: 3, 3404: 2, 3405: 0, 3406: 0, 3407: 3, 3439: 0, 3440: 0, 3479: 1, 3480: 0, 3481: 1, 3482: 0, 3483: 1, 3484: 0, 3485: 2, 3486: 0, 3487: 2, 3488: 0, 3489: 0, 3490: 2, 3491: 0, 3492: 2, 3493: 0, 3494: 2, 3495: 0, 3496: 2, 3497: 0, 3498: 2, 3499: 0, 3500: 2, 3501: 0, 3502: 2, 3503: 0, 3504: 2, 3505: 0, 3506: 2, 3507: 0, 3508: 2, 3509: 0, 3510: 2, 3511: 0, 3512: 2, 3513: 0, 3514: 0, 3515: 2, 3516: 0, 3517: 2, 3518: 0, 3519: 2, 3520: 0, 3521: 2, 3522: 0, 3523: 2, 3524: 0, 3525: 2, 3526: 0, 3527: 2, 3528: 0, 3529: 2, 3530: 0, 3531: 2, 3532: 0, 3533: 2, 3534: 0, 3535: 2, 3536: 0, 3537: 2, 3538: 0, 3539: 2, 3540: 0, 3541: 2, 3542: 0, 3543: 2, 3544: 0, 3545: 2, 3546: 0, 3547: 2, 3548: 0, 3549: 2, 3550: 0, 3551: 2, 3552: 0, 3553: 2, 3582: 2, 3583: 0, 3584: 2, 3585: 0, 3586: 2, 3587: 0, 3588: 1, 3589: 0, 3590: 1, 3591: 0, 3592: 0, 3593: 1, 3598: 2, 3599: 0, 3600: 2, 3605: 1, 3606: 0, 3607: 0, 3608: 2, 3609: 0, 3610: 2, 3611: 0, 3612: 2, 3613: 0, 3614: 2, 3615: 0, 3616: 2, 3617: 0, 3618: 2, 3619: 0, 3620: 2, 3621: 0, 3622: 2, 3623: 0, 3624: 2, 3625: 0, 3626: 2, 3627: 0, 3628: 2, 3629: 0, 3630: 2, 3631: 0, 3632: 2, 3633: 0, 3634: 1, 3635: 0, 3636: 1, 3640: 2, 3641: 0, 3642: 2, 3643: 0, 3644: 1, 3645: 0, 3646: 1, 3647: 0, 3648: 1, 3649: 0, 3650: 2, 3651: 0, 3652: 2, 3653: 0, 3654: 2, 3655: 0, 3656: 1, 3657: 0, 3658: 2, 3659: 0, 3660: 2, 3661: 0, 3662: 2, 3663: 0, 3664: 2, 3668: 2, 3669: 0, 3670: 2, 3671: 0, 3672: 2, 3673: 0, 3674: 2, 3675: 0, 3676: 1, 3677: 2, 3678: 0, 3679: 1, 3680: 2, 3681: 0, 3682: 1, 3683: 2, 3684: 0, 3685: 0, 3686: 2, 3687: 0, 3688: 2, 3689: 0, 3690: 2, 3691: 0, 3692: 2, 3696: 2, 3697: 0, 3698: 2, 3699: 0, 3700: 2, 3793: 0, 3794: 0, 3812: 0, 3854: 0, 3857: 0, 3920: 0, 3978: 0, 3979: 0, 3991: 2, 3992: 2, 4026: 0, 4037: 0, 4038: 0, 4071: 0, 4082: 0, 4083: 0, 4087: 0, 4088: 0, 4217: 2, 4414: 0, 4415: 0, 4417: 0, 4434: 0, 4437: 0, 4438: 2, 4439: 2, 4462: 0, 4467: 0, 4471: 0, 4474: 0, 4559: 0, 4647: 0, 4822: 0, 4826: 0, 4839: 0, 5018: 0, 5041: 0, 5042: 0, 5048: 0, 5221: 0, 5223: 0, 5234: 0, 5235: 0, 5243: 0, 5247: 0, 5266: 0, 5316: 0, 5320: 0, 5321: 0, 5325: 0, 5337: 0, 5361: 0, 5362: 0, 5367: 0, 5382: 0, 5383: 0, 5396: 0, 5456: 0, 5457: 0, 5469: 0, 5472: 4, 5490: 0, 5513: 0, 5514: 0, 5523: 0, 5559: 0, 5588: 1, 5589: 3, 5596: 0, 5627: 0, 5629: 0, 5641: 0, 5643: 0, 5644: 0, 5646: 2, 5654: 2, 5655: 2, 5659: 0, 5700: 0, 5825: 0, 5836: 0, 5837: 0, 5839: 0, 5842: 0, 5844: 0, 5858: 0, 5879: 0, 5880: 0, 5887: 0, 5890: 0, 6128: 1, 6129: 1, 6141: 1, 6204: 0, 6210: 0, 6211: 0, 6307: 0, 6312: 0, 6316: 0, 6362: 0, 6391: 1, 6405: 1, 6406: 0, 6407: 1, 6408: 0, 6409: 1, 6410: 0, 6411: 2, 6412: 0, 6413: 2, 6414: 0, 6415: 0, 6416: 2, 6417: 0, 6418: 2, 6419: 0, 6420: 2, 6421: 0, 6422: 2, 6423: 0, 6424: 2, 6425: 0, 6426: 2, 6427: 0, 6428: 2, 6429: 0, 6430: 2, 6431: 0, 6432: 2, 6433: 0, 6434: 2, 6435: 0, 6436: 2, 6437: 0, 6438: 2, 6439: 0, 6440: 0, 6441: 2, 6442: 0, 6443: 2, 6444: 0, 6445: 2, 6446: 0, 6447: 2, 6448: 0, 6449: 2, 6450: 0, 6451: 2, 6452: 0, 6453: 2, 6454: 0, 6455: 2, 6456: 0, 6457: 2, 6458: 0, 6459: 2, 6460: 0, 6461: 2, 6462: 0, 6463: 2, 6464: 0, 6465: 2, 6466: 0, 6467: 2, 6468: 0, 6469: 2, 6470: 0, 6471: 2, 6472: 0, 6473: 2, 6474: 0, 6475: 2, 6476: 0, 6477: 2, 6478: 0, 6479: 2, 6484: 2, 6485: 0, 6486: 2, 6487: 0, 6488: 2, 6489: 0, 6490: 2, 6491: 0, 6492: 2, 6493: 0, 6494: 1, 6495: 0, 6496: 1, 6497: 0, 6498: 0, 6499: 1, 6500: 0, 6501: 2, 6502: 0, 6503: 2, 6504: 0, 6505: 2, 6506: 0, 6507: 2, 6508: 0, 6509: 0, 6510: 2, 6515: 1, 6516: 0, 6518: 0, 6519: 2, 6520: 0, 6521: 2, 6522: 0, 6523: 2, 6524: 0, 6525: 2, 6526: 0, 6527: 2, 6528: 0, 6529: 2, 6530: 0, 6531: 2, 6532: 0, 6533: 2, 6534: 0, 6535: 2, 6536: 0, 6537: 2, 6538: 0, 6539: 2, 6540: 0, 6541: 2, 6542: 0, 6543: 2, 6544: 0, 6545: 1, 6546: 0, 6547: 1, 6548: 0, 6549: 2, 6550: 0, 6551: 2, 6552: 0, 6553: 2, 6554: 0, 6555: 2, 6556: 0, 6557: 1, 6558: 0, 6559: 1, 6560: 0, 6561: 1, 6562: 0, 6563: 2, 6564: 0, 6565: 2, 6566: 0, 6567: 0, 6568: 2, 6569: 0, 6570: 1, 6571: 0, 6572: 2, 6573: 0, 6574: 2, 6575: 0, 6576: 2, 6577: 0, 6578: 2, 6582: 2, 6583: 0, 6584: 2, 6585: 0, 6586: 2, 6587: 0, 6588: 2, 6589: 0, 6590: 2, 6591: 0, 6592: 0, 6593: 2, 6594: 0, 6595: 2, 6596: 0, 6597: 2, 6598: 0, 6599: 2, 6600: 0, 6601: 2, 6602: 0, 6603: 2, 6605: 2, 6606: 0, 6607: 2, 6608: 0, 6609: 2, 6610: 0, 6611: 0, 6612: 2, 6613: 0, 6614: 2, 6615: 0, 6616: 2, 6617: 0, 6618: 2, 6633: 2, 6646: 0, 6703: 0, 6784: 0, 6785: 1, 6786: 0, 6787: 1, 6788: 0, 6789: 1, 6790: 0, 6791: 1, 6792: 0, 6793: 1, 6794: 0, 6795: 1, 6796: 0, 6797: 1, 6798: 0, 6799: 1, 6800: 0, 6801: 1, 6802: 0, 6803: 1, 6804: 0, 6805: 1, 6806: 0, 6807: 1, 6808: 0, 6809: 1, 6810: 0, 6811: 1, 6812: 0, 6813: 1, 6814: 0, 6815: 1, 6816: 0, 6817: 1, 6818: 0, 6819: 1, 6820: 0, 6821: 1, 6822: 0, 6823: 1, 6824: 0, 6825: 1, 6826: 0, 6827: 1, 6828: 0, 6829: 1, 6830: 0, 6831: 1, 6832: 0, 6833: 1, 6834: 0, 6835: 1, 6836: 0, 6837: 1, 6838: 0, 6839: 1, 6840: 0, 6841: 1, 6842: 0, 6843: 1, 6844: 0, 6845: 1, 6846: 0, 6847: 1, 6848: 0, 6849: 1, 6850: 0, 6851: 1, 6852: 0, 6853: 1, 6854: 0, 6855: 1, 6856: 0, 6857: 1, 6858: 0, 6859: 1, 6860: 0, 6861: 1, 6862: 0, 6863: 1, 6867: 0, 6868: 1, 6870: 0, 6875: 0, 6876: 0, 6879: 0, 6880: 2, 6884: 0, 6885: 1, 6886: 0, 6887: 1, 6915: 0, 6922: 0, 6923: 2, 6924: 0, 6925: 2, 6962: 0, 6984: 0, 6991: 0, 7128: 2, 7131: 0, 7132: 2, 7142: 0, 7257: 0, 7258: 2, 7259: 0, 7260: 2, 7261: 0, 7262: 2, 7263: 0, 7264: 2, 7265: 0, 7266: 2, 7267: 0, 7268: 2, 7269: 0, 7270: 2, 7271: 0, 7272: 2, 7273: 0, 7274: 2, 7275: 0, 7276: 2, 7277: 0, 7278: 2, 7279: 0, 7280: 2, 7281: 0, 7282: 2, 7283: 0, 7284: 2, 7285: 0, 7286: 2, 7287: 0, 7288: 2, 7289: 0, 7290: 2, 7291: 0, 7292: 2, 7293: 0, 7294: 2, 7295: 0, 7296: 2, 7297: 0, 7298: 2, 7299: 0, 7300: 2, 7301: 0, 7302: 2, 7303: 0, 7304: 2, 7305: 0, 7306: 2, 7307: 0, 7308: 2, 7309: 0, 7310: 2, 7311: 0, 7312: 2, 7313: 0, 7314: 2, 7315: 0, 7316: 2, 7317: 0, 7318: 2, 7319: 0, 7320: 2, 7321: 0, 7322: 2, 7323: 0, 7324: 2, 7325: 0, 7326: 2, 7327: 0, 7328: 2, 7329: 0, 7330: 2, 7331: 0, 7332: 2, 7333: 0, 7334: 2, 7335: 0, 7336: 2, 7337: 0, 7338: 2, 7339: 0, 7340: 2, 7341: 0, 7342: 2, 7343: 0, 7344: 2, 7345: 0, 7346: 2, 7347: 0, 7348: 2, 7349: 0, 7350: 2, 7351: 0, 7352: 2, 7353: 0, 7354: 2, 7355: 0, 7356: 2, 7357: 0, 7358: 2, 7359: 0, 7360: 2, 7361: 0, 7362: 2, 7363: 0, 7364: 2, 7365: 0, 7366: 2, 7367: 0, 7368: 2, 7369: 0, 7370: 2, 7877: 0, 7878: 0, 7882: 0, 7883: 0, 7887: 0, 7899: 0, 7991: 0, 7992: 0, 8035: 2, 8036: 2, 8058: 0, 8059: 0, 8082: 0, 8083: 0, 8088: 0, 8090: 0, 8091: 2, 8092: 0, 8093: 2, 8095: 0, 8096: 2, 8097: 0, 8098: 2, 8099: 0, 8100: 2, 8101: 0, 8102: 2, 8103: 0, 8104: 2, 8105: 0, 8106: 2, 8107: 0, 8108: 2, 8109: 0, 8110: 2, 8111: 0, 8112: 2, 8113: 0, 8114: 2, 8115: 0, 8116: 2, 8117: 0, 8118: 2, 8119: 0, 8120: 2, 8121: 0, 8122: 2, 8123: 0, 8124: 2, 8125: 0, 8126: 2, 8127: 0, 8128: 2, 8129: 0, 8130: 2, 8131: 0, 8132: 2, 8133: 0, 8134: 2, 8135: 0, 8136: 2, 8137: 0, 8138: 2, 8139: 0, 8140: 2, 8141: 0, 8142: 2, 8143: 0, 8144: 2, 8145: 0, 8146: 2, 8147: 0, 8148: 2, 8149: 0, 8150: 2, 8151: 0, 8152: 2, 8153: 0, 8154: 2, 8155: 0, 8156: 2, 8157: 0, 8158: 2, 8159: 0, 8160: 2, 8161: 0, 8162: 2, 8163: 0, 8164: 2, 8165: 0, 8166: 2, 8167: 0, 8168: 2, 8169: 0, 8170: 2, 8171: 0, 8172: 2, 8173: 0, 8177: 2, 8179: 0, 8180: 2, 8181: 0, 8182: 2, 8184: 0, 8185: 2, 8187: 0, 8189: 2, 8191: 0, 8193: 2, 8196: 0, 8197: 2, 8198: 0, 8200: 2, 8201: 0, 8202: 2, 8203: 0, 8204: 2, 8205: 0, 8206: 2, 8207: 0, 8208: 2, 8209: 0, 8210: 2, 8212: 0, 8213: 2, 8214: 0, 8216: 2, 8218: 0, 8220: 2, 8222: 0, 8224: 2, 8225: 0, 8226: 2, 8311: 0, 8312: 1, 8313: 0, 8314: 1, 8315: 0, 8316: 1, 8317: 0, 8318: 1, 8319: 0, 8320: 1, 8321: 0, 8322: 1, 8323: 0, 8324: 1, 8325: 0, 8326: 1, 8327: 0, 8328: 1, 8329: 0, 8330: 1, 8331: 0, 8332: 1, 8333: 0, 8334: 1, 8335: 0, 8336: 1, 8337: 0, 8338: 1, 8339: 0, 8340: 1, 8341: 0, 8342: 1, 8343: 0, 8344: 1, 8345: 0, 8346: 1, 8347: 0, 8348: 1, 8352: 0, 8353: 0, 8379: 0, 8380: 2, 8381: 0, 8382: 2, 8383: 0, 8384: 2, 8385: 0, 8387: 2, 8391: 0, 8395: 0, 8433: 0, 8441: 0, 8455: 0, 8456: 0, 8531: 2, 8682: 0, 8686: 0, 8687: 0, 8692: 0, 8693: 0, 8826: 0, 8903: 0, 8950: 0, 8951: 0, 9039: 0, 9040: 0, 9141: 0, 9149: 0, 9150: 0, 9191: 0, 9221: 0, 9222: 0, 9249: 0, 9250: 0, 9252: 0, 9254: 0, 9265: 0, 9284: 0, 9285: 0, 9300: 0, 9354: 0, 9367: 0, 9373: 0, 9377: 0, 9387: 0, 9391: 0, 9456: 0, 9473: 0, 9498: 0, 9674: 0, 9678: 0, 9680: 0, 9709: 0, 9712: 0, 9713: 0, 9716: 0, 9741: 0, 9748: 2, 9749: 2, 9761: 0, 9766: 0, 9793: 0, 9794: 0, 9869: 0, 9874: 0, 9875: 0, 9880: 0, 9895: 0, 9943: 0, 9945: 0, 9947: 0, 9967: 0, 9972: 0, 9977: 0, 10160: 0, 10183: 0, 10188: 0, 10194: 0, 10199: 0, 10207: 0, 10212: 0, 10217: 0, 10222: 0, 10227: 0, 10235: 0, 10240: 0, 10250: 0, 10254: 0, 10270: 0, 10275: 0, 10280: 0, 10306: 0, 10329: 0, 10471: 0, 10477: 0, 10481: 2, 10516: 2, 10592: 0, 10594: 0, 10596: 0, 10598: 0, 10601: 0, 10603: 0, 10626: 0, 10632: 0, 10641: 0, 10665: 0, 10674: 0, 10744: 0, 10745: 0, 10759: 0, 10773: 0, 10802: 0, 10820: 0, 20002: 0, 20042: 0, 20050: 1, 20499: 0, 20538: 0, 20539: 0, 20790: 0, 20791: 0, 21291: 0, 21292: 0, 21500: 0, 21817: 0, 21818: 0, 22032: 0, 22033: 0, 22091: 0, 22092: 0, 22239: 0, 22240: 0, 22332: 0, 22337: 0, 22338: 0, 22391: 0, 22392: 0, 22639: 0, 22700: 0, 22739: 0, 22770: 0, 22780: 0, 22832: 0, 23090: 0, 23095: 0, 23239: 0, 23240: 0, 23433: 0, 23700: 0, 24047: 0, 24048: 0, 24100: 3, 24200: 0, 24305: 0, 24306: 0, 24382: 10, 24383: 0, 24500: 0, 24547: 0, 24548: 0, 24571: 9, 24600: 0, 25e3: 0, 25231: 0, 25884: 0, 25932: 0, 26237: 0, 26331: 0, 26332: 0, 26432: 0, 26591: 0, 26592: 0, 26632: 0, 26692: 0, 27120: 0, 27200: 0, 27291: 6, 27292: 6, 27429: 0, 27492: 0, 27493: 0, 27500: 0, 28232: 0, 28600: 0, 28991: 0, 28992: 0, 29100: 0, 29101: 0, 29220: 0, 29221: 0, 29333: 0, 29635: 0, 29636: 0, 29701: 0, 29738: 0, 29739: 0, 29849: 0, 29850: 0, 29871: 8, 29872: 7, 29873: 0, 29874: 0, 30200: 5, 30339: 0, 30340: 0, 30591: 0, 30592: 0, 30791: 0, 30792: 0, 30800: 0, 31028: 0, 31121: 0, 31154: 0, 31170: 0, 31171: 0, 31370: 0, 31528: 0, 31529: 0, 31600: 0, 31700: 0, 31838: 0, 31839: 0, 31900: 0, 31901: 0, 32061: 0, 32062: 0, 32098: 0, 32099: 2, 32100: 0, 32104: 0, 32161: 0, 32766: 0, 53048: 0, 53049: 0, 65061: 2, 65062: 2, 102041: 2, 102064: 11, 102068: 15, 102069: 16, 102118: 2, 102119: 1, 102120: 2, 102121: 2, 102217: 2, 102218: 0, 102219: 2, 102220: 2, 102378: 1, 102379: 1, 102380: 0, 102381: 1, 102589: 2, 102599: 2, 102600: 2, 102604: 2, 102647: 0, 102704: 2, 102705: 2, 102706: 0, 102731: 0, 102732: 0, 102759: 1, 102760: 1, 102761: 2, 102762: 0, 102763: 2, 102764: 0, 102765: 0, 102766: 2, 102970: 1, 102974: 2, 102993: 0, 102994: 0, 102995: 2, 102996: 2, 103015: 0, 103016: 2, 103017: 0, 103018: 2, 103025: 0, 103026: 0, 103027: 2, 103028: 2, 103035: 0, 103036: 0, 103037: 2, 103038: 2, 103039: 0, 103040: 0, 103041: 2, 103042: 2, 103043: 0, 103044: 0, 103045: 2, 103046: 2, 103047: 0, 103048: 0, 103049: 2, 103050: 2, 103051: 0, 103052: 2, 103053: 0, 103054: 2, 103055: 0, 103056: 2, 103057: 0, 103058: 0, 103059: 2, 103060: 2, 103061: 0, 103062: 0, 103063: 2, 103064: 2, 103069: 2, 103070: 0, 103071: 0, 103072: 2, 103073: 2, 103086: 0, 103087: 0, 103088: 2, 103089: 2, 103094: 1, 103095: 0, 103096: 2, 103103: 0, 103104: 2, 103105: 0, 103106: 2, 103121: 0, 103122: 2, 103123: 0, 103124: 0, 103125: 1, 103126: 1, 103127: 0, 103128: 0, 103129: 2, 103130: 2, 103131: 0, 103132: 0, 103133: 2, 103134: 2, 103135: 0, 103136: 0, 103137: 1, 103138: 1, 103139: 0, 103140: 2, 103141: 0, 103142: 2, 103143: 0, 103144: 2, 103145: 0, 103146: 1, 103147: 0, 103148: 0, 103149: 2, 103150: 2, 103151: 0, 103152: 2, 103172: 0, 103173: 2, 103174: 0, 103175: 0, 103176: 2, 103177: 2, 103178: 0, 103179: 0, 103180: 2, 103181: 2, 103182: 0, 103183: 0, 103184: 2, 103185: 2, 103228: 0, 103229: 0, 103230: 2, 103231: 2, 103250: 0, 103251: 2, 103252: 0, 103253: 2, 103260: 0, 103261: 0, 103262: 2, 103263: 2, 103270: 0, 103271: 0, 103272: 2, 103273: 2, 103274: 0, 103275: 0, 103276: 2, 103277: 2, 103278: 0, 103279: 0, 103280: 2, 103281: 2, 103282: 0, 103283: 0, 103284: 2, 103285: 2, 103286: 0, 103287: 2, 103288: 0, 103289: 2, 103290: 0, 103291: 2, 103292: 0, 103293: 0, 103294: 2, 103295: 2, 103296: 0, 103297: 0, 103298: 2, 103299: 2, 103376: 2, 103377: 0, 103378: 0, 103379: 2, 103380: 2, 103393: 0, 103394: 0, 103395: 2, 103396: 2, 103472: 0, 103473: 1, 103474: 0, 103475: 2, 103482: 0, 103483: 2, 103484: 0, 103485: 2, 103500: 0, 103501: 2, 103502: 0, 103503: 0, 103504: 1, 103505: 1, 103506: 0, 103507: 0, 103508: 2, 103509: 2, 103510: 0, 103511: 0, 103512: 2, 103513: 2, 103514: 0, 103515: 2, 103516: 0, 103517: 2, 103518: 0, 103519: 2, 103520: 0, 103521: 1, 103522: 0, 103523: 0, 103524: 2, 103525: 2, 103526: 0, 103527: 2, 103561: 2, 103562: 2, 103563: 0, 103564: 0, 103565: 2, 103566: 2, 103567: 0, 103568: 0, 103569: 2, 103570: 2, 103584: 0, 103585: 2, 103586: 0, 103587: 2, 103588: 1, 103589: 0, 103590: 2, 103591: 1, 103592: 0, 103593: 2, 103594: 1, 103695: 2, 103897: 1, 103978: 2, 103979: 0, 103980: 2, 103981: 0 };
for (o = 2e3; o <= 2045; o++) w[o] = 0;
for (o = 2056; o <= 2065; o++) w[o] = 0;
for (o = 2067; o <= 2135; o++) w[o] = 0;
for (o = 2137; o <= 2154; o++) w[o] = 0;
for (o = 2161; o <= 2170; o++) w[o] = 0;
for (o = 2172; o <= 2193; o++) w[o] = 0;
for (o = 2195; o <= 2198; o++) w[o] = 0;
for (o = 2200; o <= 2203; o++) w[o] = 0;
for (o = 2205; o <= 2217; o++) w[o] = 0;
for (o = 2222; o <= 2224; o++) w[o] = 1;
for (o = 2225; o <= 2250; o++) w[o] = 2;
for (o = 2251; o <= 2253; o++) w[o] = 1;
for (o = 2257; o <= 2264; o++) w[o] = 2;
for (o = 2274; o <= 2279; o++) w[o] = 2;
for (o = 2280; o <= 2282; o++) w[o] = 1;
for (o = 2283; o <= 2289; o++) w[o] = 2;
for (o = 2290; o <= 2292; o++) w[o] = 0;
for (o = 2308; o <= 2313; o++) w[o] = 0;
for (o = 2315; o <= 2491; o++) w[o] = 0;
for (o = 2494; o <= 2866; o++) w[o] = 0;
for (o = 2867; o <= 2869; o++) w[o] = 1;
for (o = 2870; o <= 2888; o++) w[o] = 2;
for (o = 2891; o <= 2895; o++) w[o] = 2;
for (o = 2896; o <= 2898; o++) w[o] = 1;
for (o = 2902; o <= 2908; o++) w[o] = 2;
for (o = 2915; o <= 2920; o++) w[o] = 2;
for (o = 2921; o <= 2923; o++) w[o] = 1;
for (o = 2924; o <= 2930; o++) w[o] = 2;
for (o = 2931; o <= 2962; o++) w[o] = 0;
for (o = 2964; o <= 2968; o++) w[o] = 2;
for (o = 2969; o <= 2973; o++) w[o] = 0;
for (o = 2975; o <= 2991; o++) w[o] = 0;
for (o = 2995; o <= 3051; o++) w[o] = 0;
for (o = 3054; o <= 3079; o++) w[o] = 0;
for (o = 3081; o <= 3088; o++) w[o] = 0;
for (o = 3092; o <= 3101; o++) w[o] = 0;
for (o = 3106; o <= 3138; o++) w[o] = 0;
for (o = 3146; o <= 3151; o++) w[o] = 0;
for (o = 3153; o <= 3166; o++) w[o] = 0;
for (o = 3168; o <= 3172; o++) w[o] = 0;
for (o = 3174; o <= 3203; o++) w[o] = 0;
for (o = 3294; o <= 3358; o++) w[o] = 0;
for (o = 3367; o <= 3403; o++) w[o] = 0;
for (o = 3408; o <= 3416; o++) w[o] = 0;
for (o = 3417; o <= 3438; o++) w[o] = 2;
for (o = 3441; o <= 3446; o++) w[o] = 2;
for (o = 3447; o <= 3450; o++) w[o] = 0;
for (o = 3451; o <= 3459; o++) w[o] = 2;
for (o = 3460; o <= 3478; o++) w[o] = 0;
for (o = 3554; o <= 3559; o++) w[o] = 0;
for (o = 3560; o <= 3570; o++) w[o] = 2;
for (o = 3571; o <= 3581; o++) w[o] = 0;
for (o = 3594; o <= 3597; o++) w[o] = 0;
for (o = 3601; o <= 3604; o++) w[o] = 0;
for (o = 3637; o <= 3639; o++) w[o] = 0;
for (o = 3665; o <= 3667; o++) w[o] = 0;
for (o = 3693; o <= 3695; o++) w[o] = 0;
for (o = 3701; o <= 3727; o++) w[o] = 0;
for (o = 3728; o <= 3739; o++) w[o] = 2;
for (o = 3740; o <= 3751; o++) w[o] = 0;
for (o = 3753; o <= 3760; o++) w[o] = 2;
for (o = 3761; o <= 3773; o++) w[o] = 0;
for (o = 3775; o <= 3777; o++) w[o] = 0;
for (o = 3779; o <= 3781; o++) w[o] = 0;
for (o = 3783; o <= 3785; o++) w[o] = 0;
for (o = 3788; o <= 3791; o++) w[o] = 0;
for (o = 3797; o <= 3802; o++) w[o] = 0;
for (o = 3814; o <= 3816; o++) w[o] = 0;
for (o = 3825; o <= 3829; o++) w[o] = 0;
for (o = 3832; o <= 3841; o++) w[o] = 0;
for (o = 3844; o <= 3852; o++) w[o] = 0;
for (o = 3873; o <= 3885; o++) w[o] = 0;
for (o = 3890; o <= 3893; o++) w[o] = 0;
for (o = 3907; o <= 3912; o++) w[o] = 0;
for (o = 3942; o <= 3950; o++) w[o] = 0;
for (o = 3968; o <= 3970; o++) w[o] = 0;
for (o = 3973; o <= 3976; o++) w[o] = 0;
for (o = 3986; o <= 3989; o++) w[o] = 0;
for (o = 3994; o <= 3997; o++) w[o] = 0;
for (o = 4048; o <= 4051; o++) w[o] = 0;
for (o = 4056; o <= 4063; o++) w[o] = 0;
for (o = 4093; o <= 4096; o++) w[o] = 0;
for (o = 4390; o <= 4398; o++) w[o] = 0;
for (o = 4399; o <= 4413; o++) w[o] = 2;
for (o = 4418; o <= 4433; o++) w[o] = 2;
for (o = 4455; o <= 4457; o++) w[o] = 2;
for (o = 4484; o <= 4489; o++) w[o] = 0;
for (o = 4491; o <= 4554; o++) w[o] = 0;
for (o = 4568; o <= 4589; o++) w[o] = 0;
for (o = 4652; o <= 4656; o++) w[o] = 0;
for (o = 4766; o <= 4800; o++) w[o] = 0;
for (o = 5014; o <= 5016; o++) w[o] = 0;
for (o = 5069; o <= 5072; o++) w[o] = 0;
for (o = 5105; o <= 5130; o++) w[o] = 0;
for (o = 5167; o <= 5188; o++) w[o] = 0;
for (o = 5253; o <= 5259; o++) w[o] = 0;
for (o = 5269; o <= 5275; o++) w[o] = 0;
for (o = 5292; o <= 5311; o++) w[o] = 0;
for (o = 5329; o <= 5331; o++) w[o] = 0;
for (o = 5343; o <= 5349; o++) w[o] = 0;
for (o = 5355; o <= 5357; o++) w[o] = 0;
for (o = 5387; o <= 5389; o++) w[o] = 0;
for (o = 5459; o <= 5463; o++) w[o] = 0;
for (o = 5479; o <= 5482; o++) w[o] = 0;
for (o = 5518; o <= 5520; o++) w[o] = 0;
for (o = 5530; o <= 5539; o++) w[o] = 0;
for (o = 5550; o <= 5552; o++) w[o] = 0;
for (o = 5562; o <= 5583; o++) w[o] = 0;
for (o = 5623; o <= 5625; o++) w[o] = 2;
for (o = 5631; o <= 5639; o++) w[o] = 0;
for (o = 5649; o <= 5653; o++) w[o] = 0;
for (o = 5663; o <= 5680; o++) w[o] = 0;
for (o = 5682; o <= 5685; o++) w[o] = 0;
for (o = 5875; o <= 5877; o++) w[o] = 0;
for (o = 5896; o <= 5899; o++) w[o] = 0;
for (o = 5921; o <= 5940; o++) w[o] = 0;
for (o = 6050; o <= 6125; o++) w[o] = 0;
for (o = 6244; o <= 6275; o++) w[o] = 0;
for (o = 6328; o <= 6348; o++) w[o] = 0;
for (o = 6350; o <= 6356; o++) w[o] = 0;
for (o = 6366; o <= 6372; o++) w[o] = 0;
for (o = 6381; o <= 6387; o++) w[o] = 0;
for (o = 6393; o <= 6404; o++) w[o] = 0;
for (o = 6480; o <= 6483; o++) w[o] = 0;
for (o = 6511; o <= 6514; o++) w[o] = 0;
for (o = 6579; o <= 6581; o++) w[o] = 0;
for (o = 6619; o <= 6624; o++) w[o] = 0;
for (o = 6625; o <= 6627; o++) w[o] = 2;
for (o = 6628; o <= 6632; o++) w[o] = 0;
for (o = 6634; o <= 6637; o++) w[o] = 0;
for (o = 6669; o <= 6692; o++) w[o] = 0;
for (o = 6707; o <= 6709; o++) w[o] = 0;
for (o = 6720; o <= 6723; o++) w[o] = 0;
for (o = 6732; o <= 6738; o++) w[o] = 0;
for (o = 6931; o <= 6933; o++) w[o] = 0;
for (o = 6956; o <= 6959; o++) w[o] = 0;
for (o = 7005; o <= 7007; o++) w[o] = 0;
for (o = 7057; o <= 7070; o++) w[o] = 2;
for (o = 7074; o <= 7082; o++) w[o] = 0;
for (o = 7109; o <= 7118; o++) w[o] = 0;
for (o = 7119; o <= 7127; o++) w[o] = 1;
for (o = 7374; o <= 7376; o++) w[o] = 0;
for (o = 7528; o <= 7586; o++) w[o] = 0;
for (o = 7587; o <= 7645; o++) w[o] = 2;
for (o = 7692; o <= 7696; o++) w[o] = 0;
for (o = 7755; o <= 7787; o++) w[o] = 0;
for (o = 7791; o <= 7795; o++) w[o] = 0;
for (o = 7799; o <= 7801; o++) w[o] = 0;
for (o = 7803; o <= 7805; o++) w[o] = 0;
for (o = 7825; o <= 7831; o++) w[o] = 0;
for (o = 7845; o <= 7859; o++) w[o] = 0;
for (o = 8013; o <= 8032; o++) w[o] = 0;
for (o = 8065; o <= 8068; o++) w[o] = 1;
for (o = 8518; o <= 8529; o++) w[o] = 2;
for (o = 8533; o <= 8536; o++) w[o] = 2;
for (o = 8538; o <= 8540; o++) w[o] = 2;
for (o = 8677; o <= 8679; o++) w[o] = 0;
for (o = 8836; o <= 8840; o++) w[o] = 0;
for (o = 8857; o <= 8859; o++) w[o] = 0;
for (o = 8908; o <= 8910; o++) w[o] = 0;
for (o = 9154; o <= 9159; o++) w[o] = 0;
for (o = 9205; o <= 9218; o++) w[o] = 0;
for (o = 9271; o <= 9273; o++) w[o] = 0;
for (o = 9295; o <= 9297; o++) w[o] = 0;
for (o = 9356; o <= 9360; o++) w[o] = 0;
for (o = 9404; o <= 9407; o++) w[o] = 0;
for (o = 9476; o <= 9482; o++) w[o] = 0;
for (o = 9487; o <= 9494; o++) w[o] = 0;
for (o = 9697; o <= 9699; o++) w[o] = 0;
for (o = 9821; o <= 9865; o++) w[o] = 0;
for (o = 10285; o <= 10291; o++) w[o] = 0;
for (o = 10314; o <= 10317; o++) w[o] = 0;
for (o = 10448; o <= 10465; o++) w[o] = 0;
for (o = 10726; o <= 10729; o++) w[o] = 0;
for (o = 10731; o <= 10733; o++) w[o] = 0;
for (o = 11114; o <= 11118; o++) w[o] = 0;
for (o = 20004; o <= 20032; o++) w[o] = 0;
for (o = 20047; o <= 20049; o++) w[o] = 0;
for (o = 20062; o <= 20092; o++) w[o] = 0;
for (o = 20135; o <= 20138; o++) w[o] = 0;
for (o = 20248; o <= 20258; o++) w[o] = 0;
for (o = 20348; o <= 20358; o++) w[o] = 0;
for (o = 20436; o <= 20440; o++) w[o] = 0;
for (o = 20822; o <= 20824; o++) w[o] = 0;
for (o = 20904; o <= 20932; o++) w[o] = 0;
for (o = 20934; o <= 20936; o++) w[o] = 0;
for (o = 21004; o <= 21032; o++) w[o] = 0;
for (o = 21035; o <= 21037; o++) w[o] = 0;
for (o = 21095; o <= 21097; o++) w[o] = 0;
for (o = 21148; o <= 21150; o++) w[o] = 0;
for (o = 21207; o <= 21264; o++) w[o] = 0;
for (o = 21307; o <= 21364; o++) w[o] = 0;
for (o = 21413; o <= 21423; o++) w[o] = 0;
for (o = 21453; o <= 21463; o++) w[o] = 0;
for (o = 21473; o <= 21483; o++) w[o] = 0;
for (o = 21780; o <= 21782; o++) w[o] = 0;
for (o = 21891; o <= 21894; o++) w[o] = 0;
for (o = 21896; o <= 21899; o++) w[o] = 0;
for (o = 22171; o <= 22177; o++) w[o] = 0;
for (o = 22181; o <= 22187; o++) w[o] = 0;
for (o = 22191; o <= 22197; o++) w[o] = 0;
for (o = 22207; o <= 22222; o++) w[o] = 0;
for (o = 22229; o <= 22232; o++) w[o] = 0;
for (o = 22234; o <= 22236; o++) w[o] = 0;
for (o = 22243; o <= 22250; o++) w[o] = 0;
for (o = 22262; o <= 22265; o++) w[o] = 0;
for (o = 22307; o <= 22322; o++) w[o] = 0;
for (o = 22348; o <= 22357; o++) w[o] = 0;
for (o = 22407; o <= 22422; o++) w[o] = 0;
for (o = 22462; o <= 22465; o++) w[o] = 0;
for (o = 22521; o <= 22525; o++) w[o] = 0;
for (o = 22607; o <= 22622; o++) w[o] = 0;
for (o = 22641; o <= 22646; o++) w[o] = 0;
for (o = 22648; o <= 22657; o++) w[o] = 0;
for (o = 22707; o <= 22722; o++) w[o] = 0;
for (o = 22762; o <= 22765; o++) w[o] = 0;
for (o = 22807; o <= 22822; o++) w[o] = 0;
for (o = 22991; o <= 22994; o++) w[o] = 0;
for (o = 23028; o <= 23038; o++) w[o] = 0;
for (o = 23301; o <= 23333; o++) w[o] = 2;
for (o = 23830; o <= 23853; o++) w[o] = 0;
for (o = 23866; o <= 23872; o++) w[o] = 0;
for (o = 23877; o <= 23884; o++) w[o] = 0;
for (o = 23886; o <= 23894; o++) w[o] = 0;
for (o = 23946; o <= 23948; o++) w[o] = 0;
for (o = 24311; o <= 24313; o++) w[o] = 0;
for (o = 24342; o <= 24347; o++) w[o] = 0;
for (o = 24370; o <= 24374; o++) w[o] = 10;
for (o = 24375; o <= 24381; o++) w[o] = 0;
for (o = 24718; o <= 24721; o++) w[o] = 0;
for (o = 24817; o <= 24821; o++) w[o] = 0;
for (o = 24877; o <= 24882; o++) w[o] = 0;
for (o = 24891; o <= 24893; o++) w[o] = 0;
for (o = 25391; o <= 25395; o++) w[o] = 0;
for (o = 25828; o <= 25838; o++) w[o] = 0;
for (o = 26191; o <= 26195; o++) w[o] = 0;
for (o = 26391; o <= 26393; o++) w[o] = 0;
for (o = 26701; o <= 26722; o++) w[o] = 0;
for (o = 26729; o <= 26799; o++) w[o] = 2;
for (o = 26801; o <= 26803; o++) w[o] = 2;
for (o = 26811; o <= 26813; o++) w[o] = 2;
for (o = 26847; o <= 26870; o++) w[o] = 2;
for (o = 26891; o <= 26899; o++) w[o] = 0;
for (o = 26901; o <= 26923; o++) w[o] = 0;
for (o = 26929; o <= 26946; o++) w[o] = 0;
for (o = 26948; o <= 26998; o++) w[o] = 0;
for (o = 27037; o <= 27040; o++) w[o] = 0;
for (o = 27205; o <= 27232; o++) w[o] = 0;
for (o = 27258; o <= 27260; o++) w[o] = 0;
for (o = 27391; o <= 27398; o++) w[o] = 0;
for (o = 27561; o <= 27564; o++) w[o] = 0;
for (o = 27571; o <= 27574; o++) w[o] = 0;
for (o = 27581; o <= 27584; o++) w[o] = 0;
for (o = 27591; o <= 27594; o++) w[o] = 0;
for (o = 27700; o <= 27707; o++) w[o] = 0;
for (o = 28191; o <= 28193; o++) w[o] = 0;
for (o = 28348; o <= 28358; o++) w[o] = 0;
for (o = 28402; o <= 28432; o++) w[o] = 0;
for (o = 28462; o <= 28492; o++) w[o] = 0;
for (o = 29118; o <= 29122; o++) w[o] = 0;
for (o = 29168; o <= 29172; o++) w[o] = 0;
for (o = 29177; o <= 29185; o++) w[o] = 0;
for (o = 29187; o <= 29195; o++) w[o] = 0;
for (o = 29900; o <= 29903; o++) w[o] = 0;
for (o = 30161; o <= 30179; o++) w[o] = 0;
for (o = 30491; o <= 30494; o++) w[o] = 0;
for (o = 30729; o <= 30732; o++) w[o] = 0;
for (o = 31251; o <= 31259; o++) w[o] = 0;
for (o = 31265; o <= 31268; o++) w[o] = 0;
for (o = 31275; o <= 31279; o++) w[o] = 0;
for (o = 31281; o <= 31297; o++) w[o] = 0;
for (o = 31461; o <= 31469; o++) w[o] = 0;
for (o = 31491; o <= 31495; o++) w[o] = 0;
for (o = 31917; o <= 31922; o++) w[o] = 0;
for (o = 31965; o <= 32e3; o++) w[o] = 0;
for (o = 32001; o <= 32003; o++) w[o] = 2;
for (o = 32005; o <= 32031; o++) w[o] = 2;
for (o = 32033; o <= 32060; o++) w[o] = 2;
for (o = 32064; o <= 32067; o++) w[o] = 2;
for (o = 32074; o <= 32077; o++) w[o] = 2;
for (o = 32081; o <= 32086; o++) w[o] = 0;
for (o = 32107; o <= 32130; o++) w[o] = 0;
for (o = 32133; o <= 32159; o++) w[o] = 0;
for (o = 32164; o <= 32167; o++) w[o] = 2;
for (o = 32180; o <= 32199; o++) w[o] = 0;
for (o = 32201; o <= 32260; o++) w[o] = 0;
for (o = 32301; o <= 32360; o++) w[o] = 0;
for (o = 32401; o <= 32460; o++) w[o] = 0;
for (o = 32501; o <= 32560; o++) w[o] = 0;
for (o = 32601; o <= 32662; o++) w[o] = 0;
for (o = 32664; o <= 32667; o++) w[o] = 2;
for (o = 32701; o <= 32761; o++) w[o] = 0;
for (o = 53001; o <= 53004; o++) w[o] = 0;
for (o = 53008; o <= 53019; o++) w[o] = 0;
for (o = 53021; o <= 53032; o++) w[o] = 0;
for (o = 53034; o <= 53037; o++) w[o] = 0;
for (o = 53042; o <= 53046; o++) w[o] = 0;
for (o = 53074; o <= 53080; o++) w[o] = 0;
for (o = 54001; o <= 54004; o++) w[o] = 0;
for (o = 54008; o <= 54019; o++) w[o] = 0;
for (o = 54021; o <= 54032; o++) w[o] = 0;
for (o = 54034; o <= 54037; o++) w[o] = 0;
for (o = 54042; o <= 54046; o++) w[o] = 0;
for (o = 54048; o <= 54053; o++) w[o] = 0;
for (o = 54074; o <= 54080; o++) w[o] = 0;
for (o = 54090; o <= 54096; o++) w[o] = 0;
for (o = 54098; o <= 54101; o++) w[o] = 0;
for (o = 65161; o <= 65163; o++) w[o] = 0;
for (o = 102001; o <= 102040; o++) w[o] = 0;
for (o = 102042; o <= 102063; o++) w[o] = 0;
for (o = 102065; o <= 102067; o++) w[o] = 0;
for (o = 102070; o <= 102117; o++) w[o] = 0;
for (o = 102122; o <= 102216; o++) w[o] = 0;
for (o = 102221; o <= 102377; o++) w[o] = 0;
for (o = 102382; o <= 102388; o++) w[o] = 0;
for (o = 102389; o <= 102398; o++) w[o] = 2;
for (o = 102399; o <= 102444; o++) w[o] = 0;
for (o = 102445; o <= 102447; o++) w[o] = 2;
for (o = 102448; o <= 102458; o++) w[o] = 0;
for (o = 102459; o <= 102468; o++) w[o] = 2;
for (o = 102469; o <= 102499; o++) w[o] = 0;
for (o = 102500; o <= 102519; o++) w[o] = 1;
for (o = 102520; o <= 102524; o++) w[o] = 0;
for (o = 102525; o <= 102529; o++) w[o] = 2;
for (o = 102530; o <= 102588; o++) w[o] = 0;
for (o = 102590; o <= 102598; o++) w[o] = 0;
for (o = 102601; o <= 102603; o++) w[o] = 0;
for (o = 102605; o <= 102628; o++) w[o] = 0;
for (o = 102629; o <= 102646; o++) w[o] = 2;
for (o = 102648; o <= 102700; o++) w[o] = 2;
for (o = 102701; o <= 102703; o++) w[o] = 0;
for (o = 102707; o <= 102730; o++) w[o] = 2;
for (o = 102733; o <= 102758; o++) w[o] = 2;
for (o = 102767; o <= 102900; o++) w[o] = 0;
for (o = 102901; o <= 102933; o++) w[o] = 2;
for (o = 102934; o <= 102950; o++) w[o] = 13;
for (o = 102951; o <= 102963; o++) w[o] = 0;
for (o = 102965; o <= 102969; o++) w[o] = 0;
for (o = 102971; o <= 102973; o++) w[o] = 0;
for (o = 102975; o <= 102989; o++) w[o] = 0;
for (o = 102990; o <= 102992; o++) w[o] = 1;
for (o = 102997; o <= 103002; o++) w[o] = 0;
for (o = 103003; o <= 103008; o++) w[o] = 2;
for (o = 103009; o <= 103011; o++) w[o] = 0;
for (o = 103012; o <= 103014; o++) w[o] = 2;
for (o = 103019; o <= 103021; o++) w[o] = 0;
for (o = 103022; o <= 103024; o++) w[o] = 2;
for (o = 103029; o <= 103031; o++) w[o] = 0;
for (o = 103032; o <= 103034; o++) w[o] = 2;
for (o = 103065; o <= 103068; o++) w[o] = 0;
for (o = 103074; o <= 103076; o++) w[o] = 0;
for (o = 103077; o <= 103079; o++) w[o] = 1;
for (o = 103080; o <= 103082; o++) w[o] = 0;
for (o = 103083; o <= 103085; o++) w[o] = 2;
for (o = 103090; o <= 103093; o++) w[o] = 0;
for (o = 103097; o <= 103099; o++) w[o] = 0;
for (o = 103100; o <= 103102; o++) w[o] = 2;
for (o = 103107; o <= 103109; o++) w[o] = 0;
for (o = 103110; o <= 103112; o++) w[o] = 2;
for (o = 103113; o <= 103116; o++) w[o] = 0;
for (o = 103117; o <= 103120; o++) w[o] = 2;
for (o = 103153; o <= 103157; o++) w[o] = 0;
for (o = 103158; o <= 103162; o++) w[o] = 2;
for (o = 103163; o <= 103165; o++) w[o] = 0;
for (o = 103166; o <= 103168; o++) w[o] = 1;
for (o = 103169; o <= 103171; o++) w[o] = 2;
for (o = 103186; o <= 103188; o++) w[o] = 0;
for (o = 103189; o <= 103191; o++) w[o] = 2;
for (o = 103192; o <= 103195; o++) w[o] = 0;
for (o = 103196; o <= 103199; o++) w[o] = 2;
for (o = 103200; o <= 103224; o++) w[o] = 0;
for (o = 103225; o <= 103227; o++) w[o] = 1;
for (o = 103232; o <= 103237; o++) w[o] = 0;
for (o = 103238; o <= 103243; o++) w[o] = 2;
for (o = 103244; o <= 103246; o++) w[o] = 0;
for (o = 103247; o <= 103249; o++) w[o] = 2;
for (o = 103254; o <= 103256; o++) w[o] = 0;
for (o = 103257; o <= 103259; o++) w[o] = 2;
for (o = 103264; o <= 103266; o++) w[o] = 0;
for (o = 103267; o <= 103269; o++) w[o] = 2;
for (o = 103300; o <= 103375; o++) w[o] = 0;
for (o = 103381; o <= 103383; o++) w[o] = 0;
for (o = 103384; o <= 103386; o++) w[o] = 1;
for (o = 103387; o <= 103389; o++) w[o] = 0;
for (o = 103390; o <= 103392; o++) w[o] = 2;
for (o = 103397; o <= 103399; o++) w[o] = 0;
for (o = 103400; o <= 103471; o++) w[o] = 2;
for (o = 103476; o <= 103478; o++) w[o] = 0;
for (o = 103479; o <= 103481; o++) w[o] = 2;
for (o = 103486; o <= 103488; o++) w[o] = 0;
for (o = 103489; o <= 103491; o++) w[o] = 2;
for (o = 103492; o <= 103495; o++) w[o] = 0;
for (o = 103496; o <= 103499; o++) w[o] = 2;
for (o = 103528; o <= 103543; o++) w[o] = 0;
for (o = 103544; o <= 103548; o++) w[o] = 2;
for (o = 103549; o <= 103551; o++) w[o] = 0;
for (o = 103552; o <= 103554; o++) w[o] = 1;
for (o = 103555; o <= 103557; o++) w[o] = 2;
for (o = 103558; o <= 103560; o++) w[o] = 0;
for (o = 103571; o <= 103573; o++) w[o] = 0;
for (o = 103574; o <= 103576; o++) w[o] = 2;
for (o = 103577; o <= 103580; o++) w[o] = 0;
for (o = 103581; o <= 103583; o++) w[o] = 2;
for (o = 103595; o <= 103694; o++) w[o] = 0;
for (o = 103696; o <= 103699; o++) w[o] = 0;
for (o = 103700; o <= 103793; o++) w[o] = 2;
for (o = 103794; o <= 103890; o++) w[o] = 0;
for (o = 103891; o <= 103896; o++) w[o] = 2;
for (o = 103900; o <= 103971; o++) w[o] = 2;
for (o = 103972; o <= 103977; o++) w[o] = 0;
for (o = 112e3; o <= 112101; o++) w[o] = 0;
const D3 = [102100, 102113, 3857, 3785, 900913], CE = [104905, 104971], RE = [104903], IE = [4326, ...D3, ...CE, ...RE], Ii = [-20037508342788905e-9, 20037508342788905e-9], U0 = [-20037508342787e-6, 20037508342787e-6], b1 = { wkTemplate: 'PROJCS["WGS_1984_Web_Mercator_Auxiliary_Sphere",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Mercator_Auxiliary_Sphere"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",{Central_Meridian}],PARAMETER["Standard_Parallel_1",0.0],PARAMETER["Auxiliary_Sphere_Type",0.0],UNIT["Meter",1.0]]', valid: Ii, origin: U0, dx: 1e-5 }, $3 = { 102113: { wkTemplate: 'PROJCS["WGS_1984_Web_Mercator",GEOGCS["GCS_WGS_1984_Major_Auxiliary_Sphere",DATUM["D_WGS_1984_Major_Auxiliary_Sphere",SPHEROID["WGS_1984_Major_Auxiliary_Sphere",6378137.0,0.0]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Mercator"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",{Central_Meridian}],PARAMETER["Standard_Parallel_1",0.0],UNIT["Meter",1.0]]', valid: Ii, origin: U0, dx: 1e-5 }, 102100: b1, 3785: { wkTemplate: 'PROJCS["WGS_1984_Web_Mercator",GEOGCS["GCS_WGS_1984_Major_Auxiliary_Sphere",DATUM["D_WGS_1984_Major_Auxiliary_Sphere",SPHEROID["WGS_1984_Major_Auxiliary_Sphere",6378137.0,0.0]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Mercator"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",{Central_Meridian}],PARAMETER["Standard_Parallel_1",0.0],UNIT["Meter",1.0]]', valid: Ii, origin: U0, dx: 1e-5 }, 3857: b1, 4326: { wkTemplate: 'GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",{Central_Meridian}],UNIT["Degree",0.0174532925199433]]', altTemplate: 'PROJCS["WGS_1984_Plate_Carree",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Plate_Carree"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",{Central_Meridian}],UNIT["Degrees",111319.491]]', valid: [-180, 180], origin: [-180, 90], dx: 1e-5 }, 104971: { wkTemplate: 'GEOGCS["Mars_2000_(Sphere)",DATUM["Mars_2000_(Sphere)",SPHEROID["Mars_2000_(Sphere)",3396190.0,0.0]],PRIMEM["Reference_Meridian",0.0],UNIT["Degree",0.0174532925199433]]', valid: [-180, 180], origin: [-180, 90], dx: 1e-5 }, 104905: { wkTemplate: 'GEOGCS["GCS_Mars_2000",DATUM["D_Mars_2000",SPHEROID["Mars_2000_IAU_IAG",3396190.0,169.8944472236118]],PRIMEM["Reference_Meridian",0.0],UNIT["Degree",0.0174532925199433]]', valid: [-180, 180], origin: [-180, 90], dx: 1e-5 }, 900913: b1, 104903: { wkTemplate: 'GEOGCS["GCS_Moon_2000",DATUM["D_Moon_2000",SPHEROID["Moon_2000_IAU_IAG",1737400,0,AUTHORITY["ESRI","107903"]],AUTHORITY["ESRI","106903"]],PRIMEM["Reference_Meridian",0,AUTHORITY["ESRI","108900"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["ESRI","104903"]]', valid: [-180, 180], origin: [-180, 90], dx: 1e-5 } };
function wh(t, e) {
  if (t === e) return !0;
  if (t == null || e == null) return !1;
  const r = t.wkid, n = e.wkid;
  if (r != null || n != null) {
    if (r === n || Gs(t) && Gs(e)) return !0;
    const u = t.latestWkid;
    if (u != null && n === u) return !0;
    const l = e.latestWkid;
    return l != null && r === l;
  }
  let s, i;
  return t.wkt2 && e.wkt2 ? (s = t.wkt2, i = e.wkt2) : t.wkt && e.wkt && (s = t.wkt, i = e.wkt), !(!s || !i) && s.toUpperCase() === i.toUpperCase();
}
function la(t) {
  const e = t?.wkid;
  return e != null && e >= 2e3 && $3[e] || null;
}
function F3(t) {
  if (!FE(t)) return !1;
  const { wkid: e } = t;
  if (e) return w[e] == null;
  const r = t.wkt2 || t.wkt;
  return !!r && /^\s*(?:GEOGCS|GEOGCRS|GEOGRAPHICCRS)/i.test(r);
}
function V0(t) {
  return t?.wkid === 4326;
}
function Gs(t) {
  const e = t?.wkid;
  return e != null && e >= 2e3 && D3.includes(e);
}
function kE(t) {
  return t === 104971 || t === 104905;
}
function DE(t) {
  return t === 104903;
}
function $E(t) {
  const e = t?.wkid;
  return e != null && e >= 2e3 && IE.includes(e);
}
function FE(t) {
  if (t == null) return !1;
  const e = t.wkid;
  return e != null && e >= 2e3 || t.wkt2 != null || t.wkt != null;
}
const U3 = { wkid: 4326, wkt: Xa($3[4326].wkTemplate, { Central_Meridian: "0.0" }) }, V3 = { wkid: 102100, latestWkid: 3857 }, UE = { wkid: 32662 };
function vh(t) {
  return { wkt: `GEOCCS["Spherical geocentric",
    DATUM["Not specified",
      SPHEROID["Sphere",${t.radius},0]],
    PRIMEM["Greenwich",0.0,
      AUTHORITY["EPSG","8901"]],
    UNIT["m",1.0],
    AXIS["Geocentric X",OTHER],
    AXIS["Geocentric Y",EAST],
    AXIS["Geocentric Z",NORTH]
  ]` };
}
vh(Dn);
vh(f3);
vh(h3);
`${Dn.radius}`;
const VE = Dn.radius * Math.PI / 200, z3 = /(?:LENGTH)?UNIT\[([^\]]+)]]$/i, Bs = w, j3 = /UNIT\[([^\]]+)]/i, zE = /* @__PURE__ */ new Set([4305, 4807, 4810, 4811, 4812, 4816, 4819, 4821, 4901, 4902, 37225, 104025, 104026, 104139, 104140]), jE = ou()({ millimeter: "millimeters", centimeter: "centimeters", meter: "meters", meter_german: "german-meters", kilometer: "kilometers", decimeter: "decimeters", micrometer: "micrometers", nanometer: "nanometers", "50_kilometers": "50-kilometers", "150_kilometers": "150-kilometers", foot: "feet", foot_us: "us-feet", foot_clarke: "clarke-feet", fathom: "fathoms", nautical_mile: "nautical-miles", chain_us: "us-chains", link_us: "us-links", mile_us: "us-miles", yard_clarke: "clarke-yards", chain_clarke: "clarke-chains", link_clarke: "clarke-links", yard_sears: "sears-yards", foot_sears: "sears-feet", chain_sears: "sears-chains", link_sears: "sears-links", yard_benoit_1895_a: "benoit-1895-a-yards", foot_benoit_1895_a: "benoit-1895-a-feet", chain_benoit_1895_a: "benoit-1895-a-chains", link_benoit_1895_a: "benoit-1895-a-links", yard_benoit_1895_b: "benoit-1895-b-yards", foot_benoit_1895_b: "benoit-1895-b-feet", chain_benoit_1895_b: "benoit-1895-b-chains", link_benoit_1895_b: "benoit-1895-b-links", foot_1865: "1865-feet", foot_indian: "indian-feet", foot_indian_1937: "indian-1937-feet", foot_indian_1962: "indian-1962-feet", foot_indian_1975: "indian-1975-feet", yard_indian: "indian-yards", yard_indian_1937: "indian-1937-yards", yard_indian_1962: "indian-1962-yards", yard_indian_1975: "indian-1975-yards", statute_mile: "statute-miles", foot_gold_coast: "gold-coast-feet", foot_british_1936: "british-1936-feet", yard: "yards", chain: "chains", link: "links", yard_sears_1922_truncated: "sears-1922-truncated-yards", foot_sears_1922_truncated: "sears-1922-truncated-feet", chain_sears_1922_truncated: "sears-1922-truncated-chains", link_sears_1922_truncated: "sears-1922-truncated-links", yard_us: "us-yards", inch: "inches", inch_us: "us-inches", rod: "rods", rod_us: "us-rods", nautical_mile_us: "us-nautical-miles", nautical_mile_uk: "uk-nautical-miles", smoot: "smoots", vara_tx: "tx-vara", point: "points" }), Rr = (t) => t * t, bn = (t) => t * t * t, w2 = { length: { baseUnit: "meters", units: { millimeters: { inBaseUnits: 1e-3 }, centimeters: { inBaseUnits: 0.01 }, meters: { inBaseUnits: 1 }, feet: { inBaseUnits: 0.3048 }, "us-feet": { inBaseUnits: 0.3048006096012192 }, "clarke-feet": { inBaseUnits: 0.3047972654 }, fathoms: { inBaseUnits: 1.8288 }, "nautical-miles": { inBaseUnits: 1852 }, "german-meters": { inBaseUnits: 1.0000135965 }, "us-chains": { inBaseUnits: 20.11684023368047 }, "us-links": { inBaseUnits: 0.2011684023368047 }, "us-miles": { inBaseUnits: 1609.347218694438 }, kilometers: { inBaseUnits: 1e3 }, "clarke-yards": { inBaseUnits: 0.9143917962 }, "clarke-chains": { inBaseUnits: 20.1166195164 }, "clarke-links": { inBaseUnits: 0.201166195164 }, "sears-yards": { inBaseUnits: 0.9143984146160287 }, "sears-feet": { inBaseUnits: 0.3047994715386762 }, "sears-chains": { inBaseUnits: 20.11676512155263 }, "sears-links": { inBaseUnits: 0.2011676512155263 }, "benoit-1895-a-yards": { inBaseUnits: 0.9143992 }, "benoit-1895-a-feet": { inBaseUnits: 0.3047997333333333 }, "benoit-1895-a-chains": { inBaseUnits: 20.1167824 }, "benoit-1895-a-links": { inBaseUnits: 0.201167824 }, "benoit-1895-b-yards": { inBaseUnits: 0.9143992042898124 }, "benoit-1895-b-feet": { inBaseUnits: 0.3047997347632708 }, "benoit-1895-b-chains": { inBaseUnits: 20.11678249437587 }, "benoit-1895-b-links": { inBaseUnits: 0.2011678249437587 }, "1865-feet": { inBaseUnits: 0.3048008333333334 }, "indian-feet": { inBaseUnits: 0.3047995102481469 }, "indian-1937-feet": { inBaseUnits: 0.30479841 }, "indian-1962-feet": { inBaseUnits: 0.3047996 }, "indian-1975-feet": { inBaseUnits: 0.3047995 }, "indian-yards": { inBaseUnits: 0.9143985307444408 }, "indian-1937-yards": { inBaseUnits: 0.91439523 }, "indian-1962-yards": { inBaseUnits: 0.9143988 }, "indian-1975-yards": { inBaseUnits: 0.9143985 }, miles: { inBaseUnits: 1609.344 }, "statute-miles": { inBaseUnits: 1609.344 }, "gold-coast-feet": { inBaseUnits: 0.3047997101815088 }, "british-1936-feet": { inBaseUnits: 0.3048007491 }, yards: { inBaseUnits: 0.9144 }, chains: { inBaseUnits: 20.1168 }, links: { inBaseUnits: 0.201168 }, "sears-1922-truncated-yards": { inBaseUnits: 0.914398 }, "sears-1922-truncated-feet": { inBaseUnits: 0.3047993333333334 }, "sears-1922-truncated-chains": { inBaseUnits: 20.116756 }, "sears-1922-truncated-links": { inBaseUnits: 0.20116756 }, "us-yards": { inBaseUnits: 0.9144018288036576 }, decimeters: { inBaseUnits: 0.1 }, inches: { inBaseUnits: 0.0254 }, "us-inches": { inBaseUnits: 0.0254000508001016 }, rods: { inBaseUnits: 5.0292 }, "us-rods": { inBaseUnits: 5.029210058420118 }, "us-nautical-miles": { inBaseUnits: 1853.248 }, "uk-nautical-miles": { inBaseUnits: 1853.184 }, smoots: { inBaseUnits: 1.7018 }, "tx-vara": { inBaseUnits: 0.8466683600033867 }, points: { inBaseUnits: 3527777777777778e-19 }, micrometers: { inBaseUnits: 1e-6 }, nanometers: { inBaseUnits: 1e-9 }, "50-kilometers": { inBaseUnits: 5e4 }, "150-kilometers": { inBaseUnits: 15e4 } } }, area: { baseUnit: "square-meters", units: { "square-millimeters": { inBaseUnits: Rr(1e-3) }, "square-centimeters": { inBaseUnits: Rr(0.01) }, "square-decimeters": { inBaseUnits: Rr(0.1) }, "square-meters": { inBaseUnits: 1 }, "square-kilometers": { inBaseUnits: Rr(1e3) }, "square-inches": { inBaseUnits: Rr(0.0254) }, "square-feet": { inBaseUnits: Rr(0.3048) }, "square-yards": { inBaseUnits: Rr(0.9144) }, "square-miles": { inBaseUnits: Rr(1609.344) }, "square-nautical-miles": { inBaseUnits: Rr(1852) }, "square-us-feet": { inBaseUnits: Rr(1200 / 3937) }, acres: { inBaseUnits: 15625e-7 * Rr(1609.344) }, ares: { inBaseUnits: 100 }, hectares: { inBaseUnits: 1e4 } } }, volume: { baseUnit: "liters", units: { liters: { inBaseUnits: 1 }, "cubic-millimeters": { inBaseUnits: 1e3 * bn(1e-3) }, "cubic-centimeters": { inBaseUnits: 1e3 * bn(0.01) }, "cubic-decimeters": { inBaseUnits: 1e3 * bn(0.1) }, "cubic-meters": { inBaseUnits: 1e3 }, "cubic-kilometers": { inBaseUnits: 1e3 * bn(1e3) }, "cubic-inches": { inBaseUnits: 1e3 * bn(0.0254) }, "cubic-feet": { inBaseUnits: 1e3 * bn(0.3048) }, "cubic-yards": { inBaseUnits: 1e3 * bn(0.9144) }, "cubic-miles": { inBaseUnits: 1e3 * bn(1609.344) } } }, angle: { baseUnit: "radians", units: { radians: { inBaseUnits: 1 }, degrees: { inBaseUnits: Math.PI / 180 } } } };
(() => {
  const t = {};
  for (const e in w2) for (const r in w2[e].units) t[r] = e;
  return t;
})();
function W3(t) {
  return jE.fromJSON(t.toLowerCase()) || null;
}
function WE(t, e = Dn.metersPerDegree) {
  return GE(t, !0) ?? e;
}
function GE(t, e = !1) {
  const r = t?.wkid ?? null, n = t?.wkt2 ?? t?.wkt ?? null;
  let s = null;
  if (r) {
    if (kE(r)) return f3.metersPerDegree;
    if (DE(r)) return h3.metersPerDegree;
    s = Bs.values[Bs[r]], !s && e && zE.has(r) && (s = VE);
  } else n && (q3(n) ? s = v2(z3.exec(n), s) : B3(n) && (s = v2(j3.exec(n), s)));
  return s;
}
function v2(t, e) {
  return t?.[1] ? G3(t[1]) : e;
}
function G3(t) {
  return parseFloat(t.split(",")[1]);
}
function BE(t) {
  const e = t?.wkid ?? null, r = t?.wkt2 ?? t?.wkt ?? null;
  let n = null;
  if (e) n = Bs.units[Bs[e]];
  else if (r) {
    const s = q3(r) ? z3 : B3(r) ? j3 : null;
    if (s) {
      const i = s.exec(r);
      i?.[1] && (n = HE(i[1]));
    }
  }
  return n != null ? W3(n) : null;
}
function B3(t) {
  return /^GEOCCS/i.test(t);
}
function q3(t) {
  return /^\s*(?:PROJCS|PROJCRS|PROJECTEDCRS)/i.test(t);
}
const qE = 1e-7;
function HE(t) {
  let r = /[\\"']([^\\"']+)/.exec(t)?.[1];
  if (!r || !W3(r)) {
    const n = G3(t);
    r = null;
    const s = Bs.values;
    for (let i = 0; i < s.length; ++i) if (Math.abs(n - s[i]) < qE) {
      r = Bs.units[i];
      break;
    }
  }
  return r;
}
const YE = { esriAcres: "acres", esriAres: "ares", esriHectares: "hectares", esriSquareCentimeters: "square-centimeters", esriSquareDecimeters: "square-decimeters", esriSquareFeet: "square-feet", esriSquareInches: "square-inches", esriSquareKilometers: "square-kilometers", esriSquareMeters: "square-meters", esriSquareMiles: "square-miles", esriSquareMillimeters: "square-millimeters", esriSquareUsFeet: "square-us-feet", esriSquareYards: "square-yards" }, ZE = { esriCentimeters: "centimeters", esriDecimeters: "decimeters", esriFeet: "feet", esriInches: "inches", esriKilometers: "kilometers", esriMeters: "meters", esriMiles: "miles", esriMillimeters: "millimeters", esriNauticalMiles: "nautical-miles", esriYards: "yards" }, XE = { esriDUDecimalDegrees: "degrees", esriDURadians: "radians" };
ou()(YE);
ou()(ZE);
ou()(XE);
function z0(t, e, r) {
  let n, s;
  return e === void 0 ? (s = t, n = [void 0]) : typeof e != "string" ? (s = t, n = [void 0], r = e) : (s = e, n = Array.isArray(t) ? t : [t]), (i, u) => {
    const l = i.constructor.prototype;
    for (const c of n) {
      const m = zy(i, c, s);
      m.write && typeof m.write == "object" || (m.write = {}), r && (m.write.target = r), m.write.writer = l[u];
    }
  };
}
var Hr;
let Ee = class extends l3 {
  static {
    Hr = this;
  }
  static {
    this.GCS_NAD_1927 = null;
  }
  static {
    this.WGS84 = null;
  }
  static {
    this.WebMercator = null;
  }
  static {
    this.PlateCarree = null;
  }
  static fromJSON(e) {
    if (!e) return null;
    if (e?.wkid === 102100) return Hr.WebMercator;
    if (e?.wkid === 4326) return Hr.WGS84;
    const r = new Hr();
    return r.read(e), r;
  }
  constructor(e) {
    super(e), this.latestWkid = null, this.wkid = null, this.wkt = null, this.wkt2 = null, this.vcsWkid = null, this.latestVcsWkid = null, this.imageCoordinateSystem = null;
  }
  normalizeCtorArgs(e) {
    return e && typeof e == "object" ? e : { [typeof e == "string" ? "wkt" : "wkid"]: e };
  }
  get isWGS84() {
    return V0(this);
  }
  get isWebMercator() {
    return Gs(this);
  }
  get isGeographic() {
    return F3(this);
  }
  get isWrappable() {
    return $E(this);
  }
  get metersPerUnit() {
    return WE(this);
  }
  get unit() {
    return BE(this) || (this.isGeographic ? "degrees" : null);
  }
  writeWkt(e, r) {
    this.wkid || (r.wkt = e);
  }
  clone() {
    if (this === Hr.WGS84) return new Hr(U3);
    if (this === Hr.WebMercator) return new Hr(V3);
    const e = new Hr();
    return this.wkid != null ? (e.wkid = this.wkid, this.latestWkid != null && (e.latestWkid = this.latestWkid), this.vcsWkid != null && (e.vcsWkid = this.vcsWkid), this.latestVcsWkid != null && (e.latestVcsWkid = this.latestVcsWkid)) : (this.wkt != null && (e.wkt = this.wkt), this.wkt2 != null && (e.wkt2 = this.wkt2)), this.imageCoordinateSystem && (e.imageCoordinateSystem = pr(this.imageCoordinateSystem)), e;
  }
  equals(e) {
    if (e == null) return !1;
    if (this.imageCoordinateSystem || e.imageCoordinateSystem) {
      if (this.imageCoordinateSystem == null || e.imageCoordinateSystem == null) return !1;
      const { id: r, referenceServiceName: n } = e.imageCoordinateSystem, { geodataXform: s } = e.imageCoordinateSystem, i = this.imageCoordinateSystem;
      return r == null || s ? JSON.stringify(i) === JSON.stringify(e.imageCoordinateSystem) : n ? i.id === r && i.referenceServiceName === n : i.id === r;
    }
    return wh(this, e);
  }
  toJSON(e) {
    return this.write(void 0, e);
  }
};
fe([_e({ readOnly: !0 })], Ee.prototype, "isWGS84", null), fe([_e({ readOnly: !0 })], Ee.prototype, "isWebMercator", null), fe([_e({ readOnly: !0 })], Ee.prototype, "isGeographic", null), fe([_e({ readOnly: !0 })], Ee.prototype, "isWrappable", null), fe([_e({ type: Zn, json: { write: !0 } })], Ee.prototype, "latestWkid", void 0), fe([_e({ readOnly: !0 })], Ee.prototype, "metersPerUnit", null), fe([_e({ readOnly: !0 })], Ee.prototype, "unit", null), fe([_e({ type: Zn, json: { write: !0, origins: { "web-scene": { write: { overridePolicy() {
  return { isRequired: this.wkt == null };
} } } } } })], Ee.prototype, "wkid", void 0), fe([_e({ type: String, json: { origins: { "web-scene": { write: { overridePolicy() {
  return { isRequired: this.wkid == null };
} } } } } })], Ee.prototype, "wkt", void 0), fe([z0("wkt"), z0("web-scene", "wkt")], Ee.prototype, "writeWkt", null), fe([_e({ type: String, json: { write: !1 } })], Ee.prototype, "wkt2", void 0), fe([_e({ type: Zn, json: { write: !0 } })], Ee.prototype, "vcsWkid", void 0), fe([_e({ type: Zn, json: { write: !0 } })], Ee.prototype, "latestVcsWkid", void 0), fe([_e()], Ee.prototype, "imageCoordinateSystem", void 0), Ee = Hr = fe([Ks("esri.geometry.SpatialReference")], Ee), Ee.prototype.toJSON.isDefaultToJSON = !0, Ee.GCS_NAD_1927 = Ms.freeze(new Ee({ wkid: 4267, wkt: 'GEOGCS["GCS_North_American_1927",DATUM["D_North_American_1927",SPHEROID["Clarke_1866",6378206.4,294.9786982]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]]' })), Ee.WGS84 = Ms.freeze(new Ee(U3)), Ee.WebMercator = Ms.freeze(new Ee(V3)), Ee.PlateCarree = Ms.freeze(new Ee(UE));
let Dr = class extends l3 {
  constructor(...e) {
    super(...e), this.type = null, this.hasM = !1, this.hasZ = !1, this.spatialReference = Ee.WGS84;
  }
  get cache() {
    return this.commitProperty("spatialReference"), {};
  }
  get extent() {
    return null;
  }
  readSpatialReference(e, r) {
    if (e instanceof Ee) return e;
    if (e != null) {
      const n = new Ee();
      return n.read(e, r), n;
    }
    return e;
  }
  clone() {
    return console.warn(".clone() is not implemented for " + this.declaredClass), null;
  }
  clearCache() {
    this.notifyChange("cache");
  }
  getCacheValue(e) {
    return this.cache[e];
  }
  setCacheValue(e, r) {
    this.cache[e] = r;
  }
};
fe([_e()], Dr.prototype, "type", void 0), fe([_e({ readOnly: !0 })], Dr.prototype, "cache", null), fe([_e({ readOnly: !0 })], Dr.prototype, "extent", null), fe([_e({ type: Boolean, json: { write: { overridePolicy: (t) => ({ enabled: t }) } } })], Dr.prototype, "hasM", void 0), fe([_e({ type: Boolean, json: { write: { overridePolicy: (t) => ({ enabled: t }) } } })], Dr.prototype, "hasZ", void 0), fe([_e({ type: Ee, json: { write: !0 }, value: Ee.WGS84 })], Dr.prototype, "spatialReference", void 0), fe([c3("spatialReference")], Dr.prototype, "readSpatialReference", null), Dr = fe([Ks("esri.geometry.Geometry")], Dr);
const JE = Object.prototype.toString;
function QE(t) {
  const e = "__accessorMetadata__" in t ? kn(t) : t;
  return function(...r) {
    if (r.push(e), typeof r[2] == "number") throw new Error("Using @cast has parameter decorator is not supported since 4.16");
    return KE.apply(this, r);
  };
}
function KE(t, e, r, n) {
  nu(t, e).cast = n;
}
function eN(t) {
  return (e, r) => {
    nu(e, t).cast = e[r];
  };
}
function tN(...t) {
  if (t.length !== 3 || typeof t[1] != "string") return t.length === 1 && JE.call(t[0]) === "[object Function]" ? QE(t[0]) : t.length === 1 && typeof t[0] == "string" ? eN(t[0]) : void 0;
}
function qa(t) {
  if (t && typeof t == "object" && "type" in t && t.type === "mesh") throw new Qs("internal:mesh", "Mesh geometries are not supported for this operation");
}
const rN = 57.29577951308232, nN = 0.017453292519943;
function S2(t) {
  return t * rN;
}
function E2(t) {
  return t * nN;
}
function N2(t) {
  return t.wkid != null || t.wkt != null;
}
const w1 = [0, 0];
function H3(t, e, r, n, s) {
  const i = t, u = s;
  if (u.spatialReference = r, "x" in i && "x" in u) [u.x, u.y] = e(i.x, i.y, w1, n);
  else if ("xmin" in i && "xmin" in u) [u.xmin, u.ymin] = e(i.xmin, i.ymin, w1, n), [u.xmax, u.ymax] = e(i.xmax, i.ymax, w1, n);
  else if ("paths" in i && "paths" in u || "rings" in i && "rings" in u) {
    const l = "paths" in i ? i.paths : i.rings, c = [];
    let m;
    for (let _ = 0; _ < l.length; _++) {
      const y = l[_];
      m = [], c.push(m);
      for (let v = 0; v < y.length; v++) m.push(e(y[v][0], y[v][1], [0, 0], n)), y[v].length > 2 && m[v].push(y[v][2]), y[v].length > 3 && m[v].push(y[v][3]);
    }
    "paths" in u ? u.paths = c : u.rings = c;
  } else if ("points" in i && "points" in u) {
    const l = i.points, c = [];
    for (let m = 0; m < l.length; m++) c[m] = e(l[m][0], l[m][1], [0, 0], n), l[m].length > 2 && c[m].push(l[m][2]), l[m].length > 3 && c[m].push(l[m][3]);
    u.points = c;
  }
  return s;
}
function v1(t, e) {
  const r = t && (N2(t) ? t : t.spatialReference), n = e && (N2(e) ? e : e.spatialReference);
  return !(t && "type" in t && t.type === "mesh" || e && "type" in e && e.type === "mesh" || !r || !n) && (!!wh(n, r) || Gs(n) && V0(r) || Gs(r) && V0(n));
}
function wi(t, e, r = [0, 0]) {
  e > 89.99999 ? e = 89.99999 : e < -89.99999 && (e = -89.99999);
  const n = E2(e);
  return r[0] = E2(t) * Dn.radius, r[1] = Dn.halfSemiMajorAxis * Math.log((1 + Math.sin(n)) / (1 - Math.sin(n))), r;
}
function Sh(t, e, r = [0, 0], n = !1) {
  if (t === Ii[0]) r[0] = -180;
  else if (t === Ii[1]) r[0] = 180;
  else {
    const s = S2(t / Dn.radius);
    r[0] = n ? s : s - 360 * Math.floor((s + 180) / 360);
  }
  return r[1] = S2(Math.PI / 2 - 2 * Math.atan(Math.exp(-e / Dn.radius))), r;
}
function S1(t, e = !1, r = pr(t)) {
  return qa(t), qa(r), H3(t, wi, Ee.WebMercator, e, r);
}
function Vo(t, e = !1, r = pr(t)) {
  return qa(t), qa(r), H3(t, Sh, Ee.WGS84, e, r);
}
function sN(t, e) {
  const r = t.x - e.x, n = t.y - e.y, s = t.z != null && e.z != null ? t.z - e.z : 0;
  return Math.sqrt(r * r + n * n + s * s);
}
function iN(t) {
  return Y3(t, Z3)?.[0] ?? null;
}
function oN(t) {
  return Y3(t, Z3)?.[1] ?? null;
}
function Y3({ x: t, y: e, spatialReference: r }, n = [0, 0]) {
  if (r) {
    if (Gs(r)) return Sh(t, e, n);
    if (F3(r)) return n[0] = t, n[1] = e, n;
  }
  return null;
}
const Z3 = [0, 0];
var ca;
const E1 = [0, 0];
function x2(t) {
  return t && (t.declaredClass === "esri.geometry.SpatialReference" || t.wkid != null);
}
let Ht = ca = class extends Dr {
  static copy(t, e) {
    e._set("x", t._get("x")), e._set("y", t._get("y")), e._set("z", t._get("z")), e._set("m", t._get("m"));
    const r = t._get("spatialReference");
    e._set("spatialReference", Ms.isFrozen(r) ? r : r.clone());
  }
  constructor(...t) {
    super(...t), this.x = 0, this.y = 0, this.z = void 0, this.m = void 0, this.type = "point";
  }
  normalizeCtorArgs(t, e, r, n, s) {
    let i;
    if (Array.isArray(t)) i = t, s = e, t = i[0], e = i[1], r = i[2], n = i[3];
    else if (t && typeof t == "object") {
      if (i = t, t = i.x != null ? i.x : i.longitude, e = i.y != null ? i.y : i.latitude, r = i.z, n = i.m, (s = i.spatialReference) && s.declaredClass !== "esri.geometry.SpatialReference" && (s = new Ee(s)), i.longitude != null || i.latitude != null) {
        if (i.longitude == null) nr.getLogger(this).warn(".longitude=", "Latitude was defined without longitude");
        else if (i.latitude == null) nr.getLogger(this).warn(".latitude=", "Longitude was defined without latitude");
        else if (!i.declaredClass && s?.isWebMercator) {
          const l = wi(i.longitude, i.latitude, E1);
          t = l[0], e = l[1];
        }
      }
    } else x2(r) ? (s = r, r = null) : x2(n) && (s = n, n = null);
    const u = { x: t, y: e };
    return u.x == null && u.y != null ? nr.getLogger(this).warn(".y=", "Y coordinate was defined without an X coordinate") : u.y == null && u.x != null && nr.getLogger(this).warn(".x=", "X coordinate was defined without a Y coordinate"), s != null && (u.spatialReference = s), r != null && (u.z = r), n != null && (u.m = n), u;
  }
  get cache() {
    return this.commitProperty("x"), this.commitProperty("y"), this.commitProperty("z"), this.commitProperty("m"), this.commitProperty("spatialReference"), {};
  }
  get hasM() {
    return this.m !== void 0;
  }
  set hasM(t) {
    t !== (this._get("m") !== void 0) && (this._set("m", t ? 0 : void 0), this._set("hasM", t));
  }
  get hasZ() {
    return this.z !== void 0;
  }
  set hasZ(t) {
    t !== (this._get("z") !== void 0) && (this._set("z", t ? 0 : void 0), this._set("hasZ", t));
  }
  get latitude() {
    return oN(this);
  }
  set latitude(t) {
    const { spatialReference: e, x: r } = this;
    t != null && e && (e.isWebMercator ? this._set("y", wi(r, t, E1)[1]) : e.isGeographic && this._set("y", t), this._set("latitude", t));
  }
  get longitude() {
    return iN(this);
  }
  set longitude(t) {
    const { y: e, spatialReference: r } = this;
    t != null && r && (r.isWebMercator ? this._set("x", wi(t, e, E1)[0]) : r.isGeographic && this._set("x", t), this._set("longitude", t));
  }
  writeX(t, e, r) {
    e[r] = isNaN(t) ? "NaN" : t;
  }
  readX(t) {
    return typeof t == "string" ? NaN : t;
  }
  clone() {
    const t = new ca();
    return t.x = this.x, t.y = this.y, t.z = this.z, t.m = this.m, t.spatialReference = this.spatialReference, t;
  }
  copy(t) {
    return ca.copy(t, this), this;
  }
  equals(t) {
    if (t == null) return !1;
    const { x: e, y: r, z: n, m: s, spatialReference: i } = this, { z: u, m: l } = t;
    let { x: c, y: m, spatialReference: _ } = t;
    if (!i.equals(_)) if (i.isWebMercator && _.isWGS84) [c, m] = wi(c, m), _ = i;
    else {
      if (!i.isWGS84 || !_.isWebMercator) return !1;
      [c, m] = Sh(c, m), _ = i;
    }
    return e === c && r === m && n === u && s === l && i.wkid === _.wkid;
  }
  offset(t, e, r) {
    return this.x += t, this.y += e, r != null && (this.z = (this.z ?? 0) + r), this;
  }
  normalize() {
    if (!this.spatialReference) return this;
    const t = la(this.spatialReference);
    if (!t) return this;
    let e = this.x;
    const [r, n] = t.valid, s = 2 * n;
    let i;
    return e > n ? (i = Math.ceil(Math.abs(e - n) / s), e -= i * s) : e < r && (i = Math.ceil(Math.abs(e - r) / s), e += i * s), this._set("x", e), this;
  }
  distance(t) {
    return sN(this, t);
  }
  toArray() {
    const t = this.hasZ, e = this.hasM;
    return t && e ? [this.x, this.y, this.z, this.m] : t ? [this.x, this.y, this.z] : e ? [this.x, this.y, this.m] : [this.x, this.y];
  }
  toJSON(t) {
    return this.write({}, t);
  }
};
fe([_e({ readOnly: !0 })], Ht.prototype, "cache", null), fe([_e({ type: Boolean, json: { read: !1, write: { enabled: !1, overridePolicy: null } } })], Ht.prototype, "hasM", null), fe([_e({ type: Boolean, json: { read: !1, write: { enabled: !1, overridePolicy: null } } })], Ht.prototype, "hasZ", null), fe([_e({ type: Number })], Ht.prototype, "latitude", null), fe([_e({ type: Number })], Ht.prototype, "longitude", null), fe([_e({ type: Number, json: { type: [Number, String], write: { isRequired: !0, allowNull: !0 } } }), tN((t) => isNaN(t) ? t : Ly(t))], Ht.prototype, "x", void 0), fe([z0("x")], Ht.prototype, "writeX", null), fe([c3("x")], Ht.prototype, "readX", null), fe([_e({ type: Number, json: { write: !0 } })], Ht.prototype, "y", void 0), fe([_e({ type: Number, json: { write: { overridePolicy() {
  return { enabled: this.hasZ };
} } } })], Ht.prototype, "z", void 0), fe([_e({ type: Number, json: { write: { overridePolicy() {
  return { enabled: this.hasM };
} } } })], Ht.prototype, "m", void 0), Ht = ca = fe([Ks("esri.geometry.Point")], Ht), Ht.prototype.toJSON.isDefaultToJSON = !0;
function X3(t, e) {
  return e != null && Zt(t, e.x, e.y, e.z);
}
function aN(t, e) {
  const { xmin: r, ymin: n, zmin: s, xmax: i, ymax: u, zmax: l } = e;
  return t.hasZ && e.hasZ ? Zt(t, r, n, s) && Zt(t, r, u, s) && Zt(t, i, u, s) && Zt(t, i, n, s) && Zt(t, r, n, l) && Zt(t, r, u, l) && Zt(t, i, u, l) && Zt(t, i, n, l) : Zt(t, r, n) && Zt(t, r, u) && Zt(t, i, u) && Zt(t, i, n);
}
function ki(t, e) {
  return Zt(t, e[0], e[1]);
}
function uN(t, e) {
  return Zt(t, e[0], e[1], e[2]);
}
function Zt(t, e, r, n) {
  return e >= t.xmin && e <= t.xmax && r >= t.ymin && r <= t.ymax && (n == null || !t.hasZ || n >= t.zmin && n <= t.zmax);
}
function lN(t, e) {
  if (!t || t.length < 1) return !1;
  if (cN(t)) return T2(!1, t, e);
  let r = !1;
  for (let n = 0, s = t.length; n < s; n++) r = T2(r, t[n], e);
  return r;
}
function cN(t) {
  return !Array.isArray(t[0][0]);
}
function T2(t, e, r) {
  const [n, s] = r;
  let i = t, u = 0;
  for (let l = 0, c = e.length; l < c; l++) {
    u++, u === c && (u = 0);
    const [m, _] = e[l], [y, v] = e[u];
    (_ < s && v >= s || v < s && _ >= s) && m + (s - _) / (v - _) * (y - m) < n && (i = !i);
  }
  return i;
}
function fN(t, e) {
  return X3(t, e);
}
function hN(t, e) {
  const r = t.hasZ && e.hasZ;
  let n, s, i;
  if (t.xmin <= e.xmin) {
    if (n = e.xmin, t.xmax < n) return !1;
  } else if (n = t.xmin, e.xmax < n) return !1;
  if (t.ymin <= e.ymin) {
    if (s = e.ymin, t.ymax < s) return !1;
  } else if (s = t.ymin, e.ymax < s) return !1;
  if (r && e.hasZ) {
    if (t.zmin <= e.zmin) {
      if (i = e.zmin, t.zmax < i) return !1;
    } else if (i = t.zmin, e.zmax < i) return !1;
  }
  return !0;
}
function dN(t, e) {
  const { points: r, hasZ: n } = e, s = n ? uN : ki;
  for (const i of r) if (s(t, i)) return !0;
  return !1;
}
const es = [0, 0], ts = [0, 0], rs = [0, 0], ns = [0, 0], mN = [es, ts, rs, ns], J3 = [[rs, es], [es, ts], [ts, ns], [ns, rs]];
function pN(t, e) {
  return gN(t, e.rings);
}
function gN(t, e) {
  es[0] = t.xmin, es[1] = t.ymax, ts[0] = t.xmax, ts[1] = t.ymax, rs[0] = t.xmin, rs[1] = t.ymin, ns[0] = t.xmax, ns[1] = t.ymin;
  for (const r of mN) if (lN(e, r)) return !0;
  for (const r of e) {
    if (!r.length) continue;
    let n = r[0];
    if (ki(t, n)) return !0;
    for (let s = 1; s < r.length; s++) {
      const i = r[s];
      if (ki(t, i) || Q3(n, i, J3)) return !0;
      n = i;
    }
  }
  return !1;
}
function _N(t, e) {
  es[0] = t.xmin, es[1] = t.ymax, ts[0] = t.xmax, ts[1] = t.ymax, rs[0] = t.xmin, rs[1] = t.ymin, ns[0] = t.xmax, ns[1] = t.ymin;
  const r = e.paths;
  for (const n of r) {
    if (!r.length) continue;
    let s = n[0];
    if (ki(t, s)) return !0;
    for (let i = 1; i < n.length; i++) {
      const u = n[i];
      if (ki(t, u) || Q3(s, u, J3)) return !0;
      s = u;
    }
  }
  return !1;
}
function Q3(t, e, r) {
  for (let n = 0; n < r.length; n++) if (yN(t, e, r[n][0], r[n][1])) return !0;
  return !1;
}
function yN(t, e, r, n, s) {
  const [i, u] = t, [l, c] = e, [m, _] = r, [y, v] = n, S = y - m, T = i - m, L = l - i, D = v - _, V = u - _, W = c - u, j = D * L - S * W;
  if (j === 0) return !1;
  const U = (S * V - D * T) / j, $ = (L * V - W * T) / j;
  return U >= 0 && U <= 1 && $ >= 0 && $ <= 1 && !0;
}
function bN(t) {
  switch (t) {
    case "esriGeometryEnvelope":
    case "extent":
      return hN;
    case "esriGeometryMultipoint":
    case "multipoint":
      return dN;
    case "esriGeometryPoint":
    case "point":
      return fN;
    case "esriGeometryMultiPatch":
    case "multipatch":
    case "esriGeometryPolygon":
    case "polygon":
      return pN;
    case "esriGeometryPolyline":
    case "polyline":
      return _N;
  }
}
var Ir;
function wN(t) {
  return t && (t.declaredClass === "esri.geometry.SpatialReference" || t.wkid != null);
}
function wn(t, e, r) {
  return e == null ? r : r == null ? e : t(e, r);
}
let Lt = Ir = class extends Dr {
  constructor(...t) {
    super(...t), this.type = "extent", this.xmin = 0, this.ymin = 0, this.mmin = void 0, this.zmin = void 0, this.xmax = 0, this.ymax = 0, this.mmax = void 0, this.zmax = void 0;
  }
  normalizeCtorArgs(t, e, r, n, s) {
    return wN(t) ? { spatialReference: t, xmin: 0, ymin: 0, xmax: 0, ymax: 0 } : typeof t == "object" ? (t.spatialReference = t.spatialReference == null ? Ee.WGS84 : t.spatialReference, t) : { xmin: t, ymin: e, xmax: r, ymax: n, spatialReference: s ?? Ee.WGS84 };
  }
  static fromPoint(t) {
    return new Ir({ xmin: t.x, ymin: t.y, zmin: t.z, xmax: t.x, ymax: t.y, zmax: t.z, spatialReference: t.spatialReference });
  }
  get cache() {
    return this.commitProperty("xmin"), this.commitProperty("ymin"), this.commitProperty("zmin"), this.commitProperty("mmin"), this.commitProperty("xmax"), this.commitProperty("ymax"), this.commitProperty("zmax"), this.commitProperty("mmax"), this.commitProperty("spatialReference"), {};
  }
  get center() {
    const t = new Ht({ x: 0.5 * (this.xmin + this.xmax), y: 0.5 * (this.ymin + this.ymax), spatialReference: this.spatialReference });
    return this.hasZ && (t.z = 0.5 * (this.zmin + this.zmax)), this.hasM && (t.m = 0.5 * (this.mmin + this.mmax)), t;
  }
  get extent() {
    return this.clone();
  }
  get hasM() {
    return this.mmin != null && this.mmax != null;
  }
  get hasZ() {
    return this.zmin != null && this.zmax != null;
  }
  get height() {
    return Math.abs(this.ymax - this.ymin);
  }
  get width() {
    return Math.abs(this.xmax - this.xmin);
  }
  centerAt(t) {
    const e = this.center;
    return t.z != null && this.hasZ ? this.offset(t.x - e.x, t.y - e.y, t.z - e.z) : this.offset(t.x - e.x, t.y - e.y);
  }
  clone() {
    const t = new Ir();
    return t.xmin = this.xmin, t.ymin = this.ymin, t.xmax = this.xmax, t.ymax = this.ymax, t.spatialReference = this.spatialReference, this.zmin != null && (t.zmin = this.zmin, t.zmax = this.zmax), this.mmin != null && (t.mmin = this.mmin, t.mmax = this.mmax), t;
  }
  contains(t) {
    if (!t) return !1;
    const e = this.spatialReference, r = t.spatialReference;
    return e && r && !e.equals(r) && v1(e, r) && (t = e.isWebMercator ? S1(t) : Vo(t, !0)), t.type === "point" ? X3(this, t) : t.type === "extent" && aN(this, t);
  }
  equals(t) {
    if (this === t) return !0;
    if (t == null) return !1;
    const e = this.spatialReference, r = t.spatialReference;
    return e && r && !e.equals(r) && v1(e, r) && (t = e.isWebMercator ? S1(t) : Vo(t, !0)), this.xmin === t.xmin && this.ymin === t.ymin && this.zmin === t.zmin && this.mmin === t.mmin && this.xmax === t.xmax && this.ymax === t.ymax && this.zmax === t.zmax && this.mmax === t.mmax;
  }
  expand(t) {
    const e = 0.5 * (1 - t), r = this.width * e, n = this.height * e;
    if (this.xmin += r, this.ymin += n, this.xmax -= r, this.ymax -= n, this.hasZ) {
      const s = (this.zmax - this.zmin) * e;
      this.zmin += s, this.zmax -= s;
    }
    if (this.hasM) {
      const s = (this.mmax - this.mmin) * e;
      this.mmin += s, this.mmax -= s;
    }
    return this;
  }
  intersects(t) {
    if (t == null) return !1;
    t.type === "mesh" && (t = t.extent);
    const e = this.spatialReference, r = t.spatialReference;
    return e && r && !wh(e, r) && v1(e, r) && (t = e.isWebMercator ? S1(t) : Vo(t, !0)), bN(t.type)(this, t);
  }
  normalize() {
    const t = this._normalize(!1, !0);
    return Array.isArray(t) ? t : [t];
  }
  offset(t, e, r) {
    return this.xmin += t, this.ymin += e, this.xmax += t, this.ymax += e, r != null && (this.zmin += r, this.zmax += r), this;
  }
  shiftCentralMeridian() {
    return this._normalize(!0);
  }
  union(t) {
    return this === t || (this.xmin = Math.min(this.xmin, t.xmin), this.ymin = Math.min(this.ymin, t.ymin), this.xmax = Math.max(this.xmax, t.xmax), this.ymax = Math.max(this.ymax, t.ymax), (this.hasZ || t.hasZ) && (this.zmin = wn(Math.min, this.zmin, t.zmin), this.zmax = wn(Math.max, this.zmax, t.zmax)), (this.hasM || t.hasM) && (this.mmin = wn(Math.min, this.mmin, t.mmin), this.mmax = wn(Math.max, this.mmax, t.mmax))), this;
  }
  intersection(t) {
    return this === t ? this : t != null && this.intersects(t) ? (this.xmin = Math.max(this.xmin, t.xmin), this.ymin = Math.max(this.ymin, t.ymin), this.xmax = Math.min(this.xmax, t.xmax), this.ymax = Math.min(this.ymax, t.ymax), (this.hasZ || t.hasZ) && (this.zmin = wn(Math.max, this.zmin, t.zmin), this.zmax = wn(Math.min, this.zmax, t.zmax)), (this.hasM || t.hasM) && (this.mmin = wn(Math.max, this.mmin, t.mmin), this.mmax = wn(Math.min, this.mmax, t.mmax)), this) : null;
  }
  toJSON(t) {
    return this.write({}, t);
  }
  _shiftCM(t = la(this.spatialReference)) {
    if (!t || !this.spatialReference) return this;
    const e = this.spatialReference, r = this._getCM(t);
    if (r) {
      const n = e.isWebMercator ? Vo(r) : r;
      this.xmin -= r.x, this.xmax -= r.x, e.isWebMercator || (n.x = N1(n.x, t).x), this.spatialReference = new Ee(Xa((e.isWGS84 ? t.altTemplate : null) ?? t.wkTemplate, { Central_Meridian: n.x }));
    }
    return this;
  }
  _getCM(t) {
    let e = null;
    const [r, n] = t.valid, s = this.xmin, i = this.xmax;
    return s >= r && s <= n && i >= r && i <= n || (e = this.center), e;
  }
  _normalize(t, e, r) {
    const n = this.spatialReference;
    if (!n) return this;
    const s = r ?? la(n);
    if (s == null) return this;
    const i = this._getParts(s).map((c) => c.extent);
    if (i.length < 2) return i[0] || this;
    if (i.length > 2) return t ? this._shiftCM(s) : this.set({ xmin: s.valid[0], xmax: s.valid[1] });
    if (t) return this._shiftCM(s);
    if (e) return i;
    let u = !0, l = !0;
    return i.forEach((c) => {
      c.hasZ || (u = !1), c.hasM || (l = !1);
    }), { rings: i.map((c) => {
      const m = [[c.xmin, c.ymin], [c.xmin, c.ymax], [c.xmax, c.ymax], [c.xmax, c.ymin], [c.xmin, c.ymin]];
      if (u) {
        const _ = (c.zmax - c.zmin) / 2;
        for (let y = 0; y < m.length; y++) m[y].push(_);
      }
      if (l) {
        const _ = (c.mmax - c.mmin) / 2;
        for (let y = 0; y < m.length; y++) m[y].push(_);
      }
      return m;
    }), hasZ: u, hasM: l, spatialReference: n };
  }
  _getParts(t) {
    let e = this.cache._parts;
    if (!e) {
      e = [];
      const { ymin: s, ymax: i, spatialReference: u } = this, l = this.width, c = this.xmin, m = this.xmax;
      let _;
      t = t || la(u);
      const [y, v] = t.valid;
      _ = N1(this.xmin, t);
      const S = _.x, T = _.frameId;
      _ = N1(this.xmax, t);
      const L = _.x, D = _.frameId, V = S === L && l > 0;
      if (l > 2 * v) {
        const W = new Ir(c < m ? S : L, s, v, i, u), j = new Ir(y, s, c < m ? L : S, i, u), U = new Ir(0, s, v, i, u), $ = new Ir(y, s, 0, i, u), B = [], Z = [];
        W.contains(U) && B.push(T), W.contains($) && Z.push(T), j.contains(U) && B.push(D), j.contains($) && Z.push(D);
        for (let ee = T + 1; ee < D; ee++) B.push(ee), Z.push(ee);
        e.push({ extent: W, frameIds: [T] }, { extent: j, frameIds: [D] }, { extent: U, frameIds: B }, { extent: $, frameIds: Z });
      } else S > L || V ? e.push({ extent: new Ir(S, s, v, i, u), frameIds: [T] }, { extent: new Ir(y, s, L, i, u), frameIds: [D] }) : e.push({ extent: new Ir(S, s, L, i, u), frameIds: [T] });
      this.cache._parts = e;
    }
    const r = this.hasZ, n = this.hasM;
    if (r || n) {
      const s = {};
      r && (s.zmin = this.zmin, s.zmax = this.zmax), n && (s.mmin = this.mmin, s.mmax = this.mmax);
      for (let i = 0; i < e.length; i++) e[i].extent.set(s);
    }
    return e;
  }
};
function N1(t, e) {
  const [r, n] = e.valid, s = 2 * n;
  let i, u = 0;
  return t > n ? (i = Math.ceil(Math.abs(t - n) / s), t -= i * s, u = i) : t < r && (i = Math.ceil(Math.abs(t - r) / s), t += i * s, u = -i), { x: t, frameId: u };
}
fe([_e({ readOnly: !0 })], Lt.prototype, "cache", null), fe([_e({ readOnly: !0 })], Lt.prototype, "center", null), fe([_e({ readOnly: !0 })], Lt.prototype, "extent", null), fe([_e({ readOnly: !0, json: { write: { enabled: !1, overridePolicy: null } } })], Lt.prototype, "hasM", null), fe([_e({ readOnly: !0, json: { write: { enabled: !1, overridePolicy: null } } })], Lt.prototype, "hasZ", null), fe([_e({ readOnly: !0 })], Lt.prototype, "height", null), fe([_e({ readOnly: !0 })], Lt.prototype, "width", null), fe([_e({ type: Number, json: { type: [Number, String], write: { enabled: !0, allowNull: !0 } } })], Lt.prototype, "xmin", void 0), fe([_e({ type: Number, json: { write: !0 } })], Lt.prototype, "ymin", void 0), fe([_e({ type: Number, json: { origins: { "web-scene": { write: !1 } }, read: (t) => t ?? void 0, write: { overridePolicy() {
  return { enabled: this.hasM };
} } } })], Lt.prototype, "mmin", void 0), fe([_e({ type: Number, json: { origins: { "web-scene": { write: !1 } }, write: { overridePolicy() {
  return { enabled: this.hasZ };
} } } })], Lt.prototype, "zmin", void 0), fe([_e({ type: Number, json: { write: !0 } })], Lt.prototype, "xmax", void 0), fe([_e({ type: Number, json: { write: !0 } })], Lt.prototype, "ymax", void 0), fe([_e({ type: Number, json: { origins: { "web-scene": { write: !1 } }, read: (t) => t ?? void 0, write: { overridePolicy() {
  return { enabled: this.hasM };
} } } })], Lt.prototype, "mmax", void 0), fe([_e({ type: Number, json: { origins: { "web-scene": { write: !1 } }, write: { overridePolicy() {
  return { enabled: this.hasZ };
} } } })], Lt.prototype, "zmax", void 0), Lt = Ir = fe([Ks("esri.geometry.Extent")], Lt), Lt.prototype.toJSON.isDefaultToJSON = !0;
function zo(t) {
  return typeof t == "number" && isFinite(t) && Math.floor(t) === t;
}
function P2(t) {
  if (!t) return "";
  const e = /(a|A|hh?|HH?|mm?|ss?|SSS|S|.)/g;
  let r = "";
  for (const n of t.match(e) || []) switch (n) {
    case "SSS":
    case "m":
    case "mm":
    case "h":
    case "hh":
    case "H":
    case "HH":
    case "s":
    case "ss":
      r += n;
      break;
    case "A":
    case "a":
      r += "a";
      break;
    default:
      r += `'${n}'`;
  }
  return r;
}
const A2 = "esri.core.sql.timeonly";
let mr = class Yr {
  constructor(e, r, n, s) {
    this._hour = e, this._minute = r, this._second = n, this._millisecond = s, this.declaredRootClass = A2;
  }
  static isTimeOnly(e) {
    return typeof e == "object" && e != null && "declaredRootClass" in e && e.declaredRootClass === A2;
  }
  get hour() {
    return this._hour;
  }
  get minute() {
    return this._minute;
  }
  get second() {
    return this._second;
  }
  get millisecond() {
    return this._millisecond;
  }
  equals(e) {
    return Yr.isTimeOnly(e) && e.hour === this.hour && e.minute === this.minute && e.second === this.second && e.millisecond === this.millisecond;
  }
  clone() {
    return new Yr(this.hour, this.minute, this.second, this.millisecond);
  }
  isValid() {
    return zo(this.hour) && zo(this.minute) && zo(this.second) && zo(this.millisecond) && this.hour >= 0 && this.hour < 24 && this.minute >= 0 && this.minute < 60 && this.second >= 0 && this.second < 60 && this.millisecond >= 0 && this.millisecond < 1e3;
  }
  toString() {
    return `${this.hour.toString().padStart(2, "0")}:${this.minute.toString().padStart(2, "0")}:${this.second.toString().padStart(2, "0")}` + (this.millisecond > 0 ? "." + this.millisecond.toString().padStart(3, "0") : "");
  }
  toSQLValue() {
    return this.toString();
  }
  toSQLWithKeyword() {
    return `time '${this.hour.toString().padStart(2, "0")}:${this.minute.toString().padStart(2, "0")}:${this.second.toString().padStart(2, "0")}${this.millisecond > 0 ? "." + this.millisecond.toString().padStart(3, "0") : ""}'`;
  }
  toStorageString() {
    return `${this.hour.toString().padStart(2, "0")}:${this.minute.toString().padStart(2, "0")}:${this.second.toString().padStart(2, "0")}`;
  }
  toFormat(e = null) {
    return e === null || e === "" ? this.toString() : (e = P2(e)) ? H.local(1970, 1, 1, this._hour, this._minute, this._second, this._millisecond).toFormat(e, { locale: Py(), numberingSystem: "latn" }) : "";
  }
  toNumber() {
    return this.millisecond + 1e3 * this.second + 1e3 * this.minute * 60 + 60 * this.hour * 60 * 1e3;
  }
  static fromParts(e, r, n, s) {
    const i = new Yr(e, r, n, s);
    return i.isValid() ? i : null;
  }
  static fromReader(e) {
    if (!e) return null;
    const r = e.split(":");
    return r.length !== 3 ? null : new Yr(parseInt(r[0], 10), parseInt(r[1], 10), parseInt(r[2], 10), 0);
  }
  static fromMilliseconds(e) {
    if (e > 864e5 || e < 0) return null;
    const r = Math.floor(e / 1e3 % 60), n = Math.floor(e / 6e4 % 60), s = Math.floor(e / 36e5 % 24), i = Math.floor(e % 1e3);
    return new Yr(s, n, r, i);
  }
  static fromDateJS(e) {
    return new Yr(e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds());
  }
  static fromDateTime(e) {
    return new Yr(e.hour, e.minute, e.second, e.millisecond);
  }
  static fromSqlTimeStampOffset(e) {
    return this.fromDateTime(e.toDateTime());
  }
  static fromString(e, r = null) {
    if (e === "" || e === null) return null;
    const n = [];
    r ? (r = P2(r)) && n.push(r) : r !== null && r !== "" || (n.push("HH:mm:ss"), n.push("HH:mm:ss.SSS"), n.push("hh:mm:ss a"), n.push("hh:mm:ss.SSS a"), n.push("HH:mm"), n.push("hh:mm a"), n.push("H:mm"), n.push("h:mm a"), n.push("H:mm:ss"), n.push("h:mm:ss a"), n.push("H:mm:ss.SSS"), n.push("h:mm:ss.SSS a"));
    for (const s of n) {
      const i = H.fromFormat(e, s);
      if (i.isValid) return new Yr(i.hour, i.minute, i.second, i.millisecond);
    }
    return null;
  }
  plus(e, r) {
    switch (e) {
      case "days":
      case "years":
      case "months":
        return this.clone();
      case "hours":
      case "minutes":
      case "seconds":
      case "milliseconds":
        return Yr.fromDateTime(this.toUTCDateTime().plus({ [e]: r }));
    }
    return null;
  }
  toUTCDateTime() {
    return H.utc(1970, 1, 1, this.hour, this.minute, this.second, this.millisecond);
  }
  difference(e, r) {
    switch (r.toLowerCase()) {
      case "days":
      case "day":
      case "d":
        return this.toUTCDateTime().diff(e.toUTCDateTime(), "days").days;
      case "months":
      case "month":
        return this.toUTCDateTime().diff(e.toUTCDateTime(), "months").months;
      case "minutes":
      case "minute":
      case "m":
        return r === "M" ? this.toUTCDateTime().diff(e.toUTCDateTime(), "months").months : this.toUTCDateTime().diff(e.toUTCDateTime(), "minutes").minutes;
      case "seconds":
      case "second":
      case "s":
        return this.toUTCDateTime().diff(e.toUTCDateTime(), "seconds").seconds;
      case "milliseconds":
      case "millisecond":
      case "ms":
      default:
        return this.toUTCDateTime().diff(e.toUTCDateTime(), "milliseconds").milliseconds;
      case "hours":
      case "hour":
      case "h":
        return this.toUTCDateTime().diff(e.toUTCDateTime(), "hours").hours;
      case "years":
      case "year":
      case "y":
        return this.toUTCDateTime().diff(e.toUTCDateTime(), "years").years;
    }
  }
};
function vN(t, e) {
  const r = K3[t.toLowerCase()];
  if (r == null) throw new R("FunctionNotRecognized");
  if (e.length < r.minParams || e.length > r.maxParams) throw new R("InvalidParameterCount", { name: t.toUpperCase() });
  return r.evaluate(e);
}
function L2(t, e) {
  const r = K3[t.toLowerCase()];
  return r != null && e >= r.minParams && e <= r.maxParams;
}
const K3 = { min: { minParams: 1, maxParams: 1, evaluate: (t) => M2(t[0], "min") }, max: { minParams: 1, maxParams: 1, evaluate: (t) => M2(t[0], "max") }, avg: { minParams: 1, maxParams: 1, evaluate: (t) => e9(t[0]) }, sum: { minParams: 1, maxParams: 1, evaluate: (t) => SN(t[0]) }, stddev: { minParams: 1, maxParams: 1, evaluate: (t) => EN(t[0]) }, count: { minParams: 1, maxParams: 1, evaluate: (t) => t[0] == null ? null : t[0].length }, var: { minParams: 1, maxParams: 1, evaluate: (t) => t9(t[0]) } };
function e9(t) {
  if (t === null) return null;
  let e = 0, r = 0;
  for (let n = 0; n < t.length; n++) {
    const s = t[n];
    if (s !== null) {
      if (!Eh(s)) throw new R("InvalidValueForAggregateFunction");
      r++, e += s;
    }
  }
  return r === 0 ? null : e / t.length;
}
function Eh(t) {
  return typeof t == "number";
}
function M2(t, e) {
  if (t === null) return null;
  let r = null, n = null;
  for (const s of t) {
    let i = s;
    i = Pr.isDateOnly(s) || mr.isTimeOnly(s) ? s.toNumber() : H.isDateTime(s) ? s.toMillis() : Br.isTimestampOffset(s) ? s.toMilliseconds() : s, (r === null || e === "max" && n !== null && i !== null && n <= i || e === "min" && n !== null && i !== null && n >= i) && (r = s, n = i);
  }
  return r;
}
function SN(t) {
  if (t === null) return null;
  let e = 0;
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    if (n !== null) {
      if (!Eh(n)) throw new R("InvalidValueForAggregateFunction");
      e += n;
    }
  }
  return e;
}
function EN(t) {
  if (t === null) return null;
  const e = t9(t);
  return e === null ? null : Math.sqrt(e);
}
function t9(t) {
  if (t === null || (t = t.filter((n) => n !== null)).length === 0) return null;
  const e = e9(t);
  if (e === null) return null;
  let r = 0;
  for (const n of t) {
    if (!Eh(n)) throw new R("InvalidValueForAggregateFunction");
    r += (e - n) ** 2;
  }
  return r / (t.length - 1);
}
function x1(t) {
  if (t.precision !== null || t.secondary !== null) throw new R("PrimarySecondaryQualifiers");
}
function jo(t, e) {
  if (e.includes(".")) {
    const r = e.split(".");
    t.second = parseFloat(r[0]), t.millis = parseInt(r[1], 10);
  } else t.second = parseFloat(e);
}
const O2 = "esri.core.sql.SqlInterval";
let $t = class j0 {
  constructor() {
    this.declaredRootClass = O2, this.op = "+", this.day = 0, this.second = 0, this.hour = 0, this.month = 0, this.year = 0, this.minute = 0, this.millis = 0;
  }
  static isInterval(e) {
    return typeof e == "object" && e != null && "declaredRootClass" in e && e.declaredRootClass === O2;
  }
  static createFromMilliseconds(e) {
    const r = new j0();
    return r.second = e / 1e3, r;
  }
  static createFromValueAndQualifier(e, r, n) {
    let s = null;
    const i = new j0();
    if (i.op = n === "-" ? "-" : "+", r.type === "interval-period") {
      x1(r);
      const u = new RegExp("^[0-9]{1,}$");
      if (r.period === "year" || r.period === "month") throw new R("YearMonthIntervals");
      if (r.period === "second") {
        if (!/^[0-9]{1,}(\.[0-9]{1,}){0,1}$/.test(e)) throw new R("IllegalInterval");
        jo(i, e);
      } else {
        if (!u.test(e)) throw new R("IllegalInterval");
        i[r.period] = parseFloat(e);
      }
    } else {
      if (x1(r.start), x1(r.end), r.start.period === "year" || r.start.period === "month" || r.end.period === "year" || r.end.period === "month") throw new R("YearMonthIntervals");
      switch (r.start.period) {
        case "day":
          switch (r.end.period) {
            case "hour":
              if (s = new RegExp("^[0-9]{1,} [0-9]{1,}$"), !s.test(e)) throw new R("IllegalInterval");
              i[r.start.period] = parseFloat(e.split(" ")[0]), i[r.end.period] = parseFloat(e.split(" ")[1]);
              break;
            case "minute":
              if (s = new RegExp("^[0-9]{1,} [0-9]{1,2}:[0-9]{1,}$"), !s.test(e)) throw new R("IllegalInterval");
              {
                i[r.start.period] = parseFloat(e.split(" ")[0]);
                const u = e.split(" ")[1].split(":");
                i.hour = parseFloat(u[0]), i.minute = parseFloat(u[1]);
              }
              break;
            case "second":
              if (s = new RegExp("^[0-9]{1,} [0-9]{1,2}:[0-9]{1,2}:[0-9]{1,}(\\.[0-9]{1,}){0,1}$"), !s.test(e)) throw new R("IllegalInterval");
              {
                i[r.start.period] = parseFloat(e.split(" ")[0]);
                const u = e.split(" ")[1].split(":");
                i.hour = parseFloat(u[0]), i.minute = parseFloat(u[1]), jo(i, u[2]);
              }
              break;
            default:
              throw new R("IllegalInterval");
          }
          break;
        case "hour":
          switch (r.end.period) {
            case "minute":
              if (s = new RegExp("^[0-9]{1,}:[0-9]{1,}$"), !s.test(e)) throw new R("IllegalInterval");
              i.hour = parseFloat(e.split(":")[0]), i.minute = parseFloat(e.split(":")[1]);
              break;
            case "second":
              if (s = new RegExp("^[0-9]{1,}:[0-9]{1,2}:[0-9]{1,}(\\.[0-9]{1,}){0,1}$"), !s.test(e)) throw new R("IllegalInterval");
              {
                const u = e.split(":");
                i.hour = parseFloat(u[0]), i.minute = parseFloat(u[1]), jo(i, u[2]);
              }
              break;
            default:
              throw new R("IllegalInterval");
          }
          break;
        case "minute":
          if (r.end.period !== "second") throw new R("IllegalInterval");
          if (s = new RegExp("^[0-9]{1,}:[0-9]{1,}(\\.[0-9]{1,}){0,1}$"), !s.test(e)) throw new R("IllegalInterval");
          {
            const u = e.split(":");
            i.minute = parseFloat(u[0]), jo(i, u[1]);
          }
          break;
        default:
          throw new R("IllegalInterval");
      }
    }
    return i;
  }
  valueInMilliseconds() {
    return (this.op === "-" ? -1 : 1) * (this.millis + 1e3 * this.second + 60 * this.minute * 1e3 + 60 * this.hour * 60 * 1e3 + 24 * this.day * 60 * 60 * 1e3 + this.month * (365 / 12) * 24 * 60 * 60 * 1e3 + 365 * this.year * 24 * 60 * 60 * 1e3);
  }
};
const NN = /^(\d{1,2}):(\d{1,2}):(\d{1,2})$/, xN = /^(\d{1,2}):(\d{1,2})$/, TN = /^(\d{1,2}):(\d{1,2}):(\d{1,2}).([0-9]+)$/, r9 = /^(\d{4})-(\d{1,2})-(\d{1,2})$/, PN = /^(\d{4})-(\d{1,2})-(\d{1,2}) (\d{1,2}):(\d{1,2}):(\d{1,2})(\.[0-9]+)?$/, AN = /^(\d{4})-(\d{1,2})-(\d{1,2}) (\d{1,2}):(\d{1,2}):(\d{1,2})(\.[0-9]+)? {0,1}(\+|-)(\d{1,2}):(\d{1,2})$/, LN = /^(\d{4})-(\d{1,2})-(\d{1,2}) (\d{1,2}):(\d{1,2})? {0,1}(\+|-)(\d{1,2}):(\d{1,2})$/, MN = /^(\d{4})-(\d{1,2})-(\d{1,2}) (\d{1,2}):(\d{1,2})$/;
function cu(t, e) {
  if (e instanceof Fn) return e === Sr.instance ? H.fromMillis(t.getTime(), { zone: Sr.instance }) : H.fromJSDate(t, { zone: e });
  switch (e) {
    case "system":
    case "local":
    case null:
      return H.fromJSDate(t);
    default:
      return e?.toLowerCase() === "unknown" ? H.fromMillis(t.getTime(), { zone: Sr.instance }) : H.fromJSDate(t, { zone: e });
  }
}
function vn(t) {
  return $t.isInterval(t);
}
function He(t) {
  return H.isDateTime(t);
}
function Ye(t) {
  return Pr.isDateOnly(t);
}
function Qe(t) {
  return mr.isTimeOnly(t);
}
function Ze(t) {
  return Br.isTimestampOffset(t);
}
function fu(t) {
  let e = NN.exec(t);
  if (e !== null) {
    const [, r, n, s] = e, i = mr.fromParts(parseInt(r, 10), parseInt(n, 10), parseInt(s, 10), 0);
    if (i !== null) return i;
    throw new R("InvalidTime");
  }
  if (e = xN.exec(t), e !== null) {
    const [, r, n] = e, s = mr.fromParts(parseInt(r, 10), parseInt(n, 10), 0, 0);
    if (s !== null) return s;
    throw new R("InvalidTime");
  }
  if (e = TN.exec(t), e !== null) {
    const [, r, n, s, i] = e, u = mr.fromParts(parseInt(r, 10), parseInt(n, 10), parseInt(s, 10), parseInt(i, 10));
    if (u !== null) return u;
    throw new R("InvalidTime");
  }
  throw new R("InvalidTime");
}
function Gi(t, e, r = !1) {
  let n = PN.exec(t);
  if (n !== null) {
    const [, s, i, u, l, c, m, _] = n, y = H.fromObject({ year: parseInt(s, 10), month: parseInt(i, 10), day: parseInt(u, 10), hour: parseInt(l, 10), minute: parseInt(c, 10), second: parseInt(m, 10), millisecond: _ ? parseInt(_.replace(".", ""), 10) : 0 }, { zone: u1(e) });
    if (y.isValid === !1) throw new R("InvalidTimeStamp");
    return y;
  }
  if (n = AN.exec(t), n !== null) {
    const [, s, i, u, l, c, m, _, y, v, S] = n, T = Br.fromParts(parseInt(s, 10), parseInt(i, 10), parseInt(u, 10), parseInt(l, 10), parseInt(c, 10), parseInt(m, 10), _ ? parseInt(_.replace(".", ""), 10) : 0, y === "-", parseInt(v, 10), parseInt(S, 10));
    if (T.isValid === !1) throw new R("InvalidTimeStamp");
    return T;
  }
  if (n = LN.exec(t), n !== null) {
    const [, s, i, u, l, c, m, _, y] = n, v = Br.fromParts(parseInt(s, 10), parseInt(i, 10), parseInt(u, 10), parseInt(l, 10), parseInt(c, 10), 0, 0, m === "-", parseInt(_, 10), parseInt(y, 10));
    if (v.isValid === !1) throw new R("InvalidTimeStamp");
    return v;
  }
  if (n = MN.exec(t), n !== null) {
    const [, s, i, u, l, c] = n, m = H.fromObject({ year: parseInt(s, 10), month: parseInt(i, 10), day: parseInt(u, 10), hour: parseInt(l, 10), minute: parseInt(c, 10), second: 0 }, { zone: u1(e) });
    if (m.isValid === !1) throw new R("InvalidTimeStamp");
    return m;
  }
  if (n = r9.exec(t), n !== null) {
    const [, s, i, u] = n, l = H.fromObject({ year: parseInt(s, 10), month: parseInt(i, 10), day: parseInt(u, 10), hour: 0, minute: 0, second: 0 }, { zone: u1(e) });
    if (l.isValid === !1) throw new R("InvalidTimeStamp");
    return l;
  }
  throw new R("InvalidTimeStamp");
}
function Nh(t, e) {
  const r = r9.exec(t);
  if (r === null) try {
    return Gi(t, e);
  } catch {
    throw new R("InvalidDate");
  }
  const [, n, s, i] = r, u = Pr.fromParts(parseInt(n, 10), parseInt(s, 10), parseInt(i, 10));
  if (u === null) throw new R("InvalidDate");
  return u;
}
const C2 = new Float32Array(1), Ha = new DataView(new ArrayBuffer(Float64Array.BYTES_PER_ELEMENT));
function ON(t) {
  return Ha.setFloat64(0, t), Ha.getBigInt64(0);
}
function CN(t) {
  return Ha.setBigInt64(0, t), Ha.getFloat64(0);
}
const T1 = 1000000n;
RN(1);
function RN(t) {
  const e = ON(t = Math.abs(t)), r = CN(e <= T1 ? T1 : e - T1);
  return Math.abs(t - r);
}
function IN(t) {
  return C2[0] = t, C2[0];
}
IN(34028234663852886e22);
function kN(t, e, r) {
  if (r === void 0 || +r == 0) return Math[t](e);
  if (e = +e, r = +r, isNaN(e) || typeof r != "number" || r % 1 != 0) return NaN;
  let n = e.toString().split("e");
  return n = (e = Math[t](+(n[0] + "e" + (n[1] ? +n[1] - r : -r)))).toString().split("e"), +(n[0] + "e" + (n[1] ? +n[1] + r : r));
}
function Xt(t) {
  return typeof t == "number";
}
function Nt(t) {
  return typeof t == "string" || t instanceof String;
}
function Er(t) {
  return t instanceof Date;
}
const DN = 321408e5, $N = 26784e5, FN = 864e5, UN = 36e5, VN = 6e4;
function P1(t) {
  return !!He(t) || !!Ze(t);
}
function W0(t) {
  return !!He(t) || !!Ye(t) || !!Ze(t) || !!Qe(t);
}
function Wo(t) {
  if (He(t)) return t.toMillis();
  if (Ye(t)) return t.toNumber();
  if (Ze(t)) return t.toMilliseconds();
  throw new R("InvalidDataType");
}
function fr(t, e, r) {
  if (t == null || e == null) return null;
  if (Xt(t)) {
    if (Xt(e)) return Vr(t, e, r);
    if (Nt(e)) return zN(t, e, r);
    if (W0(e)) throw new R("InvalidOperator");
    if (Ye(e)) throw new R("InvalidOperator");
  } else if (Nt(t)) {
    if (Xt(e)) return jN(t, e, r);
    if (Nt(e)) return WN(t, e, r);
    if (He(e)) throw new R("InvalidOperator");
    if (Ye(e)) throw new R("InvalidOperator");
    if (Qe(e)) throw new R("InvalidOperator");
    if (Ze(e)) throw new R("InvalidOperator");
  } else if (He(t)) {
    if (P1(e)) {
      if (Es(t.zone)) {
        if (H.isDateTime(e) && !Es(e.zone) || Br.isTimestampOffset(e)) return mi(t, e, r);
      } else if (H.isDateTime(e) && Es(e.zone) && (!Es(t.zone) || Br.isTimestampOffset(t)))
        return mi(t, e, r);
      return Vr(Wo(t), Wo(e), r);
    }
    if (Nt(e)) throw new R("InvalidOperator");
    if (Ye(e)) return GN(t, e, r);
    if (Qe(e)) throw new R("InvalidOperator");
    if (Xt(e)) throw new R("InvalidOperator");
  } else if (Ye(t)) {
    if (Ze(e)) return HN(t, e, r);
    if (He(e)) return qN(t, e, r);
    if (Nt(e)) throw new R("InvalidOperator");
    if (Ye(e)) return Vr(t.toNumber(), e.toNumber(), r);
    if (Qe(e)) throw new R("InvalidOperator");
    if (Xt(e)) throw new R("InvalidOperator");
  } else if (Qe(t)) {
    if (Qe(e)) return Vr(t.toNumber(), e.toNumber(), r);
    if (Nt(e)) throw new R("InvalidOperator");
    if (Xt(e)) throw new R("InvalidOperator");
    if (Ye(e)) throw new R("InvalidOperator");
    if (P1(e)) throw new R("InvalidOperator");
  } else if (Ze(t)) {
    if (P1(e)) return H.isDateTime(e) && Es(e.zone) ? mi(t, e, r) : Vr(Wo(t), Wo(e), r);
    if (Nt(e)) throw new R("InvalidOperator");
    if (Ye(e)) return BN(t, e, r);
    if (Qe(e)) throw new R("InvalidOperator");
    if (Xt(e)) throw new R("InvalidOperator");
  }
  switch (r) {
    case "<>":
      return t !== e;
    case "=":
      return t === e;
    case ">":
      return t > e;
    case "<":
      return t < e;
    case ">=":
      return t >= e;
    case "<=":
      return t <= e;
  }
}
function Vr(t, e, r) {
  switch (r) {
    case "<>":
      return t !== e;
    case "=":
      return t === e;
    case ">":
      return t > e;
    case "<":
      return t < e;
    case ">=":
      return t >= e;
    case "<=":
      return t <= e;
  }
}
function zN(t, e, r) {
  const n = parseFloat(e);
  if (!isNaN(n)) return Vr(t, n, r);
  const s = t.toString();
  switch (r) {
    case "<>":
      return s !== e;
    case "=":
      return s === e;
    case ">":
      return s > e;
    case "<":
      return s < e;
    case ">=":
      return s >= e;
    case "<=":
      return s <= e;
  }
}
function jN(t, e, r) {
  const n = parseFloat(t);
  if (!isNaN(n)) return Vr(n, e, r);
  const s = e.toString();
  switch (r) {
    case "<>":
      return t !== s;
    case "=":
      return t === s;
    case ">":
      return t > s;
    case "<":
      return t < s;
    case ">=":
      return t >= s;
    case "<=":
      return t <= s;
  }
}
function WN(t, e, r) {
  switch (r) {
    case "<>":
      return t !== e;
    case "=":
      return t === e;
    case ">":
      return t > e;
    case "<":
      return t < e;
    case ">=":
      return t >= e;
    case "<=":
      return t <= e;
  }
}
function GN(t, e, r) {
  const n = e.toDateTimeLuxon(t.zone);
  return Vr((t = t.startOf("day")).toMillis(), n.toMillis(), r);
}
function BN(t, e, r) {
  const n = e.toDateTimeLuxon(t.toDateTime().zone);
  return Vr((t = t.startOfDay()).toMilliseconds(), n.toMillis(), r);
}
function qN(t, e, r) {
  const n = t.toDateTimeLuxon(e.zone);
  return e = e.startOf("day"), Vr(n.toMillis(), e.toMillis(), r);
}
function HN(t, e, r) {
  const n = t.toDateTimeLuxon(e.toDateTime().zone);
  return e = e.startOfDay(), Vr(n.toMillis(), e.toMilliseconds(), r);
}
function mi(t, e, r) {
  Br.isTimestampOffset(t) && (t = t.toDateTime()), Br.isTimestampOffset(e) && (e = e.toDateTime());
  const n = R2(t), s = R2(e);
  switch (r) {
    case "<>":
      return n !== s;
    case "=":
      return n === s;
    case ">":
      return n > s;
    case "<":
      return n < s;
    case ">=":
      return n >= s;
    case "<=":
      return n <= s;
  }
}
function R2(t) {
  return t.year * DN + t.month * $N + t.day * FN + t.hour * UN + t.minute * VN + 1e3 * t.second + t.millisecond;
}
function xh(t, e, r) {
  const n = s9[t.toLowerCase()];
  if (n == null) throw new R("FunctionNotRecognized");
  if (e.length < n.minParams || e.length > n.maxParams) throw new R("InvalidParameterCount", { name: t.toUpperCase() });
  return n.evaluate(e, r);
}
function YN(t, e) {
  const r = s9[t.toLowerCase()];
  return r != null && e >= r.minParams && e <= r.maxParams;
}
function A1(t) {
  return !Er(t) && !Ye(t) && !He(t) && !Qe(t) && !Ze(t);
}
function n9(t) {
  return Ye(t) || Qe(t) ? t.toString() : Ze(t) ? t.toSQLValue() : He(t) ? t.millisecond === 0 ? t.toFormat("yyyy-LL-dd HH:mm:ss") : t.toSQL({ includeOffset: !1 }) : Er(t) ? n9(H.fromJSDate(t)) : t.toString();
}
function ZN(t) {
  if (Er(t)) return Pr.fromDateJS(t);
  if (He(t)) return Pr.fromParts(t.year, t.month, t.day);
  if (Ye(t)) return t;
  if (Qe(t)) throw new R("CannotCastValue");
  if (Ze(t) && Pr.fromParts(t.year, t.month, t.day) === null)
    throw new R("CannotCastValue");
  if (Nt(t)) {
    const e = Pr.fromReader(t);
    if (e !== null && e.isValid) return e;
  }
  throw new R("CannotCastValue");
}
function XN(t, e, r) {
  if (Er(t)) return cu(t, e);
  if (He(t)) return t;
  if (Ye(t)) return t.toDateTimeLuxon("unknown");
  if (Qe(t)) throw new R("CannotCastValue");
  if (Ze(t)) return t;
  if (Nt(t)) return Gi(t, "unknown", r);
  throw new R("CannotCastValue");
}
function JN(t) {
  if (Er(t)) return mr.fromDateJS(t);
  if (He(t)) return mr.fromDateTime(t);
  if (Ye(t)) throw new R("CannotCastValue");
  if (Qe(t)) return t;
  if (Ze(t)) return mr.fromSqlTimeStampOffset(t);
  if (Nt(t)) return fu(t);
  throw new R("CannotCastValue");
}
const s9 = { extract: { minParams: 2, maxParams: 2, evaluate: ([t, e]) => {
  if (e == null) return null;
  if (Er(e)) switch (t.toUpperCase()) {
    case "SECOND":
      return e.getSeconds();
    case "MINUTE":
      return e.getMinutes();
    case "HOUR":
      return e.getHours();
    case "DAY":
      return e.getDate();
    case "MONTH":
      return e.getMonth() + 1;
    case "YEAR":
      return e.getFullYear();
    case "TIMEZONE_HOUR":
    case "TIMEZONE_MINUTE":
      return 0;
    case "DOW":
      return H.fromJSDate(e, { zone: "system" }).weekday;
    case "DOY":
      return H.fromJSDate(e, { zone: "system" }).ordinal;
    case "WEEK":
      return H.fromJSDate(e, { zone: "system" }).weekNumber;
  }
  else if (He(e)) switch (t.toUpperCase()) {
    case "SECOND":
      return e.second;
    case "MINUTE":
      return e.minute;
    case "HOUR":
      return e.hour;
    case "DAY":
      return e.day;
    case "MONTH":
      return e.month;
    case "YEAR":
      return e.year;
    case "TIMEZONE_HOUR":
    case "TIMEZONE_MINUTE":
      throw new R("InvalidFunctionParameters", { function: "EXTRACT" });
    case "DOW":
      return e.weekday;
    case "DOY":
      return e.ordinal;
    case "WEEK":
      return e.weekNumber;
  }
  else if (Ye(e)) switch (t.toUpperCase()) {
    case "DAY":
      return e.day;
    case "MONTH":
      return e.month;
    case "YEAR":
      return e.year;
    case "TIMEZONE_HOUR":
    case "TIMEZONE_MINUTE":
      throw new R("InvalidFunctionParameters", { function: "EXTRACT" });
    case "DOW":
      return e.toDateTime("unknown").weekday;
    case "DOY":
      return e.toDateTime("unknown").ordinal;
    case "WEEK":
      return e.toDateTime("unknown").weekNumber;
  }
  else if (Qe(e)) switch (t.toUpperCase()) {
    case "SECOND":
      return e.second;
    case "MINUTE":
      return e.minute;
    case "HOUR":
      return e.hour;
  }
  else if (Ze(e)) switch (t.toUpperCase()) {
    case "SECOND":
      return e.second;
    case "MINUTE":
      return e.minute;
    case "HOUR":
      return e.hour;
    case "DAY":
      return e.day;
    case "MONTH":
      return e.month;
    case "YEAR":
      return e.year;
    case "TIMEZONE_HOUR":
      return e.timezoneOffsetHour;
    case "TIMEZONE_MINUTE":
      return e.timezoneOffsetMinutes;
    case "DOW":
      return e.toDateTime().weekday;
    case "DOY":
      return e.toDateTime().ordinal;
    case "WEEK":
      return e.toDateTime().weekNumber;
  }
  throw new R("InvalidFunctionParameters", { function: "EXTRACT" });
} }, substring: { minParams: 2, maxParams: 3, evaluate: (t) => {
  if (t.length === 2) {
    const [e, r] = t;
    return e == null || r == null ? null : e.toString().substring(r - 1);
  }
  if (t.length === 3) {
    const [e, r, n] = t;
    return e == null || r == null || n == null ? null : n <= 0 ? "" : e.toString().substring(r - 1, r + n - 1);
  }
} }, position: { minParams: 2, maxParams: 2, evaluate: ([t, e]) => t == null || e == null ? null : e.indexOf(t) + 1 }, trim: { minParams: 2, maxParams: 3, evaluate: (t) => {
  const e = t.length === 3, r = e ? t[1] : " ", n = e ? t[2] : t[1];
  if (r == null || n == null) return null;
  const s = `(${k7(r)})`;
  switch (t[0]) {
    case "BOTH":
      return n.replaceAll(new RegExp(`^${s}*|${s}*$`, "g"), "");
    case "LEADING":
      return n.replaceAll(new RegExp(`^${s}*`, "g"), "");
    case "TRAILING":
      return n.replaceAll(new RegExp(`${s}*$`, "g"), "");
  }
  throw new R("InvalidFunctionParameters", { function: "TRIM" });
} }, abs: { minParams: 1, maxParams: 1, evaluate: (t) => t[0] == null ? null : Math.abs(t[0]) }, ceiling: { minParams: 1, maxParams: 1, evaluate: (t) => t[0] == null ? null : Math.ceil(t[0]) }, floor: { minParams: 1, maxParams: 1, evaluate: (t) => t[0] == null ? null : Math.floor(t[0]) }, log: { minParams: 1, maxParams: 1, evaluate: (t) => t[0] == null ? null : Math.log(t[0]) }, log10: { minParams: 1, maxParams: 1, evaluate: (t) => t[0] == null ? null : Math.log(t[0]) * Math.LOG10E }, sin: { minParams: 1, maxParams: 1, evaluate: (t) => t[0] == null ? null : Math.sin(t[0]) }, cos: { minParams: 1, maxParams: 1, evaluate: (t) => t[0] == null ? null : Math.cos(t[0]) }, tan: { minParams: 1, maxParams: 1, evaluate: (t) => t[0] == null ? null : Math.tan(t[0]) }, asin: { minParams: 1, maxParams: 1, evaluate: (t) => t[0] == null ? null : Math.asin(t[0]) }, acos: { minParams: 1, maxParams: 1, evaluate: (t) => t[0] == null ? null : Math.acos(t[0]) }, atan: { minParams: 1, maxParams: 1, evaluate: (t) => t[0] == null ? null : Math.atan(t[0]) }, sign: { minParams: 1, maxParams: 1, evaluate: (t) => t[0] == null ? null : t[0] > 0 ? 1 : t[0] < 0 ? -1 : 0 }, power: { minParams: 2, maxParams: 2, evaluate: (t) => t[0] == null || t[1] == null ? null : t[0] ** t[1] }, mod: { minParams: 2, maxParams: 2, evaluate: (t) => t[0] == null || t[1] == null ? null : t[0] % t[1] }, round: { minParams: 1, maxParams: 2, evaluate: (t) => {
  const e = t[0], r = t.length === 2 ? 10 ** t[1] : 1;
  return e == null ? null : Math.round(e * r) / r;
} }, truncate: { minParams: 1, maxParams: 2, evaluate: (t) => t[0] == null ? null : t.length === 1 || t[1] === 0 ? Math.trunc(t[0]) : kN("trunc", t[0], -Number(t[1])) }, char_length: { minParams: 1, maxParams: 1, evaluate: (t) => Nt(t[0]) ? t[0].length : 0 }, concat: { minParams: 1, maxParams: 1 / 0, evaluate: (t) => {
  let e = "";
  for (let r = 0; r < t.length; r++) {
    if (t[r] == null) return null;
    e += t[r].toString();
  }
  return e;
} }, lower: { minParams: 1, maxParams: 1, evaluate: (t) => t[0] == null ? null : t[0].toString().toLowerCase() }, upper: { minParams: 1, maxParams: 1, evaluate: (t) => t[0] == null ? null : t[0].toString().toUpperCase() }, coalesce: { minParams: 1, maxParams: 1 / 0, evaluate: (t) => {
  for (const e of t) if (e !== null) return e;
  return null;
} }, cosh: { minParams: 1, maxParams: 1, evaluate: (t) => t[0] == null ? null : Math.cosh(t[0]) }, sinh: { minParams: 1, maxParams: 1, evaluate: (t) => t[0] == null ? null : Math.sinh(t[0]) }, tanh: { minParams: 1, maxParams: 1, evaluate: (t) => t[0] == null ? null : Math.tanh(t[0]) }, nullif: { minParams: 2, maxParams: 2, evaluate: (t) => fr(t[0], t[1], "=") ? null : t[0] }, cast: { minParams: 2, maxParams: 2, evaluate: (t, e) => {
  const r = t[0], n = t[1];
  if (r === null) return null;
  switch (n.type) {
    case "integer": {
      if (!A1(r)) throw new R("CannotCastValue");
      const s = parseInt(r, 10);
      if (isNaN(s)) throw new R("CannotCastValue");
      return s;
    }
    case "smallint": {
      if (!A1(r)) throw new R("CannotCastValue");
      const s = parseInt(r, 10);
      if (isNaN(s)) throw new R("CannotCastValue");
      if (s > 32767 || s < -32767) throw new R("CannotCastValue");
      return s;
    }
    case "float":
    case "real": {
      if (!A1(r)) throw new R("CannotCastValue");
      const s = parseFloat(r);
      if (isNaN(s)) throw new R("CannotCastValue");
      return s;
    }
    case "time":
      return JN(r);
    case "date":
      return ZN(r);
    case "timestamp":
      return XN(r, e, n.withtimezone === !0);
    case "varchar": {
      const s = n9(r);
      if (s.length > n.size) throw new R("CannotCastValue");
      return s;
    }
    default:
      throw new R("InvalidDataType");
  }
} } };
function i9(t, e, r, n) {
  if (t === "||") return xh("concat", [e, r], n);
  if (e === null || r === null) return null;
  if (Xt(e)) {
    if (Xt(r)) return Th(e, r, t);
    if (vn(r)) return ix(e, r, t);
    if (Qe(r)) return px();
    if (Ye(r)) return gx();
    if (Ze(r)) return mx();
    if (He(r)) return hx();
    if (Nt(r)) return _x(e, r, t);
    throw new R("InvalidOperator");
  }
  if (Ye(e)) {
    if (Xt(r)) return cx(e, r, t);
    if (vn(r)) return ox(e, r, t);
    if (Qe(r)) return xx();
    if (Ye(r)) return Nx(e, r, t);
    if (Ze(r)) return Ex(e, r, t);
    if (He(r)) return Sx(e, r, t);
    if (Nt(r)) return Fx();
    throw new R("InvalidOperator");
  }
  if (Qe(e)) {
    if (Xt(r)) return fx(e, r, t);
    if (vn(r)) return tx(e, r, t);
    if (Qe(r)) return Rx();
    if (Ye(r)) return Ox();
    if (Ze(r)) return Cx();
    if (He(r)) return Mx();
    if (Nt(r)) return Ux();
    throw new R("InvalidOperator");
  }
  if (vn(e)) {
    if (Xt(r)) return sx(e, r, t);
    if (vn(r)) return nx(e, r, t);
    if (Qe(r)) return KN(e, r, t);
    if (Ye(r)) return ex(e, r, t);
    if (Ze(r)) return rx(e, r, t);
    if (He(r)) return QN(e, r, t);
    if (Nt(r)) return wx();
    throw new R("InvalidOperator");
  }
  if (He(e)) {
    if (Xt(r)) return lx(e, r, t);
    if (vn(r)) return ax(e, r, t);
    if (Qe(r)) return $x();
    if (Ye(r)) return kx(e, r, t);
    if (Ze(r)) return Dx(e, r, t);
    if (He(r)) return Ix(e, r, t);
    if (Nt(r)) return Vx();
    throw new R("InvalidOperator");
  }
  if (Ze(e)) {
    if (Xt(r)) return dx(e, r, t);
    if (vn(r)) return ux(e, r, t);
    if (Qe(r)) return Tx();
    if (Ye(r)) return Px(e, r, t);
    if (Ze(r)) return Lx(e, r, t);
    if (He(r)) return Ax(e, r, t);
    if (Nt(r)) return zx();
    throw new R("InvalidOperator");
  }
  if (Nt(e)) {
    if (Xt(r)) return yx(e, r, t);
    if (vn(r)) return vx();
    if (Qe(r)) return jx();
    if (Ye(r)) return Wx();
    if (Ze(r)) return Bx();
    if (He(r)) return Gx();
    if (Nt(r)) return bx(e, r, t);
    throw new R("InvalidOperator");
  }
  throw new R("InvalidOperator");
}
function Th(t, e, r) {
  switch (r) {
    case "+":
      return t + e;
    case "-":
      return t - e;
    case "*":
      return t * e;
    case "/":
      return t / e;
  }
  throw new R("InvalidOperator");
}
function QN(t, e, r) {
  switch (r) {
    case "+":
      return e.plus({ milliseconds: t.valueInMilliseconds() });
    case "-":
      return t.valueInMilliseconds() - e.toMillis();
  }
  throw new R("InvalidOperator");
}
function KN(t, e, r) {
  if (r === "+") return e.plus("milliseconds", t.valueInMilliseconds());
  throw new R("InvalidOperator");
}
function ex(t, e, r) {
  if (r === "+") return e.plus("milliseconds", t.valueInMilliseconds());
  throw new R("InvalidOperator");
}
function tx(t, e, r) {
  switch (r) {
    case "+":
      return t.plus("milliseconds", e.valueInMilliseconds());
    case "-":
      return t.plus("milliseconds", -1 * e.valueInMilliseconds());
  }
  throw new R("InvalidOperator");
}
function rx(t, e, r) {
  if (r === "+") return e.addMilliseconds(t.valueInMilliseconds());
  throw new R("InvalidOperator");
}
function nx(t, e, r) {
  switch (r) {
    case "+":
      return $t.createFromMilliseconds(t.valueInMilliseconds() + e.valueInMilliseconds());
    case "-":
      return $t.createFromMilliseconds(t.valueInMilliseconds() - e.valueInMilliseconds());
    case "*":
      return $t.createFromMilliseconds(t.valueInMilliseconds() * e.valueInMilliseconds());
    case "/":
      return $t.createFromMilliseconds(t.valueInMilliseconds() / e.valueInMilliseconds());
  }
  throw new R("InvalidOperator");
}
function sx(t, e, r) {
  switch (r) {
    case "+":
      return $t.createFromMilliseconds(t.valueInMilliseconds() + e);
    case "-":
      return $t.createFromMilliseconds(t.valueInMilliseconds() - e);
    case "*":
      return $t.createFromMilliseconds(t.valueInMilliseconds() * e);
    case "/":
      return $t.createFromMilliseconds(t.valueInMilliseconds() / e);
  }
  throw new R("InvalidOperator");
}
function ix(t, e, r) {
  switch (r) {
    case "+":
      return $t.createFromMilliseconds(t + e.valueInMilliseconds());
    case "-":
      return $t.createFromMilliseconds(t - e.valueInMilliseconds());
    case "*":
      return $t.createFromMilliseconds(t * e.valueInMilliseconds());
    case "/":
      return $t.createFromMilliseconds(t / e.valueInMilliseconds());
  }
  throw new R("InvalidOperator");
}
function ox(t, e, r) {
  switch (r) {
    case "+":
      return t.plus("milliseconds", e.valueInMilliseconds());
    case "-":
      return t.plus("milliseconds", -1 * e.valueInMilliseconds());
  }
  throw new R("InvalidOperator");
}
function ax(t, e, r) {
  switch (r) {
    case "+":
      return t.plus({ milliseconds: e.valueInMilliseconds() });
    case "-":
      return t.minus({ milliseconds: e.valueInMilliseconds() });
  }
  throw new R("InvalidOperator");
}
function ux(t, e, r) {
  switch (r) {
    case "+":
      return t.addMilliseconds(e.valueInMilliseconds());
    case "-":
      return t.addMilliseconds(-1 * e.valueInMilliseconds());
  }
  throw new R("InvalidOperator");
}
function lx(t, e, r) {
  const n = 1e3 * e * 24 * 60 * 60;
  switch (r) {
    case "+":
      return t.plus({ milliseconds: n });
    case "-":
      return t.minus({ milliseconds: n });
  }
  throw new R("InvalidOperator");
}
function cx(t, e, r) {
  const n = 1e3 * e * 24 * 60 * 60;
  switch (r) {
    case "+":
      return t.plus("milliseconds", n);
    case "-":
      return t.plus("milliseconds", -1 * n);
  }
  throw new R("InvalidOperator");
}
function fx(t, e, r) {
  const n = 1e3 * e * 24 * 60 * 60;
  switch (r) {
    case "+":
      return t.plus("milliseconds", n);
    case "-":
      return t.plus("milliseconds", -1 * n);
  }
  throw new R("InvalidOperator");
}
function hx(t, e, r) {
  throw new R("InvalidOperator");
}
function dx(t, e, r) {
  const n = 1e3 * e * 24 * 60 * 60;
  switch (r) {
    case "+":
      return t.addMilliseconds(n);
    case "-":
      return t.addMilliseconds(-1 * n);
  }
  throw new R("InvalidOperator");
}
function mx(t, e, r) {
  throw new R("InvalidOperator");
}
function px(t, e, r) {
  throw new R("InvalidOperator");
}
function gx(t, e, r) {
  throw new R("InvalidOperator");
}
function _x(t, e, r) {
  const n = parseFloat(e);
  if (isNaN(n)) throw new R("InvalidOperator");
  return Th(t, n, r);
}
function yx(t, e, r) {
  const n = parseFloat(t);
  if (isNaN(n)) throw new R("InvalidOperator");
  return Th(n, e, r);
}
function bx(t, e, r) {
  if (r === "+") return t + e;
  throw new R("InvalidOperator");
}
function wx(t, e, r) {
  throw new R("InvalidOperator");
}
function vx(t, e, r) {
  throw new R("InvalidOperator");
}
function Sx(t, e, r) {
  if (r === "-") return t.toDateTimeLuxon(e.zone).diff(e).as("days");
  throw new R("InvalidOperator");
}
function Ex(t, e, r) {
  if (r === "-") return t.toDateTimeLuxon(e.toDateTime().zone).diff(e.toDateTime()).as("days");
  throw new R("InvalidOperator");
}
function Nx(t, e, r) {
  if (r === "-") return t.toDateTimeLuxon("UTC").diff(e.toDateTimeLuxon("UTC")).as("days");
  throw new R("InvalidOperator");
}
function xx(t, e, r) {
  throw new R("InvalidOperator");
}
function Tx(t, e, r) {
  throw new R("InvalidOperator");
}
function Px(t, e, r) {
  if (r === "-") return t.toDateTime().diff(e.toDateTimeLuxon(t.toDateTime().zone)).as("days");
  throw new R("InvalidOperator");
}
function Ax(t, e, r) {
  if (r === "-") return t.toDateTime().diff(e).as("days");
  throw new R("InvalidOperator");
}
function Lx(t, e, r) {
  if (r === "-") return t.toDateTime().diff(e.toDateTime()).as("days");
  throw new R("InvalidOperator");
}
function Mx(t, e, r) {
  throw new R("InvalidOperator");
}
function Ox(t, e, r) {
  throw new R("InvalidOperator");
}
function Cx(t, e, r) {
  throw new R("InvalidOperator");
}
function Rx(t, e, r) {
  throw new R("InvalidOperator");
}
function Ix(t, e, r) {
  if (r === "-") return t.diff(e).as("days");
  throw new R("InvalidOperator");
}
function kx(t, e, r) {
  if (r === "-") return t.diff(e.toDateTimeLuxon(t.zone)).as("days");
  throw new R("InvalidOperator");
}
function Dx(t, e, r) {
  if (r === "-") return t.diff(e.toDateTime()).as("days");
  throw new R("InvalidOperator");
}
function $x(t, e, r) {
  throw new R("InvalidOperator");
}
function Fx(t, e, r) {
  throw new R("InvalidOperator");
}
function Ux(t, e, r) {
  throw new R("InvalidOperator");
}
function Vx(t, e, r) {
  throw new R("InvalidOperator");
}
function zx(t, e, r) {
  throw new R("InvalidOperator");
}
function jx(t, e, r) {
  throw new R("InvalidOperator");
}
function Wx(t, e, r) {
  throw new R("InvalidOperator");
}
function Gx(t, e, r) {
  throw new R("InvalidOperator");
}
function Bx(t, e, r) {
  throw new R("InvalidOperator");
}
let L1 = class extends SyntaxError {
  constructor(e, r, n, s) {
    super(e), this.expected = r, this.found = n, this.location = s, this.name = "SyntaxError";
  }
  format(e) {
    let r = "Error: " + this.message;
    if (this.location) {
      let n = null;
      const s = e.find((c) => c.source === this.location.source);
      s && (n = s.text.split(/\r\n|\n|\r/g));
      const i = this.location.start, u = this.location.source && typeof this.location.source.offset == "function" ? this.location.source.offset(i) : i, l = this.location.source + ":" + u.line + ":" + u.column;
      if (n) {
        const c = this.location.end, m = "".padEnd(u.line.toString().length, " "), _ = n[i.line - 1], y = (i.line === c.line ? c.column : _.length + 1) - i.column || 1;
        r += `
 --> ` + l + `
` + m + ` |
` + u.line + " | " + _ + `
` + m + " | " + "".padEnd(i.column - 1, " ") + "".padEnd(y, "^");
      } else r += `
 at ` + l;
    }
    return r;
  }
  static buildMessage(e, r) {
    function n(v) {
      return v.codePointAt(0).toString(16).toUpperCase();
    }
    const s = Object.prototype.hasOwnProperty.call(RegExp.prototype, "unicode") ? new RegExp("[\\p{C}\\p{Mn}\\p{Mc}]", "gu") : null;
    function i(v) {
      return s ? v.replace(s, (S) => "\\u{" + n(S) + "}") : v;
    }
    function u(v) {
      return i(v.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, (S) => "\\x0" + n(S)).replace(/[\x10-\x1F\x7F-\x9F]/g, (S) => "\\x" + n(S)));
    }
    function l(v) {
      return i(v.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, (S) => "\\x0" + n(S)).replace(/[\x10-\x1F\x7F-\x9F]/g, (S) => "\\x" + n(S)));
    }
    const c = { literal: (v) => '"' + u(v.text) + '"', class(v) {
      const S = v.parts.map((T) => Array.isArray(T) ? l(T[0]) + "-" + l(T[1]) : l(T));
      return "[" + (v.inverted ? "^" : "") + S.join("") + "]" + (v.unicode ? "u" : "");
    }, any: () => "any character", end: () => "end of input", other: (v) => v.description };
    function m(v) {
      return c[v.type](v);
    }
    function _(v) {
      const S = v.map(m);
      if (S.sort(), S.length > 0) {
        let T = 1;
        for (let L = 1; L < S.length; L++) S[L - 1] !== S[L] && (S[T] = S[L], T++);
        S.length = T;
      }
      switch (S.length) {
        case 1:
          return S[0];
        case 2:
          return S[0] + " or " + S[1];
        default:
          return S.slice(0, -1).join(", ") + ", or " + S[S.length - 1];
      }
    }
    function y(v) {
      return v ? '"' + u(v) + '"' : "end of input";
    }
    return "Expected " + _(e) + " but " + y(r) + " found.";
  }
};
function qx(t, e) {
  const r = {}, n = (e = e !== void 0 ? e : {}).grammarSource, s = { start: Ch };
  let i = Ch;
  const u = "!", l = "=", c = ">=", m = ">", _ = "<=", y = "<>", v = "!=", S = "||", T = "@", L = "'", D = "N'", V = "''", W = ".", j = "null", U = "true", $ = "false", B = "in", Z = "is", ee = "like", ye = "escape", Ie = "not", ve = "and", le = "or", K = "between", Y = "from", re = "for", te = "substring", ae = "extract", ge = "trim", Te = "position", et = "timestamp", lt = "date", qr = "time", fn = "leading", en = "trailing", is = "both", tn = "cast", Ot = "as", ti = "integer", hu = "int", du = "smallint", mu = "float", pu = "real", gu = "varchar", _u = "to", yu = "interval", bu = "year", wu = "timezone_hour", vu = "timezone_minute", Su = "month", Eu = "day", Nu = "hour", xu = "minute", Tu = "second", Bi = "dow", Un = "doy", Pu = "week", Au = "case", Lu = "end", qi = "when", Mu = "then", Ou = "else", ri = ",", Cu = "(", Vn = ")", Hi = "`", Yi = /^[<-=]/, os = /^[+\-]/, Ru = /^[*\/]/, Iu = /^[A-Za-z_\x80-\uFFFF]/, ku = /^[A-Za-z0-9_]/, Zi = /^[A-Za-z0-9_.\x80-\uFFFF]/, Du = /^["]/, Xi = /^[^']/, $u = /^[0-9]/, Fu = /^[eE]/, Uu = /^[ \t\n\r]/, A = /^[^`]/, Vu = ne("!", !1), zu = ne("=", !1), ju = ne(">=", !1), Wu = ne(">", !1), Gu = ne("<=", !1), Bu = ne("<>", !1), qu = _r([["<", "="]], !1, !1, !1), Hu = ne("!=", !1), as = _r(["+", "-"], !1, !1, !1), Yu = ne("||", !1), Zu = _r(["*", "/"], !1, !1, !1), Xu = _r([["A", "Z"], ["a", "z"], "_", ["", "￿"]], !1, !1, !1), Ju = _r([["A", "Z"], ["a", "z"], ["0", "9"], "_"], !1, !1, !1), Ji = _r([["A", "Z"], ["a", "z"], ["0", "9"], "_", ".", ["", "￿"]], !1, !1, !1), Qu = _r(['"'], !1, !1, !1), Ku = ne("@", !1), Qi = ne("'", !1), el = ne("N'", !1), Ki = ne("''", !1), eo = _r(["'"], !0, !1, !1), tl = ne(".", !1), rl = _r([["0", "9"]], !1, !1, !1), nl = _r(["e", "E"], !1, !1, !1), sl = ne("NULL", !0), il = ne("TRUE", !0), ol = ne("FALSE", !0), al = ne("IN", !0), ul = ne("IS", !0), ll = ne("LIKE", !0), cl = ne("ESCAPE", !0), fl = ne("NOT", !0), hl = ne("AND", !0), dl = ne("OR", !0), ml = ne("BETWEEN", !0), pl = ne("FROM", !0), gl = ne("FOR", !0), _l = ne("SUBSTRING", !0), yl = ne("EXTRACT", !0), bl = ne("TRIM", !0), wl = ne("POSITION", !0), vl = ne("TIMESTAMP", !0), Sl = ne("DATE", !0), El = ne("TIME", !0), Nl = ne("LEADING", !0), xl = ne("TRAILING", !0), Tl = ne("BOTH", !0), Pl = ne("CAST", !0), Al = ne("AS", !0), Ll = ne("INTEGER", !0), Ml = ne("INT", !0), Ol = ne("SMALLINT", !0), Cl = ne("FLOAT", !0), Rl = ne("REAL", !0), Il = ne("VARCHAR", !0), kl = ne("TO", !0), Dl = ne("INTERVAL", !0), $l = ne("YEAR", !0), Fl = ne("TIMEZONE_HOUR", !0), Ul = ne("TIMEZONE_MINUTE", !0), Vl = ne("MONTH", !0), zl = ne("DAY", !0), jl = ne("HOUR", !0), Wl = ne("MINUTE", !0), Gl = ne("SECOND", !0), Bl = ne("DOW", !0), ql = ne("DOY", !0), Hl = ne("WEEK", !0), Yl = ne("CASE", !0), Zl = ne("END", !0), Xl = ne("WHEN", !0), Jl = ne("THEN", !0), Ql = ne("ELSE", !0), Kl = ne(",", !1), ec = ne("(", !1), tc = ne(")", !1), rc = _r([" ", "	", `
`, "\r"], !1, !1, !1), to = ne("`", !1), ro = _r(["`"], !0, !1, !1);
  function Ah(a) {
    return a;
  }
  function nc(a) {
    return { type: "expression-list", location: J(), value: a };
  }
  function no(a, f, d) {
    return { op: f, expr: d, location: J() };
  }
  function sc(a, f) {
    return ai(a, f);
  }
  function so(a, f, d) {
    return { op: f, expr: d, location: J() };
  }
  function ic(a, f) {
    return ai(a, f);
  }
  function oc(a) {
    return Vb("NOT", a, J());
  }
  function ac(a, f) {
    return f == "" || f == null || f == null ? a : f.type == "arithmetic" ? ai(a, f.tail) : dd(f.op, a, f.right, f.escape, J());
  }
  function io(a, f) {
    return { op: a, expr: f, location: J() };
  }
  function uc(a) {
    return { type: "arithmetic", tail: a };
  }
  function lc(a, f) {
    return { op: a + "NOT", right: f };
  }
  function cc(a, f) {
    return { op: a, right: f };
  }
  function fc(a, f, d) {
    return yr(J(), f, d);
  }
  function hc(a, f) {
    return { op: "NOT" + a, right: f };
  }
  function dc(a, f, d) {
    return yr(J(), f, d);
  }
  function mc(a, f) {
    return { op: a, right: f };
  }
  function pc(a) {
    return a[0] + " " + a[2];
  }
  function gc(a) {
    return a[0] + " " + a[2];
  }
  function _c(a, f, d) {
    return { op: a, right: f, escape: d.value };
  }
  function yc(a, f) {
    return { op: a, right: f, escape: "" };
  }
  function bc(a, f) {
    return { op: a, right: f };
  }
  function wc(a, f) {
    return { op: a, right: f };
  }
  function oo(a, f, d) {
    return { op: f, expr: d, location: J() };
  }
  function vc(a, f) {
    return ai(a, f);
  }
  function ao(a, f, d) {
    return { op: f, expr: d, location: J() };
  }
  function Sc(a, f) {
    return ai(a, f);
  }
  function Ec(a) {
    return a.paren = !0, a;
  }
  function Nc(a) {
    return /^CURRENT_DATE$/i.test(a) ? { type: "current-time", location: J(), mode: "date" } : /^CURRENT_TIMESTAMP$/i.test(a) ? { type: "current-time", location: J(), mode: "timestamp" } : /^CURRENT_TIME$/i.test(a) ? { type: "current-time", location: J(), mode: "time" } : /^CURRENT_USER$/i.test(a) ? { type: "current-user", location: J() } : { type: "column-reference", location: J(), table: "", column: a };
  }
  function xc(a) {
    return { type: "column-reference", location: J(), table: "", column: a, delimited: !0 };
  }
  function Lh(a) {
    return a;
  }
  function Tc(a, f) {
    return a + f.join("");
  }
  function Pc(a, f) {
    return a + f.join("");
  }
  function Mh(a) {
    return a;
  }
  function Ac(a) {
    return a.join("");
  }
  function Lc() {
    return '"';
  }
  function Mc(a) {
    return { type: "parameter", location: J(), value: a[1] };
  }
  function Oc(a, f) {
    return yr(J(), a, f);
  }
  function Cc(a, f) {
    return yr(J(), a, f);
  }
  function Rc(a) {
    return { type: "function", location: J(), name: "extract", args: a };
  }
  function Ic(a, f, d) {
    return yr(J(), a, f, ...d ? [d] : []);
  }
  function kc(a, f, d) {
    return yr(J(), a, f, d);
  }
  function Dc(a) {
    return { type: "function", location: J(), name: "substring", args: a };
  }
  function $c(a, f) {
    return yr(J(), a, f);
  }
  function Fc(a, f) {
    return yr(J(), a, f);
  }
  function Uc(a) {
    return { type: "function", location: J(), name: "cast", args: a };
  }
  function Vc() {
    return { type: "data-type", location: J(), value: { type: "integer" } };
  }
  function zc() {
    return { type: "data-type", location: J(), value: { type: "smallint" } };
  }
  function jc() {
    return { type: "data-type", location: J(), value: { type: "float" } };
  }
  function Wc() {
    return { type: "data-type", location: J(), value: { type: "real" } };
  }
  function Gc() {
    return { type: "data-type", location: J(), value: { type: "date" } };
  }
  function Bc() {
    return { type: "data-type", location: J(), value: { type: "timestamp" } };
  }
  function qc() {
    return { type: "data-type", location: J(), value: { type: "time" } };
  }
  function Hc(a) {
    return { type: "data-type", location: J(), value: { type: "varchar", size: parseInt(a) } };
  }
  function Yc(a, f, d) {
    return yr(J(), a, f, d);
  }
  function Zc(a, f) {
    return yr(J(), a, f);
  }
  function Xc(a) {
    return { type: "function", location: J(), name: "trim", args: a };
  }
  function Jc(a) {
    return { type: "string", location: J(), value: a ?? "BOTH" };
  }
  function Qc(a, f) {
    return yr(J(), a, f);
  }
  function Kc(a, f) {
    return yr(J(), a, f);
  }
  function ef(a) {
    return { type: "function", location: J(), name: "position", args: a };
  }
  function tf(a, f) {
    return { type: "function", location: J(), name: a, args: f };
  }
  function rf(a) {
    return { type: "string", location: J(), value: a };
  }
  function nf(a) {
    return a.type === "string" && zb(a.value), { type: "timestamp", location: J(), value: a.value };
  }
  function sf(a) {
    return a.type === "string" && jb(a.value), { type: "time", location: J(), value: a.value };
  }
  function of(a, f, d) {
    return { type: "interval", location: J(), value: f, qualifier: d, op: a };
  }
  function af(a, f) {
    return { type: "interval", location: J(), value: a, qualifier: f, op: "" };
  }
  function uf(a, f) {
    return { type: "interval-qualifier", location: J(), start: a, end: f };
  }
  function lf(a, f) {
    return { type: "interval-period", location: J(), period: a.value, precision: f, secondary: null };
  }
  function cf(a) {
    return { type: "interval-period", location: J(), period: a.value, precision: null, secondary: null };
  }
  function ff(a) {
    return { type: "interval-period", location: J(), period: a.value, precision: null, secondary: null };
  }
  function hf(a, f) {
    return { type: "interval-period", location: J(), period: "second", precision: a, secondary: f };
  }
  function df(a) {
    return { type: "interval-period", location: J(), period: "second", precision: a, secondary: null };
  }
  function mf() {
    return { type: "interval-period", location: J(), period: "second", precision: null, secondary: null };
  }
  function pf(a, f) {
    return { type: "interval-period", location: J(), period: a.value, precision: f, secondary: null };
  }
  function gf(a) {
    return { type: "interval-period", location: J(), period: a.value, precision: null, secondary: null };
  }
  function _f(a, f) {
    return { type: "interval-period", location: J(), period: "second", precision: a, secondary: f };
  }
  function yf(a) {
    return { type: "interval-period", location: J(), period: "second", precision: a, secondary: null };
  }
  function bf() {
    return { type: "interval-period", location: J(), period: "second", precision: null, secondary: null };
  }
  function wf() {
    return { type: "string", location: J(), value: "day" };
  }
  function vf() {
    return { type: "string", location: J(), value: "hour" };
  }
  function Sf() {
    return { type: "string", location: J(), value: "minute" };
  }
  function Ef() {
    return { type: "string", location: J(), value: "month" };
  }
  function uo() {
    return { type: "string", location: J(), value: "year" };
  }
  function ke(a) {
    return parseFloat(a);
  }
  function hn(a) {
    return parseFloat(a);
  }
  function Xe(a) {
    return a.type === "string" && Wb(a.value), { type: "date", location: J(), value: a.value };
  }
  function Nf() {
    return { type: "null", location: J(), value: null };
  }
  function xf() {
    return { type: "boolean", location: J(), value: !0 };
  }
  function Tf() {
    return { type: "boolean", location: J(), value: !1 };
  }
  function lo() {
    return "'";
  }
  function Pf(a) {
    return { type: "string", location: J(), value: a.join("") };
  }
  function he(a, f) {
    return { type: "case-expression", location: J(), format: "simple", operand: a, clauses: f, else: null, elseLocation: null };
  }
  function ni(a, f, d) {
    return { type: "case-expression", location: J(), format: "simple", operand: a, clauses: f, else: d.value, elseLocation: d.location };
  }
  function Jt(a) {
    return { type: "case-expression", location: J(), format: "searched", clauses: a, else: null, elseLocation: null };
  }
  function Af(a, f) {
    return { type: "case-expression", location: J(), format: "searched", clauses: a, else: f.value, elseLocation: f.location };
  }
  function Lf(a, f) {
    return { type: "when-clause", location: J(), operand: a, value: f };
  }
  function Mf(a, f) {
    return { type: "when-clause", location: J(), operand: a, value: f };
  }
  function Of(a) {
    return { type: "else-clause", location: J(), value: a };
  }
  function Ge(a) {
    return { type: "number", location: J(), value: a };
  }
  function mt(a, f, d) {
    return parseFloat(a + f + d);
  }
  function pt(a, f) {
    return parseFloat(a + f);
  }
  function Ar(a, f) {
    return parseFloat(a + f);
  }
  function Tt(a) {
    return parseFloat(a);
  }
  function Pt(a, f) {
    return a[0] + f;
  }
  function I(a) {
    return "." + (a ?? "");
  }
  function gt(a, f) {
    return a + f;
  }
  function Ct(a) {
    return a.join("");
  }
  function ct(a, f) {
    return "e" + (f === null ? "" : f);
  }
  function Me() {
    return "IN";
  }
  function ze() {
    return "IS";
  }
  function qt() {
    return "LIKE";
  }
  function Ft() {
    return "ESCAPE";
  }
  function Qt() {
    return "NOT";
  }
  function it() {
    return "AND";
  }
  function _t() {
    return "OR";
  }
  function Rt() {
    return "BETWEEN";
  }
  function yt() {
    return "FROM";
  }
  function De() {
    return "FOR";
  }
  function Be() {
    return "SUBSTRING";
  }
  function It() {
    return "EXTRACT";
  }
  function ce() {
    return "TRIM";
  }
  function At() {
    return "POSITION";
  }
  function Pe() {
    return "TIMESTAMP";
  }
  function ft() {
    return "DATE";
  }
  function Lr() {
    return "TIME";
  }
  function p() {
    return "LEADING";
  }
  function E() {
    return "TRAILING";
  }
  function k() {
    return "BOTH";
  }
  function G() {
    return "CAST";
  }
  function X() {
    return "AS";
  }
  function se() {
    return "INTEGER";
  }
  function me() {
    return "INT";
  }
  function ie() {
    return "SMALLINT";
  }
  function Oe() {
    return "FLOAT";
  }
  function gr() {
    return "REAL";
  }
  function co() {
    return "VARCHAR";
  }
  function fo() {
    return "TO";
  }
  function ho() {
    return "INTERVAL";
  }
  function mo() {
    return "YEAR";
  }
  function Cf() {
    return "TIMEZONE_HOUR";
  }
  function po() {
    return "TIMEZONE_MINUTE";
  }
  function d9() {
    return "MONTH";
  }
  function m9() {
    return "DAY";
  }
  function p9() {
    return "HOUR";
  }
  function g9() {
    return "MINUTE";
  }
  function _9() {
    return "SECOND";
  }
  function y9() {
    return "DOW";
  }
  function b9() {
    return "DOY";
  }
  function w9() {
    return "WEEK";
  }
  function v9() {
    return "CASE";
  }
  function S9() {
    return "END";
  }
  function E9() {
    return "WHEN";
  }
  function N9() {
    return "THEN";
  }
  function x9() {
    return "ELSE";
  }
  function iT(a) {
    return a;
  }
  function T9(a) {
    return a.join("");
  }
  let h = 0 | e.peg$currPos, M = h;
  const us = [{ line: 1, column: 1 }];
  let si, Mr = h, go = e.peg$maxFailExpected || [], P = 0 | e.peg$silentFails;
  if (e.startRule) {
    if (!(e.startRule in s)) throw new Error(`Can't start parsing from rule "` + e.startRule + '".');
    i = s[e.startRule];
  }
  function J() {
    return _o(M, h);
  }
  function Rf(a, f) {
    throw L9(a, f = f !== void 0 ? f : _o(M, h));
  }
  function P9(a = h) {
    const f = t.codePointAt(a);
    return f === void 0 ? "" : String.fromCodePoint(f);
  }
  function ne(a, f) {
    return { type: "literal", text: a, ignoreCase: f };
  }
  function _r(a, f, d, b) {
    return { type: "class", parts: a, inverted: f, ignoreCase: d, unicode: b };
  }
  function A9() {
    return { type: "end" };
  }
  function Oh(a) {
    let f, d = us[a];
    if (d) return d;
    if (a >= us.length) f = us.length - 1;
    else for (f = a; !us[--f]; ) ;
    for (d = us[f], d = { line: d.line, column: d.column }; f < a; ) t.charCodeAt(f) === 10 ? (d.line++, d.column = 1) : d.column++, f++;
    return us[a] = d, d;
  }
  function _o(a, f, d) {
    const b = Oh(a), x = Oh(f);
    return { source: n, start: { offset: a, line: b.line, column: b.column }, end: { offset: f, line: x.line, column: x.column } };
  }
  function q(a) {
    h < Mr || (h > Mr && (Mr = h, go = []), go.push(a));
  }
  function L9(a, f) {
    return new L1(a, null, null, f);
  }
  function M9(a, f, d) {
    return new L1(L1.buildMessage(a, f), a, f, d);
  }
  function Ch() {
    let a, f;
    return a = h, C(), f = $e(), f !== r ? (C(), M = a, a = f) : (h = a, a = r), a;
  }
  function Rh() {
    let a, f, d, b, x, z, ue, Se;
    if (a = h, f = bt(), f !== r) {
      for (C(), d = [], b = $e(); b !== r; ) d.push(b), b = h, x = h, z = C(), ue = dn(), ue !== r ? (Se = C(), z = [z, ue, Se], x = z) : (h = x, x = r), x !== r ? (x = $e(), x === r ? (h = b, b = r) : b = x) : b = x;
      b = C(), x = wt(), x !== r ? (M = a, a = nc(d)) : (h = a, a = r);
    } else h = a, a = r;
    return a;
  }
  function $e() {
    let a, f, d, b, x, z;
    if (a = h, f = If(), f !== r) {
      for (d = [], b = h, C(), x = Qh(), x !== r ? (C(), z = If(), z !== r ? (M = b, b = no(f, x, z)) : (h = b, b = r)) : (h = b, b = r); b !== r; ) d.push(b), b = h, C(), x = Qh(), x !== r ? (C(), z = If(), z !== r ? (M = b, b = no(f, x, z)) : (h = b, b = r)) : (h = b, b = r);
      M = a, a = sc(f, d);
    } else h = a, a = r;
    return a;
  }
  function If() {
    let a, f, d, b, x, z;
    if (a = h, f = yo(), f !== r) {
      for (d = [], b = h, C(), x = xo(), x !== r ? (C(), z = yo(), z !== r ? (M = b, b = so(f, x, z)) : (h = b, b = r)) : (h = b, b = r); b !== r; ) d.push(b), b = h, C(), x = xo(), x !== r ? (C(), z = yo(), z !== r ? (M = b, b = so(f, x, z)) : (h = b, b = r)) : (h = b, b = r);
      M = a, a = ic(f, d);
    } else h = a, a = r;
    return a;
  }
  function yo() {
    let a, f, d, b, x;
    return a = h, f = oi(), f === r && (f = h, t.charCodeAt(h) === 33 ? (d = u, h++) : (d = r, P === 0 && q(Vu)), d !== r ? (b = h, P++, t.charCodeAt(h) === 61 ? (x = l, h++) : (x = r, P === 0 && q(zu)), P--, x === r ? b = void 0 : (h = b, b = r), b !== r ? (d = [d, b], f = d) : (h = f, f = r)) : (h = f, f = r)), f !== r ? (d = C(), b = yo(), b !== r ? (M = a, a = oc(b)) : (h = a, a = r)) : (h = a, a = r), a === r && (a = O9()), a;
  }
  function O9() {
    let a, f, d, b;
    return a = h, f = rn(), f !== r ? (d = h, C(), b = C9(), b !== r ? d = b : (h = d, d = r), d === r && (d = null), M = a, a = ac(f, d)) : (h = a, a = r), a;
  }
  function C9() {
    let a;
    return a = R9(), a === r && (a = $9(), a === r && (a = k9(), a === r && (a = I9(), a === r && (a = D9())))), a;
  }
  function R9() {
    let a, f, d, b, x;
    if (a = h, f = [], d = h, C(), b = Ih(), b !== r ? (C(), x = rn(), x !== r ? (M = d, d = io(b, x)) : (h = d, d = r)) : (h = d, d = r), d !== r) for (; d !== r; ) f.push(d), d = h, C(), b = Ih(), b !== r ? (C(), x = rn(), x !== r ? (M = d, d = io(b, x)) : (h = d, d = r)) : (h = d, d = r);
    else f = r;
    return f !== r && (M = a, f = uc(f)), a = f, a;
  }
  function Ih() {
    let a;
    return t.substr(h, 2) === c ? (a = c, h += 2) : (a = r, P === 0 && q(ju)), a === r && (t.charCodeAt(h) === 62 ? (a = m, h++) : (a = r, P === 0 && q(Wu)), a === r && (t.substr(h, 2) === _ ? (a = _, h += 2) : (a = r, P === 0 && q(Gu)), a === r && (t.substr(h, 2) === y ? (a = y, h += 2) : (a = r, P === 0 && q(Bu)), a === r && (a = t.charAt(h), Yi.test(a) ? h++ : (a = r, P === 0 && q(qu)), a === r && (t.substr(h, 2) === v ? (a = v, h += 2) : (a = r, P === 0 && q(Hu))))))), a;
  }
  function I9() {
    let a, f, d, b;
    return a = h, f = Xh(), f !== r ? (C(), d = oi(), d !== r ? (C(), b = rn(), b !== r ? (M = a, a = lc(f, b)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r), a === r && (a = h, f = Xh(), f !== r ? (C(), d = rn(), d !== r ? (M = a, a = cc(f, d)) : (h = a, a = r)) : (h = a, a = r)), a;
  }
  function k9() {
    let a, f, d, b, x, z, ue, Se;
    return a = h, f = oi(), f !== r ? (C(), d = Kh(), d !== r ? (b = C(), x = h, z = rn(), z !== r ? (C(), ue = xo(), ue !== r ? (C(), Se = rn(), Se !== r ? (M = x, x = fc(d, z, Se)) : (h = x, x = r)) : (h = x, x = r)) : (h = x, x = r), x !== r ? (M = a, a = hc(d, x)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r), a === r && (a = h, f = Kh(), f !== r ? (C(), d = h, b = rn(), b !== r ? (x = C(), z = xo(), z !== r ? (C(), ue = rn(), ue !== r ? (M = d, d = dc(f, b, ue)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r), d !== r ? (M = a, a = mc(f, d)) : (h = a, a = r)) : (h = a, a = r)), a;
  }
  function kh() {
    let a, f, d, b, x;
    return a = h, f = h, d = oi(), d !== r ? (b = C(), x = Jh(), x !== r ? (d = [d, b, x], f = d) : (h = f, f = r)) : (h = f, f = r), f !== r && (M = a, f = pc(f)), a = f, a === r && (a = Jh()), a;
  }
  function Dh() {
    let a, f, d, b, x;
    return a = h, f = h, d = oi(), d !== r ? (b = C(), x = Vf(), x !== r ? (d = [d, b, x], f = d) : (h = f, f = r)) : (h = f, f = r), f !== r && (M = a, f = gc(f)), a = f, a === r && (a = Vf()), a;
  }
  function D9() {
    let a, f, d, b, x;
    return a = h, f = kh(), f !== r ? (C(), d = zn(), d !== r ? (C(), b = gb(), b !== r ? (C(), x = Uf(), x !== r ? (M = a, a = _c(f, d, x)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r), a === r && (a = h, f = kh(), f !== r ? (C(), d = zn(), d !== r ? (M = a, a = yc(f, d)) : (h = a, a = r)) : (h = a, a = r)), a;
  }
  function $9() {
    let a, f, d;
    return a = h, f = Dh(), f !== r ? (C(), d = Rh(), d !== r ? (M = a, a = bc(f, d)) : (h = a, a = r)) : (h = a, a = r), a === r && (a = h, f = Dh(), f !== r ? (C(), d = Ff(), d !== r ? (M = a, a = wc(f, d)) : (h = a, a = r)) : (h = a, a = r)), a;
  }
  function rn() {
    let a, f, d, b, x, z;
    if (a = h, f = kf(), f !== r) {
      for (d = [], b = h, C(), x = $h(), x !== r ? (C(), z = kf(), z !== r ? (M = b, b = oo(f, x, z)) : (h = b, b = r)) : (h = b, b = r); b !== r; ) d.push(b), b = h, C(), x = $h(), x !== r ? (C(), z = kf(), z !== r ? (M = b, b = oo(f, x, z)) : (h = b, b = r)) : (h = b, b = r);
      M = a, a = vc(f, d);
    } else h = a, a = r;
    return a;
  }
  function $h() {
    let a;
    return a = t.charAt(h), os.test(a) ? h++ : (a = r, P === 0 && q(as)), a === r && (t.substr(h, 2) === S ? (a = S, h += 2) : (a = r, P === 0 && q(Yu))), a;
  }
  function kf() {
    let a, f, d, b, x, z;
    if (a = h, f = Df(), f !== r) {
      for (d = [], b = h, C(), x = Fh(), x !== r ? (C(), z = Df(), z !== r ? (M = b, b = ao(f, x, z)) : (h = b, b = r)) : (h = b, b = r); b !== r; ) d.push(b), b = h, C(), x = Fh(), x !== r ? (C(), z = Df(), z !== r ? (M = b, b = ao(f, x, z)) : (h = b, b = r)) : (h = b, b = r);
      M = a, a = Sc(f, d);
    } else h = a, a = r;
    return a;
  }
  function Fh() {
    let a;
    return a = t.charAt(h), Ru.test(a) ? h++ : (a = r, P === 0 && q(Zu)), a;
  }
  function Df() {
    let a, f, d, b;
    return a = J9(), a === r && (a = B9(), a === r && (a = q9(), a === r && (a = Y9(), a === r && (a = Z9(), a === r && (a = H9(), a === r && (a = X9(), a === r && (a = ab(), a === r && (a = F9(), a === r && (a = Ff(), a === r && (a = h, f = bt(), f !== r ? (C(), d = $e(), d !== r ? (C(), b = wt(), b !== r ? (M = a, a = Ec(d)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r))))))))))), a;
  }
  function F9() {
    let a, f;
    return a = h, f = U9(), f !== r && (M = a, f = Nc(f)), a = f, a === r && (a = h, f = z9(), f !== r && (M = a, f = xc(f)), a = f), a;
  }
  function U9() {
    let a, f;
    return a = h, f = V9(), f !== r && (M = a, f = f), a = f, a;
  }
  function V9() {
    let a, f, d, b;
    if (a = h, f = $f(), f !== r) {
      for (d = [], b = Vh(); b !== r; ) d.push(b), b = Vh();
      M = a, a = Tc(f, d);
    } else h = a, a = r;
    return a;
  }
  function Uh() {
    let a, f, d, b;
    if (a = h, f = $f(), f !== r) {
      for (d = [], b = de(); b !== r; ) d.push(b), b = de();
      M = a, a = Pc(f, d);
    } else h = a, a = r;
    return a;
  }
  function $f() {
    let a;
    return a = t.charAt(h), Iu.test(a) ? h++ : (a = r, P === 0 && q(Xu)), a;
  }
  function de() {
    let a;
    return a = t.charAt(h), ku.test(a) ? h++ : (a = r, P === 0 && q(Ju)), a;
  }
  function Vh() {
    let a;
    return a = t.charAt(h), Zi.test(a) ? h++ : (a = r, P === 0 && q(Ji)), a;
  }
  function z9() {
    let a, f, d, b;
    return a = h, f = bo(), f !== r ? (d = j9(), b = bo(), b !== r ? (M = a, a = d) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function j9() {
    let a, f, d;
    for (a = h, f = [], d = zh(); d !== r; ) f.push(d), d = zh();
    return M = a, f = Ac(f), a = f, a;
  }
  function zh() {
    let a;
    return a = G9(), a === r && (a = W9()), a;
  }
  function W9() {
    let a, f, d;
    return a = h, f = bo(), f !== r ? (d = bo(), d !== r ? (M = a, a = Lc()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function G9() {
    let a;
    return a = t.charAt(h), Zi.test(a) ? h++ : (a = r, P === 0 && q(Ji)), a;
  }
  function bo() {
    let a;
    return a = t.charAt(h), Du.test(a) ? h++ : (a = r, P === 0 && q(Qu)), a;
  }
  function Ff() {
    let a, f, d, b;
    return a = h, f = h, t.charCodeAt(h) === 64 ? (d = T, h++) : (d = r, P === 0 && q(Ku)), d !== r ? (b = Uh(), b !== r ? (d = [d, b], f = d) : (h = f, f = r)) : (h = f, f = r), f !== r && (M = a, f = Mc(f)), a = f, a;
  }
  function B9() {
    let a, f, d, b, x, z, ue, Se;
    return a = h, f = ed(), f !== r ? (C(), d = h, b = bt(), b !== r ? (C(), x = Gh(), x !== r ? (C(), z = zf(), z !== r ? (C(), ue = $e(), ue !== r ? (C(), Se = wt(), Se !== r ? (M = d, d = Oc(x, ue)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r), d === r && (d = h, b = bt(), b !== r ? (C(), x = Gh(), x !== r ? (C(), z = dn(), z !== r ? (C(), ue = $e(), ue !== r ? (C(), Se = wt(), Se !== r ? (M = d, d = Cc(x, ue)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r)), d !== r ? (M = a, a = Rc(d)) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function q9() {
    let a, f, d, b, x, z, ue, Se, mn, Ao, ui;
    return a = h, f = yb(), f !== r ? (C(), d = h, b = bt(), b !== r ? (C(), x = $e(), x !== r ? (C(), z = zf(), z !== r ? (C(), ue = $e(), ue !== r ? (C(), Se = h, mn = _b(), mn !== r ? (Ao = C(), ui = $e(), ui !== r ? (C(), Se = ui) : (h = Se, Se = r)) : (h = Se, Se = r), Se === r && (Se = null), mn = wt(), mn !== r ? (M = d, d = Ic(x, ue, Se)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r), d === r && (d = h, b = bt(), b !== r ? (C(), x = $e(), x !== r ? (C(), z = dn(), z !== r ? (C(), ue = $e(), ue !== r ? (C(), Se = dn(), Se !== r ? (mn = C(), Ao = $e(), Ao !== r ? (ui = wt(), ui !== r ? (M = d, d = kc(x, ue, Ao)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r)), d !== r ? (M = a, a = Dc(d)) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function H9() {
    let a, f, d, b, x, z, ue, Se;
    return a = h, f = Nb(), f !== r ? (C(), d = h, b = bt(), b !== r ? (C(), x = $e(), x !== r ? (C(), z = xb(), z !== r ? (C(), ue = jh(), ue !== r ? (C(), Se = wt(), Se !== r ? (M = d, d = $c(x, ue)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r), d === r && (d = h, b = bt(), b !== r ? (C(), x = $e(), x !== r ? (C(), z = dn(), z !== r ? (C(), ue = jh(), ue !== r ? (C(), Se = wt(), Se !== r ? (M = d, d = Fc(x, ue)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r)), d !== r ? (M = a, a = Uc(d)) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function jh() {
    let a, f, d, b, x;
    return a = h, f = Tb(), f === r && (f = Pb()), f !== r && (M = a, f = Vc()), a = f, a === r && (a = h, f = Ab(), f !== r && (M = a, f = zc()), a = f, a === r && (a = h, f = Lb(), f !== r && (M = a, f = jc()), a = f, a === r && (a = h, f = Mb(), f !== r && (M = a, f = Wc()), a = f, a === r && (a = h, f = rd(), f !== r && (M = a, f = Gc()), a = f, a === r && (a = h, f = td(), f !== r && (M = a, f = Bc()), a = f, a === r && (a = h, f = nd(), f !== r && (M = a, f = qc()), a = f, a === r && (a = h, f = Ob(), f !== r ? (C(), d = bt(), d !== r ? (C(), b = jn(), b !== r ? (C(), x = wt(), x !== r ? (M = a, a = Hc(b)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r)))))))), a;
  }
  function Y9() {
    let a, f, d, b, x, z, ue, Se, mn;
    return a = h, f = bb(), f !== r ? (C(), d = h, b = bt(), b !== r ? (C(), x = Wh(), C(), z = $e(), z !== r ? (C(), ue = zf(), ue !== r ? (C(), Se = $e(), Se !== r ? (C(), mn = wt(), mn !== r ? (M = d, d = Yc(x, z, Se)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r), d === r && (d = h, b = bt(), b !== r ? (C(), x = Wh(), C(), z = $e(), z !== r ? (C(), ue = wt(), ue !== r ? (M = d, d = Zc(x, z)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r)), d !== r ? (M = a, a = Xc(d)) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function Wh() {
    let a, f;
    return a = h, f = vb(), f === r && (f = Sb(), f === r && (f = Eb())), f === r && (f = null), M = a, f = Jc(f), a = f, a;
  }
  function Z9() {
    let a, f, d, b, x, z, ue, Se;
    return a = h, f = wb(), f !== r ? (C(), d = h, b = bt(), b !== r ? (C(), x = $e(), x !== r ? (C(), z = Vf(), z !== r ? (C(), ue = $e(), ue !== r ? (C(), Se = wt(), Se !== r ? (M = d, d = Qc(x, ue)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r), d === r && (d = h, b = bt(), b !== r ? (C(), x = $e(), x !== r ? (C(), z = dn(), z !== r ? (C(), ue = $e(), ue !== r ? (C(), Se = wt(), Se !== r ? (M = d, d = Kc(x, ue)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r)) : (h = d, d = r)), d !== r ? (M = a, a = ef(d)) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function X9() {
    let a, f, d, b;
    return a = h, f = h, P++, d = ed(), P--, d === r ? f = void 0 : (h = f, f = r), f !== r ? (d = Ub(), d !== r ? (C(), b = Rh(), b !== r ? (M = a, a = tf(d, b)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function Gh() {
    let a, f;
    return a = h, f = id(), f === r && (f = od(), f === r && (f = ad(), f === r && (f = ud(), f === r && (f = ld(), f === r && (f = Wn(), f === r && (f = Rb(), f === r && (f = Ib(), f === r && (f = kb(), f === r && (f = Db(), f === r && (f = $b())))))))))), f !== r && (M = a, f = rf(f)), a = f, a;
  }
  function J9() {
    let a;
    return a = Uf(), a === r && (a = cb(), a === r && (a = ob(), a === r && (a = ib(), a === r && (a = sb(), a === r && (a = Q9(), a === r && (a = eb(), a === r && (a = K9()))))))), a;
  }
  function Q9() {
    let a, f, d;
    return a = h, f = td(), f !== r ? (C(), d = zn(), d !== r ? (M = a, a = nf(d)) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function K9() {
    let a, f, d;
    return a = h, f = nd(), f !== r ? (C(), d = zn(), d !== r ? (M = a, a = sf(d)) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function eb() {
    let a, f, d, b, x;
    return a = h, f = sd(), f !== r ? (C(), d = t.charAt(h), os.test(d) ? h++ : (d = r, P === 0 && q(as)), d !== r ? (C(), b = zn(), b !== r ? (C(), x = Bh(), x !== r ? (M = a, a = of(d, b, x)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r), a === r && (a = h, f = sd(), f !== r ? (C(), d = zn(), d !== r ? (C(), b = Bh(), b !== r ? (M = a, a = af(d, b)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r)), a;
  }
  function Bh() {
    let a, f, d, b;
    return a = h, f = tb(), f !== r ? (C(), d = Cb(), d !== r ? (C(), b = rb(), b !== r ? (M = a, a = uf(f, b)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r), a === r && (a = nb()), a;
  }
  function tb() {
    let a, f, d, b, x;
    return a = h, f = ii(), f !== r ? (C(), d = bt(), d !== r ? (C(), b = vo(), b !== r ? (C(), x = wt(), x !== r ? (M = a, a = lf(f, b)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r), a === r && (a = h, f = ii(), f !== r && (M = a, f = cf(f)), a = f), a;
  }
  function rb() {
    let a, f, d, b, x, z, ue;
    return a = h, f = ii(), f !== r && (M = a, f = ff(f)), a = f, a === r && (a = h, f = Wn(), f !== r ? (C(), d = bt(), d !== r ? (C(), b = vo(), b !== r ? (C(), x = dn(), x !== r ? (C(), z = wo(), z !== r ? (C(), ue = wt(), ue !== r ? (M = a, a = hf(b, z)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r), a === r && (a = h, f = Wn(), f !== r ? (C(), d = bt(), d !== r ? (C(), b = vo(), b !== r ? (C(), x = wt(), x !== r ? (M = a, a = df(b)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r), a === r && (a = h, f = Wn(), f !== r && (M = a, f = mf()), a = f))), a;
  }
  function nb() {
    let a, f, d, b, x, z, ue;
    return a = h, f = ii(), f !== r ? (C(), d = bt(), d !== r ? (C(), b = wo(), b !== r ? (C(), x = wt(), x !== r ? (M = a, a = pf(f, b)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r), a === r && (a = h, f = ii(), f !== r && (M = a, f = gf(f)), a = f, a === r && (a = h, f = Wn(), f !== r ? (C(), d = bt(), d !== r ? (C(), b = vo(), b !== r ? (C(), x = dn(), x !== r ? (C(), z = wo(), z !== r ? (C(), ue = wt(), ue !== r ? (M = a, a = _f(b, z)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r), a === r && (a = h, f = Wn(), f !== r ? (C(), d = bt(), d !== r ? (C(), b = wo(), b !== r ? (C(), x = wt(), x !== r ? (M = a, a = yf(b)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r), a === r && (a = h, f = Wn(), f !== r && (M = a, f = bf()), a = f)))), a;
  }
  function ii() {
    let a, f;
    return a = h, f = ad(), f !== r && (M = a, f = wf()), a = f, a === r && (a = h, f = ud(), f !== r && (M = a, f = vf()), a = f, a === r && (a = h, f = ld(), f !== r && (M = a, f = Sf()), a = f, a === r && (a = h, f = od(), f !== r && (M = a, f = Ef()), a = f, a === r && (a = h, f = id(), f !== r && (M = a, f = uo()), a = f)))), a;
  }
  function wo() {
    let a, f;
    return a = h, f = jn(), f !== r && (M = a, f = ke(f)), a = f, a;
  }
  function vo() {
    let a, f;
    return a = h, f = jn(), f !== r && (M = a, f = hn(f)), a = f, a;
  }
  function sb() {
    let a, f, d;
    return a = h, f = rd(), f !== r ? (C(), d = zn(), d !== r ? (M = a, a = Xe(d)) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function ib() {
    let a, f;
    return a = h, f = db(), f !== r && (M = a, f = Nf()), a = f, a;
  }
  function ob() {
    let a, f;
    return a = h, f = mb(), f !== r && (M = a, f = xf()), a = f, a === r && (a = h, f = pb(), f !== r && (M = a, f = Tf()), a = f), a;
  }
  function zn() {
    let a;
    return a = Uf(), a === r && (a = Ff()), a;
  }
  function Uf() {
    let a, f, d, b, x;
    if (a = h, t.charCodeAt(h) === 39 ? (f = L, h++) : (f = r, P === 0 && q(Qi)), f === r && (t.substr(h, 2) === D ? (f = D, h += 2) : (f = r, P === 0 && q(el))), f !== r) {
      for (d = [], b = h, t.substr(h, 2) === V ? (x = V, h += 2) : (x = r, P === 0 && q(Ki)), x !== r && (M = b, x = lo()), b = x, b === r && (b = t.charAt(h), Xi.test(b) ? h++ : (b = r, P === 0 && q(eo))); b !== r; ) d.push(b), b = h, t.substr(h, 2) === V ? (x = V, h += 2) : (x = r, P === 0 && q(Ki)), x !== r && (M = b, x = lo()), b = x, b === r && (b = t.charAt(h), Xi.test(b) ? h++ : (b = r, P === 0 && q(eo)));
      t.charCodeAt(h) === 39 ? (b = L, h++) : (b = r, P === 0 && q(Qi)), b !== r ? (M = a, a = Pf(d)) : (h = a, a = r);
    } else h = a, a = r;
    return a;
  }
  function ab() {
    let a;
    return a = ub(), a === r && (a = lb()), a;
  }
  function ub() {
    let a, f, d, b, x, z, ue;
    if (a = h, f = To(), f !== r) if (C(), d = $e(), d !== r) {
      for (C(), b = [], x = h, z = Eo(), z !== r ? (ue = C(), x = z) : (h = x, x = r); x !== r; ) b.push(x), x = h, z = Eo(), z !== r ? (ue = C(), x = z) : (h = x, x = r);
      x = Po(), x !== r ? (M = a, a = he(d, b)) : (h = a, a = r);
    } else h = a, a = r;
    else h = a, a = r;
    if (a === r) if (a = h, f = To(), f !== r) if (C(), d = $e(), d !== r) {
      for (C(), b = [], x = h, z = Eo(), z !== r ? (ue = C(), x = z) : (h = x, x = r); x !== r; ) b.push(x), x = h, z = Eo(), z !== r ? (ue = C(), x = z) : (h = x, x = r);
      x = qh(), x !== r ? (z = C(), ue = Po(), ue !== r ? (M = a, a = ni(d, b, x)) : (h = a, a = r)) : (h = a, a = r);
    } else h = a, a = r;
    else h = a, a = r;
    return a;
  }
  function lb() {
    let a, f, d, b, x, z;
    if (a = h, f = To(), f !== r) {
      for (C(), d = [], b = h, x = So(), x !== r ? (z = C(), b = x) : (h = b, b = r); b !== r; ) d.push(b), b = h, x = So(), x !== r ? (z = C(), b = x) : (h = b, b = r);
      b = Po(), b !== r ? (M = a, a = Jt(d)) : (h = a, a = r);
    } else h = a, a = r;
    if (a === r) if (a = h, f = To(), f !== r) {
      for (C(), d = [], b = h, x = So(), x !== r ? (z = C(), b = x) : (h = b, b = r); b !== r; ) d.push(b), b = h, x = So(), x !== r ? (z = C(), b = x) : (h = b, b = r);
      b = qh(), b !== r ? (x = C(), z = Po(), z !== r ? (M = a, a = Af(d, b)) : (h = a, a = r)) : (h = a, a = r);
    } else h = a, a = r;
    return a;
  }
  function So() {
    let a, f, d, b, x;
    return a = h, f = cd(), f !== r ? (C(), d = $e(), d !== r ? (C(), b = fd(), b !== r ? (C(), x = $e(), x !== r ? (M = a, a = Lf(d, x)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function Eo() {
    let a, f, d, b, x;
    return a = h, f = cd(), f !== r ? (C(), d = $e(), d !== r ? (C(), b = fd(), b !== r ? (C(), x = $e(), x !== r ? (M = a, a = Mf(d, x)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function qh() {
    let a, f, d;
    return a = h, f = Fb(), f !== r ? (C(), d = $e(), d !== r ? (M = a, a = Of(d)) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function cb() {
    let a, f, d, b;
    return a = h, f = fb(), f !== r ? (d = h, P++, b = $f(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = Ge(f)) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function fb() {
    let a, f, d, b;
    return a = h, f = No(), f !== r ? (d = Hh(), d !== r ? (b = Yh(), b !== r ? (M = a, a = mt(f, d, b)) : (h = a, a = r)) : (h = a, a = r)) : (h = a, a = r), a === r && (a = h, f = No(), f !== r ? (d = Hh(), d !== r ? (M = a, a = pt(f, d)) : (h = a, a = r)) : (h = a, a = r), a === r && (a = h, f = No(), f !== r ? (d = Yh(), d !== r ? (M = a, a = Ar(f, d)) : (h = a, a = r)) : (h = a, a = r), a === r && (a = h, f = No(), f !== r && (M = a, f = Tt(f)), a = f))), a;
  }
  function No() {
    let a, f, d;
    return a = jn(), a === r && (a = h, f = t.charAt(h), os.test(f) ? h++ : (f = r, P === 0 && q(as)), f !== r ? (d = jn(), d !== r ? (M = a, a = Pt(f, d)) : (h = a, a = r)) : (h = a, a = r)), a;
  }
  function Hh() {
    let a, f, d;
    return a = h, t.charCodeAt(h) === 46 ? (f = W, h++) : (f = r, P === 0 && q(tl)), f !== r ? (d = jn(), d === r && (d = null), M = a, a = I(d)) : (h = a, a = r), a;
  }
  function Yh() {
    let a, f, d;
    return a = h, f = hb(), f !== r ? (d = jn(), d !== r ? (M = a, a = gt(f, d)) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function jn() {
    let a, f, d;
    if (a = h, f = [], d = Zh(), d !== r) for (; d !== r; ) f.push(d), d = Zh();
    else f = r;
    return f !== r && (M = a, f = Ct(f)), a = f, a;
  }
  function Zh() {
    let a;
    return a = t.charAt(h), $u.test(a) ? h++ : (a = r, P === 0 && q(rl)), a;
  }
  function hb() {
    let a, f, d;
    return a = h, f = t.charAt(h), Fu.test(f) ? h++ : (f = r, P === 0 && q(nl)), f !== r ? (d = t.charAt(h), os.test(d) ? h++ : (d = r, P === 0 && q(as)), d === r && (d = null), M = a, a = ct(f, d)) : (h = a, a = r), a;
  }
  function db() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 4), f.toLowerCase() === j ? h += 4 : (f = r, P === 0 && q(sl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (f = [f, d], a = f) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function mb() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 4), f.toLowerCase() === U ? h += 4 : (f = r, P === 0 && q(il)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (f = [f, d], a = f) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function pb() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 5), f.toLowerCase() === $ ? h += 5 : (f = r, P === 0 && q(ol)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (f = [f, d], a = f) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function Vf() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 2), f.toLowerCase() === B ? h += 2 : (f = r, P === 0 && q(al)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = Me()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function Xh() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 2), f.toLowerCase() === Z ? h += 2 : (f = r, P === 0 && q(ul)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = ze()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function Jh() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 4), f.toLowerCase() === ee ? h += 4 : (f = r, P === 0 && q(ll)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = qt()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function gb() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 6), f.toLowerCase() === ye ? h += 6 : (f = r, P === 0 && q(cl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = Ft()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function oi() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 3), f.toLowerCase() === Ie ? h += 3 : (f = r, P === 0 && q(fl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = Qt()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function xo() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 3), f.toLowerCase() === ve ? h += 3 : (f = r, P === 0 && q(hl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = it()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function Qh() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 2), f.toLowerCase() === le ? h += 2 : (f = r, P === 0 && q(dl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = _t()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function Kh() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 7), f.toLowerCase() === K ? h += 7 : (f = r, P === 0 && q(ml)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = Rt()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function zf() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 4), f.toLowerCase() === Y ? h += 4 : (f = r, P === 0 && q(pl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = yt()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function _b() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 3), f.toLowerCase() === re ? h += 3 : (f = r, P === 0 && q(gl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = De()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function yb() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 9), f.toLowerCase() === te ? h += 9 : (f = r, P === 0 && q(_l)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = Be()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function ed() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 7), f.toLowerCase() === ae ? h += 7 : (f = r, P === 0 && q(yl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = It()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function bb() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 4), f.toLowerCase() === ge ? h += 4 : (f = r, P === 0 && q(bl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = ce()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function wb() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 8), f.toLowerCase() === Te ? h += 8 : (f = r, P === 0 && q(wl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = At()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function td() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 9), f.toLowerCase() === et ? h += 9 : (f = r, P === 0 && q(vl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = Pe()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function rd() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 4), f.toLowerCase() === lt ? h += 4 : (f = r, P === 0 && q(Sl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = ft()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function nd() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 4), f.toLowerCase() === qr ? h += 4 : (f = r, P === 0 && q(El)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = Lr()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function vb() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 7), f.toLowerCase() === fn ? h += 7 : (f = r, P === 0 && q(Nl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = p()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function Sb() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 8), f.toLowerCase() === en ? h += 8 : (f = r, P === 0 && q(xl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = E()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function Eb() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 4), f.toLowerCase() === is ? h += 4 : (f = r, P === 0 && q(Tl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = k()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function Nb() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 4), f.toLowerCase() === tn ? h += 4 : (f = r, P === 0 && q(Pl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = G()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function xb() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 2), f.toLowerCase() === Ot ? h += 2 : (f = r, P === 0 && q(Al)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = X()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function Tb() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 7), f.toLowerCase() === ti ? h += 7 : (f = r, P === 0 && q(Ll)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = se()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function Pb() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 3), f.toLowerCase() === hu ? h += 3 : (f = r, P === 0 && q(Ml)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = me()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function Ab() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 8), f.toLowerCase() === du ? h += 8 : (f = r, P === 0 && q(Ol)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = ie()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function Lb() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 5), f.toLowerCase() === mu ? h += 5 : (f = r, P === 0 && q(Cl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = Oe()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function Mb() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 4), f.toLowerCase() === pu ? h += 4 : (f = r, P === 0 && q(Rl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = gr()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function Ob() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 7), f.toLowerCase() === gu ? h += 7 : (f = r, P === 0 && q(Il)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = co()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function Cb() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 2), f.toLowerCase() === _u ? h += 2 : (f = r, P === 0 && q(kl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = fo()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function sd() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 8), f.toLowerCase() === yu ? h += 8 : (f = r, P === 0 && q(Dl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = ho()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function id() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 4), f.toLowerCase() === bu ? h += 4 : (f = r, P === 0 && q($l)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = mo()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function Rb() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 13), f.toLowerCase() === wu ? h += 13 : (f = r, P === 0 && q(Fl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = Cf()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function Ib() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 15), f.toLowerCase() === vu ? h += 15 : (f = r, P === 0 && q(Ul)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = po()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function od() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 5), f.toLowerCase() === Su ? h += 5 : (f = r, P === 0 && q(Vl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = d9()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function ad() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 3), f.toLowerCase() === Eu ? h += 3 : (f = r, P === 0 && q(zl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = m9()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function ud() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 4), f.toLowerCase() === Nu ? h += 4 : (f = r, P === 0 && q(jl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = p9()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function ld() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 6), f.toLowerCase() === xu ? h += 6 : (f = r, P === 0 && q(Wl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = g9()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function Wn() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 6), f.toLowerCase() === Tu ? h += 6 : (f = r, P === 0 && q(Gl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = _9()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function kb() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 3), f.toLowerCase() === Bi ? h += 3 : (f = r, P === 0 && q(Bl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = y9()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function Db() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 3), f.toLowerCase() === Un ? h += 3 : (f = r, P === 0 && q(ql)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = b9()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function $b() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 4), f.toLowerCase() === Pu ? h += 4 : (f = r, P === 0 && q(Hl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = w9()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function To() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 4), f.toLowerCase() === Au ? h += 4 : (f = r, P === 0 && q(Yl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = v9()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function Po() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 3), f.toLowerCase() === Lu ? h += 3 : (f = r, P === 0 && q(Zl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = S9()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function cd() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 4), f.toLowerCase() === qi ? h += 4 : (f = r, P === 0 && q(Xl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = E9()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function fd() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 4), f.toLowerCase() === Mu ? h += 4 : (f = r, P === 0 && q(Jl)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = N9()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function Fb() {
    let a, f, d, b;
    return a = h, f = t.substr(h, 4), f.toLowerCase() === Ou ? h += 4 : (f = r, P === 0 && q(Ql)), f !== r ? (d = h, P++, b = de(), P--, b === r ? d = void 0 : (h = d, d = r), d !== r ? (M = a, a = x9()) : (h = a, a = r)) : (h = a, a = r), a;
  }
  function dn() {
    let a;
    return t.charCodeAt(h) === 44 ? (a = ri, h++) : (a = r, P === 0 && q(Kl)), a;
  }
  function bt() {
    let a;
    return t.charCodeAt(h) === 40 ? (a = Cu, h++) : (a = r, P === 0 && q(ec)), a;
  }
  function wt() {
    let a;
    return t.charCodeAt(h) === 41 ? (a = Vn, h++) : (a = r, P === 0 && q(tc)), a;
  }
  function C() {
    let a, f;
    for (a = [], f = hd(); f !== r; ) a.push(f), f = hd();
    return a;
  }
  function hd() {
    let a;
    return a = t.charAt(h), Uu.test(a) ? h++ : (a = r, P === 0 && q(rc)), a;
  }
  function Ub() {
    let a, f, d, b;
    if (a = h, f = Uh(), f !== r && (M = a, f = f), a = f, a === r) if (a = h, t.charCodeAt(h) === 96 ? (f = Hi, h++) : (f = r, P === 0 && q(to)), f !== r) {
      if (d = [], b = t.charAt(h), A.test(b) ? h++ : (b = r, P === 0 && q(ro)), b !== r) for (; b !== r; ) d.push(b), b = t.charAt(h), A.test(b) ? h++ : (b = r, P === 0 && q(ro));
      else d = r;
      d !== r ? (t.charCodeAt(h) === 96 ? (b = Hi, h++) : (b = r, P === 0 && q(to)), b !== r ? (M = a, a = T9(d)) : (h = a, a = r)) : (h = a, a = r);
    } else h = a, a = r;
    return a;
  }
  function Vb(a, f, d) {
    return { type: "unary-expression", location: d, operator: a, expr: f };
  }
  function dd(a, f, d, b, x) {
    const z = { type: "binary-expression", location: x, operator: a, left: f, right: d };
    return b !== void 0 && (z.escape = b), z;
  }
  function yr(a, ...f) {
    return { type: "expression-list", location: a, value: f };
  }
  function ai(a, f) {
    let d = a;
    for (const { op: b, expr: x, location: { end: z } } of f) d = dd(b, d, x, void 0, { ...d.location, end: z });
    return d;
  }
  function zb(a) {
    /^(\d{4})-(\d{1,2})-(\d{1,2})$|^(\d{4})-(\d{1,2})-(\d{1,2}) (\d{1,2}):(\d{1,2}):(\d{1,2})(\.[0-9]+)?$|^(\d{4})-(\d{1,2})-(\d{1,2}) (\d{1,2}):(\d{1,2}):(\d{1,2})(\.[0-9]+)?[ ]{0,1}(\+|\-)(\d{1,2}):(\d{1,2})$|^(\d{4})-(\d{1,2})-(\d{1,2}) (\d{1,2}):(\d{1,2})?[ ]{0,1}(\+|\-)(\d{1,2}):(\d{1,2})$|^(\d{4})-(\d{1,2})-(\d{1,2}) (\d{1,2}):(\d{1,2})$/.test(a) !== !0 && Rf("Timestamp literal is invalid");
  }
  function jb(a) {
    /^(\d{1,2}):(\d{1,2}):(\d{1,2})$|^(\d{1,2}):(\d{1,2})$|^(\d{1,2}):(\d{1,2}):(\d{1,2}).([0-9]+)$/.test(a) !== !0 && Rf("Time literal is invalid");
  }
  function Wb(a) {
    /^(\d{4})-(\d{1,2})-(\d{1,2})$|^(\d{4})-(\d{1,2})-(\d{1,2}) (\d{1,2}):(\d{1,2}):(\d{1,2})(\.[0-9]+)?$|^(\d{4})-(\d{1,2})-(\d{1,2}) (\d{1,2}):(\d{1,2}):(\d{1,2})(\.[0-9]+)?[ ]{0,1}(\+|\-)(\d{1,2}):(\d{1,2})$|^(\d{4})-(\d{1,2})-(\d{1,2}) (\d{1,2}):(\d{1,2})?[ ]{0,1}(\+|\-)(\d{1,2}):(\d{1,2})$|^(\d{4})-(\d{1,2})-(\d{1,2}) (\d{1,2}):(\d{1,2})$/.test(a) !== !0 && Rf("Date literal is invalid");
  }
  si = i();
  const jf = si !== r && h === t.length;
  function md() {
    throw si !== r && h < t.length && q(A9()), M9(go, Mr < t.length ? P9(Mr) : null, Mr < t.length ? _o(Mr, Mr + 1) : _o(Mr, Mr));
  }
  return e.peg$library ? { peg$result: si, peg$currPos: h, peg$FAILED: r, peg$maxFailExpected: go, peg$maxFailPos: Mr, peg$success: jf, peg$throw: jf ? void 0 : md } : jf ? si : void md();
}
class Hx {
  static parse(e) {
    return qx(e);
  }
}
function St(t, e) {
  if (t != null) switch (e(t), t.type) {
    case "when-clause":
      St(t.operand, e), St(t.value, e);
      break;
    case "case-expression":
      for (const r of t.clauses) St(r, e);
      t.format === "simple" && St(t.operand, e), t.else !== null && St(t.else, e);
      break;
    case "expression-list":
      for (const r of t.value) St(r, e);
      break;
    case "unary-expression":
      St(t.expr, e);
      break;
    case "binary-expression":
      St(t.left, e), St(t.right, e);
      break;
    case "function":
      St(t.args, e);
      break;
    case "interval":
      St(t.value, e), St(t.qualifier, e);
      break;
    case "interval-qualifier":
      St(t.start, e), St(t.end, e);
  }
}
const Yx = /* @__PURE__ */ new Set(["current_timestamp", "current_date", "current_time"]);
class Zx {
  constructor(e) {
    this.staticData = e;
  }
  makeBool(e) {
    return o9(e);
  }
  featureValue(e, r, n, s) {
    return h9(e, r, n, s);
  }
  equalsNull(e) {
    return e === null;
  }
  applyLike(e, r, n) {
    return H0(e, r, n);
  }
  ensureArray(e) {
    return B0(e);
  }
  applyIn(e, r) {
    return q0(e, r);
  }
  currentTimestamp(e) {
    return l9(e);
  }
  currentDate(e) {
    return c9(e);
  }
  currentTime(e) {
    return f9(e);
  }
  makeSqlInterval(e, r, n) {
    return $t.createFromValueAndQualifier(e, r, n);
  }
  convertInterval(e) {
    return $t.isInterval(e) ? e.valueInMilliseconds() : e;
  }
  compare(e, r, n) {
    return fr(r, n, e);
  }
  calculate(e, r, n, s) {
    return i9(e, r, n, s);
  }
  evaluateTime(e) {
    return fu(e);
  }
  evaluateTimestamp(e, r, n) {
    return Gi(e, r, n);
  }
  evaluateDate(e, r) {
    return Nh(e, r);
  }
  evaluateFunction(e, r, n) {
    return xh(e, r, n);
  }
  lookup(e, r) {
    const n = r[e];
    return n === void 0 ? null : n;
  }
  between(e, r) {
    return e == null || r[0] == null || r[1] == null ? null : fr(e, r[0], ">=") && fr(e, r[1], "<=");
  }
  notbetween(e, r) {
    return e == null || r[0] == null || r[1] == null ? null : fr(e, r[0], "<") || fr(e, r[1], ">");
  }
  ternaryNot(e) {
    return fa(e);
  }
  ternaryAnd(e, r) {
    return a9(e, r);
  }
  ternaryOr(e, r) {
    return u9(e, r);
  }
}
function Fe(t, ...e) {
  return `this.${t}(${e.join(", ")})`;
}
function vt(t) {
  return t === void 0 ? "void 0" : JSON.stringify(t);
}
function Xx({ type: t, start: e, end: r }) {
  return `{type: ${vt(t)}, start: ${G0(e)}, end: ${G0(r)}}`;
}
function G0({ type: t, period: e, precision: r, secondary: n }) {
  return JSON.stringify({ type: t, period: e, precision: r, secondary: n });
}
function Jx({ type: t, size: e, withtimezone: r }) {
  return JSON.stringify({ type: t, size: e, withtimezone: r });
}
const I2 = "feature", k2 = "lookups", D2 = "attributeAdapter", $2 = "fieldsIndex", vs = "timeZone", F2 = "currentUser";
class Qx {
  constructor(e) {
    this._parseTree = e, this._staticData = /* @__PURE__ */ Object.create(null), this._nextStaticDataId = 0, this._tempVars = /* @__PURE__ */ new Set(), this._nextTempVarId = 0;
  }
  compile() {
    const e = this._compileNode(this._parseTree), r = `
      ${this._tempVars.size > 0 ? `var ${Array.from(this._tempVars).join(", ")};` : ""}
      return this.convertInterval(${e});
    `;
    return new Function(I2, k2, D2, $2, vs, F2, r).bind(new Zx(this._staticData));
  }
  _storeStaticData(e) {
    const r = "static$" + this._nextStaticDataId++;
    return this._staticData[r] = e, r;
  }
  _compileRefStaticData(e) {
    return `this.staticData[${vt(e)}]`;
  }
  _generateTempVar() {
    const e = "temp$" + this._nextTempVarId++;
    return this._tempVars.add(e), e;
  }
  _compileSimpleCase(e) {
    const r = this._compileNode(e.operand), n = this._generateTempVar(), s = [];
    for (const i of e.clauses) {
      const u = Fe("compare", vt("="), n, this._compileNode(i.operand)), l = this._compileNode(i.value);
      s.push(`${u} ? (${l}) :`);
    }
    return e.else != null ? s.push(this._compileNode(e.else)) : s.push(vt(null)), `(${n} = ${r}, ${s.join(" ")})`;
  }
  _compileSearchedCase(e) {
    const r = [];
    for (const n of e.clauses) {
      const s = Fe("makeBool", this._compileNode(n.operand)), i = this._compileNode(n.value);
      r.push(`${s} ? (${i}) :`);
    }
    return e.else != null ? r.push(this._compileNode(e.else)) : r.push(vt(null)), r.join(" ");
  }
  _compileInExpr(e, r) {
    const n = /* @__PURE__ */ new Set(), s = [];
    for (const l of r.value) l.type === "number" || l.type === "string" ? n.add(l.value) : s.push(l);
    const i = this._compileNode(e), u = Fe("ensureArray", this._compileNode({ type: "expression-list", location: r.location, value: s }));
    if (n.size > 0) {
      const l = this._compileRefStaticData(this._storeStaticData(n)), c = this._generateTempVar();
      return s.length > 0 ? `(${c} = ${i}, ${l}.has(${c}) || ${Fe("applyIn", c, u)})` : `(${c} = ${i}, ${c} == null ? null : ${l}.has(${c}))`;
    }
    return Fe("applyIn", i, u);
  }
  _compileNode(e) {
    switch (e.type) {
      case "interval":
        return Fe("makeSqlInterval", this._compileNode(e.value), e.qualifier.type === "interval-qualifier" ? Xx(e.qualifier) : G0(e.qualifier), vt(e.op));
      case "case-expression":
        return e.format === "simple" ? this._compileSimpleCase(e) : this._compileSearchedCase(e);
      case "parameter":
        return Fe("lookup", vt(e.value.toLowerCase()), k2);
      case "expression-list":
        return `[${e.value.map((r) => this._compileNode(r)).join(", ")}]`;
      case "unary-expression":
        return Fe("ternaryNot", this._compileNode(e.expr));
      case "binary-expression":
        switch (e.operator) {
          case "AND":
            return Fe("ternaryAnd", this._compileNode(e.left), this._compileNode(e.right));
          case "OR":
            return Fe("ternaryOr", this._compileNode(e.left), this._compileNode(e.right));
          case "IS":
            if (e.right.type !== "null") throw new R("UnsupportedIsRhs");
            return Fe("equalsNull", this._compileNode(e.left));
          case "ISNOT":
            if (e.right.type !== "null") throw new R("UnsupportedIsRhs");
            return `!${Fe("equalsNull", this._compileNode(e.left))}`;
          case "IN":
            return this._compileInExpr(e.left, e.right);
          case "NOT IN":
            return Fe("ternaryNot", this._compileInExpr(e.left, e.right));
          case "BETWEEN":
            return Fe("between", this._compileNode(e.left), this._compileNode(e.right));
          case "NOTBETWEEN":
            return Fe("notbetween", this._compileNode(e.left), this._compileNode(e.right));
          case "LIKE":
            return Fe("applyLike", this._compileNode(e.left), this._compileNode(e.right), vt(e.escape));
          case "NOT LIKE":
            return Fe("ternaryNot", Fe("applyLike", this._compileNode(e.left), this._compileNode(e.right), vt(e.escape)));
          case "<>":
          case "<":
          case ">":
          case ">=":
          case "<=":
          case "=":
            return Fe("compare", vt(e.operator), this._compileNode(e.left), this._compileNode(e.right));
          case "*":
          case "-":
          case "+":
          case "/":
          case "||":
            return Fe("calculate", vt(e.operator), this._compileNode(e.left), this._compileNode(e.right), vs);
          default:
            throw new R("UnsupportedOperator", { operator: e.operator });
        }
      case "null":
      case "boolean":
      case "string":
      case "number":
        return vt(e.value);
      case "time":
        try {
          return this._compileRefStaticData(this._storeStaticData(fu(e.value)));
        } catch {
          return Fe("evaluateTime", vt(e.value));
        }
      case "date":
        try {
          return this._compileRefStaticData(this._storeStaticData(Nh(e.value, "unknown")));
        } catch {
          return Fe("evaluateDate", vt(e.value), vt("unknown"));
        }
      case "timestamp":
        try {
          return this._compileRefStaticData(this._storeStaticData(Gi(e.value, "unknown")));
        } catch {
          return Fe("evaluateTimestamp", vt(e.value), vt("unknown"));
        }
      case "current-time":
        return e.mode === "date" ? Fe("currentDate", vs) : e.mode === "time" ? Fe("currentTime", vs) : Fe("currentTimestamp", vs);
      case "current-user":
        return F2;
      case "column-reference":
        return Fe("featureValue", I2, vt(e.column), $2, D2);
      case "data-type":
        return Jx(e.value);
      case "function":
        return Fe("evaluateFunction", vt(e.name), this._compileNode(e.args), vs);
    }
    throw new R("UnsupportedSyntax", { node: e.type });
  }
}
class Ph {
  static create(e, r = {}) {
    return new Ph(e, r.fieldsIndex, r.timeZone ?? void 0, r.currentUser);
  }
  constructor(e, r, n = "UTC", s = null) {
    this.fieldsIndex = r, this.timeZone = n, this.currentUser = s, this.parameters = {}, this._compiledExecutor = null, this._hasDateFunctions = void 0, this.parseTree = Hx.parse(e);
    const { isStandardized: i, isAggregate: u, currentUserRequired: l, referencedFieldNames: c } = this._extractExpressionInfo(r);
    this._referencedFieldNames = c, this.isStandardized = i, this.isAggregate = u, this.currentUserRequired = l;
  }
  static convertValueToStorageFormat(e, r = null) {
    if (r === null) return Er(e) ? e.getTime() : He(e) ? e.toMillis() : Ze(e) ? e.toStorageFormat() : Qe(e) ? e.toStorageString() : Ye(e) ? e.toStorageFormat() : e;
    switch (r) {
      case "date":
        return Er(e) ? e.getTime() : He(e) ? e.toMillis() : Ze(e) ? e.toMilliseconds() : Ye(e) ? e.toNumber() : e;
      case "date-only":
        return Er(e) ? Pr.fromDateJS(e).toString() : Ze(e) ? Pr.fromSqlTimeStampOffset(e).toString() : He(e) ? Pr.fromDateTime(e).toString() : e;
      case "time-only":
        return Er(e) ? mr.fromDateJS(e).toStorageString() : He(e) ? mr.fromDateTime(e).toStorageString() : Ze(e) ? mr.fromSqlTimeStampOffset(e).toStorageString() : Qe(e) ? e.toStorageString() : e;
      case "timestamp-offset":
        if (Er(e)) return Br.fromJSDate(e).toStorageFormat();
        if (He(e)) return Br.fromDateTime(e).toStorageFormat();
        if (Ze(e)) return e.toStorageFormat();
    }
    return e;
  }
  get fieldNames() {
    return this._referencedFieldNames;
  }
  testSet(e, r = pi, n = this.currentUser) {
    return !!this._evaluateNode(this.parseTree, null, r, e, n);
  }
  calculateValue(e, r = pi, n = this.currentUser) {
    const s = this._evaluateNode(this.parseTree, e, r, null, n);
    return $t.isInterval(s) ? s.valueInMilliseconds() / 864e5 : s;
  }
  tryGetCompiledExecutor() {
    if (this._compiledExecutor != null) return this._compiledExecutor;
    if (F("esri-csp-restrictions")) return null;
    const e = new Qx(this.parseTree);
    return this._compiledExecutor = e.compile(), this._compiledExecutor;
  }
  calculateValueCompiled(e, r = pi, n = this.currentUser) {
    const s = this.tryGetCompiledExecutor();
    return s == null ? this.calculateValue(e, r) : s(e, this.parameters, r, this.fieldsIndex, this.timeZone, n ?? null);
  }
  testFeature(e, r = pi, n = this.currentUser) {
    return !!this._evaluateNode(this.parseTree, e, r, null, n);
  }
  testFeatureCompiled(e, r = pi, n = this.currentUser) {
    const s = this.tryGetCompiledExecutor();
    return s == null ? this.testFeature(e, r) : !!s(e, this.parameters, r, this.fieldsIndex, this.timeZone, n ?? null);
  }
  get hasDateFunctions() {
    return this._hasDateFunctions != null || (this._hasDateFunctions = !1, St(this.parseTree, (e) => {
      e.type === "current-time" ? this._hasDateFunctions = !0 : e.type === "function" && (this._hasDateFunctions = this._hasDateFunctions || Yx.has(e.name.toLowerCase()));
    })), this._hasDateFunctions;
  }
  getFunctions() {
    const e = /* @__PURE__ */ new Set();
    return St(this.parseTree, (r) => {
      r.type === "function" && e.add(r.name.toLowerCase());
    }), Array.from(e);
  }
  getExpressions() {
    const e = /* @__PURE__ */ new Map();
    return St(this.parseTree, (r) => {
      if (r.type === "function") {
        const n = r.name.toLowerCase(), s = r.args.value[0];
        if (s.type === "column-reference") {
          const i = s.column, u = `${n}-${i}`;
          e.has(u) || e.set(u, { aggregateType: n, field: i });
        }
      }
    }), [...e.values()];
  }
  getVariables() {
    const e = /* @__PURE__ */ new Set();
    return St(this.parseTree, (r) => {
      r.type === "parameter" && e.add(r.value.toLowerCase());
    }), Array.from(e);
  }
  _extractExpressionInfo(e) {
    const r = [], n = /* @__PURE__ */ new Set();
    let s = !0, i = !1, u = !1;
    return St(this.parseTree, (l) => {
      switch (l.type) {
        case "column-reference": {
          const c = e?.get(l.column);
          let m, _;
          c ? m = _ = c.name ?? "" : (_ = l.column, m = _.toLowerCase()), n.has(m) || (n.add(m), r.push(_)), l.column = _;
          break;
        }
        case "current-user":
          u = !0;
          break;
        case "function": {
          const { name: c, args: m } = l, _ = m.value.length;
          s && (s = YN(c, _)), i === !1 && (i = L2(c, _));
          break;
        }
      }
    }), { referencedFieldNames: Array.from(r), isStandardized: s, isAggregate: i, currentUserRequired: u };
  }
  _evaluateNode(e, r, n, s, i) {
    let u;
    switch (e.type) {
      case "interval": {
        const l = this._evaluateNode(e.value, r, n, s, i);
        return $t.createFromValueAndQualifier(l, e.qualifier, e.op);
      }
      case "case-expression":
        if (e.format === "simple") {
          const l = this._evaluateNode(e.operand, r, n, s, i);
          for (let c = 0; c < e.clauses.length; c++) if (fr(l, this._evaluateNode(e.clauses[c].operand, r, n, s, i), "=")) return this._evaluateNode(e.clauses[c].value, r, n, s, i);
          if (e.else !== null) return this._evaluateNode(e.else, r, n, s, i);
        } else {
          for (let l = 0; l < e.clauses.length; l++) if (o9(this._evaluateNode(e.clauses[l].operand, r, n, s, i))) return this._evaluateNode(e.clauses[l].value, r, n, s, i);
          if (e.else !== null) return this._evaluateNode(e.else, r, n, s, i);
        }
        return null;
      case "parameter":
        return u = this.parameters[e.value.toLowerCase()], Er(u) ? H.fromJSDate(u) : u != null && typeof u == "object" && "toDateTime" in u ? u.toDateTime() : u;
      case "expression-list": {
        const l = [];
        for (const c of e.value) l.push(this._evaluateNode(c, r, n, s, i));
        return l;
      }
      case "unary-expression":
        return fa(this._evaluateNode(e.expr, r, n, s, i));
      case "binary-expression":
        switch (e.operator) {
          case "AND":
            return a9(this._evaluateNode(e.left, r, n, s, i), this._evaluateNode(e.right, r, n, s, i));
          case "OR":
            return u9(this._evaluateNode(e.left, r, n, s, i), this._evaluateNode(e.right, r, n, s, i));
          case "IS":
            if (e.right.type !== "null") throw new R("UnsupportedIsRhs");
            return this._evaluateNode(e.left, r, n, s, i) === null;
          case "ISNOT":
            if (e.right.type !== "null") throw new R("UnsupportedIsRhs");
            return this._evaluateNode(e.left, r, n, s, i) !== null;
          case "IN": {
            const l = B0(this._evaluateNode(e.right, r, n, s, i));
            return q0(this._evaluateNode(e.left, r, n, s, i), l);
          }
          case "NOT IN": {
            const l = B0(this._evaluateNode(e.right, r, n, s, i));
            return fa(q0(this._evaluateNode(e.left, r, n, s, i), l));
          }
          case "BETWEEN": {
            const l = this._evaluateNode(e.left, r, n, s, i), c = this._evaluateNode(e.right, r, n, s, i);
            return l == null || c[0] == null || c[1] == null ? null : fr(l, c[0], ">=") && fr(l, c[1], "<=");
          }
          case "NOTBETWEEN": {
            const l = this._evaluateNode(e.left, r, n, s, i), c = this._evaluateNode(e.right, r, n, s, i);
            return l == null || c[0] == null || c[1] == null ? null : fr(l, c[0], "<") || fr(l, c[1], ">");
          }
          case "LIKE":
            return H0(this._evaluateNode(e.left, r, n, s, i), this._evaluateNode(e.right, r, n, s, i), e.escape);
          case "NOT LIKE":
            return fa(H0(this._evaluateNode(e.left, r, n, s, i), this._evaluateNode(e.right, r, n, s, i), e.escape));
          case "<>":
          case "<":
          case ">":
          case ">=":
          case "<=":
          case "=":
            return fr(this._evaluateNode(e.left, r, n, s, i), this._evaluateNode(e.right, r, n, s, i), e.operator);
          case "-":
          case "+":
          case "*":
          case "/":
          case "||":
            return i9(e.operator, this._evaluateNode(e.left, r, n, s, i), this._evaluateNode(e.right, r, n, s, i), this.timeZone);
        }
      case "null":
      case "boolean":
      case "string":
      case "number":
        return e.value;
      case "date":
        return e.parsedValue ??= Nh(e.value, "unknown"), e.parsedValue;
      case "timestamp":
        return e.parsedValue ??= Gi(e.value, "unknown"), e.parsedValue;
      case "time":
        return fu(e.value);
      case "current-time":
        return e.mode === "date" ? c9(this.timeZone) : e.mode === "time" ? f9(this.timeZone) : l9(this.timeZone);
      case "current-user":
        return i ?? null;
      case "column-reference":
        return h9(r, e.column, this.fieldsIndex, n);
      case "data-type":
        return e.value;
      case "function": {
        if (this.isAggregate && L2(e.name, e.args.value.length)) {
          const c = [];
          for (const m of e.args?.value || []) {
            const _ = [];
            for (const y of s || []) _.push(this._evaluateNode(m, y, n, null, i));
            c.push(_);
          }
          return vN(e.name, c);
        }
        const l = this._evaluateNode(e.args, r, n, s, i);
        return xh(e.name, l, this.timeZone);
      }
    }
    throw new R("UnsupportedSyntax", { node: e.type });
  }
}
function o9(t) {
  return t === !0;
}
function B0(t) {
  return Array.isArray(t) ? t : [t];
}
function fa(t) {
  return t !== null ? t !== !0 : null;
}
function a9(t, e) {
  return t != null && e != null ? t === !0 && e === !0 : t !== !1 && e !== !1 && null;
}
function u9(t, e) {
  return t != null && e != null ? t === !0 || e === !0 : t === !0 || e === !0 || null;
}
function q0(t, e) {
  if (t == null) return null;
  let r = !1;
  for (const n of e) if (n == null) r = null;
  else {
    if (t === n) {
      r = !0;
      break;
    }
    if (W0(t) && W0(n) && (r = fr(t, n, "="), r)) break;
  }
  return r;
}
function l9(t) {
  return cu(/* @__PURE__ */ new Date(), t);
}
function c9(t) {
  return Pr.fromNow(t);
}
function f9(t) {
  const e = cu(/* @__PURE__ */ new Date(), t);
  return mr.fromDateTime(e);
}
const U2 = "-[]/{}()*+?.\\^$|";
function Kx(t, e) {
  const r = e;
  let n = "", s = 0;
  for (let i = 0; i < t.length; i++) {
    const u = t.charAt(i);
    switch (s) {
      case 0:
        u === r ? s = 1 : U2.includes(u) ? n += "\\" + u : n += u === "%" ? ".*" : u === "_" ? "." : u;
        break;
      case 1:
        U2.includes(u) ? n += "\\" + u : n += u, s = 0;
    }
  }
  return new RegExp("^" + n + "$", "m");
}
function H0(t, e, r) {
  return t == null ? null : Kx(e, r).test(t);
}
function eT(t) {
  return t && typeof t.attributes == "object";
}
function h9(t, e, r, n) {
  if ("getAttributeSQL" in n) return n.getAttributeSQL(t, e);
  const s = n.getAttribute(t, e);
  if (s == null) return s;
  const i = r?.get(e);
  switch (i?.type) {
    case "esriFieldTypeDate":
    case "date":
      return cu(new Date(s), r?.getLuxonTimeZone(i.name) ?? xt.utcInstance);
    case "esriFieldTypeDateOnly":
    case "date-only":
      return Pr.fromReader(s);
    case "esriFieldTypeTimeOnly":
    case "time-only":
      return mr.fromReader(s);
    case "esriFieldTypeTimestampOffset":
    case "timestamp-offset":
      return new Br(s);
  }
  return s;
}
const pi = { getAttribute: (t, e) => (eT(t) ? t.attributes : t)[e] };
class tT {
  constructor(e, r) {
    this._cache = new og(e), this._invalidCache = new og(r);
  }
  get(e, r) {
    const n = `${r?.uid}:${e}`, s = this._cache.get(n);
    if (s) return s;
    if (this._invalidCache.get(n) != null) return null;
    try {
      const i = Ph.create(e, { fieldsIndex: r });
      return this._cache.put(n, i), i;
    } catch (i) {
      return this._invalidCache.put(n, i), null;
    }
  }
  getError(e, r) {
    const n = `${r?.uid}:${e}`;
    return this._invalidCache.get(n) ?? null;
  }
}
var rT = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  WhereClauseCache: tT
}), nT = async function(t = {}) {
  var e, r, n, s = t, i = new Promise((p, E) => {
    e = p, r = E;
  }), u = "./this.program", l = "", c = "";
  function m(p) {
    return s.locateFile ? s.locateFile(p, c) : c + p;
  }
  try {
    c = new URL(".", l).href;
  } catch {
  }
  n = async (p) => {
    var E = await fetch(p, { credentials: "same-origin" });
    if (E.ok) return E.arrayBuffer();
    throw new Error(E.status + " : " + E.url);
  };
  var _, y, v, S, T, L, D, V, W, j, U = console.log.bind(console), $ = console.error.bind(console), B = !1;
  function Z(p, E) {
    p || re(E);
  }
  function ee() {
    var p = y.buffer;
    v = new Int8Array(p), T = new Int16Array(p), S = new Uint8Array(p), L = new Int32Array(p), D = new Uint32Array(p), V = new Float32Array(p), j = new Float64Array(p), W = new BigInt64Array(p), new BigUint64Array(p);
  }
  function ye() {
    fn(Fu), A.t();
  }
  var Ie, ve = 0, le = null;
  function K(p) {
    ve++;
  }
  function Y(p) {
    if (--ve == 0 && le) {
      var E = le;
      le = null, E();
    }
  }
  function re(p) {
    $(p = "Aborted(" + p + ")"), B = !0, p += ". Build with -sASSERTIONS for more info.";
    var E = new WebAssembly.RuntimeError(p);
    throw r(E), E;
  }
  function te() {
    return s.locateFile ? m("pe-wasm.wasm") : new URL("pe-wasm.wasm", "").href;
  }
  function ae(p) {
    throw "both async and sync fetching of the wasm failed";
  }
  async function ge(p) {
    try {
      var E = await n(p);
      return new Uint8Array(E);
    } catch {
    }
    return ae();
  }
  async function Te(p, E) {
    try {
      var k = await ge(p);
      return await WebAssembly.instantiate(k, E);
    } catch (G) {
      $(`failed to asynchronously prepare wasm: ${G}`), re(G);
    }
  }
  async function et(p, E, k) {
    if (typeof WebAssembly.instantiateStreaming == "function") try {
      var G = fetch(E, { credentials: "same-origin" });
      return await WebAssembly.instantiateStreaming(G, k);
    } catch (X) {
      $(`wasm streaming compile failed: ${X}`), $("falling back to ArrayBuffer instantiation");
    }
    return Te(E, k);
  }
  function lt() {
    return { a: Uu };
  }
  async function qr() {
    function p(G, X) {
      return A = G.exports, y = A.s, ee(), Y(), A;
    }
    function E(G) {
      return p(G.instance);
    }
    K();
    var k = lt();
    Ie ??= te();
    try {
      return E(await et(_, Ie, k));
    } catch (G) {
      return r(G), Promise.reject(G);
    }
  }
  var fn = (p) => {
    for (; p.length > 0; ) p.shift()(s);
  };
  function en(p, E = "i8") {
    switch (E.endsWith("*") && (E = "*"), E) {
      case "i1":
      case "i8":
        return v[p];
      case "i16":
        return T[p >> 1];
      case "i32":
        return L[p >> 2];
      case "i64":
        return W[p >> 3];
      case "float":
        return V[p >> 2];
      case "double":
        return j[p >> 3];
      case "*":
        return D[p >> 2];
      default:
        re(`invalid type for getValue: ${E}`);
    }
  }
  var is = typeof TextDecoder < "u" ? new TextDecoder() : void 0, tn = (p, E = 0, k = NaN) => {
    for (var G = E + k, X = E; p[X] && !(X >= G); ) ++X;
    if (X - E > 16 && p.buffer && is) return is.decode(p.subarray(E, X));
    for (var se = ""; E < X; ) {
      var me = p[E++];
      if (128 & me) {
        var ie = 63 & p[E++];
        if ((224 & me) != 192) {
          var Oe = 63 & p[E++];
          if ((me = (240 & me) == 224 ? (15 & me) << 12 | ie << 6 | Oe : (7 & me) << 18 | ie << 12 | Oe << 6 | 63 & p[E++]) < 65536) se += String.fromCharCode(me);
          else {
            var gr = me - 65536;
            se += String.fromCharCode(55296 | gr >> 10, 56320 | 1023 & gr);
          }
        } else se += String.fromCharCode((31 & me) << 6 | ie);
      } else se += String.fromCharCode(me);
    }
    return se;
  }, Ot = (p, E) => p ? tn(S, p, E) : "";
  function ti(p, E, k) {
    return 0;
  }
  var hu = (p, E, k) => {
  };
  function du(p, E, k) {
    return 0;
  }
  function mu(p, E, k, G) {
  }
  var pu = (p) => {
  }, gu = (p, E) => {
  }, _u = (p, E, k) => {
  }, yu = () => re(""), bu = (p) => p % 4 == 0 && (p % 100 != 0 || p % 400 == 0), wu = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], vu = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], Su = (p) => (bu(p.getFullYear()) ? wu : vu)[p.getMonth()] + p.getDate() - 1, Eu = 9007199254740992, Nu = -9007199254740992, xu = (p) => p < Nu || p > Eu ? NaN : Number(p);
  function Tu(p, E) {
    p = xu(p);
    var k = new Date(1e3 * p);
    L[E >> 2] = k.getSeconds(), L[E + 4 >> 2] = k.getMinutes(), L[E + 8 >> 2] = k.getHours(), L[E + 12 >> 2] = k.getDate(), L[E + 16 >> 2] = k.getMonth(), L[E + 20 >> 2] = k.getFullYear() - 1900, L[E + 24 >> 2] = k.getDay();
    var G = 0 | Su(k);
    L[E + 28 >> 2] = G, L[E + 36 >> 2] = -60 * k.getTimezoneOffset();
    var X = new Date(k.getFullYear(), 0, 1), se = new Date(k.getFullYear(), 6, 1).getTimezoneOffset(), me = X.getTimezoneOffset(), ie = 0 | (se != me && k.getTimezoneOffset() == Math.min(me, se));
    L[E + 32 >> 2] = ie;
  }
  var Bi = (p, E, k, G) => {
    if (!(G > 0)) return 0;
    for (var X = k, se = k + G - 1, me = 0; me < p.length; ++me) {
      var ie = p.charCodeAt(me);
      if (ie >= 55296 && ie <= 57343 && (ie = 65536 + ((1023 & ie) << 10) | 1023 & p.charCodeAt(++me)), ie <= 127) {
        if (k >= se) break;
        E[k++] = ie;
      } else if (ie <= 2047) {
        if (k + 1 >= se) break;
        E[k++] = 192 | ie >> 6, E[k++] = 128 | 63 & ie;
      } else if (ie <= 65535) {
        if (k + 2 >= se) break;
        E[k++] = 224 | ie >> 12, E[k++] = 128 | ie >> 6 & 63, E[k++] = 128 | 63 & ie;
      } else {
        if (k + 3 >= se) break;
        E[k++] = 240 | ie >> 18, E[k++] = 128 | ie >> 12 & 63, E[k++] = 128 | ie >> 6 & 63, E[k++] = 128 | 63 & ie;
      }
    }
    return E[k] = 0, k - X;
  }, Un = (p, E, k) => Bi(p, S, E, k), Pu = (p, E, k, G) => {
    var X = (/* @__PURE__ */ new Date()).getFullYear(), se = new Date(X, 0, 1), me = new Date(X, 6, 1), ie = se.getTimezoneOffset(), Oe = me.getTimezoneOffset(), gr = Math.max(ie, Oe);
    D[p >> 2] = 60 * gr, L[E >> 2] = +(ie != Oe);
    var co = (mo) => {
      var Cf = mo >= 0 ? "-" : "+", po = Math.abs(mo);
      return `UTC${Cf}${String(Math.floor(po / 60)).padStart(2, "0")}${String(po % 60).padStart(2, "0")}`;
    }, fo = co(ie), ho = co(Oe);
    Oe < ie ? (Un(fo, k, 17), Un(ho, G, 17)) : (Un(fo, G, 17), Un(ho, k, 17));
  }, Au = () => Date.now(), Lu = () => 2147483648, qi = (p, E) => Math.ceil(p / E) * E, Mu = (p) => {
    var E = (p - y.buffer.byteLength + 65535) / 65536 | 0;
    try {
      return y.grow(E), ee(), 1;
    } catch {
    }
  }, Ou = (p) => {
    var E = S.length;
    p >>>= 0;
    var k = Lu();
    if (p > k) return !1;
    for (var G = 1; G <= 4; G *= 2) {
      var X = E * (1 + 0.2 / G);
      X = Math.min(X, p + 100663296);
      var se = Math.min(k, qi(Math.max(p, X), 65536));
      if (Mu(se)) return !0;
    }
    return !1;
  }, ri = {}, Cu = () => u, Vn = () => {
    if (!Vn.strings) {
      var p = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: Cu() };
      for (var E in ri) ri[E] === void 0 ? delete p[E] : p[E] = ri[E];
      var k = [];
      for (var E in p) k.push(`${E}=${p[E]}`);
      Vn.strings = k;
    }
    return Vn.strings;
  }, Hi = (p, E) => {
    var k = 0, G = 0;
    for (var X of Vn()) {
      var se = E + k;
      D[p + G >> 2] = se, k += Un(X, se, 1 / 0) + 1, G += 4;
    }
    return 0;
  }, Yi = (p) => {
    for (var E = 0, k = 0; k < p.length; ++k) {
      var G = p.charCodeAt(k);
      G <= 127 ? E++ : G <= 2047 ? E += 2 : G >= 55296 && G <= 57343 ? (E += 4, ++k) : E += 3;
    }
    return E;
  }, os = (p, E) => {
    var k = Vn();
    D[p >> 2] = k.length;
    var G = 0;
    for (var X of k) G += Yi(X) + 1;
    return D[E >> 2] = G, 0;
  }, Ru = (p) => 52, Iu = (p, E, k, G) => 52;
  function ku(p, E, k, G) {
    return 70;
  }
  var Zi = [null, [], []], Du = (p, E) => {
    var k = Zi[p];
    E === 0 || E === 10 ? ((p === 1 ? U : $)(tn(k)), k.length = 0) : k.push(E);
  }, Xi = (p, E, k, G) => {
    for (var X = 0, se = 0; se < k; se++) {
      var me = D[E >> 2], ie = D[E + 4 >> 2];
      E += 8;
      for (var Oe = 0; Oe < ie; Oe++) Du(p, S[me + Oe]);
      X += ie;
    }
    return D[G >> 2] = X, 0;
  }, $u = (p, E, k) => {
    var G = Yi(p) + 1, X = new Array(G);
    return Bi(p, X, 0, X.length), X;
  }, Fu = [];
  s.getValue = en, s.UTF8ToString = Ot;
  var Uu = { c: ti, o: hu, i: du, d: mu, m: pu, l: gu, n: _u, j: yu, p: Tu, q: Pu, r: Au, k: Ou, f: Hi, g: os, a: Ru, h: Iu, e: ku, b: Xi }, A = await qr();
  A.t, s._webidl_free = A.u, s._webidl_malloc = A.v;
  var Vu = s._emscripten_bind_PeObject_getCode_0 = A.w, zu = s._emscripten_bind_PeObject_getName_1 = A.x, ju = s._emscripten_bind_PeObject_getType_0 = A.y, Wu = s._emscripten_bind_PeCoordsys_isEqual_1 = A.z, Gu = s._emscripten_bind_PeCoordsys_getCode_0 = A.A, Bu = s._emscripten_bind_PeCoordsys_getName_1 = A.B, qu = s._emscripten_bind_PeCoordsys_getType_0 = A.C, Hu = s._emscripten_bind_PeUnit_getUnitFactor_0 = A.D, as = s._emscripten_bind_PeUnit_getCode_0 = A.E, Yu = s._emscripten_bind_PeUnit_getName_1 = A.F, Zu = s._emscripten_bind_PeUnit_getType_0 = A.G, Xu = s._emscripten_bind_VoidPtr___destroy___0 = A.H, Ju = s._emscripten_bind_PeAngunit_getCode_0 = A.I, Ji = s._emscripten_bind_PeAngunit_getName_1 = A.J, Qu = s._emscripten_bind_PeAngunit_getType_0 = A.K, Ku = s._emscripten_bind_PeAngunit_getUnitFactor_0 = A.L, Qi = s._emscripten_bind_PeDatum_getSpheroid_0 = A.M, el = s._emscripten_bind_PeDatum_getCode_0 = A.N, Ki = s._emscripten_bind_PeDatum_getName_1 = A.O, eo = s._emscripten_bind_PeDatum_getType_0 = A.P, tl = s._emscripten_bind_PeDefs_get_PE_BUFFER_MAX_0 = A.Q, rl = s._emscripten_bind_PeDefs_get_PE_NAME_MAX_0 = A.R, nl = s._emscripten_bind_PeDefs_get_PE_MGRS_MAX_0 = A.S, sl = s._emscripten_bind_PeDefs_get_PE_USNG_MAX_0 = A.T, il = s._emscripten_bind_PeDefs_get_PE_DD_MAX_0 = A.U, ol = s._emscripten_bind_PeDefs_get_PE_DMS_MAX_0 = A.V, al = s._emscripten_bind_PeDefs_get_PE_DDM_MAX_0 = A.W, ul = s._emscripten_bind_PeDefs_get_PE_UTM_MAX_0 = A.X, ll = s._emscripten_bind_PeDefs_get_PE_PARM_MAX_0 = A.Y, cl = s._emscripten_bind_PeDefs_get_PE_TYPE_NONE_0 = A.Z, fl = s._emscripten_bind_PeDefs_get_PE_TYPE_GEOGCS_0 = A._, hl = s._emscripten_bind_PeDefs_get_PE_TYPE_PROJCS_0 = A.$, dl = s._emscripten_bind_PeDefs_get_PE_TYPE_GEOGTRAN_0 = A.aa, ml = s._emscripten_bind_PeDefs_get_PE_TYPE_COORDSYS_0 = A.ba, pl = s._emscripten_bind_PeDefs_get_PE_TYPE_UNIT_0 = A.ca, gl = s._emscripten_bind_PeDefs_get_PE_TYPE_LINUNIT_0 = A.da, _l = s._emscripten_bind_PeDefs_get_PE_STR_OPTS_NONE_0 = A.ea, yl = s._emscripten_bind_PeDefs_get_PE_STR_AUTH_NONE_0 = A.fa, bl = s._emscripten_bind_PeDefs_get_PE_STR_AUTH_TOP_0 = A.ga, wl = s._emscripten_bind_PeDefs_get_PE_STR_NAME_CANON_0 = A.ha, vl = s._emscripten_bind_PeDefs_get_PE_STR_FMT_WKT_0 = A.ia, Sl = s._emscripten_bind_PeDefs_get_PE_STR_FMT_WKT2_0 = A.ja, El = s._emscripten_bind_PeDefs_get_PE_PARM_X0_0 = A.ka, Nl = s._emscripten_bind_PeDefs_get_PE_PARM_ND_0 = A.la, xl = s._emscripten_bind_PeDefs_get_PE_TRANSFORM_1_TO_2_0 = A.ma, Tl = s._emscripten_bind_PeDefs_get_PE_TRANSFORM_2_TO_1_0 = A.na, Pl = s._emscripten_bind_PeDefs_get_PE_TRANSFORM_P_TO_G_0 = A.oa, Al = s._emscripten_bind_PeDefs_get_PE_TRANSFORM_G_TO_P_0 = A.pa, Ll = s._emscripten_bind_PeDefs_get_PE_HORIZON_RECT_0 = A.qa, Ml = s._emscripten_bind_PeDefs_get_PE_HORIZON_POLY_0 = A.ra, Ol = s._emscripten_bind_PeDefs_get_PE_HORIZON_LINE_0 = A.sa, Cl = s._emscripten_bind_PeDefs_get_PE_HORIZON_DELTA_0 = A.ta, Rl = s._emscripten_bind_PeDouble_PeDouble_1 = A.ua, Il = s._emscripten_bind_PeDouble_get_val_0 = A.va, kl = s._emscripten_bind_PeDouble_set_val_1 = A.wa, Dl = s._emscripten_bind_PeDouble___destroy___0 = A.xa, $l = s._emscripten_bind_PeFactory_initialize_1 = A.ya, Fl = s._emscripten_bind_PeFactory_factoryByType_2 = A.za, Ul = s._emscripten_bind_PeFactory_fromString_2 = A.Aa, Vl = s._emscripten_bind_PeFactory_getCode_1 = A.Ba, zl = s._emscripten_bind_PeGCSExtent_PeGCSExtent_6 = A.Ca, jl = s._emscripten_bind_PeGCSExtent_getLLon_0 = A.Da, Wl = s._emscripten_bind_PeGCSExtent_getSLat_0 = A.Ea, Gl = s._emscripten_bind_PeGCSExtent_getRLon_0 = A.Fa, Bl = s._emscripten_bind_PeGCSExtent_getNLat_0 = A.Ga, ql = s._emscripten_bind_PeGCSExtent___destroy___0 = A.Ha, Hl = s._emscripten_bind_PeGeogcs_Delete_0 = A.Ia, Yl = s._emscripten_bind_PeGeogcs_cloneAlterUnits_1 = A.Ja, Zl = s._emscripten_bind_PeGeogcs_getDatum_0 = A.Ka, Xl = s._emscripten_bind_PeGeogcs_getPrimem_0 = A.La, Jl = s._emscripten_bind_PeGeogcs_getUnit_0 = A.Ma, Ql = s._emscripten_bind_PeGeogcs_isEqual_1 = A.Na, Kl = s._emscripten_bind_PeGeogcs_getCode_0 = A.Oa, ec = s._emscripten_bind_PeGeogcs_getName_1 = A.Pa, tc = s._emscripten_bind_PeGeogcs_getType_0 = A.Qa, rc = s._emscripten_bind_PeGeogtran_isEqual_1 = A.Ra, to = s._emscripten_bind_PeGeogtran_getGeogcs1_0 = A.Sa, ro = s._emscripten_bind_PeGeogtran_getGeogcs2_0 = A.Ta, Ah = s._emscripten_bind_PeGeogtran_getParameters_0 = A.Ua, nc = s._emscripten_bind_PeGeogtran_loadConstants_0 = A.Va, no = s._emscripten_bind_PeGeogtran_getCode_0 = A.Wa, sc = s._emscripten_bind_PeGeogtran_getName_1 = A.Xa, so = s._emscripten_bind_PeGeogtran_getType_0 = A.Ya, ic = s._emscripten_bind_PeGTlistExtended_getGTlist_6 = A.Za, oc = s._emscripten_bind_PeGTlistExtended_get_PE_GTLIST_OPTS_COMMON_0 = A._a, ac = s._emscripten_bind_PeGTlistExtendedEntry_getEntries_0 = A.$a, io = s._emscripten_bind_PeGTlistExtendedEntry_getSteps_0 = A.ab, uc = s._emscripten_bind_PeGTlistExtendedEntry_Delete_1 = A.bb, lc = s._emscripten_bind_PeGTlistExtendedGTs_getDirection_0 = A.cb, cc = s._emscripten_bind_PeGTlistExtendedGTs_getGeogtran_0 = A.db, fc = s._emscripten_bind_PeHorizon_getNump_0 = A.eb, hc = s._emscripten_bind_PeHorizon_getKind_0 = A.fb, dc = s._emscripten_bind_PeHorizon_getInclusive_0 = A.gb, mc = s._emscripten_bind_PeHorizon_getSize_0 = A.hb, pc = s._emscripten_bind_PeHorizon_getCoord_0 = A.ib, gc = s._emscripten_bind_PeInteger_PeInteger_1 = A.jb, _c = s._emscripten_bind_PeInteger_get_val_0 = A.kb, yc = s._emscripten_bind_PeInteger_set_val_1 = A.lb, bc = s._emscripten_bind_PeInteger___destroy___0 = A.mb, wc = s._emscripten_bind_PeLineType_geodetic_distance_10 = A.nb, oo = s._emscripten_bind_PeLineType_geodetic_coordinate_9 = A.ob, vc = s._emscripten_bind_PeLineType_geodesic_coordinate_8 = A.pb, ao = s._emscripten_bind_PeLineType_great_elliptic_distance_9 = A.qb, Sc = s._emscripten_bind_PeMath_phi_to_eta_2 = A.rb, Ec = s._emscripten_bind_PeMath_eta_to_phi_2 = A.sb, Nc = s._emscripten_bind_PeMath_phi_to_phig_2 = A.tb, xc = s._emscripten_bind_PeMath_q_3 = A.ub, Lh = s._emscripten_bind_PeMath_q90_2 = A.vb, Tc = s._emscripten_bind_PeNotationMgrs_get_PE_MGRS_STYLE_NEW_0 = A.wb, Pc = s._emscripten_bind_PeNotationMgrs_get_PE_MGRS_STYLE_OLD_0 = A.xb, Mh = s._emscripten_bind_PeNotationMgrs_get_PE_MGRS_STYLE_AUTO_0 = A.yb, Ac = s._emscripten_bind_PeNotationMgrs_get_PE_MGRS_180_ZONE_1_PLUS_0 = A.zb, Lc = s._emscripten_bind_PeNotationMgrs_get_PE_MGRS_ADD_SPACES_0 = A.Ab, Mc = s._emscripten_bind_PeNotationUtm_get_PE_UTM_OPTS_NONE_0 = A.Bb, Oc = s._emscripten_bind_PeNotationUtm_get_PE_UTM_OPTS_NS_0 = A.Cb, Cc = s._emscripten_bind_PeNotationUtm_get_PE_UTM_OPTS_NS_STRICT_0 = A.Db, Rc = s._emscripten_bind_PeNotationUtm_get_PE_UTM_OPTS_ADD_SPACES_0 = A.Eb, Ic = s._emscripten_bind_PeParameter_getValue_0 = A.Fb, kc = s._emscripten_bind_PeParameter_getCode_0 = A.Gb, Dc = s._emscripten_bind_PeParameter_getName_1 = A.Hb, $c = s._emscripten_bind_PeParameter_getType_0 = A.Ib, Fc = s._emscripten_bind_PePCSInfo_getCentralMeridian_0 = A.Jb, Uc = s._emscripten_bind_PePCSInfo_getDomainMinx_0 = A.Kb, Vc = s._emscripten_bind_PePCSInfo_getDomainMiny_0 = A.Lb, zc = s._emscripten_bind_PePCSInfo_getDomainMaxx_0 = A.Mb, jc = s._emscripten_bind_PePCSInfo_getDomainMaxy_0 = A.Nb, Wc = s._emscripten_bind_PePCSInfo_getNorthPoleLocation_0 = A.Ob, Gc = s._emscripten_bind_PePCSInfo_getNorthPoleGeometry_0 = A.Pb, Bc = s._emscripten_bind_PePCSInfo_getSouthPoleLocation_0 = A.Qb, qc = s._emscripten_bind_PePCSInfo_getSouthPoleGeometry_0 = A.Rb, Hc = s._emscripten_bind_PePCSInfo_isDensificationNeeded_0 = A.Sb, Yc = s._emscripten_bind_PePCSInfo_isGcsHorizonMultiOverlap_0 = A.Tb, Zc = s._emscripten_bind_PePCSInfo_isPannableRectangle_0 = A.Ub, Xc = s._emscripten_bind_PePCSInfo_generate_2 = A.Vb, Jc = s._emscripten_bind_PePCSInfo_get_PE_PCSINFO_OPTION_NONE_0 = A.Wb, Qc = s._emscripten_bind_PePCSInfo_get_PE_PCSINFO_OPTION_DOMAIN_0 = A.Xb, Kc = s._emscripten_bind_PePCSInfo_get_PE_POLE_OUTSIDE_BOUNDARY_0 = A.Yb, ef = s._emscripten_bind_PePCSInfo_get_PE_POLE_POINT_0 = A.Zb, tf = s._emscripten_bind_PePrimem_getLongitude_0 = A._b, rf = s._emscripten_bind_PePrimem_getCode_0 = A.$b, nf = s._emscripten_bind_PePrimem_getName_1 = A.ac, sf = s._emscripten_bind_PePrimem_getType_0 = A.bc, of = s._emscripten_bind_PeProjcs_Delete_0 = A.cc, af = s._emscripten_bind_PeProjcs_getGeogcs_0 = A.dc, uf = s._emscripten_bind_PeProjcs_getProjection_0 = A.ec, lf = s._emscripten_bind_PeProjcs_getParameters_0 = A.fc, cf = s._emscripten_bind_PeProjcs_getUnit_0 = A.gc, ff = s._emscripten_bind_PeProjcs_loadConstants_0 = A.hc, hf = s._emscripten_bind_PeProjcs_horizonGcsGenerate_0 = A.ic, df = s._emscripten_bind_PeProjcs_horizonPcsGenerate_0 = A.jc, mf = s._emscripten_bind_PeProjcs_isEqual_1 = A.kc, pf = s._emscripten_bind_PeProjcs_getCode_0 = A.lc, gf = s._emscripten_bind_PeProjcs_getName_1 = A.mc, _f = s._emscripten_bind_PeProjcs_getType_0 = A.nc, yf = s._emscripten_bind_PeSpheroid_getAxis_0 = A.oc, bf = s._emscripten_bind_PeSpheroid_getFlattening_0 = A.pc, wf = s._emscripten_bind_PeSpheroid_getCode_0 = A.qc, vf = s._emscripten_bind_PeSpheroid_getName_1 = A.rc, Sf = s._emscripten_bind_PeSpheroid_getType_0 = A.sc, Ef = s._emscripten_bind_PeVersion_version_string_0 = A.tc;
  function uo() {
    function p() {
      s.calledRun = !0, B || (ye(), e(s));
    }
    ve > 0 || ve > 0 ? le = uo : p();
  }
  function ke() {
  }
  function hn(p) {
    return (p || ke).__cache__;
  }
  function Xe(p, E) {
    var k = hn(E), G = k[p];
    return G || ((G = Object.create((E || ke).prototype)).ptr = p, k[p] = G);
  }
  function Nf(p, E) {
    return Xe(p.ptr, E);
  }
  function xf(p) {
    if (!p.__destroy__) throw "Error: Cannot destroy object. (Did you create it yourself?)";
    p.__destroy__(), delete hn(p.__class__)[p.ptr];
  }
  function Tf(p, E) {
    return p.ptr === E.ptr;
  }
  function lo(p) {
    return p.ptr;
  }
  function Pf(p) {
    return p.__class__;
  }
  s._pe_getPeGTlistExtendedEntrySize = A.uc, s._pe_getPeGTlistExtendedGTsSize = A.vc, s._pe_getPeHorizonSize = A.wc, s._pe_geog_to_geog = A.xc, s._pe_geog_to_proj = A.yc, s._pe_geog_to_dd = A.zc, s._pe_dd_to_geog = A.Ac, s._pe_geog_to_ddm = A.Bc, s._pe_ddm_to_geog = A.Cc, s._pe_geog_to_dms = A.Dc, s._pe_dms_to_geog = A.Ec, s._pe_geog_to_mgrs_extended = A.Fc, s._pe_mgrs_to_geog_extended = A.Gc, s._pe_geog_to_usng = A.Hc, s._pe_usng_to_geog = A.Ic, s._pe_geog_to_utm = A.Jc, s._pe_utm_to_geog = A.Kc, s._pe_object_to_string_ext = A.Lc, s._pe_proj_to_geog_center = A.Mc, uo(), ke.prototype = Object.create(ke.prototype), ke.prototype.constructor = ke, ke.prototype.__class__ = ke, ke.__cache__ = {}, s.WrapperObject = ke, s.getCache = hn, s.wrapPointer = Xe, s.castObject = Nf, s.NULL = Xe(0), s.destroy = xf, s.compare = Tf, s.getPointer = lo, s.getClass = Pf;
  var he = { buffer: 0, size: 0, pos: 0, temps: [], needed: 0, prepare() {
    if (he.needed) {
      for (var p = 0; p < he.temps.length; p++) s._webidl_free(he.temps[p]);
      he.temps.length = 0, s._webidl_free(he.buffer), he.buffer = 0, he.size += he.needed, he.needed = 0;
    }
    he.buffer || (he.size += 128, he.buffer = s._webidl_malloc(he.size), Z(he.buffer)), he.pos = 0;
  }, alloc(p, E) {
    Z(he.buffer);
    var k, G = E.BYTES_PER_ELEMENT, X = p.length * G;
    return X = qi(X, 8), he.pos + X >= he.size ? (Z(X > 0), he.needed += X, k = s._webidl_malloc(X), he.temps.push(k)) : (k = he.buffer + he.pos, he.pos += X), k;
  }, copy(p, E, k) {
    k /= E.BYTES_PER_ELEMENT;
    for (var G = 0; G < p.length; G++) E[k + G] = p[G];
  } };
  function ni(p) {
    if (typeof p == "string") {
      var E = $u(p), k = he.alloc(E, v);
      return he.copy(E, v, k), k;
    }
    return p;
  }
  function Jt(p) {
    if (typeof p == "object") {
      var E = he.alloc(p, v);
      return he.copy(p, v, E), E;
    }
    return p;
  }
  function Af(p) {
    if (typeof p == "object") {
      var E = he.alloc(p, T);
      return he.copy(p, T, E), E;
    }
    return p;
  }
  function Lf(p) {
    if (typeof p == "object") {
      var E = he.alloc(p, L);
      return he.copy(p, L, E), E;
    }
    return p;
  }
  function Mf(p) {
    if (typeof p == "object") {
      var E = he.alloc(p, V);
      return he.copy(p, V, E), E;
    }
    return p;
  }
  function Of(p) {
    if (typeof p == "object") {
      var E = he.alloc(p, j);
      return he.copy(p, j, E), E;
    }
    return p;
  }
  function Ge() {
    throw "cannot construct a PeObject, no constructor in IDL";
  }
  function mt() {
    throw "cannot construct a PeCoordsys, no constructor in IDL";
  }
  function pt() {
    throw "cannot construct a PeUnit, no constructor in IDL";
  }
  function Ar() {
    throw "cannot construct a VoidPtr, no constructor in IDL";
  }
  function Tt() {
    throw "cannot construct a PeAngunit, no constructor in IDL";
  }
  function Pt() {
    throw "cannot construct a PeDatum, no constructor in IDL";
  }
  function I() {
    throw "cannot construct a PeDefs, no constructor in IDL";
  }
  function gt(p) {
    p && typeof p == "object" && (p = p.ptr), this.ptr = Rl(p), hn(gt)[this.ptr] = this;
  }
  function Ct() {
    throw "cannot construct a PeFactory, no constructor in IDL";
  }
  function ct(p, E, k, G, X, se) {
    p && typeof p == "object" && (p = p.ptr), E && typeof E == "object" && (E = E.ptr), k && typeof k == "object" && (k = k.ptr), G && typeof G == "object" && (G = G.ptr), X && typeof X == "object" && (X = X.ptr), se && typeof se == "object" && (se = se.ptr), this.ptr = zl(p, E, k, G, X, se), hn(ct)[this.ptr] = this;
  }
  function Me() {
    throw "cannot construct a PeGeogcs, no constructor in IDL";
  }
  function ze() {
    throw "cannot construct a PeGeogtran, no constructor in IDL";
  }
  function qt() {
    throw "cannot construct a PeGTlistExtended, no constructor in IDL";
  }
  function Ft() {
    throw "cannot construct a PeGTlistExtendedEntry, no constructor in IDL";
  }
  function Qt() {
    throw "cannot construct a PeGTlistExtendedGTs, no constructor in IDL";
  }
  function it() {
    throw "cannot construct a PeHorizon, no constructor in IDL";
  }
  function _t(p) {
    p && typeof p == "object" && (p = p.ptr), this.ptr = gc(p), hn(_t)[this.ptr] = this;
  }
  function Rt() {
    throw "cannot construct a PeLineType, no constructor in IDL";
  }
  function yt() {
    throw "cannot construct a PeMath, no constructor in IDL";
  }
  function De() {
    throw "cannot construct a PeNotationMgrs, no constructor in IDL";
  }
  function Be() {
    throw "cannot construct a PeNotationUtm, no constructor in IDL";
  }
  function It() {
    throw "cannot construct a PeParameter, no constructor in IDL";
  }
  function ce() {
    throw "cannot construct a PePCSInfo, no constructor in IDL";
  }
  function At() {
    throw "cannot construct a PePrimem, no constructor in IDL";
  }
  function Pe() {
    throw "cannot construct a PeProjcs, no constructor in IDL";
  }
  function ft() {
    throw "cannot construct a PeSpheroid, no constructor in IDL";
  }
  function Lr() {
    throw "cannot construct a PeVersion, no constructor in IDL";
  }
  return Ge.prototype = Object.create(ke.prototype), Ge.prototype.constructor = Ge, Ge.prototype.__class__ = Ge, Ge.__cache__ = {}, s.PeObject = Ge, Ge.prototype.getCode = Ge.prototype.getCode = function() {
    var p = this.ptr;
    return Vu(p);
  }, Ge.prototype.getName = Ge.prototype.getName = function(p) {
    var E = this.ptr;
    return he.prepare(), typeof p == "object" && (p = Jt(p)), Ot(zu(E, p));
  }, Ge.prototype.getType = Ge.prototype.getType = function() {
    var p = this.ptr;
    return ju(p);
  }, mt.prototype = Object.create(Ge.prototype), mt.prototype.constructor = mt, mt.prototype.__class__ = mt, mt.__cache__ = {}, s.PeCoordsys = mt, mt.prototype.isEqual = mt.prototype.isEqual = function(p) {
    var E = this.ptr;
    return p && typeof p == "object" && (p = p.ptr), !!Wu(E, p);
  }, mt.prototype.getCode = mt.prototype.getCode = function() {
    var p = this.ptr;
    return Gu(p);
  }, mt.prototype.getName = mt.prototype.getName = function(p) {
    var E = this.ptr;
    return he.prepare(), typeof p == "object" && (p = Jt(p)), Ot(Bu(E, p));
  }, mt.prototype.getType = mt.prototype.getType = function() {
    var p = this.ptr;
    return qu(p);
  }, pt.prototype = Object.create(Ge.prototype), pt.prototype.constructor = pt, pt.prototype.__class__ = pt, pt.__cache__ = {}, s.PeUnit = pt, pt.prototype.getUnitFactor = pt.prototype.getUnitFactor = function() {
    var p = this.ptr;
    return Hu(p);
  }, pt.prototype.getCode = pt.prototype.getCode = function() {
    var p = this.ptr;
    return as(p);
  }, pt.prototype.getName = pt.prototype.getName = function(p) {
    var E = this.ptr;
    return he.prepare(), typeof p == "object" && (p = Jt(p)), Ot(Yu(E, p));
  }, pt.prototype.getType = pt.prototype.getType = function() {
    var p = this.ptr;
    return Zu(p);
  }, Ar.prototype = Object.create(ke.prototype), Ar.prototype.constructor = Ar, Ar.prototype.__class__ = Ar, Ar.__cache__ = {}, s.VoidPtr = Ar, Ar.prototype.__destroy__ = Ar.prototype.__destroy__ = function() {
    var p = this.ptr;
    Xu(p);
  }, Tt.prototype = Object.create(pt.prototype), Tt.prototype.constructor = Tt, Tt.prototype.__class__ = Tt, Tt.__cache__ = {}, s.PeAngunit = Tt, Tt.prototype.getCode = Tt.prototype.getCode = function() {
    var p = this.ptr;
    return Ju(p);
  }, Tt.prototype.getName = Tt.prototype.getName = function(p) {
    var E = this.ptr;
    return he.prepare(), typeof p == "object" && (p = Jt(p)), Ot(Ji(E, p));
  }, Tt.prototype.getType = Tt.prototype.getType = function() {
    var p = this.ptr;
    return Qu(p);
  }, Tt.prototype.getUnitFactor = Tt.prototype.getUnitFactor = function() {
    var p = this.ptr;
    return Ku(p);
  }, Pt.prototype = Object.create(Ge.prototype), Pt.prototype.constructor = Pt, Pt.prototype.__class__ = Pt, Pt.__cache__ = {}, s.PeDatum = Pt, Pt.prototype.getSpheroid = Pt.prototype.getSpheroid = function() {
    var p = this.ptr;
    return Xe(Qi(p), ft);
  }, Pt.prototype.getCode = Pt.prototype.getCode = function() {
    var p = this.ptr;
    return el(p);
  }, Pt.prototype.getName = Pt.prototype.getName = function(p) {
    var E = this.ptr;
    return he.prepare(), typeof p == "object" && (p = Jt(p)), Ot(Ki(E, p));
  }, Pt.prototype.getType = Pt.prototype.getType = function() {
    var p = this.ptr;
    return eo(p);
  }, I.prototype = Object.create(ke.prototype), I.prototype.constructor = I, I.prototype.__class__ = I, I.__cache__ = {}, s.PeDefs = I, I.prototype.get_PE_BUFFER_MAX = I.prototype.get_PE_BUFFER_MAX = function() {
    var p = this.ptr;
    return tl(p);
  }, Object.defineProperty(I.prototype, "PE_BUFFER_MAX", { get: I.prototype.get_PE_BUFFER_MAX }), I.prototype.get_PE_NAME_MAX = I.prototype.get_PE_NAME_MAX = function() {
    var p = this.ptr;
    return rl(p);
  }, Object.defineProperty(I.prototype, "PE_NAME_MAX", { get: I.prototype.get_PE_NAME_MAX }), I.prototype.get_PE_MGRS_MAX = I.prototype.get_PE_MGRS_MAX = function() {
    var p = this.ptr;
    return nl(p);
  }, Object.defineProperty(I.prototype, "PE_MGRS_MAX", { get: I.prototype.get_PE_MGRS_MAX }), I.prototype.get_PE_USNG_MAX = I.prototype.get_PE_USNG_MAX = function() {
    var p = this.ptr;
    return sl(p);
  }, Object.defineProperty(I.prototype, "PE_USNG_MAX", { get: I.prototype.get_PE_USNG_MAX }), I.prototype.get_PE_DD_MAX = I.prototype.get_PE_DD_MAX = function() {
    var p = this.ptr;
    return il(p);
  }, Object.defineProperty(I.prototype, "PE_DD_MAX", { get: I.prototype.get_PE_DD_MAX }), I.prototype.get_PE_DMS_MAX = I.prototype.get_PE_DMS_MAX = function() {
    var p = this.ptr;
    return ol(p);
  }, Object.defineProperty(I.prototype, "PE_DMS_MAX", { get: I.prototype.get_PE_DMS_MAX }), I.prototype.get_PE_DDM_MAX = I.prototype.get_PE_DDM_MAX = function() {
    var p = this.ptr;
    return al(p);
  }, Object.defineProperty(I.prototype, "PE_DDM_MAX", { get: I.prototype.get_PE_DDM_MAX }), I.prototype.get_PE_UTM_MAX = I.prototype.get_PE_UTM_MAX = function() {
    var p = this.ptr;
    return ul(p);
  }, Object.defineProperty(I.prototype, "PE_UTM_MAX", { get: I.prototype.get_PE_UTM_MAX }), I.prototype.get_PE_PARM_MAX = I.prototype.get_PE_PARM_MAX = function() {
    var p = this.ptr;
    return ll(p);
  }, Object.defineProperty(I.prototype, "PE_PARM_MAX", { get: I.prototype.get_PE_PARM_MAX }), I.prototype.get_PE_TYPE_NONE = I.prototype.get_PE_TYPE_NONE = function() {
    var p = this.ptr;
    return cl(p);
  }, Object.defineProperty(I.prototype, "PE_TYPE_NONE", { get: I.prototype.get_PE_TYPE_NONE }), I.prototype.get_PE_TYPE_GEOGCS = I.prototype.get_PE_TYPE_GEOGCS = function() {
    var p = this.ptr;
    return fl(p);
  }, Object.defineProperty(I.prototype, "PE_TYPE_GEOGCS", { get: I.prototype.get_PE_TYPE_GEOGCS }), I.prototype.get_PE_TYPE_PROJCS = I.prototype.get_PE_TYPE_PROJCS = function() {
    var p = this.ptr;
    return hl(p);
  }, Object.defineProperty(I.prototype, "PE_TYPE_PROJCS", { get: I.prototype.get_PE_TYPE_PROJCS }), I.prototype.get_PE_TYPE_GEOGTRAN = I.prototype.get_PE_TYPE_GEOGTRAN = function() {
    var p = this.ptr;
    return dl(p);
  }, Object.defineProperty(I.prototype, "PE_TYPE_GEOGTRAN", { get: I.prototype.get_PE_TYPE_GEOGTRAN }), I.prototype.get_PE_TYPE_COORDSYS = I.prototype.get_PE_TYPE_COORDSYS = function() {
    var p = this.ptr;
    return ml(p);
  }, Object.defineProperty(I.prototype, "PE_TYPE_COORDSYS", { get: I.prototype.get_PE_TYPE_COORDSYS }), I.prototype.get_PE_TYPE_UNIT = I.prototype.get_PE_TYPE_UNIT = function() {
    var p = this.ptr;
    return pl(p);
  }, Object.defineProperty(I.prototype, "PE_TYPE_UNIT", { get: I.prototype.get_PE_TYPE_UNIT }), I.prototype.get_PE_TYPE_LINUNIT = I.prototype.get_PE_TYPE_LINUNIT = function() {
    var p = this.ptr;
    return gl(p);
  }, Object.defineProperty(I.prototype, "PE_TYPE_LINUNIT", { get: I.prototype.get_PE_TYPE_LINUNIT }), I.prototype.get_PE_STR_OPTS_NONE = I.prototype.get_PE_STR_OPTS_NONE = function() {
    var p = this.ptr;
    return _l(p);
  }, Object.defineProperty(I.prototype, "PE_STR_OPTS_NONE", { get: I.prototype.get_PE_STR_OPTS_NONE }), I.prototype.get_PE_STR_AUTH_NONE = I.prototype.get_PE_STR_AUTH_NONE = function() {
    var p = this.ptr;
    return yl(p);
  }, Object.defineProperty(I.prototype, "PE_STR_AUTH_NONE", { get: I.prototype.get_PE_STR_AUTH_NONE }), I.prototype.get_PE_STR_AUTH_TOP = I.prototype.get_PE_STR_AUTH_TOP = function() {
    var p = this.ptr;
    return bl(p);
  }, Object.defineProperty(I.prototype, "PE_STR_AUTH_TOP", { get: I.prototype.get_PE_STR_AUTH_TOP }), I.prototype.get_PE_STR_NAME_CANON = I.prototype.get_PE_STR_NAME_CANON = function() {
    var p = this.ptr;
    return wl(p);
  }, Object.defineProperty(I.prototype, "PE_STR_NAME_CANON", { get: I.prototype.get_PE_STR_NAME_CANON }), I.prototype.get_PE_STR_FMT_WKT = I.prototype.get_PE_STR_FMT_WKT = function() {
    var p = this.ptr;
    return vl(p);
  }, Object.defineProperty(I.prototype, "PE_STR_FMT_WKT", { get: I.prototype.get_PE_STR_FMT_WKT }), I.prototype.get_PE_STR_FMT_WKT2 = I.prototype.get_PE_STR_FMT_WKT2 = function() {
    var p = this.ptr;
    return Sl(p);
  }, Object.defineProperty(I.prototype, "PE_STR_FMT_WKT2", { get: I.prototype.get_PE_STR_FMT_WKT2 }), I.prototype.get_PE_PARM_X0 = I.prototype.get_PE_PARM_X0 = function() {
    var p = this.ptr;
    return El(p);
  }, Object.defineProperty(I.prototype, "PE_PARM_X0", { get: I.prototype.get_PE_PARM_X0 }), I.prototype.get_PE_PARM_ND = I.prototype.get_PE_PARM_ND = function() {
    var p = this.ptr;
    return Nl(p);
  }, Object.defineProperty(I.prototype, "PE_PARM_ND", { get: I.prototype.get_PE_PARM_ND }), I.prototype.get_PE_TRANSFORM_1_TO_2 = I.prototype.get_PE_TRANSFORM_1_TO_2 = function() {
    var p = this.ptr;
    return xl(p);
  }, Object.defineProperty(I.prototype, "PE_TRANSFORM_1_TO_2", { get: I.prototype.get_PE_TRANSFORM_1_TO_2 }), I.prototype.get_PE_TRANSFORM_2_TO_1 = I.prototype.get_PE_TRANSFORM_2_TO_1 = function() {
    var p = this.ptr;
    return Tl(p);
  }, Object.defineProperty(I.prototype, "PE_TRANSFORM_2_TO_1", { get: I.prototype.get_PE_TRANSFORM_2_TO_1 }), I.prototype.get_PE_TRANSFORM_P_TO_G = I.prototype.get_PE_TRANSFORM_P_TO_G = function() {
    var p = this.ptr;
    return Pl(p);
  }, Object.defineProperty(I.prototype, "PE_TRANSFORM_P_TO_G", { get: I.prototype.get_PE_TRANSFORM_P_TO_G }), I.prototype.get_PE_TRANSFORM_G_TO_P = I.prototype.get_PE_TRANSFORM_G_TO_P = function() {
    var p = this.ptr;
    return Al(p);
  }, Object.defineProperty(I.prototype, "PE_TRANSFORM_G_TO_P", { get: I.prototype.get_PE_TRANSFORM_G_TO_P }), I.prototype.get_PE_HORIZON_RECT = I.prototype.get_PE_HORIZON_RECT = function() {
    var p = this.ptr;
    return Ll(p);
  }, Object.defineProperty(I.prototype, "PE_HORIZON_RECT", { get: I.prototype.get_PE_HORIZON_RECT }), I.prototype.get_PE_HORIZON_POLY = I.prototype.get_PE_HORIZON_POLY = function() {
    var p = this.ptr;
    return Ml(p);
  }, Object.defineProperty(I.prototype, "PE_HORIZON_POLY", { get: I.prototype.get_PE_HORIZON_POLY }), I.prototype.get_PE_HORIZON_LINE = I.prototype.get_PE_HORIZON_LINE = function() {
    var p = this.ptr;
    return Ol(p);
  }, Object.defineProperty(I.prototype, "PE_HORIZON_LINE", { get: I.prototype.get_PE_HORIZON_LINE }), I.prototype.get_PE_HORIZON_DELTA = I.prototype.get_PE_HORIZON_DELTA = function() {
    var p = this.ptr;
    return Cl(p);
  }, Object.defineProperty(I.prototype, "PE_HORIZON_DELTA", { get: I.prototype.get_PE_HORIZON_DELTA }), gt.prototype = Object.create(ke.prototype), gt.prototype.constructor = gt, gt.prototype.__class__ = gt, gt.__cache__ = {}, s.PeDouble = gt, gt.prototype.get_val = gt.prototype.get_val = function() {
    var p = this.ptr;
    return Il(p);
  }, gt.prototype.set_val = gt.prototype.set_val = function(p) {
    var E = this.ptr;
    p && typeof p == "object" && (p = p.ptr), kl(E, p);
  }, Object.defineProperty(gt.prototype, "val", { get: gt.prototype.get_val, set: gt.prototype.set_val }), gt.prototype.__destroy__ = gt.prototype.__destroy__ = function() {
    var p = this.ptr;
    Dl(p);
  }, Ct.prototype = Object.create(ke.prototype), Ct.prototype.constructor = Ct, Ct.prototype.__class__ = Ct, Ct.__cache__ = {}, s.PeFactory = Ct, Ct.prototype.initialize = Ct.prototype.initialize = function(p) {
    he.prepare(), p = p && typeof p == "object" ? p.ptr : ni(p), $l(p);
  }, Ct.prototype.factoryByType = Ct.prototype.factoryByType = function(p, E) {
    return p && typeof p == "object" && (p = p.ptr), E && typeof E == "object" && (E = E.ptr), Xe(Fl(p, E), Ge);
  }, Ct.prototype.fromString = Ct.prototype.fromString = function(p, E) {
    return he.prepare(), p && typeof p == "object" && (p = p.ptr), E = E && typeof E == "object" ? E.ptr : ni(E), Xe(Ul(p, E), Ge);
  }, Ct.prototype.getCode = Ct.prototype.getCode = function(p) {
    return p && typeof p == "object" && (p = p.ptr), Vl(p);
  }, ct.prototype = Object.create(ke.prototype), ct.prototype.constructor = ct, ct.prototype.__class__ = ct, ct.__cache__ = {}, s.PeGCSExtent = ct, ct.prototype.getLLon = ct.prototype.getLLon = function() {
    var p = this.ptr;
    return jl(p);
  }, ct.prototype.getSLat = ct.prototype.getSLat = function() {
    var p = this.ptr;
    return Wl(p);
  }, ct.prototype.getRLon = ct.prototype.getRLon = function() {
    var p = this.ptr;
    return Gl(p);
  }, ct.prototype.getNLat = ct.prototype.getNLat = function() {
    var p = this.ptr;
    return Bl(p);
  }, ct.prototype.__destroy__ = ct.prototype.__destroy__ = function() {
    var p = this.ptr;
    ql(p);
  }, Me.prototype = Object.create(mt.prototype), Me.prototype.constructor = Me, Me.prototype.__class__ = Me, Me.__cache__ = {}, s.PeGeogcs = Me, Me.prototype.Delete = Me.prototype.Delete = function() {
    var p = this.ptr;
    Hl(p);
  }, Me.prototype.cloneAlterUnits = Me.prototype.cloneAlterUnits = function(p) {
    var E = this.ptr;
    return p && typeof p == "object" && (p = p.ptr), Xe(Yl(E, p), Me);
  }, Me.prototype.getDatum = Me.prototype.getDatum = function() {
    var p = this.ptr;
    return Xe(Zl(p), Pt);
  }, Me.prototype.getPrimem = Me.prototype.getPrimem = function() {
    var p = this.ptr;
    return Xe(Xl(p), At);
  }, Me.prototype.getUnit = Me.prototype.getUnit = function() {
    var p = this.ptr;
    return Xe(Jl(p), Tt);
  }, Me.prototype.isEqual = Me.prototype.isEqual = function(p) {
    var E = this.ptr;
    return p && typeof p == "object" && (p = p.ptr), !!Ql(E, p);
  }, Me.prototype.getCode = Me.prototype.getCode = function() {
    var p = this.ptr;
    return Kl(p);
  }, Me.prototype.getName = Me.prototype.getName = function(p) {
    var E = this.ptr;
    return he.prepare(), typeof p == "object" && (p = Jt(p)), Ot(ec(E, p));
  }, Me.prototype.getType = Me.prototype.getType = function() {
    var p = this.ptr;
    return tc(p);
  }, ze.prototype = Object.create(Ge.prototype), ze.prototype.constructor = ze, ze.prototype.__class__ = ze, ze.__cache__ = {}, s.PeGeogtran = ze, ze.prototype.isEqual = ze.prototype.isEqual = function(p) {
    var E = this.ptr;
    return p && typeof p == "object" && (p = p.ptr), !!rc(E, p);
  }, ze.prototype.getGeogcs1 = ze.prototype.getGeogcs1 = function() {
    var p = this.ptr;
    return Xe(to(p), Me);
  }, ze.prototype.getGeogcs2 = ze.prototype.getGeogcs2 = function() {
    var p = this.ptr;
    return Xe(ro(p), Me);
  }, ze.prototype.getParameters = ze.prototype.getParameters = function() {
    var p = this.ptr;
    return Ah(p);
  }, ze.prototype.loadConstants = ze.prototype.loadConstants = function() {
    var p = this.ptr;
    return !!nc(p);
  }, ze.prototype.getCode = ze.prototype.getCode = function() {
    var p = this.ptr;
    return no(p);
  }, ze.prototype.getName = ze.prototype.getName = function(p) {
    var E = this.ptr;
    return he.prepare(), typeof p == "object" && (p = Jt(p)), Ot(sc(E, p));
  }, ze.prototype.getType = ze.prototype.getType = function() {
    var p = this.ptr;
    return so(p);
  }, qt.prototype = Object.create(ke.prototype), qt.prototype.constructor = qt, qt.prototype.__class__ = qt, qt.__cache__ = {}, s.PeGTlistExtended = qt, qt.prototype.getGTlist = qt.prototype.getGTlist = function(p, E, k, G, X, se) {
    return p && typeof p == "object" && (p = p.ptr), E && typeof E == "object" && (E = E.ptr), k && typeof k == "object" && (k = k.ptr), G && typeof G == "object" && (G = G.ptr), X && typeof X == "object" && (X = X.ptr), se && typeof se == "object" && (se = se.ptr), Xe(ic(p, E, k, G, X, se), Ft);
  }, qt.prototype.get_PE_GTLIST_OPTS_COMMON = qt.prototype.get_PE_GTLIST_OPTS_COMMON = function() {
    var p = this.ptr;
    return oc(p);
  }, Object.defineProperty(qt.prototype, "PE_GTLIST_OPTS_COMMON", { get: qt.prototype.get_PE_GTLIST_OPTS_COMMON }), Ft.prototype = Object.create(ke.prototype), Ft.prototype.constructor = Ft, Ft.prototype.__class__ = Ft, Ft.__cache__ = {}, s.PeGTlistExtendedEntry = Ft, Ft.prototype.getEntries = Ft.prototype.getEntries = function() {
    var p = this.ptr;
    return Xe(ac(p), Qt);
  }, Ft.prototype.getSteps = Ft.prototype.getSteps = function() {
    var p = this.ptr;
    return io(p);
  }, Ft.prototype.Delete = Ft.prototype.Delete = function(p) {
    p && typeof p == "object" && (p = p.ptr), uc(p);
  }, Qt.prototype = Object.create(ke.prototype), Qt.prototype.constructor = Qt, Qt.prototype.__class__ = Qt, Qt.__cache__ = {}, s.PeGTlistExtendedGTs = Qt, Qt.prototype.getDirection = Qt.prototype.getDirection = function() {
    var p = this.ptr;
    return lc(p);
  }, Qt.prototype.getGeogtran = Qt.prototype.getGeogtran = function() {
    var p = this.ptr;
    return Xe(cc(p), ze);
  }, it.prototype = Object.create(ke.prototype), it.prototype.constructor = it, it.prototype.__class__ = it, it.__cache__ = {}, s.PeHorizon = it, it.prototype.getNump = it.prototype.getNump = function() {
    var p = this.ptr;
    return fc(p);
  }, it.prototype.getKind = it.prototype.getKind = function() {
    var p = this.ptr;
    return hc(p);
  }, it.prototype.getInclusive = it.prototype.getInclusive = function() {
    var p = this.ptr;
    return dc(p);
  }, it.prototype.getSize = it.prototype.getSize = function() {
    var p = this.ptr;
    return mc(p);
  }, it.prototype.getCoord = it.prototype.getCoord = function() {
    var p = this.ptr;
    return pc(p);
  }, _t.prototype = Object.create(ke.prototype), _t.prototype.constructor = _t, _t.prototype.__class__ = _t, _t.__cache__ = {}, s.PeInteger = _t, _t.prototype.get_val = _t.prototype.get_val = function() {
    var p = this.ptr;
    return _c(p);
  }, _t.prototype.set_val = _t.prototype.set_val = function(p) {
    var E = this.ptr;
    p && typeof p == "object" && (p = p.ptr), yc(E, p);
  }, Object.defineProperty(_t.prototype, "val", { get: _t.prototype.get_val, set: _t.prototype.set_val }), _t.prototype.__destroy__ = _t.prototype.__destroy__ = function() {
    var p = this.ptr;
    bc(p);
  }, Rt.prototype = Object.create(ke.prototype), Rt.prototype.constructor = Rt, Rt.prototype.__class__ = Rt, Rt.__cache__ = {}, s.PeLineType = Rt, Rt.prototype.geodetic_distance = Rt.prototype.geodetic_distance = function(p, E, k, G, X, se, me, ie, Oe, gr) {
    p && typeof p == "object" && (p = p.ptr), E && typeof E == "object" && (E = E.ptr), k && typeof k == "object" && (k = k.ptr), G && typeof G == "object" && (G = G.ptr), X && typeof X == "object" && (X = X.ptr), se && typeof se == "object" && (se = se.ptr), me && typeof me == "object" && (me = me.ptr), ie && typeof ie == "object" && (ie = ie.ptr), Oe && typeof Oe == "object" && (Oe = Oe.ptr), gr && typeof gr == "object" && (gr = gr.ptr), wc(p, E, k, G, X, se, me, ie, Oe, gr);
  }, Rt.prototype.geodetic_coordinate = Rt.prototype.geodetic_coordinate = function(p, E, k, G, X, se, me, ie, Oe) {
    p && typeof p == "object" && (p = p.ptr), E && typeof E == "object" && (E = E.ptr), k && typeof k == "object" && (k = k.ptr), G && typeof G == "object" && (G = G.ptr), X && typeof X == "object" && (X = X.ptr), se && typeof se == "object" && (se = se.ptr), me && typeof me == "object" && (me = me.ptr), ie && typeof ie == "object" && (ie = ie.ptr), Oe && typeof Oe == "object" && (Oe = Oe.ptr), oo(p, E, k, G, X, se, me, ie, Oe);
  }, Rt.prototype.geodesic_coordinate = Rt.prototype.geodesic_coordinate = function(p, E, k, G, X, se, me, ie) {
    p && typeof p == "object" && (p = p.ptr), E && typeof E == "object" && (E = E.ptr), k && typeof k == "object" && (k = k.ptr), G && typeof G == "object" && (G = G.ptr), X && typeof X == "object" && (X = X.ptr), se && typeof se == "object" && (se = se.ptr), me && typeof me == "object" && (me = me.ptr), ie && typeof ie == "object" && (ie = ie.ptr), vc(p, E, k, G, X, se, me, ie);
  }, Rt.prototype.great_elliptic_distance = Rt.prototype.great_elliptic_distance = function(p, E, k, G, X, se, me, ie, Oe) {
    p && typeof p == "object" && (p = p.ptr), E && typeof E == "object" && (E = E.ptr), k && typeof k == "object" && (k = k.ptr), G && typeof G == "object" && (G = G.ptr), X && typeof X == "object" && (X = X.ptr), se && typeof se == "object" && (se = se.ptr), me && typeof me == "object" && (me = me.ptr), ie && typeof ie == "object" && (ie = ie.ptr), Oe && typeof Oe == "object" && (Oe = Oe.ptr), ao(p, E, k, G, X, se, me, ie, Oe);
  }, yt.prototype = Object.create(ke.prototype), yt.prototype.constructor = yt, yt.prototype.__class__ = yt, yt.__cache__ = {}, s.PeMath = yt, yt.prototype.phi_to_eta = yt.prototype.phi_to_eta = function(p, E) {
    return p && typeof p == "object" && (p = p.ptr), E && typeof E == "object" && (E = E.ptr), Sc(p, E);
  }, yt.prototype.eta_to_phi = yt.prototype.eta_to_phi = function(p, E) {
    return p && typeof p == "object" && (p = p.ptr), E && typeof E == "object" && (E = E.ptr), Ec(p, E);
  }, yt.prototype.phi_to_phig = yt.prototype.phi_to_phig = function(p, E) {
    return p && typeof p == "object" && (p = p.ptr), E && typeof E == "object" && (E = E.ptr), Nc(p, E);
  }, yt.prototype.q = yt.prototype.q = function(p, E, k) {
    return p && typeof p == "object" && (p = p.ptr), E && typeof E == "object" && (E = E.ptr), k && typeof k == "object" && (k = k.ptr), xc(p, E, k);
  }, yt.prototype.q90 = yt.prototype.q90 = function(p, E) {
    return p && typeof p == "object" && (p = p.ptr), E && typeof E == "object" && (E = E.ptr), Lh(p, E);
  }, De.prototype = Object.create(ke.prototype), De.prototype.constructor = De, De.prototype.__class__ = De, De.__cache__ = {}, s.PeNotationMgrs = De, De.prototype.get_PE_MGRS_STYLE_NEW = De.prototype.get_PE_MGRS_STYLE_NEW = function() {
    var p = this.ptr;
    return Tc(p);
  }, Object.defineProperty(De.prototype, "PE_MGRS_STYLE_NEW", { get: De.prototype.get_PE_MGRS_STYLE_NEW }), De.prototype.get_PE_MGRS_STYLE_OLD = De.prototype.get_PE_MGRS_STYLE_OLD = function() {
    var p = this.ptr;
    return Pc(p);
  }, Object.defineProperty(De.prototype, "PE_MGRS_STYLE_OLD", { get: De.prototype.get_PE_MGRS_STYLE_OLD }), De.prototype.get_PE_MGRS_STYLE_AUTO = De.prototype.get_PE_MGRS_STYLE_AUTO = function() {
    var p = this.ptr;
    return Mh(p);
  }, Object.defineProperty(De.prototype, "PE_MGRS_STYLE_AUTO", { get: De.prototype.get_PE_MGRS_STYLE_AUTO }), De.prototype.get_PE_MGRS_180_ZONE_1_PLUS = De.prototype.get_PE_MGRS_180_ZONE_1_PLUS = function() {
    var p = this.ptr;
    return Ac(p);
  }, Object.defineProperty(De.prototype, "PE_MGRS_180_ZONE_1_PLUS", { get: De.prototype.get_PE_MGRS_180_ZONE_1_PLUS }), De.prototype.get_PE_MGRS_ADD_SPACES = De.prototype.get_PE_MGRS_ADD_SPACES = function() {
    var p = this.ptr;
    return Lc(p);
  }, Object.defineProperty(De.prototype, "PE_MGRS_ADD_SPACES", { get: De.prototype.get_PE_MGRS_ADD_SPACES }), Be.prototype = Object.create(ke.prototype), Be.prototype.constructor = Be, Be.prototype.__class__ = Be, Be.__cache__ = {}, s.PeNotationUtm = Be, Be.prototype.get_PE_UTM_OPTS_NONE = Be.prototype.get_PE_UTM_OPTS_NONE = function() {
    var p = this.ptr;
    return Mc(p);
  }, Object.defineProperty(Be.prototype, "PE_UTM_OPTS_NONE", { get: Be.prototype.get_PE_UTM_OPTS_NONE }), Be.prototype.get_PE_UTM_OPTS_NS = Be.prototype.get_PE_UTM_OPTS_NS = function() {
    var p = this.ptr;
    return Oc(p);
  }, Object.defineProperty(Be.prototype, "PE_UTM_OPTS_NS", { get: Be.prototype.get_PE_UTM_OPTS_NS }), Be.prototype.get_PE_UTM_OPTS_NS_STRICT = Be.prototype.get_PE_UTM_OPTS_NS_STRICT = function() {
    var p = this.ptr;
    return Cc(p);
  }, Object.defineProperty(Be.prototype, "PE_UTM_OPTS_NS_STRICT", { get: Be.prototype.get_PE_UTM_OPTS_NS_STRICT }), Be.prototype.get_PE_UTM_OPTS_ADD_SPACES = Be.prototype.get_PE_UTM_OPTS_ADD_SPACES = function() {
    var p = this.ptr;
    return Rc(p);
  }, Object.defineProperty(Be.prototype, "PE_UTM_OPTS_ADD_SPACES", { get: Be.prototype.get_PE_UTM_OPTS_ADD_SPACES }), It.prototype = Object.create(Ge.prototype), It.prototype.constructor = It, It.prototype.__class__ = It, It.__cache__ = {}, s.PeParameter = It, It.prototype.getValue = It.prototype.getValue = function() {
    var p = this.ptr;
    return Ic(p);
  }, It.prototype.getCode = It.prototype.getCode = function() {
    var p = this.ptr;
    return kc(p);
  }, It.prototype.getName = It.prototype.getName = function(p) {
    var E = this.ptr;
    return he.prepare(), typeof p == "object" && (p = Jt(p)), Ot(Dc(E, p));
  }, It.prototype.getType = It.prototype.getType = function() {
    var p = this.ptr;
    return $c(p);
  }, ce.prototype = Object.create(ke.prototype), ce.prototype.constructor = ce, ce.prototype.__class__ = ce, ce.__cache__ = {}, s.PePCSInfo = ce, ce.prototype.getCentralMeridian = ce.prototype.getCentralMeridian = function() {
    var p = this.ptr;
    return Fc(p);
  }, ce.prototype.getDomainMinx = ce.prototype.getDomainMinx = function() {
    var p = this.ptr;
    return Uc(p);
  }, ce.prototype.getDomainMiny = ce.prototype.getDomainMiny = function() {
    var p = this.ptr;
    return Vc(p);
  }, ce.prototype.getDomainMaxx = ce.prototype.getDomainMaxx = function() {
    var p = this.ptr;
    return zc(p);
  }, ce.prototype.getDomainMaxy = ce.prototype.getDomainMaxy = function() {
    var p = this.ptr;
    return jc(p);
  }, ce.prototype.getNorthPoleLocation = ce.prototype.getNorthPoleLocation = function() {
    var p = this.ptr;
    return Wc(p);
  }, ce.prototype.getNorthPoleGeometry = ce.prototype.getNorthPoleGeometry = function() {
    var p = this.ptr;
    return Gc(p);
  }, ce.prototype.getSouthPoleLocation = ce.prototype.getSouthPoleLocation = function() {
    var p = this.ptr;
    return Bc(p);
  }, ce.prototype.getSouthPoleGeometry = ce.prototype.getSouthPoleGeometry = function() {
    var p = this.ptr;
    return qc(p);
  }, ce.prototype.isDensificationNeeded = ce.prototype.isDensificationNeeded = function() {
    var p = this.ptr;
    return !!Hc(p);
  }, ce.prototype.isGcsHorizonMultiOverlap = ce.prototype.isGcsHorizonMultiOverlap = function() {
    var p = this.ptr;
    return !!Yc(p);
  }, ce.prototype.isPannableRectangle = ce.prototype.isPannableRectangle = function() {
    var p = this.ptr;
    return !!Zc(p);
  }, ce.prototype.generate = ce.prototype.generate = function(p, E) {
    return p && typeof p == "object" && (p = p.ptr), E && typeof E == "object" && (E = E.ptr), Xe(Xc(p, E), ce);
  }, ce.prototype.get_PE_PCSINFO_OPTION_NONE = ce.prototype.get_PE_PCSINFO_OPTION_NONE = function() {
    var p = this.ptr;
    return Jc(p);
  }, Object.defineProperty(ce.prototype, "PE_PCSINFO_OPTION_NONE", { get: ce.prototype.get_PE_PCSINFO_OPTION_NONE }), ce.prototype.get_PE_PCSINFO_OPTION_DOMAIN = ce.prototype.get_PE_PCSINFO_OPTION_DOMAIN = function() {
    var p = this.ptr;
    return Qc(p);
  }, Object.defineProperty(ce.prototype, "PE_PCSINFO_OPTION_DOMAIN", { get: ce.prototype.get_PE_PCSINFO_OPTION_DOMAIN }), ce.prototype.get_PE_POLE_OUTSIDE_BOUNDARY = ce.prototype.get_PE_POLE_OUTSIDE_BOUNDARY = function() {
    var p = this.ptr;
    return Kc(p);
  }, Object.defineProperty(ce.prototype, "PE_POLE_OUTSIDE_BOUNDARY", { get: ce.prototype.get_PE_POLE_OUTSIDE_BOUNDARY }), ce.prototype.get_PE_POLE_POINT = ce.prototype.get_PE_POLE_POINT = function() {
    var p = this.ptr;
    return ef(p);
  }, Object.defineProperty(ce.prototype, "PE_POLE_POINT", { get: ce.prototype.get_PE_POLE_POINT }), At.prototype = Object.create(Ge.prototype), At.prototype.constructor = At, At.prototype.__class__ = At, At.__cache__ = {}, s.PePrimem = At, At.prototype.getLongitude = At.prototype.getLongitude = function() {
    var p = this.ptr;
    return tf(p);
  }, At.prototype.getCode = At.prototype.getCode = function() {
    var p = this.ptr;
    return rf(p);
  }, At.prototype.getName = At.prototype.getName = function(p) {
    var E = this.ptr;
    return he.prepare(), typeof p == "object" && (p = Jt(p)), Ot(nf(E, p));
  }, At.prototype.getType = At.prototype.getType = function() {
    var p = this.ptr;
    return sf(p);
  }, Pe.prototype = Object.create(mt.prototype), Pe.prototype.constructor = Pe, Pe.prototype.__class__ = Pe, Pe.__cache__ = {}, s.PeProjcs = Pe, Pe.prototype.Delete = Pe.prototype.Delete = function() {
    var p = this.ptr;
    of(p);
  }, Pe.prototype.getGeogcs = Pe.prototype.getGeogcs = function() {
    var p = this.ptr;
    return Xe(af(p), Me);
  }, Pe.prototype.getProjection = Pe.prototype.getProjection = function() {
    var p = this.ptr;
    return Xe(uf(p), Ge);
  }, Pe.prototype.getParameters = Pe.prototype.getParameters = function() {
    var p = this.ptr;
    return lf(p);
  }, Pe.prototype.getUnit = Pe.prototype.getUnit = function() {
    var p = this.ptr;
    return Xe(cf(p), pt);
  }, Pe.prototype.loadConstants = Pe.prototype.loadConstants = function() {
    var p = this.ptr;
    return !!ff(p);
  }, Pe.prototype.horizonGcsGenerate = Pe.prototype.horizonGcsGenerate = function() {
    var p = this.ptr;
    return Xe(hf(p), it);
  }, Pe.prototype.horizonPcsGenerate = Pe.prototype.horizonPcsGenerate = function() {
    var p = this.ptr;
    return Xe(df(p), it);
  }, Pe.prototype.isEqual = Pe.prototype.isEqual = function(p) {
    var E = this.ptr;
    return p && typeof p == "object" && (p = p.ptr), !!mf(E, p);
  }, Pe.prototype.getCode = Pe.prototype.getCode = function() {
    var p = this.ptr;
    return pf(p);
  }, Pe.prototype.getName = Pe.prototype.getName = function(p) {
    var E = this.ptr;
    return he.prepare(), typeof p == "object" && (p = Jt(p)), Ot(gf(E, p));
  }, Pe.prototype.getType = Pe.prototype.getType = function() {
    var p = this.ptr;
    return _f(p);
  }, ft.prototype = Object.create(Ge.prototype), ft.prototype.constructor = ft, ft.prototype.__class__ = ft, ft.__cache__ = {}, s.PeSpheroid = ft, ft.prototype.getAxis = ft.prototype.getAxis = function() {
    var p = this.ptr;
    return yf(p);
  }, ft.prototype.getFlattening = ft.prototype.getFlattening = function() {
    var p = this.ptr;
    return bf(p);
  }, ft.prototype.getCode = ft.prototype.getCode = function() {
    var p = this.ptr;
    return wf(p);
  }, ft.prototype.getName = ft.prototype.getName = function(p) {
    var E = this.ptr;
    return he.prepare(), typeof p == "object" && (p = Jt(p)), Ot(vf(E, p));
  }, ft.prototype.getType = ft.prototype.getType = function() {
    var p = this.ptr;
    return Sf(p);
  }, Lr.prototype = Object.create(ke.prototype), Lr.prototype.constructor = Lr, Lr.prototype.__class__ = Lr, Lr.__cache__ = {}, s.PeVersion = Lr, Lr.prototype.version_string = Lr.prototype.version_string = function() {
    var p = this.ptr;
    return Ot(Ef(p));
  }, s.ensureCache = he, s.ensureString = ni, s.ensureInt8 = Jt, s.ensureInt16 = Af, s.ensureInt32 = Lf, s.ensureFloat32 = Mf, s.ensureFloat64 = Of, i;
}, sT = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  default: nT
});
