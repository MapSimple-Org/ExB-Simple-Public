import { proxyExports as v, getControllersCount as w, trackPropKey as y } from "@arcgis/lumina/controllers";
import { AccessorController as b, getAccessorControllerBoundProperties as E, makeBinderProxy as x } from "@arcgis/lumina/controllers/accessor";
import { isEsriInternalEnv as M } from "@arcgis/toolkit/error";
import { V as g } from "./useView.js";
import { watch as m } from "@arcgis/core/core/reactiveUtils.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
const I = (d, e) => (t) => C(t, d);
class p extends b {
  #o = /* @__PURE__ */ new Map();
  #e;
  #t;
  constructor(e, t) {
    super(e, t), new g(e);
    const i = this, o = i.instance;
    let n = o.viewModel, l = o.visibleElements;
    const r = new Proxy(this.exports, {
      get(s, c, h) {
        return c === "viewModel" ? n : c === "visibleElements" ? l : Reflect.get(s, c, h);
      }
    });
    if (i.#t = o, i.instance = r, i.exports = r, n) {
      const s = {
        component: e,
        get exports() {
          return i.instance.viewModel;
        }
      };
      E(i).set("viewModel", "viewModel"), e.addController(s), n = x(e, new WeakRef(s), w(e) - 1, n, i.#o);
    }
    i.instance.visibleElements && (l = i.#i(o));
  }
  hostConnected() {
    this.instance = this.#t, super.hostConnected();
  }
  hostLoad() {
    this.#e = m(() => this.component.el.view, (e) => {
      const t = this.instance;
      !("view" in t) && typeof t.viewModel == "object" ? t.viewModel.view = e : t.view = e, !("map" in t) && typeof t.viewModel == "object" ? t.viewModel.map = e?.map : t.map = e?.map;
    }, { sync: !0, initial: !0 });
  }
  hostUpdate(e) {
    e.has("closed") && (this.instance.visible = !this.component.closed);
  }
  hostLoaded() {
    const { el: e } = this.component;
    e.childElem ??= document.createElement("div"), this.instance.container = e.childElem, (this.component.el.shadowRoot ?? this.component.el).appendChild(this.instance.container), this.component.closed !== void 0 && this.onLifecycle(() => m(() => this.instance.visible, (i) => this.component.closed = !i, { initial: !0 }));
  }
  #i(e) {
    return new Proxy(e.visibleElements, {
      get: (t, i) => {
        if (typeof i == "symbol" || i in Promise.prototype)
          return t[i];
        const o = [i], n = this.#s(o);
        return y(this.component, (l) => {
          const r = l;
          this.component[r] = !1;
          let s = e.visibleElements ?? {}, c;
          for (const a of o.slice(0, -1))
            if (typeof s[a] == "object" && s[a] !== null)
              s = s[a];
            else {
              c = !!s[a];
              break;
            }
          c === void 0 && (c = !!(s[o.slice(-1)[0]] ?? !0));
          const f = r.startsWith("hide") || r.startsWith("show") ? r.startsWith("hide") : c;
          this.onUpdate((a) => {
            if (a.has(r)) {
              const u = this.component[r];
              this.#n(o, u, f);
            }
          });
        }, n);
      }
    });
  }
  #s(e) {
    const t = new Proxy({}, {
      get: (i, o) => {
        const n = Reflect.get(i, o);
        return typeof o == "symbol" || o in Promise.prototype ? n : (e.push(o), t);
      }
    });
    return t;
  }
  #n(e, t, i) {
    let o = this.instance.visibleElements ?? {};
    for (const l of e.slice(0, -1))
      (typeof o[l] != "object" || o[l] === null) && (o[l] = {}), o = o[l];
    const n = !!(i ? !t : t);
    o[e.at(-1)] = n;
  }
  hostDestroy() {
    this.#e?.remove(), super.hostDestroy();
  }
}
process.env.NODE_ENV !== "production" && M() && (p.devOnly$allowedPropNameMismatches = /* @__PURE__ */ new Set([
  "manager",
  "el",
  "position",
  "multipleSortEnabled",
  // Deprecated
  "focusTrapEnabled",
  "focusTrapDisabled",
  // Deprecated
  "hideLastEditInfo"
]));
const C = v(p);
export {
  I as m
};
