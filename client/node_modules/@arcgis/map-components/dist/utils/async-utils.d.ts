import { nil } from '@arcgis/toolkit/type';
import { default as EsriError } from '@arcgis/core/core/Error.js';
export interface AbortError extends EsriError {
    name: "AbortError";
}
export interface AbortOptions {
    signal?: AbortSignal | null;
}
export declare function createAbortError(description?: string): AbortError;
export declare function throwIfAborted(params: AbortOptions | AbortSignal | nil, description?: string): void;
export declare function signalFromSignalOrOptions(params: AbortOptions | AbortSignal | nil): AbortSignal | undefined;
export declare function isAborted(params: AbortOptions | AbortSignal | nil): boolean;
export declare function isAbortError(error: unknown): error is AbortError;
export declare function onAbort(params: AbortOptions | AbortSignal | nil, callback: () => void): IHandle | nil;
export interface Task<T> extends IHandle, Disposable {
    readonly value: nil | T;
    readonly error: unknown;
    readonly finished: boolean;
    readonly promise: Promise<T>;
    abort: () => void;
}
type TaskFunction<T> = (signal: AbortSignal) => Promise<T>;
type TaskOptions = AbortOptions | AbortSignal | nil;
/**
 * Wraps an async function (or function returning a promise) in order to create an abortable task.
 * This hides the complexity of creating and managing abort controllers, etc.
 *
 * 3D: Do not use this for anything else than wrapping trivial promises/promise chains. Do use a Scheduler task
 * to perform significant work:
 *
 * ```ts
 * this._queryTask = createTask((signal) => {
 *   const data = await view.resourceController.schedule(slowTask, signal);
 *   throwIfAborted(signal);
 *   // do things with data
 * });
 * ```
 *
 * Example:
 *
 *    ```ts
 *    const task = createTask((signal) => {
 *      return promiseUtils.whenOrAbort(doSomethingAsync(), signal);
 *    });
 *
 *    // Wait for the result
 *    task.promise.then((result) => console.log(result));
 *
 *    // Or abort it when not needed anymore.
 *    task.abort();
 *    ```
 *
 * @param task
 *    The task which is to be executed and made abortable. It receives a signal which can be passed to async operations
 *    in order for them to check whether the task has been aborted.
 *
 * @param options
 *    Abort the task
 *
 * @return
 *    An object which encapsulates the state of the task.
 *
 * @ignore
 */
export declare function createTask<T>(task: TaskFunction<T>, options?: TaskOptions): Task<T>;
export declare function ignoreAbortErrors(promise: Promise<unknown>): Promise<unknown>;
/**
 * Schedules a function to be called during the browser's idle periods, using `window.requestIdleCallback` if available,
 * or falling back to a `setTimeout`-based polyfill. This allows you to perform background or low-priority work without
 * impacting critical rendering or user interactions.
 *
 * @param callback - The function to execute when the browser is idle. Receives an object with `didTimeout` and `timeRemaining`.
 * @param options - Optional configuration for the idle callback, such as a timeout in milliseconds.
 * @returns A numeric handle that can be used to cancel the scheduled callback.
 */
export declare function requestIdleCallback(callback: IdleRequestCallback, options?: IdleRequestOptions): number;
/**
 * Cancels a previously scheduled idle callback or timeout.
 *
 * This function attempts to cancel an idle callback using `window.cancelIdleCallback` if it is available in the current
 * environment. If not, it falls back to clearing the timeout using `window.clearTimeout`.
 *
 * @param id - The identifier of the idle callback or timeout to cancel.
 */
export declare function cancelIdleCallback(id: number): void;
export {};
