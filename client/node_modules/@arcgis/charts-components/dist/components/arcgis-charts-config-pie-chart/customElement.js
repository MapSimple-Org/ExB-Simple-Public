import { c as C } from "../../chunks/runtime.js";
import "@arcgis/toolkit/intl";
import { isEqual as n, cloneDeep as d } from "lodash-es";
import "../../chunks/series-types.js";
import { R as u } from "../../chunks/rest-js-object-literals.js";
import "d3-array";
import { g as y, ba as I } from "../../chunks/interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import { h as F } from "../../chunks/index4.js";
import "@arcgis/toolkit/dom";
import { LitElement as v, createEvent as m } from "@arcgis/lumina";
import { css as P, html as c } from "lit";
import { C as h } from "../../chunks/interfaces3.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
const L = P`:host{overflow-y:auto;overflow-x:hidden;margin-bottom:var(--arcgis-charts-intra-section-margin);margin-top:var(--arcgis-charts-intra-section-margin);height:100%}`;
class S extends v {
  constructor() {
    super(...arguments), this.onModelConfigChange = async (e) => {
      const s = e?.detail.config ?? this.model.config;
      this.layer === void 0 && await this.updateFetchLayerFieldsInfo(s);
    }, this.popoverPlacement = "leading", this.arcgisChartsConfigNoSeriesUpdate = m(), this.arcgisChartsConfigWebChartChange = m();
  }
  static {
    this.properties = { layerFieldsInfo: 16, model: 0, popoverPlacement: 3, seriesColor: 2, calculatedMinMaxBounds: 2, page: 3, layer: 0, usePopupTemplateFieldsInfo: 5, filterBySelection: 5, chartData: 0 };
  }
  static {
    this.styles = L;
  }
  async load() {
    this.layer !== void 0 && await this.layerChange(this.layer, void 0), this.seriesColor !== void 0 && this.seriesColorChange(this.seriesColor), this.usePopupTemplateFieldsInfo !== void 0 && await this.usePopupTemplateFieldsInfoChange(this.usePopupTemplateFieldsInfo, void 0), this.modelChange(this.model), this.onModelConfigChange();
  }
  async willUpdate(e) {
    e.has("model") && this.modelChange(this.model, e.get("model")), e.has("layer") && await this.layerChange(this.layer, e.get("layer")), e.has("usePopupTemplateFieldsInfo") && await this.usePopupTemplateFieldsInfoChange(this.usePopupTemplateFieldsInfo, e.get("usePopupTemplateFieldsInfo")), e.has("seriesColor") && this.seriesColorChange(this.seriesColor), this.layerFieldsInfo === void 0 && await this.updateFetchLayerFieldsInfo();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
  }
  modelChange(e, i) {
    i?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange), e?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
  }
  async layerChange(e, i) {
    e !== void 0 && !n(i, e) && await this.updateFetchLayerFieldsInfo();
  }
  async usePopupTemplateFieldsInfoChange(e, i) {
    e !== void 0 && e !== i && await this.updateFetchLayerFieldsInfo();
  }
  seriesColorChange(e) {
    const { slices: i, groupedSlices: s, groupOfSlices: a } = e?.get(0) ?? {};
    let o = [];
    this.filterBySelection === !0 ? o = this.model.slices?.map((r) => i?.find((t) => t.sliceId === r.sliceId) ?? s?.find((t) => t.sliceId === r.sliceId) ?? r) ?? [] : o = (i ?? []).concat(s ?? []), o.forEach((r, t) => {
      const f = this.model.slices?.find((g) => g.sliceId === o[t].sliceId);
      f && (o[t] = { ...o[t], ...f });
      const l = o[t].fillSymbol;
      l !== void 0 && !n(l?.outline?.color, l?.color) && (l.outline = {
        ...l.outline ?? {},
        type: u.SLS,
        color: l.color
      });
    });
    const p = (s ?? []).map((r) => r.sliceId);
    s !== void 0 && !n(p, this.model.groupedSliceIds) && (this.model.groupedSliceIds = d(p)), n(o, this.model.slices) || (this.model.slices = d(o)), a !== void 0 && !n(a, this.model.sliceGrouping) && (this.model.sliceGrouping = d(a));
  }
  async updateFetchLayerFieldsInfo(e) {
    const i = e ?? this.model.config;
    let s = this.layer;
    if (!s) {
      const a = F(i) ? i.iLayer : void 0;
      a && (s = await y(a));
    }
    s && (this.layerFieldsInfo = await I(s, this.usePopupTemplateFieldsInfo));
  }
  render() {
    let e;
    switch (this.page) {
      case h.Data:
        e = c`<arcgis-charts-config-pie-chart-data .model=${this.model} .layerFieldsInfo=${this.layerFieldsInfo}></arcgis-charts-config-pie-chart-data>`;
        break;
      case h.Slices:
        e = c`<arcgis-charts-config-pie-chart-slices .model=${this.model} .chartData=${this.chartData} .popoverPlacement=${this.popoverPlacement}></arcgis-charts-config-pie-chart-slices>`;
        break;
      case h.Format:
        e = c`<arcgis-charts-config-format .model=${this.model}></arcgis-charts-config-format>`;
        break;
      case h.General:
        e = c`<arcgis-charts-config-general .model=${this.model}></arcgis-charts-config-general>`;
        break;
      default:
        e = "";
        break;
    }
    return e;
  }
}
C("arcgis-charts-config-pie-chart", S);
export {
  S as ArcgisChartsConfigPieChart
};
