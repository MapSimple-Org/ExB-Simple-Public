import { c as F } from "../../chunks/runtime.js";
import { repeat as N } from "lit/directives/repeat.js";
import { keyed as v } from "lit/directives/keyed.js";
import { createModel as V } from "../../model.js";
import { b as $, a as b, f as U, p as L, k as _, j as S } from "../../chunks/type-guards.js";
import "@arcgis/toolkit/intl";
import { isEqual as B } from "lodash-es";
import { W as o, i as R } from "../../chunks/series-types.js";
import { y as w, cA as D, cl as E, N as z } from "../../chunks/interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import "@arcgis/toolkit/dom";
import { C } from "../../chunks/index5.js";
import { a as T } from "../../chunks/chart-ui-utils.js";
import { r as W } from "../../chunks/popover-ui-utils.js";
import { substitute as H } from "@arcgis/core/intl.js";
import { C as n } from "../../chunks/interfaces3.js";
import "d3-array";
import { LitElement as G, createEvent as y, renderElement as I, safeStyleMap as X, safeClassMap as h } from "@arcgis/lumina";
import { css as Z, html as c } from "lit";
import { createRef as O, ref as j } from "lit/directives/ref.js";
import { u as K } from "../../chunks/useT9n.js";
import { s as x, g as q } from "../../chunks/store.js";
import { h as Y, a as M, s as Q } from "../../chunks/web-component-utils.js";
import { A as J } from "../../chunks/axis-model-wrapper.js";
import { d as ee } from "../../chunks/chart-ui-utils2.js";
import { C as te } from "../../chunks/interfaces4.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
const d = {
  chartUIComponent: "chart-ui-component",
  tabBar: "tab-bar",
  tab: "tab"
};
function P(m, e) {
  const a = /* @__PURE__ */ new Set();
  let t = e;
  return m?.forEach((i, s) => {
    const r = i.chartId;
    (a.has(r) || r === void 0 || r === "") && (i.chartId = `Chart_${Date.now()}_${s}`, e === r && (t = i.chartId)), a.add(r);
  }), t;
}
function ae(m, e, a) {
  return m?.filter((t) => E(a, t.config) && t.layer?.id === e) ?? [];
}
function ie(m) {
  const { modelList: e, layerList: a, activeLayerId: t, disableEditing: i } = m, s = /* @__PURE__ */ new Map();
  return e?.forEach((r) => {
    const l = r.layer;
    l && s.set(l.id, l);
  }), i || a.forEach((r) => s.set(r.id, r)), Array.from(s.values()).filter((r) => !t || r.id === t);
}
function se(m, e) {
  m.forEach((a) => {
    e.forEach((t) => {
      a?.id === t.layer?.id && k(a, t);
    });
  });
}
function k(m, e) {
  const a = m;
  if (a) {
    const t = [...a?.charts ?? []], i = t?.findIndex((r) => r.id === e.chartId);
    let s = !1;
    i !== void 0 && i > -1 ? (s = !B(t[i], e.config), t[i] = e.config) : a && !w(e.config) && (s = !0, t.push(e.config)), s && (a.charts = t);
  }
}
function re(m, e) {
  const a = m;
  if (a) {
    const t = [...a.charts ?? []], i = t.findIndex((s) => s.id === e);
    i > -1 && (t.splice(i, 1), a.charts = t);
  }
}
function oe(m, e) {
  const a = m;
  if (a) {
    let t = [...a.charts ?? []];
    t = D({
      arrayA: t,
      arrayB: e.map((i) => i.config),
      getKey: (i) => i.id ?? i.title?.content.text ?? ""
    }), a.charts = t;
  }
}
const ne = Z`:host{display:flex;flex-direction:column;flex:1 1 auto;overflow:hidden;height:inherit;max-height:100%}.chart-ui-component{overflow-y:auto;overflow-x:hidden}.label{display:flex;margin-left:1rem;margin-bottom:.5rem;justify-content:space-between}.text{display:flex;margin-left:1rem;width:calc(100% - 1.5rem);height:2rem;margin-bottom:.5rem;justify-content:space-between}.field-list{max-height:50vh;overflow-y:scroll}.row{padding:.5rem}.bin-count-container{display:flex;width:calc(100% - 1rem);padding:.5rem}.bin-count-slider{margin-left:1rem;width:calc(90% - 1rem)}.bin-count-input{margin-left:1rem;height:2rem;width:2rem}.bin-row{padding:.5rem 0 .5rem .5rem}.tab-bar{display:flex}.tab{flex:1;height:2.5rem}`;
class le extends G {
  constructor() {
    super(), this.selectChartTypePopover = null, this.chartsListFlowItem = O(), this.supportedChartTypes = [
      o.BarSeries,
      o.BoxPlotSeries,
      o.LineSeries,
      o.PieSeries,
      o.HistogramSeries,
      o.ScatterSeries
    ], this._messages = K(), this.chartDataProcessComplete = (e) => {
      const a = e, { chartData: t, model: i } = a.detail, s = this.getModel(this.selectedChartId);
      if (i?.isSameChartAs(s))
        switch (s?.chartType) {
          case o.HistogramSeries:
            this.chartData = t, i && (i.dataStore.chartData = t);
            break;
          case o.PieSeries: {
            this.chartData = t, i && (i.dataStore.chartData = t);
            break;
          }
          case o.ScatterSeries: {
            const l = t, { dataItems: p, r2: g, aggregated: u } = l;
            let f = g;
            Number.isFinite(g) || (f = void 0), this.r2 = f, U(i) && (i.dataStore.r2 = f, i.dataStore.aggregated = u, u && (i.additionalTooltipField = void 0)), this.calculatedDataMinMaxBounds = this.getDataExtent(p), i && (i.dataStore.calculatedDataMinMaxBounds = this.calculatedDataMinMaxBounds);
            break;
          }
          case o.LineSeries:
          case o.BarSeries: {
            const { dataItems: l, timeIntervalInfo: p } = t;
            if (($(s) || b(s) && s.binTemporalData) && (p?.size !== void 0 && s.temporalBinningSize !== p?.size && (s.temporalBinningSize = p?.size), p?.unit !== void 0 && s.temporalBinningUnit !== p?.unit && p?.unit !== R.Quarter && (s.temporalBinningUnit = p?.unit)), this.calculatedDataMinMaxBounds = this.getDataExtent(l), i && (i.dataStore.calculatedDataMinMaxBounds = this.calculatedDataMinMaxBounds), b(s)) {
              const g = s.xAxisField, u = l.some((A) => A[g] === null), f = s.nullCategory;
              u && f === void 0 && (s.nullCategory = te.nullCategory);
            }
            break;
          }
        }
    }, this.chartAxesMinMaxChange = (e) => {
      const a = e, { bounds: t, model: i } = a.detail, s = this.getModel(this.selectedChartId), r = i?.isSameChartAs(s), l = s?.chartType;
      if (r)
        switch (l) {
          case o.BarSeries:
          case o.BoxPlotSeries:
          case o.LineSeries:
          case o.HistogramSeries:
          case o.ScatterSeries:
            this.calculatedMinMaxBounds = t, i && (i.dataStore.calculatedMinMaxBounds = t), this.updateAxesBoundsInAppState(t);
            break;
        }
    }, this.chartSeriesColorChange = (e) => {
      const a = e, { data: t, model: i } = a.detail, s = this.getModel(this.selectedChartId);
      if (i?.isSameChartAs(s))
        switch (s?.chartType) {
          case o.BarSeries:
          case o.BoxPlotSeries:
          case o.LineSeries:
          case o.HistogramSeries:
            this.seriesColor = t, i && (i.dataStore.seriesColor = t);
            break;
          case o.PieSeries: {
            const l = /* @__PURE__ */ new Map([[0, t]]);
            this.seriesColor = l, i && (i.dataStore.seriesColor = l);
            break;
          }
          case o.ScatterSeries:
        }
    }, this.chartNoRenderPropChange = (e) => {
      const a = e, { propName: t, value: i, model: s } = a.detail, r = this.modelList.find((l) => s?.isSameChartAs(l));
      if (r)
        switch (t) {
          case "rotation":
            typeof i == "boolean" && _(r) && (r.rotatedState = i);
            break;
          case "legendPosition":
            typeof i == "string" && L(r) && (r.legendPosition = i);
            break;
          case "legendVisibility":
            typeof i == "boolean" && L(r) && (r.legendVisibility = i);
            break;
        }
    }, this.chartLegendItemVisibilityChange = async (e) => {
      const a = e, { legendItemVisibility: t, model: i } = a.detail, s = this.modelList.find((r) => i?.isSameChartAs(r));
      s?.setSeriesVisibility(t), S(s) && ((s.getMinBound(1) === null || Number.isNaN(s.getMinBound(1))) && s.setMinBound(null, 1), (s.getMaxBound(1) === null || Number.isNaN(s.getMaxBound(1))) && s.setMaxBound(null, 1), $(s) && ((s.getMinBound(0) === null || Number.isNaN(s.getMinBound(0))) && s.setMinBound(null, 0), (s.getMaxBound(0) === null || Number.isNaN(s.getMaxBound(0))) && s.setMaxBound(null, 0)));
    }, this.onSelectChartTypeChange = (e) => {
      this.currentChartTypeText = "", this.calculatedDataMinMaxBounds = void 0, this.calculatedMinMaxBounds = void 0, this.removeSelectChartTypePopover();
      const { selectedModelType: a, layerId: t } = e.target;
      a !== void 0 && (this.allowChartSyncing = !0, this.arcgisChartsConfigNewChart.emit({
        key: "key",
        chartType: a,
        layerId: t
      }));
    }, this.onAddChartClose = () => {
      this.removeSelectChartTypePopover();
    }, this.onModelConfigChange = (e) => {
      if (this.syncChartsToLayers && this.allowChartSyncing) {
        const a = e.target;
        k(a?.layer, a);
      }
      this.requestUpdate();
    }, this.allowChartSyncing = !1, this.currentChartTypeText = "", this.modelList = [], this.layerList = [], this.disableEditing = !1, this.syncChartsToLayers = !1, this.panelNumber = 0, this.arcgisChartsConfigChartViewChartClose = y(), this.arcgisChartsConfigModelListChange = y(), this.arcgisChartsConfigNewChart = y(), this.arcgisChartsConfigPanelNumberChange = y(), this.arcgisChartsConfigSelectedChartChange = y(), this.listen("arcgisChartsConfigModelListReorder", this.modelListReorderChangeListener);
  }
  static {
    this.properties = { selectedPanel: 16, currentChartTypeText: 16, messageOverrides: 0, modelList: [0, { hasChanged: M }], layerList: [0, { hasChanged: M }], selectedChartId: 3, activeLayerId: 3, disableEditing: 7, syncChartsToLayers: 7, timeZone: 3, headerTitle: 3, open: 7, chartData: [0, { hasChanged: M }], r2: 9, calculatedDataMinMaxBounds: [0, { hasChanged: M }], calculatedMinMaxBounds: [2, { hasChanged: M }], seriesColor: [2, { hasChanged: Y }], popoverPlacement: 3, usePopupTemplateFieldsInfo: 5, panelNumber: 11, filterBySelection: 5 };
  }
  static {
    this.styles = ne;
  }
  async setFocus() {
    this.chartsListFlowItem.value?.setFocus();
  }
  connectedCallback() {
    super.connectedCallback(), this.addChartEventListeners();
  }
  async load() {
    await this.layerListChange();
    const e = this.getModel(this.selectedChartId);
    this.setEventBasedPropsFromModelData(e);
  }
  async willUpdate(e) {
    e.has("layerList") && (this.hasUpdated || this.layerList?.length > 0) && await this.layerListChange(), e.has("panelNumber") && (this.hasUpdated || this.panelNumber !== 0) && this.panelNumberChange(this.panelNumber), e.has("modelList") && (this.hasUpdated || this.modelList?.length > 0) && await this.modelListChange(this.modelList, e.get("modelList")), e.has("selectedChartId") && await this.selectedChartIdChange(this.selectedChartId);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.clearPartialModels(), this.removeSelectChartTypePopover(), this.removeChartEventListeners();
  }
  modelListReorderChangeListener(e) {
    const { modelList: a } = e.detail;
    if (this.modelList = D({
      arrayA: this.modelList,
      arrayB: a,
      getKey: (t) => t.chartId ?? t.titleText ?? ""
    }), this.syncChartsToLayers) {
      const t = a.find((i) => i.layer?.id !== void 0)?.layer?.id;
      if (t) {
        const i = this.layerList.find((s) => s.id.toString() === t);
        i && oe(i, a);
      }
    }
  }
  async layerListChange() {
    const e = [], a = this.layerList.map((i) => i.id.toString()), t = [...this.modelList.filter((i) => a.includes(i.layer?.id ?? ""))];
    for (let i of this.layerList ?? []) {
      if (i.type === "sublayer") {
        const r = await i.createFeatureLayer();
        if (!r)
          continue;
        i = r;
      }
      const s = i;
      for (const r of s.charts ?? []) {
        const l = await V({
          layer: i,
          config: r
        });
        l !== void 0 && e.push(l);
      }
    }
    P(e), e.forEach((i) => {
      t.find((r) => r.isSameChartAs(i)) === void 0 && t.push(i);
    }), this.modelList = t;
  }
  async modelListChange(e, a) {
    this.selectedChartId = P(e, this.selectedChartId), a?.forEach((i) => {
      i.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }), e.forEach((i) => {
      i.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    });
    const t = this.getModel(this.selectedChartId);
    this.currentChartTypeText = t?.chartType !== void 0 ? await T(t.chartType) : "", this.syncChartsToLayers && this.allowChartSyncing && se(this.layerList, e), this.arcgisChartsConfigModelListChange.emit({ modelList: e });
  }
  async selectedChartIdChange(e) {
    this.selectedChartId === void 0 && (this.panelNumber = 0), this.selectedPanel = n.Data;
    const a = this.getModel(e);
    this.setEventBasedPropsFromModelData(a), this.currentChartTypeText = a?.chartType !== void 0 ? await T(a.chartType) : "", e !== void 0 && e !== x.selectedChartId && (x.selectedChartId = e), this.allowChartSyncing = !0, this.arcgisChartsConfigSelectedChartChange.emit({
      key: "key",
      model: a
    });
  }
  panelNumberChange(e) {
    e === 0 ? this.clearPartialModels() : e === 1 && this.removeSelectChartTypePopover(), this.arcgisChartsConfigPanelNumberChange.emit({ panelNumber: e, modelList: this.modelList });
  }
  addChartEventListeners() {
    document.addEventListener(C.DataProcessComplete, this.chartDataProcessComplete), document.addEventListener(C.AxesMinMaxChange, this.chartAxesMinMaxChange), document.addEventListener(C.SeriesColorChange, this.chartSeriesColorChange), document.addEventListener(C.NoRenderPropChange, this.chartNoRenderPropChange), document.addEventListener(C.LegendItemVisibilityChange, this.chartLegendItemVisibilityChange);
  }
  removeChartEventListeners() {
    document.removeEventListener(C.DataProcessComplete, this.chartDataProcessComplete), document.removeEventListener(C.AxesMinMaxChange, this.chartAxesMinMaxChange), document.removeEventListener(C.SeriesColorChange, this.chartSeriesColorChange), document.removeEventListener(C.NoRenderPropChange, this.chartNoRenderPropChange), document.removeEventListener(C.LegendItemVisibilityChange, this.chartLegendItemVisibilityChange);
  }
  getDataExtent(e) {
    const a = this.getModel(this.selectedChartId)?.config;
    let t = [];
    if (a !== void 0 && e !== void 0) {
      const i = z({
        chartConfig: a,
        chartData: e
      }), { minY: s, maxY: r, minX: l, maxX: p } = i;
      t = [
        { isXAxis: !0, minimum: l, maximum: p },
        { isXAxis: !1, minimum: s, maximum: r }
      ];
    }
    return t;
  }
  updateAxesBoundsInAppState(e) {
    e?.forEach((a) => {
      const { isXAxis: t, maximum: i, minimum: s } = a, r = this.getModel(this.selectedChartId);
      if (r !== void 0 && S(r) && this.selectedChartId !== void 0) {
        const l = new J(r, t), p = q({
          chartId: this.selectedChartId,
          isXAxis: t,
          isLogarithmic: l.getLogarithmic()
        }), g = x.chartAxesBoundDataMap;
        g[this.selectedChartId] === void 0 && (g[this.selectedChartId] = {});
        const u = g[this.selectedChartId]?.[p], f = {
          defaultMinBound: u?.defaultMinBound === u?.currMinBound ? s : u?.defaultMinBound,
          currMinBound: s,
          defaultMaxBound: u?.defaultMaxBound === u?.currMaxBound ? i : u?.defaultMaxBound,
          currMaxBound: i
        };
        !B(u, f) && this.selectedChartId !== void 0 && g?.[this.selectedChartId] !== void 0 && (g[this.selectedChartId][p] = f);
      }
    });
  }
  getPlacement() {
    let e;
    if (this.popoverPlacement !== void 0)
      e = this.popoverPlacement;
    else {
      const a = this.modelList?.filter((i) => E(Q, i.config)).length;
      e = Number(a) <= 2 ? "bottom" : "top";
    }
    return e;
  }
  onBackFlow() {
    this.panelNumber -= 1;
  }
  onAddChartClick(e) {
    const { referenceElement: a, layerId: t } = e.detail;
    this.setupSelectChartTypePopover(a, t);
  }
  setupSelectChartTypePopover(e, a) {
    const t = this.getPlacement();
    this.removeSelectChartTypePopover(), this.selectChartTypePopover = I(c`<arcgis-charts-config-select-chart-type-popover .referenceElement=${e} open .layerId=${a} .popoverPlacement=${t} @arcgisChartsConfigPopoverClose=${this.onAddChartClose} @arcgisChartsConfigSelectChartTypeChange=${this.onSelectChartTypeChange}></arcgis-charts-config-select-chart-type-popover>`), !document.body.contains(this.selectChartTypePopover) && this.selectChartTypePopover !== null && document.body.appendChild(this.selectChartTypePopover);
  }
  getModel(e) {
    return this.modelList?.find((a) => a.chartId === e);
  }
  removeSelectChartTypePopover() {
    this.selectChartTypePopover !== void 0 && (this.selectChartTypePopover?.remove(), this.selectChartTypePopover = W(this.selectChartTypePopover));
  }
  clearPartialModels() {
    this.modelList = this.modelList.filter((e) => !w(e.config));
  }
  onViewChartDelete(e) {
    const { chartId: a } = e.detail;
    if (a !== void 0) {
      const t = this.modelList.find((s) => s.chartId === a), i = this.layerList.find((s) => s.id === t?.layer?.id);
      this.modelList = [...this.modelList.filter((s) => s.chartId !== a)], i && this.syncChartsToLayers && this.allowChartSyncing && re(i, a);
    }
  }
  onViewChartsSelect(e) {
    this.selectedChartId === e.detail.chartId && (this.allowChartSyncing = !0, this.arcgisChartsConfigSelectedChartChange.emit({
      key: "key",
      model: this.getModel(this.selectedChartId)
    })), this.selectedChartId = e.detail.chartId;
  }
  onViewChartsEdit(e) {
    this.onViewChartsSelect(e), this.panelNumber = 1;
  }
  onViewChartClose() {
    this.open = !1, this.removeSelectChartTypePopover(), this.arcgisChartsConfigChartViewChartClose.emit();
  }
  setEventBasedPropsFromModelData(e) {
    this.chartData = e?.dataStore.chartData, this.r2 = e?.dataStore.r2, this.seriesColor = e?.dataStore.seriesColor, this.calculatedMinMaxBounds = e?.dataStore.calculatedMinMaxBounds, this.calculatedDataMinMaxBounds = e?.dataStore.calculatedDataMinMaxBounds;
  }
  createTooltip(e) {
    const a = e.target;
    let t = "";
    switch (a.icon) {
      case "configure":
        t = this._messages.data ?? "";
        break;
      case "graph-bar-stacked":
      case "graph-line-series":
      case "box-chart-series":
        t = this._messages.series ?? "";
        break;
      case "graph-pie-slice":
        t = this._messages.slices ?? "";
        break;
      case "graph-axis":
        t = this._messages.axes ?? "";
        break;
      case "graph-guides":
        t = this._messages.guides ?? "";
        break;
      case "palette":
        t = this._messages.format ?? "";
        break;
      case "text":
        t = this._messages.general ?? "";
        break;
      default:
        t = "";
        break;
    }
    this.tooltip = I(c`<calcite-tooltip style=${X({ opacity: 1, zIndex: "var(--calcite-floating-ui-z-index)" })} .referenceElement=${a} open placement=top>${t}</calcite-tooltip>`), document.body.appendChild(this.tooltip);
  }
  destroyTooltip() {
    ee(this.tooltip);
  }
  renderViewCharts() {
    const e = ie({
      modelList: this.modelList,
      layerList: this.layerList,
      activeLayerId: this.activeLayerId,
      disableEditing: this.disableEditing
    });
    return N(e, (a) => a.id, (a) => c`<arcgis-charts-config-view-charts .noGroup=${this.activeLayerId !== void 0} .modelList=${ae(this.modelList, a.id.toString(), this.supportedChartTypes)} .selectedChartId=${this.selectedChartId ?? ""} .layer=${a} .disableEditing=${this.disableEditing} @arcgisChartsConfigViewChartSelect=${this.onViewChartsSelect} @arcgisChartsConfigViewChartEdit=${this.onViewChartsEdit} @arcgisChartsConfigViewChartDelete=${this.onViewChartDelete} @arcgisChartsConfigViewChartAddChart=${this.onAddChartClick}></arcgis-charts-config-view-charts>`);
  }
  render() {
    return this.open !== !1 ? c`<calcite-flow>${v("charts-list", c`<calcite-flow-item .selected=${this.panelNumber === 0 || this.disableEditing} .heading=${this.headerTitle ?? this._messages.defaultHeaderTitle} closable @calciteFlowItemClose=${this.onViewChartClose} ${j(this.chartsListFlowItem)}>${this.renderViewCharts()}</calcite-flow-item>`)}${this.renderTabs()}</calcite-flow>` : null;
  }
  renderTabs() {
    const e = this.getModel(this.selectedChartId);
    return v("chart-edit", c`<calcite-flow-item .selected=${this.panelNumber >= 1 && !this.disableEditing} @calciteFlowItemBack=${this.onBackFlow} .heading=${this._messages[this.selectedPanel ?? n.Data]} .description=${this.currentChartTypeText !== "" && this._messages.pageFlowTitle !== void 0 ? H(this._messages.pageFlowTitle, {
      chartName: e?.titleText ?? this.currentChartTypeText,
      layerName: e?.layer?.title ?? ""
    }) : ""}>${e?.chartType !== void 0 ? c`<calcite-action-bar class=${h(d.tabBar)} layout=horizontal expand-disabled><calcite-action class=${h(d.tab)} icon=configure scale=s alignment=center .active=${this.selectedPanel === n.Data || this.selectedPanel === void 0} @click=${() => {
      this.selectedPanel = n.Data;
    }} @mouseover=${this.createTooltip} @mouseout=${this.destroyTooltip} text></calcite-action>${e?.chartType === o.BarSeries ? c`<calcite-action class=${h(d.tab)} icon=graph-bar-stacked scale=s alignment=center .active=${this.selectedPanel === n.Series} @click=${() => {
      this.selectedPanel = n.Series;
    }} @mouseover=${this.createTooltip} @mouseout=${this.destroyTooltip} text></calcite-action>` : null}${e?.chartType === o.LineSeries ? c`<calcite-action class=${h(d.tab)} icon=graph-line-series scale=s alignment=center .active=${this.selectedPanel === n.Series} @click=${() => {
      this.selectedPanel = n.Series;
    }} @mouseover=${this.createTooltip} @mouseout=${this.destroyTooltip} text></calcite-action>` : null}${e?.chartType === o.BoxPlotSeries ? c`<calcite-action class=${h(d.tab)} icon=box-chart-series scale=s alignment=center .active=${this.selectedPanel === n.Series} @click=${() => {
      this.selectedPanel = n.Series;
    }} @mouseover=${this.createTooltip} @mouseout=${this.destroyTooltip} text></calcite-action>` : null}${e?.chartType === o.PieSeries ? c`<calcite-action class=${h(d.tab)} icon=graph-pie-slice scale=s alignment=center .active=${this.selectedPanel === n.Slices} @click=${() => {
      this.selectedPanel = n.Slices;
    }} @mouseover=${this.createTooltip} @mouseout=${this.destroyTooltip} text></calcite-action>` : null}${e?.chartType !== o.PieSeries ? c`<calcite-action class=${h(d.tab)} icon=graph-axis scale=s alignment=center .active=${this.selectedPanel === n.Axes} @click=${() => {
      this.selectedPanel = n.Axes;
    }} @mouseover=${this.createTooltip} @mouseout=${this.destroyTooltip} text></calcite-action>` : null}${e?.chartType !== o.PieSeries ? c`<calcite-action class=${h(d.tab)} icon=graph-guides scale=s alignment=center .active=${this.selectedPanel === n.Guides} @click=${() => {
      this.selectedPanel = n.Guides;
    }} @mouseover=${this.createTooltip} @mouseout=${this.destroyTooltip} text></calcite-action>` : null}<calcite-action class=${h(d.tab)} icon=palette scale=s alignment=center .active=${this.selectedPanel === n.Format} @click=${() => {
      this.selectedPanel = n.Format;
    }} @mouseover=${this.createTooltip} @mouseout=${this.destroyTooltip} text></calcite-action><calcite-action class=${h(d.tab)} icon=text scale=s alignment=center .active=${this.selectedPanel === n.General} @click=${() => {
      this.selectedPanel = n.General;
    }} @mouseover=${this.createTooltip} @mouseout=${this.destroyTooltip} text></calcite-action></calcite-action-bar>` : null}${this.renderChartUIComponent()}</calcite-flow-item>`);
  }
  renderChartUIComponent() {
    const e = this.getModel(this.selectedChartId), a = e?.layer;
    let t = null;
    if (e !== void 0 && !this.disableEditing)
      switch (e?.chartType) {
        case "barSeries":
          t = c`<arcgis-charts-config-bar-chart class=${h(d.chartUIComponent)} .model=${e} .timeZone=${this.timeZone} .usePopupTemplateFieldsInfo=${this.usePopupTemplateFieldsInfo} .layer=${a} .page=${this.selectedPanel ?? n.Data} .calculatedMinMaxBounds=${this.calculatedMinMaxBounds} .seriesColor=${this.seriesColor}></arcgis-charts-config-bar-chart>`;
          break;
        case "lineSeries":
          t = c`<arcgis-charts-config-line-chart class=${h(d.chartUIComponent)} .model=${e} .timeZone=${this.timeZone} .usePopupTemplateFieldsInfo=${this.usePopupTemplateFieldsInfo} .layer=${a} .page=${this.selectedPanel ?? n.Data} .calculatedDataMinMaxBounds=${this.calculatedDataMinMaxBounds} .calculatedMinMaxBounds=${this.calculatedMinMaxBounds} .seriesColor=${this.seriesColor}></arcgis-charts-config-line-chart>`;
          break;
        case "pieSeries":
          t = c`<arcgis-charts-config-pie-chart class=${h(d.chartUIComponent)} .model=${e} .usePopupTemplateFieldsInfo=${this.usePopupTemplateFieldsInfo} .layer=${a} .chartData=${this.chartData} .page=${this.selectedPanel ?? n.Data} .calculatedMinMaxBounds=${this.calculatedMinMaxBounds} .seriesColor=${this.seriesColor} .filterBySelection=${this.filterBySelection}></arcgis-charts-config-pie-chart>`;
          break;
        case "histogramSeries":
          t = c`<arcgis-charts-config-histogram class=${h(d.chartUIComponent)} .model=${e} .usePopupTemplateFieldsInfo=${this.usePopupTemplateFieldsInfo} .layer=${a} .page=${this.selectedPanel ?? n.Data} .chartData=${this.chartData} .calculatedMinMaxBounds=${this.calculatedMinMaxBounds} .seriesColor=${this.seriesColor}></arcgis-charts-config-histogram>`;
          break;
        case "scatterSeries":
          t = c`<arcgis-charts-config-scatter-plot class=${h(d.chartUIComponent)} .model=${e} .usePopupTemplateFieldsInfo=${this.usePopupTemplateFieldsInfo} .layer=${a} .page=${this.selectedPanel ?? n.Data} .r2=${this.r2} .calculatedDataMinMaxBounds=${this.calculatedDataMinMaxBounds} .calculatedMinMaxBounds=${this.calculatedMinMaxBounds}></arcgis-charts-config-scatter-plot>`;
          break;
        case "boxPlotSeries":
          t = c`<arcgis-charts-config-box-plot class=${h(d.chartUIComponent)} .model=${e} .usePopupTemplateFieldsInfo=${this.usePopupTemplateFieldsInfo} .layer=${a} .page=${this.selectedPanel ?? n.Data} .calculatedMinMaxBounds=${this.calculatedMinMaxBounds} .seriesColor=${this.seriesColor}></arcgis-charts-config-box-plot>`;
          break;
      }
    return t;
  }
}
F("arcgis-charts-config-create-flow", le);
export {
  le as ArcgisChartsConfigCreateFlow
};
