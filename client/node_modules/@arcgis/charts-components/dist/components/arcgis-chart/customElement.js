import { c as Bm } from "../../chunks/runtime.js";
import { LitElement as Mm, createEvent as St, safeClassMap as cl } from "@arcgis/lumina";
import Nm from "html2canvas";
import Pm from "jszip";
import { html as _o, css as Vm } from "lit";
import { createRef as Em, ref as dl } from "lit/directives/ref.js";
import { cloneDeep as Ge, debounce as Ye, isEqual as fo, isEmpty as ka } from "lodash-es";
import { d as Y, W as b, u as z, g as Ln, e as Ie, S as kc, a as Wt, j as Ht, i as xe, r as Ui, v as zm, o as ke, s as ul, l as Wm, m as Ic, h as fl, q as Ia, p as Hm } from "../../chunks/series-types.js";
import { substitute as Ra } from "@arcgis/core/intl.js";
import ml from "@arcgis/core/layers/FeatureLayer.js";
import { color as mo, percent as gt, LinePattern as wc, RectanglePattern as Gm, p50 as Ae, p0 as Ke, p100 as Te, Label as yi, Rectangle as zs, DateFormatter as Xm, NumberFormatter as $c, Series as Ws, HeatLegend as Dc, Container as Gi, Legend as Fn, Scrollbar as Fs, SerialChart as Ba, Tooltip as za, Template as Wa, Graphics as ui, Bullet as Ti, RoundedRectangle as go, Slice as Ma, Timezone as Ym, DataItem as Um, Color as jm, Modal as qm, addLicense as _m, registry as Zm, Root as Km } from "@amcharts/amcharts5";
import { PieChart as ti, PieSeries as ht } from "@amcharts/amcharts5/percent.js";
import { AxisRendererCircular as fi, RadarCursor as Oc, ClockHand as As, RadarChart as ji, AxisRendererRadial as Qm, RadarLineSeries as Hs } from "@amcharts/amcharts5/radar.js";
import { XYChart as Se, AxisRendererX as $t, LineSeries as ge, XYCursor as Rc, ColumnSeries as Ee, StepLineSeries as An, CandlestickSeries as ua, DateAxis as tt, ValueAxis as we, XYSeries as Gs, CategoryAxis as Ct, AxisRendererY as qi, AxisBullet as Jm } from "@amcharts/amcharts5/xy.js";
import { unsafeGetElementDirection as Xs } from "@arcgis/toolkit/dom";
import { getElementLocale as Tn } from "@arcgis/toolkit/intl";
import { c as an } from "../../chunks/index.js";
import { p as U, cC as P, d as ii, a2 as ei, ci as De, aF as on, X as Io, a6 as ai, Y as kn, cm as ye, m as eg, l as Ki, k as ki, U as Na, P as J, G as be, a4 as Me, ck as Bc, K as Ys, O as $e, cc as jt, ce as zt, cs as He, c7 as pt, cg as Mc, q as Ha, ag as Us, ai as Nc, bd as tg, be as ig, ar as js, as as Pc, ah as In, cb as Ii, cD as Ne, cG as ho, cq as nn, aS as Vc, bE as Ec, I as wi, c0 as qs, ba as qt, bW as Si, bX as _s, b6 as wn, bj as Zs, a3 as Ks, E as $i, N as $n, M as ag, B as Qs, ad as wo, aB as zc, ao as Js, F as po, aq as Wc, ap as Hc, a as wa, $ as Gc, bi as Xc, L as Yc, D as bi, c9 as sn, b9 as bo, x as er, b7 as ro, b$ as rn, i as Uc, aZ as jc, a5 as og, H as ng, bH as sg, cd as gl, ch as rg, r as lg, c6 as Ho, y as oo, s as cg, g as dg, cr as ug, C as fg, bt as hl, cu as mg, h as gg } from "../../chunks/interfaces.js";
import { A as K, C as fs } from "../../chunks/interfaces2.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import { h as qc, l as _c, d as Dn, g as Zc, c as hg } from "../../chunks/index3.js";
import { b as ln, d as $a, c as Kc, q as Qc, s as ms, t as pg, r as bg, h as hi, u as On } from "../../chunks/index4.js";
import { i as Di, s as Ga, C as A, a as ft, e as Rn, m as Jc, g as oi, b as yg, c as ni, d as bt, f as qe, n as ed, h as si, j as tr, k as yo, l as mi, o as Lt, p as Ft, q as Bt, t as Xa, u as td, v as $o, w as Qi, x as id, R as cn, y as ad, z as Oi, A as od, B as nd, D as sd, E as rd, F as ld, G as dn, H as cd, I as fa, J as Do, K as dd, L as ir, M as Sg, N as pl, O as Ya, P as Ji, Q as Oo, S as Ua, T as xg, U as ar, V as or, W as ud, X as Bn, Y as fd, Z as md, _ as Mn, $ as ja, a0 as qa, a1 as xi, a2 as ea, a3 as gd, a4 as hd, a5 as Nn, a6 as Cg, a7 as pd, a8 as bd, a9 as nr, aa as vg, ab as yd, ac as sr, ad as Lg, ae as Fg, af as Sd, ag as xd, ah as Ts, ai as Pn, aj as rr, ak as Ag, al as Cd, am as Tg, an as kg, ao as Ig, ap as wg, aq as $g, ar as Dg, as as Og, at as Rg, au as Bg, av as bl, aw as yl, ax as Mg, ay as Ng, r as Pg } from "../../chunks/config-update.js";
import { range as Vg } from "d3-array";
import { C as G } from "../../chunks/interfaces4.js";
import { c as at, b as dt, d as xt, R as te, i as gs, e as se, f as ee, a as Eg, j as hs } from "../../chunks/rest-js-object-literals.js";
import { v5 as un } from "uuid";
import zg from "@amcharts/amcharts5/themes/Animated.js";
import Wg from "@amcharts/amcharts5/themes/Responsive.js";
import { LineSeriesDataItem as ta, DateAxis as ze, ValueAxis as ve, CategoryAxis as lt, CategoryAxisDataItem as Pa, DateAxisDataItem as Vn, XYChart as ne, PieChart as Le, AxisFill as Hg, AxisFillCircular as Gg, LineSeries as ue, ColumnSeries as Xe, PieSeries as Nt, GaugeChart as yt, XYCursor as vd, XYSeries as Ci, SerialChart as Ld, Cursor as Xg, AxisLabel as lr, ColumnSeriesDataItem as Ro, CandlestickSeries as _e, StepLineSeries as vt, LegendDataItem as ia, CandlestickSeriesDataItem as Yg, PieSeriesDataItem as ri, Legend as Ug, Series as jg, AxisRendererX as wt, AxisRendererCircular as En, AxisLabelCircular as cr, ValueAxisDataItem as dr, AxisRendererY as Va, ClockHand as qg } from "@amcharts/amcharts4/charts.js";
import { Exporting as _g } from "@amcharts/amcharts5/plugins/exporting.js";
import { isLight as Zg } from "@amcharts/amcharts5/.internal/core/util/Utils.js";
import { curveLinearClosed as Kg, curveLinear as Qg, curveCardinal as Jg, curveBumpY as eh, curveBumpX as th } from "d3-shape";
import { DateFormatter as Fd, NumberFormatter as Ad, Group as ih, Color as fn, percent as ot, LinePattern as Td, RectPattern as kd, color as zn, MouseCursorStyle as Gt, Label as So, DropShadowFilter as ah, Sprite as ur, utils as Id, Polygon as wd, Container as fr, Tooltip as $d, RoundedRectangle as oh, Percent as mn, Slice as Dd, options as lo, useTheme as nh, unuseTheme as sh, create as mr } from "@amcharts/amcharts4/core.js";
import Sl from "@amcharts/amcharts4/themes/animated.js";
import "@amcharts/amcharts4/.internal/charts/axes/Axis.js";
import { isLight as rh } from "@amcharts/amcharts4/.internal/core/utils/Colors.js";
import { Scrollbar as xl } from "@amcharts/amcharts4/.internal/core/elements/Scrollbar.js";
import { u as Cl } from "../../chunks/useT9n.js";
import { f as lh } from "../../chunks/interfaces3.js";
import { i as xo, a as ch, b as dh } from "../../chunks/type-guards.js";
import { createModel as uh } from "../../model.js";
import { L as Zo, b as Ko, c as Qo, S as Jo, V as no, A as vl, E as Go, C as fh } from "../../chunks/index5.js";
import { u as mh, o as gh } from "../../chunks/action-bar-utils.js";
import { n as Ll } from "../../chunks/chart-ui-utils2.js";
import { t as Fl, b as Al, D as hh, m as ph } from "../../chunks/web-component-utils.js";
import * as pi from "@arcgis/core/core/reactiveUtils.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
var Xo = { exports: {} }, ps, Tl;
function bh() {
  if (Tl) return ps;
  Tl = 1;
  function t(e) {
    var i = new e(), a = i;
    function o() {
      var s = i;
      return s.next ? i = s.next : (i = new e(), a = i), s.next = null, s;
    }
    function n(s) {
      a.next = s, a = s;
    }
    return {
      get: o,
      release: n
    };
  }
  return ps = t, ps;
}
var kl;
function yh() {
  if (kl) return Xo.exports;
  kl = 1;
  var t = bh();
  function e(n, s, r) {
    if (typeof n == "function" && (r = s, s = n, n = null), r < 1)
      throw new Error("fastqueue concurrency must be greater than 1");
    var l = t(a), c = null, u = null, d = 0, m = null, g = {
      push: v,
      drain: i,
      saturated: i,
      pause: y,
      paused: !1,
      concurrency: r,
      running: h,
      resume: x,
      idle: C,
      length: p,
      getQueue: S,
      unshift: F,
      empty: i,
      kill: k,
      killAndDrain: $,
      error: O
    };
    return g;
    function h() {
      return d;
    }
    function y() {
      g.paused = !0;
    }
    function p() {
      for (var D = c, R = 0; D; )
        D = D.next, R++;
      return R;
    }
    function S() {
      for (var D = c, R = []; D; )
        R.push(D.value), D = D.next;
      return R;
    }
    function x() {
      if (g.paused) {
        g.paused = !1;
        for (var D = 0; D < g.concurrency; D++)
          d++, T();
      }
    }
    function C() {
      return d === 0 && g.length() === 0;
    }
    function v(D, R) {
      var M = l.get();
      M.context = n, M.release = T, M.value = D, M.callback = R || i, M.errorHandler = m, d === g.concurrency || g.paused ? u ? (u.next = M, u = M) : (c = M, u = M, g.saturated()) : (d++, s.call(n, M.value, M.worked));
    }
    function F(D, R) {
      var M = l.get();
      M.context = n, M.release = T, M.value = D, M.callback = R || i, d === g.concurrency || g.paused ? c ? (M.next = c, c = M) : (c = M, u = M, g.saturated()) : (d++, s.call(n, M.value, M.worked));
    }
    function T(D) {
      D && l.release(D);
      var R = c;
      R ? g.paused ? d-- : (u === c && (u = null), c = R.next, R.next = null, s.call(n, R.value, R.worked), u === null && g.empty()) : --d === 0 && g.drain();
    }
    function k() {
      c = null, u = null, g.drain = i;
    }
    function $() {
      c = null, u = null, g.drain(), g.drain = i;
    }
    function O(D) {
      m = D;
    }
  }
  function i() {
  }
  function a() {
    this.value = null, this.callback = i, this.next = null, this.release = i, this.context = null, this.errorHandler = null;
    var n = this;
    this.worked = function(r, l) {
      var c = n.callback, u = n.errorHandler, d = n.value;
      n.value = null, n.callback = i, n.errorHandler && u(r, d), c.call(n.context, r, l), n.release(n);
    };
  }
  function o(n, s, r) {
    typeof n == "function" && (r = s, s = n, n = null);
    function l(y, p) {
      s.call(this, y).then(function(S) {
        p(null, S);
      }, p);
    }
    var c = e(n, l, r), u = c.push, d = c.unshift;
    return c.push = m, c.unshift = g, c.drained = h, c;
    function m(y) {
      var p = new Promise(function(S, x) {
        u(y, function(C, v) {
          if (C) {
            x(C);
            return;
          }
          S(v);
        });
      });
      return p.catch(i), p;
    }
    function g(y) {
      var p = new Promise(function(S, x) {
        d(y, function(C, v) {
          if (C) {
            x(C);
            return;
          }
          S(v);
        });
      });
      return p.catch(i), p;
    }
    function h() {
      var y = c.drain, p = new Promise(function(S) {
        c.drain = function() {
          y(), S();
        };
      });
      return p;
    }
  }
  return Xo.exports = e, Xo.exports.promise = o, Xo.exports;
}
var Sh = yh();
const zi = {
  Show: "show",
  Hide: "hide",
  NotifyPanel: "notifyPanel",
  DisableInteractions: "disable-interactions",
  Chart: "chart"
};
function xh(t) {
  const { dataContext: e, dataIndex: i, objectIdField: a } = t;
  return `${ei.sliceIdPrefix}-${e[a ?? ""]?.toString() ?? i}`;
}
function Ch(t) {
  const { chartConfig: e, chartData: i, fieldList: a } = t, o = U(e.series) === P.PieFromFields;
  if (e.orderOptions?.data !== void 0 || o) {
    Ga({
      arrayToSort: i,
      chartConfig: e,
      fieldList: a
    });
    const { slices: n } = e.series[0];
    n !== void 0 && n.sort((s, r) => {
      const l = i.findIndex(
        (u) => u[G.pieChart.technicalFieldSliceId] === s.sliceId
      ), c = i.findIndex(
        (u) => u[G.pieChart.technicalFieldSliceId] === r.sliceId
      );
      return l - c;
    });
  }
}
function Wn(t) {
  const { data: e, newChartConfig: i, pieSlicesSymbols: a, fieldList: o } = t, n = i.series[0], s = U(i.series) === P.PieFromFields ? ii : n.x;
  e.forEach((r) => {
    const l = Di(r), c = r[G.pieChart.technicalFieldSliceId], u = l ? n.sliceGrouping?.label : gn(a?.slices, c)?.label;
    vh({ dataContext: r, x: s, newLabel: u });
  }), Ch({ chartConfig: i, chartData: e, fieldList: o });
}
function vh(t) {
  const { dataContext: e, newLabel: i, x: a } = t;
  i === void 0 ? e[G.originalCategoryValue] !== void 0 && (e[a] = e[G.originalCategoryValue]) : e[a] !== i && (e[G.originalCategoryValue] === void 0 && (e[G.originalCategoryValue] = e[a]), e[a] = i);
}
function gn(t, e) {
  let i;
  return t !== void 0 && e !== void 0 && (i = t.find((a) => a.sliceId === e)), i;
}
function Od(t) {
  const { dataContext: e, isNonAggregatedChart: i, x: a, dataIndex: o, objectIdField: n, isPieFromFields: s } = t;
  let r = "";
  return s === !0 ? r = e[G.originalCategoryValue] ?? e[ii] : i ? r = xh({
    dataContext: e,
    dataIndex: o,
    objectIdField: n
  }) : (r = e[G.typeOrDomainIdValue] ?? e[G.originalCategoryValue], r === "" ? r = ei.emptySliceId : r === null && (r = ei.nullSliceId), r = r ?? e[a]), r === void 0 && (r = ei.undefinedSliceId), r.toString();
}
function Rd(t) {
  const {
    dataContext: e,
    sliceFromConfig: i,
    isGroupOfSlices: a,
    seriesConfig: o,
    fieldList: n,
    isPieFromFields: s,
    labelUpdateNeeded: r,
    colorMatch: l,
    utilsStrings: c
  } = t, { sliceGrouping: u } = o;
  let { x: d } = o;
  s && (d = ii);
  const m = e[d] ?? e[G.originalCategoryValue], g = e[G.originalCategoryValue] ?? m;
  let h = m;
  if (r) {
    if (a)
      h = u?.label ?? u?.originalLabel?.toString() ?? c.pieChart.defaultSliceGroupingLabel;
    else if (l && e[G.rendererSymbolField]?.label !== void 0)
      h = e[G.rendererSymbolField].label;
    else if (i !== void 0 || n !== void 0) {
      h = i?.label ?? g;
      const y = e[G.typeOrDomainIdValue];
      y !== void 0 && h?.toString() === y?.toString() ? h = g : h === g && g !== void 0 && g !== null && (h = De(n, g));
    } else i === void 0 && (h = g);
    h === G.nullValue ? h = "null" : h != null && (h = h.toString());
  }
  return h;
}
function Bd(t, e) {
  return t[0]?.sliceGrouping?.percentageThreshold !== e[0]?.sliceGrouping?.percentageThreshold;
}
function Bo(t) {
  const { groupOfSlicesDataContext: e, chartData: i } = t;
  return (e ?? i?.find((n) => n[ei.defaultGroupOfSlicesId] === !0))?.[G.pieChart.technicalFieldGroupedSlices];
}
function gr(t) {
  const { dataContext: e, pieSlicesSymbols: i, seriesConfig: a } = t;
  let o = a.fillSymbol ? { ...a.fillSymbol } : on();
  if (Di(e))
    o = {
      ...G.pieChart.sliceGrouping.fillSymbol,
      ...i?.groupOfSlices?.fillSymbol
    };
  else {
    const s = e[G.pieChart.technicalFieldSliceId], r = i?.slices?.find(
      (l) => l.sliceId === s
    );
    o = Ge(r?.fillSymbol ?? a.fillSymbol ?? on());
  }
  return o;
}
const Lh = "arcgis-charts-randomization-seed", Md = un(Lh, un.URL), ae = {
  XAxisTitle: "XAxisTitle",
  YAxisTitle: "YAxisTitle",
  ChartTitle: "ChartTitle",
  ChartSubTitle: "ChartSubTitle",
  ChartFooter: "ChartFooter",
  GuideLabel: "GuideLabel",
  LegendTitle: "LegendTitle"
}, Fh = "AM5C241025748", le = {
  SelectEnded: "selectended",
  DataValidated: "datavalidated",
  Opened: "opened",
  BoundsChanged: "boundschanged",
  PointerUp: "pointerup",
  FrameEnded: "frameended",
  Click: "click"
}, ks = /* @__PURE__ */ new Map();
function Ah(t, e) {
  return ga(t, e);
}
function Th(t, e) {
  ma(t, e);
}
function ma(t, e) {
  const i = ks.get(t) ?? {};
  ks.set(t, { ...i, ...e });
}
function ga(t, e) {
  return ks.get(t)?.[e];
}
function w(t, e) {
  return ga(t, e);
}
function de(t, e) {
  ma(t, e);
}
function he(t, e) {
  return ga(t, e);
}
function Pe(t, e) {
  ma(t, e);
}
function _i(t, e) {
  return ga(t, e);
}
function _a(t, e) {
  ma(t, e);
}
function Ri(t, e) {
  return ga(t, e);
}
function kh(t, e) {
  ma(t, e);
}
function At(t, e) {
  return ga(t, e);
}
function hr(t, e) {
  ma(t, e);
}
function Ih(t, e) {
  return ga(t, e);
}
function wh(t, e) {
  ma(t, e);
}
const ce = {
  Guides: "guides",
  Ticks: "ticks",
  GaugeFirstAndLastGuides: "firstAndLast",
  GaugeTicksWithLabels: "gaugeTicksWithLabels"
};
function $h(t, e) {
  e === !0 && t.setThemes([Wg.new(t)]);
}
function Dh(t, e) {
  e === !0 && t.setThemes([zg.new(t)]);
}
function re(t) {
  let e = mo("#000000"), i = Io;
  if (t != null) {
    const [a, o, n, s] = t;
    i = s / 255, e = mo(`rgba(${a}, ${o}, ${n}, ${i})`);
  }
  return { color: e, opacity: i };
}
function Re(t, e) {
  e === !1 && (!("isHiding" in t) || !t.isHiding()) ? (t.set("visible", !1), "hide" in t && t.hide()) : e !== !1 && (!("isShowing" in t) || !t.isShowing()) && (t.set("visible", !0), "show" in t && t.show());
}
function Ce(t) {
  const { childId: e, parent: i, useChildId: a } = t, o = a ? e : Xt(e, i.uid);
  return i.children.values.find((n) => n.get("id") === o);
}
function Xt(t, e) {
  return `${t}${e}`;
}
function Za(t, e = 100) {
  return setTimeout(() => t(), e);
}
function Il(t) {
  let e = Number.NaN;
  if (typeof t == "number")
    e = t;
  else if (t.includes("%")) {
    const i = Number.parseFloat(t.trim().replace("%", "").trim());
    Number.isFinite(i) && (e = gt(i));
  }
  return e;
}
function Oh(t, e) {
  return e !== !0 || t?.includes("Dot") === !0 ? "round" : "square";
}
function Rh(t, e) {
  const i = t ?? at.Solid, a = e ?? A.lineWidth, o = {
    [at.Solid]: [],
    [at.Dot]: [1, a],
    [at.DashDotDot]: [4 * a, a, 1, a, 1, a],
    [at.Dash]: [4 * a, 3 * a],
    [at.DashDot]: [4 * a, 3 * a, 1, 3 * a],
    [at.Null]: []
  };
  return o[i] ?? o[at.Null];
}
function Bh(t) {
  const { root: e, fill: i, rotation: a, isLinePattern: o } = t;
  let n;
  return o !== !1 ? n = wc.new(e, {
    width: A.patternLineProperties.width ?? Number.NaN,
    height: A.patternLineProperties.height ?? Number.NaN,
    strokeWidth: A.patternLineProperties.strokeWidth ?? Number.NaN,
    fill: i,
    // TODO: or is it `color`?
    rotation: a ?? Number.NaN
  }) : n = Gm.new(e, {
    // rectWidth: ChartDefaults.patternRectProperties.rectWidth ?? Number.NaN,
    // rectHeight: ChartDefaults.patternRectProperties.rectHeight ?? Number.NaN,
    // width: ChartDefaults.patternRectProperties.width ?? Number.NaN,
    // height: ChartDefaults.patternRectProperties.height ?? Number.NaN,
    // backgroundOpacity: ChartDefaults.patternRectProperties.backgroundOpacity ?? Number.NaN,
    // fillOpacity: ChartDefaults.patternRectProperties.fillOpacity ?? Number.NaN,
    // strokeWidth: ChartDefaults.patternRectProperties.strokeWidth ?? Number.NaN,
    // fill: EsriColorToAmChartsColor(ChartDefaults.color),
    // backgroundFill: fill,
    // rotation: rotation ?? Number.NaN
  }), n;
}
function Mh(t) {
  const { fill: e, root: i, style: a } = t;
  let o, n, s = !0;
  switch (a) {
    case dt.Horizontal: {
      n = 0;
      break;
    }
    case dt.Vertical: {
      n = 90;
      break;
    }
    case dt.ForwardDiagonal: {
      n = 45;
      break;
    }
    case dt.BackwardDiagonal: {
      n = 135;
      break;
    }
    case dt.DiagonalCross:
    case dt.Cross: {
      n = 0, s = !1;
      break;
    }
    case dt.Solid:
  }
  return n !== void 0 && i !== void 0 && (o = Bh({ root: i, fill: e, rotation: n, isLinePattern: s })), o;
}
function Nd(t, e = 0) {
  return (t ?? e) % 360;
}
function Nh(t, e) {
  let i = "";
  const n = (e ?? 0) / 2, s = 0 - n, r = 0 + n, l = 0 - n, c = 0 + n;
  switch (t) {
    case xt.Circle:
      i = `M ${s},0 a ${n},${n} 0 1,0 ${n * 2},0 a ${n},${n} 0 1,0 ${-n * 2},0`;
      break;
    case xt.Cross:
      i = `M ${s},0 L ${r},0 M 0,${l} L 0,${c} E`;
      break;
    case xt.Diamond:
      i = `M ${s},0 L 0,${l} L ${r},0 L 0,${c} L ${s},0 Z`;
      break;
    case xt.Square:
      i = `M ${s},${c} L ${s},${l} L ${r},${l} L ${r},${c} L ${s},${c} Z`;
      break;
    case xt.Triangle:
      i = `M ${s},${c} L 0,${l} L ${r},${c} L ${s},${c} Z`;
      break;
    case xt.X:
      i = `M ${s},${c} L ${r},${l} M ${s},${l} L ${r},${c} E`;
      break;
  }
  return i;
}
function Pd(t, e) {
  const i = {
    stroke: re().color,
    strokeWidth: A.lineWidth,
    strokeDasharray: [],
    linecap: e !== !0 ? "round" : "square",
    strokeOpacity: Io
  };
  if (t != null) {
    const a = re(t.color);
    i.stroke = a.color, t.width !== void 0 && (i.strokeWidth = t.width, i.strokeOpacity = t.width === 0 ? 0 : a.opacity), t.style !== void 0 && t.style !== at.Null && (i.strokeDasharray = Rh(t.style, i.strokeWidth), i.linecap = Oh(t.style, e));
  }
  return i;
}
function Vd(t, e) {
  let i = t;
  const [a, o, n, s] = t?.color ?? e ?? A.color, r = [a, o, n, s];
  return i == null ? i = { type: te.SLS, color: r } : i.color === void 0 && (i.color = r), Pd(i, !1);
}
function Ph(t, e) {
  const { color: i, outline: a, style: o } = t, n = re(i);
  return {
    pattern: Mh({ root: e, fill: n.color, style: o }),
    fill: n.color,
    outline: Vd(a, i),
    fillOpacity: n.opacity
  };
}
function Vh(t) {
  const { color: e, style: i, size: a, outline: o, xoffset: n, yoffset: s, angle: r } = t, l = Nd(r), c = i !== void 0 ? Nh(i, a) : "", u = re(e);
  return {
    path: c,
    fill: u.color,
    outline: Vd(o, e),
    xOffset: n ?? 0,
    yOffset: s ?? 0,
    angle: l,
    fillOpacity: u.opacity
  };
}
function Eh(t) {
  let e;
  switch (t) {
    case gs.LineThrough:
    case gs.Underline:
      e = t;
      break;
    case gs.None:
  }
  return e;
}
function zh(t) {
  return t === !0 ? "wrap" : "none";
}
function Ed(t, e) {
  let i = Ae;
  switch (t ?? e) {
    case se.Right:
      i = Te;
      break;
    case se.Left:
      i = Ke;
      break;
    case se.Center:
    case se.Justify:
  }
  return i;
}
function zd(t, e) {
  let i = Ae;
  switch (t ?? e) {
    case ee.Top:
      i = Ke;
      break;
    case ee.Bottom:
      i = Te;
      break;
    case ee.Baseline:
    case ee.Middle:
  }
  return i;
}
function Wh(t) {
  const { angle: e, mappedHAlignment: i, mappedVAlignment: a, isGuideLabel: o } = t;
  let n = i, s = a, r = i;
  const l = a;
  return (Math.abs(e) === 270 || Math.abs(e) === 90) && (o || (r = void 0, s = void 0), l === Ke ? n = Te : l === Te ? n = Ke : l === Ae && (n = Ae)), { align: n, valign: s, horizontalCenter: r, verticalCenter: l };
}
function pr(t) {
  const { root: e, symbol: i, defaultToColorFromRamp: a, colorRampIndex: o, isChartFillSymbol: n = !1 } = t;
  let s;
  if (a === !0) {
    const r = n ? kn : Io;
    if (i.color = i.color ?? ai({ colorIndex: o, opacity: r }), ln(i) || $a(i)) {
      const { outline: l } = i;
      l !== void 0 && (l.color = l?.color ?? ai({ colorIndex: o }), i.outline = { ...l });
    }
  }
  return $a(i) && (i.style ??= A.lineMarker.markerStyle, i.size ??= A.lineMarker.markerSize), Kc(i) ? s = Pd(i, !0) : $a(i) ? s = Vh(i) : ln(i) && (s = Ph(i, e)), s;
}
function Hh(t) {
  const { input: e, isGuideLabel: i, defaults: a } = t, o = Nd(e.angle, a?.rotation), n = Ed(e.horizontalAlignment, a?.horizontalCenter), s = zd(e.verticalAlignment, a?.verticalCenter), { align: r, valign: l, horizontalCenter: c, verticalCenter: u } = Wh({
    angle: o,
    mappedHAlignment: n,
    mappedVAlignment: s,
    isGuideLabel: i
  });
  return {
    fill: re(e.color).color,
    fontFamily: e.font?.family ?? "Arial, Helvetica, sans-serif",
    fontSize: e.font?.size ?? A.generalFontSize,
    fontWeight: e.font?.weight ?? "400",
    textDecoration: Eh(e.font?.decoration),
    align: r,
    valign: l,
    verticalCenter: u,
    horizontalCenter: c,
    text: ft({ textSymbol: e, format: "amChartsV5" }),
    angle: o,
    xOffset: e.xoffset ?? a?.dx ?? 0,
    yOffset: e.yoffset ?? a?.dy ?? 0,
    backgroundFill: re(e.backgroundColor).color,
    borderFill: re(e.borderLineColor).color,
    borderWidth: e.borderLineSize ?? 1,
    // haloSize: input.haloSize ?? -1,
    haloColor: re(e.haloColor).color,
    rtl: (e.rightToLeft ?? Xs(document.documentElement)) === "rtl" ? "rtl" : "ltr",
    wrap: zh(a?.wrap),
    maxWidth: a?.maxWidth ?? Number.NaN
  };
}
function Wd(t, e) {
  e !== void 0 && (e.marginBottom !== void 0 && t.set("marginBottom", e.marginBottom), e.marginTop !== void 0 && t.set("marginTop", e.marginTop), e.marginRight !== void 0 && t.set("marginRight", e.marginRight), e.marginLeft !== void 0 && t.set("marginLeft", e.marginLeft), e.verticalCenter !== void 0 && t.set("y", zd(e.verticalCenter)), e.horizontalCenter !== void 0 && t.set("x", Ed(e.horizontalCenter)), e.strokeWidth !== void 0 && t.get("background")?.set("strokeWidth", e.strokeWidth), e.paddingBottom !== void 0 && t.set("paddingBottom", e.paddingBottom), e.paddingTop !== void 0 && t.set("paddingTop", e.paddingTop), e.paddingLeft !== void 0 && t.set("paddingLeft", e.paddingLeft), e.paddingRight !== void 0 && t.set("paddingRight", e.paddingRight), e.maxWidth !== void 0 && t.set("maxWidth", e.maxWidth));
}
function Co(t) {
  const { root: e, parent: i, defaults: a, index: o, id: n } = t, s = yi.new(e, {
    text: "",
    textAlign: "center",
    background: zs.new(e, {}),
    paddingBottom: 0,
    paddingTop: 0,
    paddingLeft: 0,
    paddingRight: 0
  });
  return n !== void 0 && s.set("id", n), Wd(s, a), i !== void 0 && i.children.insertIndex(o ?? i.children.length, s), s;
}
function wl(t) {
  const { label: e, offset: i, offsetProperty: a } = t;
  e.adapters.remove(a), (e instanceof yi ? [e] : e.entities).forEach((n) => {
    if (typeof i == "string" && !Number.isFinite(Number(i))) {
      let s = Rn(i);
      typeof s == "number" && (s /= 100, n.adapters.add(a, () => (a === "dx" ? n.width() : n.height()) * (s ?? 0)));
    } else {
      const s = Number(i);
      Number.isFinite(s) && n.set(a, s);
    }
  });
}
function Pt(t) {
  const { label: e, labelConfig: i, defaults: a, skipSettingText: o, skipSettingXAndY: n } = t, s = i?.visible ?? !0;
  if (e !== void 0 && !e.isDisposed() && i !== void 0) {
    const r = e instanceof yi && At(e.uid, "isGuide"), l = Hh({ input: i.content, isGuideLabel: r, defaults: a });
    e.setAll({
      fill: l.fill,
      fontFamily: l.fontFamily,
      fontWeight: l.fontWeight,
      fontSize: l.fontSize,
      textDecoration: l.textDecoration,
      rotation: l.angle,
      direction: l.rtl,
      oversizedBehavior: l.wrap,
      maxWidth: l.maxWidth
      // TODO: double check whether issue #6942 happens here too
    }), o || e.setAll({ text: l.text }), n || (wl({
      label: e,
      offset: l.xOffset,
      offsetProperty: "dx"
    }), wl({
      label: e,
      offset: l.yOffset,
      offsetProperty: "dy"
    }), e.setAll({
      centerX: l.align,
      centerY: l.valign,
      x: l.horizontalCenter,
      y: l.verticalCenter
    })), e.get("background")?.setAll({
      strokeWidth: l.borderWidth,
      strokeOpacity: 1
    }), e.set("visible", s), e instanceof yi ? Re(e, s) : e.entities.forEach((c) => {
      Re(c, s);
    });
  }
}
function vi(t) {
  const { chart: e, label: i, labelType: a } = t, { legendTitle: o } = A.legendProperties, n = w(e.uid, "config");
  let s = o.maxWidth ?? Number.NaN, r = Number.NaN;
  switch (a) {
    case ae.GuideLabel:
      if (e instanceof Se) {
        const l = i.get("rotation");
        l === 90 || l === 270 ? s = e.seriesContainer.height() : s = e.seriesContainer.width();
      }
      break;
    case ae.XAxisTitle:
      e instanceof Se && (s = e.seriesContainer.width());
      break;
    case ae.YAxisTitle:
      e instanceof Se && (r = e.seriesContainer.height());
      break;
    case ae.ChartTitle:
    case ae.ChartSubTitle:
    case ae.ChartFooter:
      s = e.chartContainer.width() - 20;
      break;
    case ae.LegendTitle:
      n?.legend?.position !== void 0 && (n?.legend?.position === Y.Top || n?.legend?.position === Y.Bottom) && (s = e.chartContainer.width() - 20);
      break;
  }
  s > 0 && i.setAll({
    maxWidth: s,
    oversizedBehavior: "wrap"
  }), r > 0 && a === ae.YAxisTitle && i.setAll({
    maxHeight: r,
    oversizedBehavior: "wrap"
  });
}
function vo(t) {
  const { chart: e } = t;
  vi(t), e.events.on(
    le.BoundsChanged,
    Ye(() => vi(t), A.debounceTime)
  );
}
function Hd(t) {
  const { hour: e, minute: i = 0, format: a, locale: o = "en-US" } = t, n = a && Object.keys(a).length > 0 ? a : {
    hour: "numeric",
    minute: "2-digit",
    hour12: !0
  };
  let s = e.toString();
  if (Number.isInteger(e) && e >= 0 && e <= 23 && Number.isInteger(i) && i >= 0 && i <= 59) {
    const r = new Date(2e3, 0, 1, e, i);
    s = new Intl.DateTimeFormat(o, n).format(r);
  }
  return s;
}
function Gd(t) {
  const { weekdayNumber: e, format: i, locale: a = "en-US", firstDayOfWeek: o = 7 } = t, n = i && Object.keys(i).length > 0 ? i : { weekday: "long" };
  let s = e.toString();
  if (Number.isInteger(e) && e > 0 && e <= 7 && Number.isInteger(o) && o > 0 && o <= 7) {
    const r = (e + o - 1) % 7, l = new Date(2e3, 0, 2 + r);
    s = new Intl.DateTimeFormat(a, n).format(l);
  }
  return s;
}
function Xd(t) {
  const { monthNumber: e, format: i, locale: a = "en-US" } = t, o = i && Object.keys(i).length > 0 ? i : { month: "long" };
  let n = e.toString();
  if (Number.isInteger(e) && e > 0 && e <= 12) {
    const s = new Date(2e3, e - 1);
    n = new Intl.DateTimeFormat(a, o).format(s);
  }
  return n;
}
function hn(t, e) {
  const i = e.get("axisFill"), a = e.get("label");
  if (i !== void 0 && a !== void 0) {
    const o = At(a.uid, "guideLabelConfig"), n = t.get("renderer") instanceof $t, s = Math.round(i.width()), r = Math.round(i.height()), l = Math.round(a.height()), c = Math.round(a.width()), { horizontalAlignment: u, verticalAlignment: d } = o ?? {};
    let m = 0, g = 0;
    if (n) {
      const h = s !== 0;
      switch (u) {
        case se.Left:
          h ? m = -c / 2 : m = -c;
          break;
        case se.Right:
          h ? m = c / 2 : m = c;
          break;
        case se.Center:
        case se.Justify:
          break;
        default:
          h || (m = c / 2);
          break;
      }
      switch (d) {
        case ee.Bottom:
          h ? g = -l : g = -l / 2;
          break;
        case ee.Middle:
          g = -r / 2;
          break;
        case ee.Top:
        default:
          g = -r + l / 2;
          break;
      }
    } else {
      const h = r !== 0;
      switch (u) {
        case se.Center:
          m = s / 2;
          break;
        case se.Left:
          m = c / 2;
          break;
        case se.Right:
        default:
          m = s - c / 2;
          break;
      }
      switch (d) {
        case ee.Bottom:
          h ? g = r / 2 : g = l;
          break;
        case ee.Top:
          h ? g = -r / 2 + l / 2 : g = -l;
          break;
        case ee.Middle:
        default:
          h || (g = -l / 2);
          break;
      }
    }
    a.setAll({ dx: m, dy: g });
  }
}
function Gh(t) {
  const { axis: e, guide: i, label: a } = t, { chart: o } = e;
  if (o) {
    const n = e.get("renderer") instanceof $t ? o.yAxes.getIndex(0) : o.xAxes.getIndex(0);
    n && (n.events.on(
      le.BoundsChanged,
      Ye(() => {
        hn(e, i);
      }, A.debounceTime)
    ), e.events.on(
      le.BoundsChanged,
      Ye(() => {
        hn(e, i);
      }, A.debounceTime)
    ));
  }
  a.setAll({
    paddingTop: 0,
    paddingRight: 0,
    paddingBottom: 0,
    paddingLeft: 0
  });
}
function Xh(t) {
  const { guide: e, axis: i, guideLabelConfig: a } = t, o = e.get("label");
  if (o !== void 0) {
    Wd(o), hr(o.uid, { isGuide: !0, guideLabelConfig: a });
    const { chart: n } = i;
    n !== void 0 && vo({
      chart: n,
      label: o,
      labelType: ae.GuideLabel
    }), Gh({ axis: i, guide: e, label: o });
  }
}
function Yh(t) {
  const { axis: e, guide: i, guideConfig: a, guideType: o } = t, n = i?.get("label");
  if (n !== void 0)
    if (a.label !== void 0) {
      const s = e.get("renderer") instanceof $t;
      let r;
      e instanceof fi || (s ? o === te.SFS ? r = A.verticalSurfaceGuideLabels : r = A.verticalLineGuideLabels : o === te.SFS ? r = A.horizontalSurfaceGuideLabels : r = A.horizontalLineGuideLabels), hr(n.uid, { guideLabelConfig: a.label });
      const l = {
        type: b.Text,
        visible: a.visible,
        content: {
          ...a.label,
          // Resetting the alignments - they will be fully handled by adjustGuideLabelsPositionCallback()
          verticalAlignment: ee.Middle,
          horizontalAlignment: se.Center,
          // For guide labels, when dir attribute is set to "rtl" along with the "lang",
          // we need to ignore the guide label's rtl property and set the rightToLeft property from labelConfig
          // to the rtl value from chart. See issue #7798 for more details
          rightToLeft: n.get("direction") === "rtl"
        }
      };
      Pt({ label: n, labelConfig: l, defaults: r }), n.events.once(le.BoundsChanged, () => {
        hn(e, i);
      }), hn(e, i);
    } else
      Re(n, !1);
}
function Yd(t) {
  const { element: e, fill: i, fillOpacity: a, pattern: o } = t, n = e.get("tooltip");
  let s = !0;
  o !== void 0 ? (n !== void 0 && (s = !1, n.get("background")?.set("fill", i)), e.set("fillPattern", o)) : e.set("fill", i), n !== void 0 && n.set("getFillFromSprite", s), e.set("fillOpacity", a);
}
function pn(t, e) {
  t.setAll({
    stroke: e.stroke,
    strokeDasharray: e.strokeDasharray,
    strokeOpacity: e.strokeOpacity,
    strokeWidth: e.strokeWidth,
    lineCap: e.linecap
  });
}
function Ud(t) {
  const { element: e, markerSymbol: i, visible: a, defaultToColorFromRamp: o, colorRampIndex: n } = t;
  let s;
  return e !== void 0 && i !== void 0 && (s = pr({
    symbol: i,
    defaultToColorFromRamp: o,
    colorRampIndex: n
  }), s !== void 0 && (e.setAll({
    svgPath: s.path,
    rotation: s.angle,
    dx: s.xOffset,
    dy: s.yOffset
  }), Yd({
    element: e,
    fill: s.fill,
    fillOpacity: s.fillOpacity
  }), pn(e, s.outline)), Re(e, a)), s;
}
function na(t) {
  const {
    root: e,
    element: i,
    fillSymbol: a,
    visible: o,
    defaultToColorFromRamp: n,
    colorRampIndex: s,
    isChartFillSymbol: r,
    keepCurrentVisibility: l
  } = t;
  let c;
  return i !== void 0 && !i.isDisposed() && (a !== void 0 && (c = pr({
    root: e,
    symbol: a,
    defaultToColorFromRamp: n,
    colorRampIndex: s,
    isChartFillSymbol: r
  }), c !== void 0 && (Yd({
    element: i,
    fill: c.fill,
    fillOpacity: c.fillOpacity,
    pattern: c.pattern
  }), pn(i, c.outline))), l || Re(i, o)), c;
}
function Yt(t) {
  const { element: e, lineSymbol: i, visible: a, defaultToColorFromRamp: o, colorRampIndex: n } = t;
  let s;
  return e !== void 0 && !e.isDisposed() && (i !== void 0 && (s = pr({
    symbol: i,
    defaultToColorFromRamp: o,
    colorRampIndex: n
  }), s !== void 0 && (pn(e, s), e instanceof ge && pn(e.strokes.template, s))), Re(e, a)), s;
}
function mt(t) {
  const {
    root: e,
    element: i,
    seriesIndex: a,
    seriesSymbol: o,
    isChartFillSymbol: n,
    colorMatch: s,
    rendererSymbol: r,
    keepCurrentVisibility: l
  } = t;
  let c, u;
  s && r !== void 0 && (c = Jc({
    rendererSymbol: r,
    seriesSymbol: o,
    colorIndex: a
  }));
  const d = {
    root: e,
    element: i,
    defaultToColorFromRamp: !0,
    colorRampIndex: a
  }, m = c ?? { ...o };
  switch (o.type) {
    case te.SLS:
      u = Yt({
        ...d,
        lineSymbol: m
      });
      break;
    case te.SFS:
      u = na({
        ...d,
        fillSymbol: m,
        isChartFillSymbol: n,
        keepCurrentVisibility: l
      });
      break;
    case te.SMS:
      u = Ud({
        ...d,
        markerSymbol: m
      });
      break;
  }
  return { symbolWithColorInfo: m, stylingInfo: u };
}
function $l(t, e) {
  if (e !== void 0) {
    const { elementColor: i, elementOutlineColor: a, elementOutlineWidth: o, rotation: n, transformation: s } = e, { opacity: r, scale: l } = s ?? {};
    if (i !== void 0 && t.setAll({ fill: re(i).color, fillOpacity: 1 }), a !== void 0 && t.setAll({ stroke: re(a).color, strokeOpacity: 1 }), o !== void 0 && t.setAll({ strokeWidth: o }), n !== void 0 && t.setAll({ rotation: n }), l !== void 0 && t.setAll({ scale: l }), r !== void 0) {
      t.setAll({ fillOpacity: (t.get("fillOpacity") ?? 1) * r });
      const c = t.get("strokeOpacity");
      c !== void 0 && t.setAll({ strokeOpacity: c * r });
    }
  }
}
async function Uh(t = Tn(document.documentElement).t9nLocale) {
  let e = await import("@amcharts/amcharts5/locales/en_US.js");
  switch (t) {
    case "ar":
      e = await import("@amcharts/amcharts5/locales/ar.js");
      break;
    case "bs":
      e = await import("@amcharts/amcharts5/locales/bs_BA.js");
      break;
    case "bg":
      e = await import("../../chunks/bg_BG.js");
      break;
    case "ca":
      e = await import("@amcharts/amcharts5/locales/ca_ES.js");
      break;
    case "cs":
      e = await import("@amcharts/amcharts5/locales/cs_CZ.js");
      break;
    case "da":
      break;
    case "de":
      e = await import("@amcharts/amcharts5/locales/de_DE.js");
      break;
    case "el":
      e = await import("@amcharts/amcharts5/locales/el_GR.js");
      break;
    case "es":
      e = await import("@amcharts/amcharts5/locales/es_ES.js");
      break;
    case "et":
      e = await import("@amcharts/amcharts5/locales/et_EE.js");
      break;
    case "fi":
      e = await import("@amcharts/amcharts5/locales/fi_FI.js");
      break;
    case "fr":
      e = await import("@amcharts/amcharts5/locales/fr_FR.js");
      break;
    case "he":
      e = await import("@amcharts/amcharts5/locales/he_IL.js");
      break;
    case "hr":
      e = await import("@amcharts/amcharts5/locales/hr_HR.js");
      break;
    case "hu":
      e = await import("@amcharts/amcharts5/locales/hu_HU.js");
      break;
    case "id":
      e = await import("@amcharts/amcharts5/locales/id_ID.js");
      break;
    case "it":
      e = await import("@amcharts/amcharts5/locales/it_IT.js");
      break;
    case "ja":
      e = await import("@amcharts/amcharts5/locales/ja_JP.js");
      break;
    case "ko":
      e = await import("@amcharts/amcharts5/locales/ko_KR.js");
      break;
    case "lt":
      e = await import("@amcharts/amcharts5/locales/lt_LT.js");
      break;
    case "lv":
      e = await import("@amcharts/amcharts5/locales/lv_LV.js");
      break;
    case "no":
      e = await import("@amcharts/amcharts5/locales/nb_NO.js");
      break;
    case "nl":
      e = await import("@amcharts/amcharts5/locales/nl_NL.js");
      break;
    case "pl":
      e = await import("@amcharts/amcharts5/locales/pl_PL.js");
      break;
    case "pt-BR":
      e = await import("@amcharts/amcharts5/locales/pt_BR.js");
      break;
    case "pt-PT":
      e = await import("@amcharts/amcharts5/locales/pt_PT.js");
      break;
    case "ro":
      e = await import("@amcharts/amcharts5/locales/ro_RO.js");
      break;
    case "ru":
      e = await import("@amcharts/amcharts5/locales/ru_RU.js");
      break;
    case "sr":
      e = await import("@amcharts/amcharts5/locales/sr_RS.js");
      break;
    case "sk":
      e = await import("../../chunks/sk_SK.js");
      break;
    case "sl":
      e = await import("@amcharts/amcharts5/locales/sl_SL.js");
      break;
    case "sv":
      e = await import("@amcharts/amcharts5/locales/sv_SE.js");
      break;
    case "th":
      e = await import("@amcharts/amcharts5/locales/th_TH.js");
      break;
    case "tr":
      break;
    case "uk":
      e = await import("@amcharts/amcharts5/locales/uk_UA.js");
      break;
    case "vi":
      e = await import("@amcharts/amcharts5/locales/vi_VN.js");
      break;
    case "zh-CN":
      e = await import("@amcharts/amcharts5/locales/zh_Hans.js");
      break;
    case "zh-HK":
      e = await import("@amcharts/amcharts5/locales/zh_Hant.js");
      break;
    case "zh-TW":
      e = await import("@amcharts/amcharts5/locales/zh_Hant.js");
      break;
  }
  const i = (await qc(t)).customAmchartsStrings;
  return { ...e.default, ...i };
}
function Dt(t) {
  const { root: e, type: i, intlOptions: a, formatLocale: o } = t;
  let n;
  switch (i) {
    case b.NumberAxisFormat: {
      n = $c.new(e, {}), n.set("intlLocales", o), n.set("numberFormat", a);
      break;
    }
    case b.DateAxisFormat: {
      n = Xm.new(e, {}), n.set("intlLocales", o);
      break;
    }
  }
  return n;
}
const me = {
  Top: "top",
  Bottom: "bottom",
  Median: "median",
  Outliers: "outliers"
}, Hi = {
  Outlier: "outlier",
  Box: "box",
  OutlierToOutlier: "outlier-outlier",
  OutlierToBox: "outlier-box",
  BoxToOutlier: "box-outlier",
  BoxToBox: "box-box"
};
function jh(t, e) {
  const i = t[G.boxPlot.boxPlotOutlierId] === !0 ? Hi.Outlier : Hi.Box, a = typeof e == "number" ? Hi.Outlier : Hi.Box;
  return `${i}-${a}`;
}
function qh(t) {
  const { oneSelectedItem: e, dataContext: i, selectedOutlierKey: a } = t;
  return e[a] === i[a];
}
function _h(t) {
  const { elementMin: e, elementMax: i, selectedOutlierValue: a } = t;
  let o;
  return typeof e == "number" && typeof i == "number" && typeof a == "number" && (o = a >= e && a <= i), o;
}
function Zh(t) {
  const { selectedMin: e, selectedMax: i, elementOutlierValue: a, oneSelectedItem: o, iqrField: n } = t;
  let s;
  typeof e == "number" && typeof i == "number" && typeof a == "number" && (s = a >= e && a <= i);
  const r = n in o;
  return s !== !1 && r;
}
function Kh(t) {
  const { selectedMin: e, selectedMax: i, elementMin: a, oneSelectedItem: o, elementMax: n, iqrField: s } = t;
  let r;
  typeof a == "number" && typeof n == "number" && typeof e == "number" && typeof i == "number" && (r = !(a >= i || n <= e));
  const l = s in o;
  return r !== !1 && l;
}
function Qh(t) {
  const { oneSelectedItem: e, dataContext: i, xAxisField: a } = t, o = i[G.typeOrDomainIdValue] ?? i[G.originalCategoryValue] ?? i[G.boxPlot.boxPlotCategory] ?? i[a], n = e[G.typeOrDomainIdValue] ?? e[G.originalCategoryValue] ?? e[G.boxPlot.boxPlotCategory] ?? e[a];
  return o === n;
}
function Jh(t) {
  const { chartSubType: e, yAxisField: i, splitBy: a, showOutliers: o } = t, n = e === P.BoxPlotMultiFieldsAndCategory ? i : void 0, s = { y: n, splitBy: a }, r = be({
    ...s,
    key: J.Outlier
  }), l = be({
    ...s,
    key: J.Max,
    showOutliers: o
  }), c = be({
    ...s,
    key: J.Min,
    showOutliers: o
  }), u = be({
    ...s,
    key: J.Max,
    showOutliers: !1
  }), d = be({
    ...s,
    key: J.Min,
    showOutliers: !1
  }), m = be({
    ...s,
    key: J.Max,
    showOutliers: !0
  }), g = be({
    ...s,
    key: J.Min,
    showOutliers: !0
  }), h = be({
    splitBy: a,
    y: n,
    key: J.IQR
  });
  return {
    selectedOutlierKey: r,
    maxField: l,
    minField: c,
    selectedMaxFieldWoOutliers: u,
    selectedMinFieldWoOutliers: d,
    selectedMaxFieldWithOutliers: m,
    selectedMinFieldWithOutliers: g,
    iqrField: h
  };
}
function ep(t) {
  const { elementDataContext: e, layerOidField: i, xAxisField: a, splitBy: o, yAxisField: n, chartSubType: s, showOutliers: r } = t, l = e;
  let c;
  if (l?.[G.boxPlot.boxPlotMeanLineMarkerId] === !0) {
    const d = be({
      splitBy: o,
      key: J.Average
    });
    c = (m) => {
      const g = !a || !(a in m && a in l) || m[a] === l[a], h = d in m && d in l;
      return g && h;
    };
  } else
    a !== void 0 && n !== void 0 && (c = (d) => {
      let m;
      if (i !== void 0 && i in d && i in l)
        m = d[i] === l[i];
      else {
        const {
          selectedOutlierKey: g,
          maxField: h,
          minField: y,
          selectedMaxFieldWoOutliers: p,
          selectedMinFieldWoOutliers: S,
          selectedMaxFieldWithOutliers: x,
          selectedMinFieldWithOutliers: C,
          iqrField: v
        } = Jh({ chartSubType: s, yAxisField: n, splitBy: o, showOutliers: r }), F = l[g], T = d[g], k = l[y], $ = l[h], O = d[S] ?? d[C], D = d[p] ?? d[x];
        let R = Qh({ oneSelectedItem: d, dataContext: l, xAxisField: a });
        if (R)
          switch (jh(d, F)) {
            case Hi.OutlierToOutlier:
              R = qh({ oneSelectedItem: d, dataContext: l, selectedOutlierKey: g });
              break;
            case Hi.OutlierToBox:
              R = _h({ elementMin: k, elementMax: $, selectedOutlierValue: T });
              break;
            case Hi.BoxToOutlier:
              R = Zh({
                selectedMin: O,
                selectedMax: D,
                elementOutlierValue: F,
                oneSelectedItem: d,
                iqrField: v
              });
              break;
            case Hi.BoxToBox:
              R = Kh({
                selectedMin: O,
                selectedMax: D,
                elementMin: k,
                oneSelectedItem: d,
                elementMax: $,
                iqrField: v
              });
              break;
          }
        m = R === !0;
      }
      return m;
    });
  return c;
}
function br(t) {
  const { layerOidField: e, sliceDataContext: i, selectionDataContext: a, xAxisField: o } = t;
  let n = !1;
  if (e !== void 0 && e in i && e in a)
    n = a[e]?.toString() === i[e]?.toString();
  else {
    let s = i[G.typeOrDomainIdValue];
    s === void 0 && (s = i[G.originalCategoryValue]), s === void 0 && (s = i[o]), s === void 0 && (s = i[ii]);
    let r = a[G.typeOrDomainIdValue];
    r === void 0 && (r = a[G.originalCategoryValue]), r === void 0 && (r = a[o]), r === void 0 && (r = a[ii]), n = s !== void 0 && r !== void 0 && s === r;
  }
  return n;
}
function Hn(t) {
  const { options: e, elementDataContext: i, selectionDataItems: a, layerOidField: o, xAxisField: n, yAxisField: s, chartType: r } = t, { originalCategoryValue: l } = G;
  let c = !1, u;
  if (i !== void 0 && a !== void 0)
    switch (r) {
      case b.HeatSeries:
        const d = i, m = n && d[n] !== void 0 ? d[n] : d[Me.xField], g = s && d[s] !== void 0 ? d[s] : d[Me.yField];
        u = (h) => {
          const y = n && h[n] !== void 0 ? h[n] : h[Me.xField], p = s && h[s] !== void 0 ? h[s] : h[Me.yField];
          return m === y && g === p;
        };
        break;
      case b.RadarSeries:
      case b.BarSeries:
      case b.LineSeries:
      case b.ComboLineAndBarSeries:
        if (n !== void 0 && s !== void 0) {
          const h = i;
          u = (y) => {
            let p;
            if (o !== void 0 && o in y && o in h)
              p = y[o] === h[o];
            else if (G.dateBinningRange in h && typeof y[n] == "number") {
              const S = y[n], x = y[G.dateBinningRange], C = Array.isArray(x) && Number.isFinite(x[0]) && Number.isFinite(x[1]), [v, F] = C ? x : [0, 0], [T, k] = h[G.dateBinningRange], $ = h[G.lastTemporalBin] === !0 ? S <= k : S < k;
              p = (C ? v < k && T < F : S >= T && $) && s in y && Number.isFinite(y[s]);
            } else {
              const S = (v) => {
                let F = v[G.typeOrDomainIdValue];
                return F === void 0 && (F = v[l]), F === void 0 && (F = v[n]), F = F === null ? G.nullValue : F, F;
              }, x = S(h);
              p = S(y) === x && s in y;
            }
            return p;
          };
        }
        break;
      case b.BoxPlotSeries:
        u = ep(t);
        break;
      case b.ScatterSeries:
        if (n !== void 0 && s !== void 0) {
          const h = i;
          if (!yg({
            dataContext: h,
            chartLimits: e?.chartLimits
          }))
            u = (y) => {
              let p;
              return o !== void 0 && o in h && o in y ? p = y[o] === h[o] : p = y[n] === h[n] && y[s] === h[s], p;
            };
          else {
            const { dataContextXMinField: y, dataContextXMaxField: p, dataContextYMinField: S, dataContextYMaxField: x } = G.scatterplotAggregationFields, { [y]: C, [p]: v } = h, F = n !== s ? h[S] : C, T = n !== s ? h[x] : v, k = (O) => {
              const D = O[n] ?? Number.NaN, R = C ?? Number.NaN, M = v ?? Number.NaN;
              return C === v ? D === R : (D ?? Number.NaN) >= R && (D ?? Number.NaN) < M;
            }, $ = (O) => {
              const D = O[s] ?? Number.NaN, R = F ?? Number.NaN, M = T ?? Number.NaN;
              return F === T ? D === R : D >= R && D < M;
            };
            u = (O) => k(O) && $(O);
          }
        }
        break;
      case b.HistogramSeries:
        u = (h) => {
          let y = !1;
          const { minValue: p, maxValue: S } = i, { isLastBin: x } = i;
          if (n !== void 0 && n in h) {
            const C = h[n];
            y = typeof C == "number" && C >= p && (x && C <= S || !x && C < S);
          } else if ("minValue" in h && "maxValue" in h) {
            const { minValue: C, maxValue: v } = h;
            y = !(p >= v || S <= C);
          }
          return y;
        };
        break;
      case b.PieSeries:
        n !== void 0 && (u = (h) => {
          const y = i, p = Di(y), S = [y];
          return p && S.push(...Bo({ groupOfSlicesDataContext: y }) ?? []), S.some(
            (C) => br({
              sliceDataContext: C,
              selectionDataContext: h,
              layerOidField: o,
              xAxisField: n
            })
          );
        });
        break;
    }
  return u !== void 0 && (c = a.some(u)), c;
}
function Li(t) {
  const {
    isFeatureCollectionLayer: e,
    dataContext: i,
    yAxisField: a,
    yList: o,
    xAxisField: n,
    splitBy: s,
    chartType: r,
    chartSubType: l,
    showOutliers: c
  } = t;
  let u = { ...i };
  if (i !== void 0) {
    if (r === b.RadarSeries || r === b.BarSeries || r === b.LineSeries || r === b.ComboLineAndBarSeries || r === b.PieSeries) {
      r !== b.PieSeries && (e || l !== P.BarAndLineNoAggregation && l !== P.BarAndLineSplitByNoAggregation) && o.forEach((m) => {
        m !== a && delete u[m];
      });
      const d = oi({
        value: i[n],
        dataContext: i,
        keepNullValues: !0
      });
      u[n] = d, !ye(s) && !eg(s) && (u[ki(s)] = Ki({ where: s, escape: !1 }));
    } else if (r === b.BoxPlotSeries) {
      u = { [n]: i[n] }, [
        Na.uniqueIdsName,
        G.boxPlot.boxPlotMeanLineMarkerId,
        G.boxPlot.boxPlotOutlierId,
        G.typeOrDomainIdValue
      ].forEach((m) => {
        i[m] && (u[m] = i[m]);
      });
      const d = l === P.BoxPlotMultiFieldsAndCategory ? a : void 0;
      Object.values(J).forEach((m) => {
        const g = be({ key: m, y: d, splitBy: s, showOutliers: c });
        i[g] !== void 0 && (u[g] = i[g]);
      });
    }
  }
  return u;
}
function jd(t, e, i) {
  const a = e - t;
  let o = [];
  if (a !== 0) {
    if (i === 1)
      o = [t];
    else if (i > 1) {
      const n = a / (i - 1);
      o = [...Vg(t, e, n), e];
    }
  }
  return o;
}
function qd({ x: t, mean: e, stddev: i, scalingFactor: a }) {
  const n = -1 / (2 * i ** 2);
  return (a ?? 1) * Math.exp(n * (t - e) ** 2);
}
function _d(t) {
  let e = 0;
  if (t.length > 0)
    for (let i = 0; i < t.length; i += 1)
      t[i].count > e && (e = t[i].count);
  return e;
}
const st = {
  CustomActive: "custom-active",
  CustomInactive: "custom-inactive",
  Default: "default",
  Active: "active"
};
function Zd(t) {
  let e = !1, i;
  if (t.target.dataItem?.component instanceof Ws ? { chart: i } = t.target.dataItem.component : (t.target instanceof Rc || t.target instanceof Oc) && ({ chart: i } = t.target), i instanceof Se || i instanceof ti) {
    const a = w(i.uid, "actionMode");
    if (a !== void 0) {
      const { originalEvent: o } = t;
      e = a === K.MultiSelection || a === K.MultiSelectionWithCtrlKey && ("ctrlKey" in o && o.ctrlKey || "metaKey" in o && o.metaKey);
    }
  }
  return e;
}
function ut(t) {
  const { element: e, selected: i, multiSelect: a, isDateOrCategoryAxis: o, backToDefaultState: n } = t;
  let s = !1;
  if (e !== void 0) {
    const r = Ri(e.uid, "selected") ?? !1;
    s = r, a !== !0 ? o === !0 ? s = r ? !1 : r !== i : s = i : s = r !== i;
    const l = n === !0 ? st.Default : st.CustomInactive;
    e.states.apply(st.Default), e.states.apply(s ? st.CustomActive : l), s !== r && kh(e.uid, { selected: s });
  }
  return s;
}
function tp(t, e) {
  const i = w(e.chart?.uid ?? Number.NaN, "actionMode"), a = Zd(t);
  return i === K.MonoSelection || i === K.MultiSelectionWithCtrlKey && !a;
}
function _t(t, e) {
  const { selectedElementsTheme: i, nonSelectedElementsTheme: a } = e ?? A.selectionTheme ?? {}, o = t.states.create(st.CustomActive, {}), n = t.states.create(st.CustomInactive, {});
  $l(o, i), $l(n, a);
}
function ip(t) {
  return !!/^data:[a-z]+\/[a-z+.-]+;base64/u.test(t);
}
function Kd(t, e = 512) {
  if (!ip(t))
    throw new Error("Cannot convert a string that is not a data uri to a blob");
  const i = t.split(",")[0].split(":")[1].split(";")[0], a = atob(t.split(",")[1]), o = [];
  for (let n = 0; n < a.length; n += e) {
    const s = a.slice(n, n + e), r = new Array(s.length);
    for (let c = 0; c < s.length; c++)
      r[c] = s.charCodeAt(c);
    const l = new Uint8Array(r);
    o.push(l);
  }
  return new Blob(o, { type: i });
}
function Ea(t) {
  const { value: e, valueFormat: i, formatLocale: a, root: o } = t;
  let n = e?.toString();
  const s = Dt({
    type: i.type,
    intlOptions: i.intlOptions,
    formatLocale: a,
    root: o
  });
  return typeof e == "number" && i.type === b.NumberAxisFormat ? n = s.format(e, ni(i)) : (typeof e == "number" || e instanceof Date) && i.type === b.DateAxisFormat && (n = s.format(e, ni(i))), n;
}
async function ap(t) {
  const { root: e, exportOptions: i } = t, { format: a, quality: o = 1, ...n } = i, s = o < 0 || o > 1 ? 1 : o, l = await _g.new(e, {}).exportImage(a, {
    quality: s,
    ...n
  }), c = Kd(l), u = a === "jpg" ? "image/jpeg" : "image/png";
  return new File([c], `chart.${a}`, { type: u });
}
function co(t, e) {
  if (t !== void 0 && e !== void 0 && (t.states.lookup("default")?.setAll({
    fill: e.fill,
    // stylingInfo.pattern ?? stylingInfo.fill,
    fillOpacity: e.fillOpacity
  }), e.outline !== void 0)) {
    const { outline: i } = e;
    t.states.lookup("default")?.setAll({
      stroke: i.stroke,
      // "strokeOpacity": outline.stroke.alpha === 0 ? 0 : 1,
      strokeDasharray: i.strokeDasharray,
      lineCap: i.linecap,
      strokeWidth: i.strokeWidth
    });
  }
}
function yr(t) {
  const {
    pieChart: e,
    valueIntlOptions: i,
    percentageIntlOptions: a,
    displayNumericValue: o,
    displayPercentage: n,
    valuePrefix: s,
    valueSuffix: r,
    percentagePrefix: l,
    percentageSuffix: c
  } = t, { root: u } = e, d = w(e.uid, "formatLocale"), m = Dt({
    root: u,
    type: b.NumberAxisFormat,
    intlOptions: i,
    formatLocale: d
  }), g = Dt({
    root: u,
    type: b.NumberAxisFormat,
    intlOptions: { ...a, style: "percent" },
    formatLocale: d
  }), h = bt(w(e.uid, "rtl") ?? !1, " ");
  return (p, S, x) => {
    let C = "";
    if (S !== void 0 && x !== void 0) {
      const v = `${s ?? ""}${m.format(S)}${r ?? ""}`, F = `${l ?? ""}${g.format(Math.abs(x / 100))}${c ?? ""}`;
      Number.isFinite(S) ? o === !0 && n === !0 ? C = `${F}${h}(${v})` : o === !0 ? C = v : n === !0 && (C = F) : C = "";
    }
    return C;
  };
}
function op(t, e) {
  let i = !1;
  if (e === Y.Right || e === Y.Left)
    i = !0;
  else {
    const a = t.dataItems[0]?.get("itemContainer").bounds().left;
    a !== void 0 && (i = !t.dataItems.some((o) => o.get("itemContainer").bounds().left !== a));
  }
  return i;
}
function np(t) {
  let e = !1;
  const i = t.dataItems[0]?.get("itemContainer").bounds().bottom;
  return i !== void 0 && (e = !t.dataItems.some(
    (a) => a.get("itemContainer").bounds().bottom !== i
  )), e;
}
function sp(t) {
  hr(t.uid, { isLegendValueLabel: !0 }), t.valueLabels.template.adapters.add("text", (e, i) => {
    let a = e ?? "";
    const o = Ah(
      t.uid,
      "pieChartLegendValueLabelsFormatter"
    );
    return o !== void 0 && (a = o(
      i.dataItem?.get("value") ?? 0,
      i.dataItem?.get("valuePercentTotal") ?? 0
    )), a;
  }), t.valueLabels.template.set("text", "");
}
function Qd(t) {
  const { legend: e, seriesConfig: i, webChartLegend: a, pieChartLegendValueLabelFormatter: o, chart: n } = t, {
    visible: s,
    body: r,
    displayNumericValue: l,
    displayPercentage: c
  } = a ?? {};
  if (z(i) === b.PieSeries) {
    const { numericValueFormat: d, percentValueFormat: m, valuePrefix: g, valueSuffix: h, percentagePrefix: y, percentageSuffix: p } = i[0], S = l ?? A.pieChart.displayNumericValueOnLegend, x = c ?? A.pieChart.displayPercentageOnLegend;
    let C = o;
    if (o === void 0) {
      const O = yr({
        pieChart: n,
        valueIntlOptions: d?.intlOptions,
        percentageIntlOptions: m?.intlOptions,
        displayNumericValue: S,
        displayPercentage: x,
        valuePrefix: g,
        valueSuffix: h,
        percentagePrefix: y,
        percentageSuffix: p
      });
      C = (D, R) => O("", D, R);
    }
    Th(e.uid, {
      pieChartLegendValueLabelsFormatter: C
    });
    const F = w(n?.uid ?? 0, "config")?.legend?.position ?? A.legendProperties.position, T = op(e, F), k = {
      type: b.Text,
      visible: s,
      content: {
        ...r,
        type: te.TS,
        text: ".",
        verticalAlignment: ee.Middle,
        // The horizontalAlignment value needs to be consistent with the one set by `handleValueLabelsRightAlignment()`. It avoids flickering the labels.
        horizontalAlignment: T ? se.Right : se.Center
      }
    };
    Pt({
      label: e.valueLabels.template,
      labelConfig: k,
      defaults: A.legendProperties.valueLabels
    });
    const $ = w(n?.uid ?? 0, "rtl") ?? !1;
    e.valueLabels.template.setAll({
      x: void 0,
      y: void 0,
      paddingRight: 5,
      textAlign: $ ? "right" : "left",
      disabled: S === !1 && x === !1
    });
  }
}
function rp(t, e) {
  t.labels.template.adapters.add("maxWidth", (i) => {
    let a = i;
    const o = w(e.uid, "config"), n = o?.legend?.labelMaxWidth, s = o?.legend?.position ?? A.legendProperties.position;
    if (s === Y.Right || s === Y.Left)
      a = n ?? A.legendProperties.legendLabels.maxWidth;
    else if (n !== void 0)
      a = n;
    else {
      let r = 0;
      t.valueLabels.template.get("forceHidden") || t.valueLabels.each((c) => {
        const u = c.get("width", 0);
        typeof u == "number" && (r = Math.max(r, u));
      });
      const l = t.get("width", 200);
      typeof l == "number" && (a = l + r);
    }
    return a;
  }), t.valueLabels.template.adapters.add("maxWidth", (i) => {
    let a = i;
    const o = w(e.uid, "config"), n = o?.legend?.valueLabelMaxWidth, s = o?.legend?.position ?? A.legendProperties.position;
    return s === Y.Right || s === Y.Left ? a = n ?? A.legendProperties.valueLabels.maxWidth : a = n ?? Number.NaN, a;
  });
}
function Jd(t) {
  let e = 0;
  for (const i of t.dataItems) {
    const a = i.get("label")?._contentWidth ?? 0;
    e = Math.max(e, a);
  }
  return e;
}
function lp(t, e) {
  for (const i of t.dataItems)
    i.get("label")?.set("width", e);
}
function cp(t, e) {
  let i = 0;
  for (const a of t.dataItems) {
    const o = a.get("marker")?._contentWidth ?? 0, n = a.get("valueLabel")?._contentWidth ?? 0, s = o + e + n;
    i = Math.max(i, s);
  }
  return Math.ceil(i) + A.legendPadding;
}
function eu(t, e) {
  Za(() => {
    const i = np(t), a = e === Y.Right || e === Y.Left || !i;
    lp(
      t,
      a ? Jd(t) : void 0
    );
  });
}
function dp(t) {
  const { legend: e, chart: i, seriesConfig: a, legendConfig: o } = t, { displayCategory: n } = o ?? {}, s = n ?? A.pieChart.displayCategoryOnLegend, r = w(i?.uid ?? 0, "rtl") ?? !1;
  e.labels.template.setAll({
    forceHidden: s === !1,
    direction: r ? "rtl" : "ltr"
  }), Za(() => {
    const l = Jd(e), c = cp(e, l);
    e.itemContainers.template.setAll({
      width: c,
      layout: i.root.horizontalLayout
    }), rp(e, i), Qd({
      legend: e,
      seriesConfig: a,
      webChartLegend: o,
      chart: i
    });
    const u = o.position ?? A.legendProperties.position;
    eu(e, u), e.markDirty();
  });
}
const f = {
  Rotated: 0,
  NonRotated: 1,
  RTL: 2,
  LTR: 3,
  Stacked: 4,
  Stacked100: 5,
  SideBySide: 6,
  LegendTop: 7,
  LegendBottom: 8,
  LegendLeft: 9,
  LegendRight: 10,
  DateAxis: 11,
  ValueAxis: 12,
  CategoryAxis: 13,
  OrderByFieldsASC: 14,
  OrderByFieldsDESC: 15
}, tu = /* @__PURE__ */ new Set([
  // Case of descending order for a DateAxis
  // SideBySide
  `${f.NonRotated}-${f.LTR}-${f.SideBySide}-${f.LegendLeft}-${f.DateAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.LTR}-${f.SideBySide}-${f.LegendRight}-${f.DateAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.LTR}-${f.SideBySide}-${f.LegendTop}-${f.DateAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.LTR}-${f.SideBySide}-${f.LegendBottom}-${f.DateAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.RTL}-${f.SideBySide}-${f.LegendLeft}-${f.DateAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.RTL}-${f.SideBySide}-${f.LegendRight}-${f.DateAxis}-${f.OrderByFieldsDESC}`,
  `${f.Rotated}-${f.LTR}-${f.SideBySide}-${f.LegendRight}-${f.DateAxis}-${f.OrderByFieldsDESC}`,
  `${f.Rotated}-${f.LTR}-${f.SideBySide}-${f.LegendLeft}-${f.DateAxis}-${f.OrderByFieldsDESC}`,
  `${f.Rotated}-${f.LTR}-${f.SideBySide}-${f.LegendTop}-${f.DateAxis}-${f.OrderByFieldsDESC}`,
  `${f.Rotated}-${f.LTR}-${f.SideBySide}-${f.LegendBottom}-${f.DateAxis}-${f.OrderByFieldsDESC}`,
  `${f.Rotated}-${f.RTL}-${f.SideBySide}-${f.LegendRight}-${f.DateAxis}-${f.OrderByFieldsDESC}`,
  `${f.Rotated}-${f.RTL}-${f.SideBySide}-${f.LegendLeft}-${f.DateAxis}-${f.OrderByFieldsDESC}`,
  // Stacked:
  // LTR and notRotated chart
  `${f.NonRotated}-${f.LTR}-${f.Stacked}-${f.LegendLeft}-${f.DateAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked}-${f.LegendRight}-${f.DateAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked}-${f.LegendTop}-${f.DateAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked}-${f.LegendBottom}-${f.DateAxis}-${f.OrderByFieldsDESC}`,
  // RTL and choosing between rotated or notRotated chart
  `${f.NonRotated}-${f.RTL}-${f.Stacked}-${f.LegendLeft}-${f.DateAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.RTL}-${f.Stacked}-${f.LegendRight}-${f.DateAxis}-${f.OrderByFieldsDESC}`,
  `${f.Rotated}-${f.RTL}-${f.Stacked}-${f.LegendTop}-${f.DateAxis}-${f.OrderByFieldsDESC}`,
  `${f.Rotated}-${f.RTL}-${f.Stacked}-${f.LegendBottom}-${f.DateAxis}-${f.OrderByFieldsDESC}`,
  // Stacked100:
  // LTR and notRotated chart
  `${f.NonRotated}-${f.LTR}-${f.Stacked100}-${f.LegendLeft}-${f.DateAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked100}-${f.LegendRight}-${f.DateAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked100}-${f.LegendTop}-${f.DateAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked100}-${f.LegendBottom}-${f.DateAxis}-${f.OrderByFieldsDESC}`,
  // RTL and choosing between rotated or notRotated chart
  `${f.NonRotated}-${f.RTL}-${f.Stacked100}-${f.LegendLeft}-${f.DateAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.RTL}-${f.Stacked100}-${f.LegendRight}-${f.DateAxis}-${f.OrderByFieldsDESC}`,
  `${f.Rotated}-${f.RTL}-${f.Stacked100}-${f.LegendTop}-${f.DateAxis}-${f.OrderByFieldsDESC}`,
  `${f.Rotated}-${f.RTL}-${f.Stacked100}-${f.LegendBottom}-${f.DateAxis}-${f.OrderByFieldsDESC}`,
  // Case of ascending order for a DateAxis
  // SideBySide
  `${f.NonRotated}-${f.RTL}-${f.SideBySide}-${f.LegendTop}-${f.DateAxis}-${f.OrderByFieldsASC}`,
  `${f.NonRotated}-${f.RTL}-${f.SideBySide}-${f.LegendBottom}-${f.DateAxis}-${f.OrderByFieldsASC}`,
  `${f.Rotated}-${f.RTL}-${f.SideBySide}-${f.LegendBottom}-${f.DateAxis}-${f.OrderByFieldsASC}`,
  `${f.Rotated}-${f.RTL}-${f.SideBySide}-${f.LegendTop}-${f.DateAxis}-${f.OrderByFieldsASC}`,
  // Stacked:
  // LTR and notRotated chart
  `${f.NonRotated}-${f.LTR}-${f.Stacked}-${f.LegendLeft}-${f.DateAxis}-${f.OrderByFieldsASC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked}-${f.LegendRight}-${f.DateAxis}-${f.OrderByFieldsASC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked}-${f.LegendTop}-${f.DateAxis}-${f.OrderByFieldsASC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked}-${f.LegendBottom}-${f.DateAxis}-${f.OrderByFieldsASC}`,
  // RTL and choosing between rotated or notRotated chart
  `${f.NonRotated}-${f.RTL}-${f.Stacked}-${f.LegendLeft}-${f.DateAxis}-${f.OrderByFieldsASC}`,
  `${f.NonRotated}-${f.RTL}-${f.Stacked}-${f.LegendRight}-${f.DateAxis}-${f.OrderByFieldsASC}`,
  `${f.Rotated}-${f.RTL}-${f.Stacked}-${f.LegendTop}-${f.DateAxis}-${f.OrderByFieldsASC}`,
  `${f.Rotated}-${f.RTL}-${f.Stacked}-${f.LegendBottom}-${f.DateAxis}-${f.OrderByFieldsASC}`,
  // Stacked100:
  // LTR and notRotated chart
  `${f.NonRotated}-${f.LTR}-${f.Stacked100}-${f.LegendLeft}-${f.DateAxis}-${f.OrderByFieldsASC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked100}-${f.LegendRight}-${f.DateAxis}-${f.OrderByFieldsASC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked100}-${f.LegendTop}-${f.DateAxis}-${f.OrderByFieldsASC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked100}-${f.LegendBottom}-${f.DateAxis}-${f.OrderByFieldsASC}`,
  // RTL and choosing between rotated or notRotated chart
  `${f.NonRotated}-${f.RTL}-${f.Stacked100}-${f.LegendLeft}-${f.DateAxis}-${f.OrderByFieldsASC}`,
  `${f.NonRotated}-${f.RTL}-${f.Stacked100}-${f.LegendRight}-${f.DateAxis}-${f.OrderByFieldsASC}`,
  `${f.Rotated}-${f.RTL}-${f.Stacked100}-${f.LegendTop}-${f.DateAxis}-${f.OrderByFieldsASC}`,
  `${f.Rotated}-${f.RTL}-${f.Stacked100}-${f.LegendBottom}-${f.DateAxis}-${f.OrderByFieldsASC}`,
  // Case of ascending order for a CategoryAxis
  // SideBySide
  `${f.NonRotated}-${f.RTL}-${f.SideBySide}-${f.LegendTop}-${f.CategoryAxis}-${f.OrderByFieldsASC}`,
  `${f.NonRotated}-${f.RTL}-${f.SideBySide}-${f.LegendBottom}-${f.CategoryAxis}-${f.OrderByFieldsASC}`,
  `${f.Rotated}-${f.RTL}-${f.SideBySide}-${f.LegendTop}-${f.CategoryAxis}-${f.OrderByFieldsASC}`,
  `${f.Rotated}-${f.RTL}-${f.SideBySide}-${f.LegendBottom}-${f.CategoryAxis}-${f.OrderByFieldsASC}`,
  // Stacked:
  // LTR and notRotated chart: done done
  `${f.NonRotated}-${f.LTR}-${f.Stacked}-${f.LegendRight}-${f.CategoryAxis}-${f.OrderByFieldsASC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked}-${f.LegendLeft}-${f.CategoryAxis}-${f.OrderByFieldsASC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked}-${f.LegendTop}-${f.CategoryAxis}-${f.OrderByFieldsASC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked}-${f.LegendBottom}-${f.CategoryAxis}-${f.OrderByFieldsASC}`,
  // RTL and choosing between rotated or notRotated chart
  `${f.NonRotated}-${f.RTL}-${f.Stacked}-${f.LegendLeft}-${f.CategoryAxis}-${f.OrderByFieldsASC}`,
  `${f.NonRotated}-${f.RTL}-${f.Stacked}-${f.LegendRight}-${f.CategoryAxis}-${f.OrderByFieldsASC}`,
  `${f.Rotated}-${f.RTL}-${f.Stacked}-${f.LegendTop}-${f.CategoryAxis}-${f.OrderByFieldsASC}`,
  `${f.Rotated}-${f.RTL}-${f.Stacked}-${f.LegendBottom}-${f.CategoryAxis}-${f.OrderByFieldsASC}`,
  // Stacked100:
  // LTR and notRotated chart: done done
  `${f.NonRotated}-${f.LTR}-${f.Stacked100}-${f.LegendRight}-${f.CategoryAxis}-${f.OrderByFieldsASC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked100}-${f.LegendLeft}-${f.CategoryAxis}-${f.OrderByFieldsASC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked100}-${f.LegendTop}-${f.CategoryAxis}-${f.OrderByFieldsASC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked100}-${f.LegendBottom}-${f.CategoryAxis}-${f.OrderByFieldsASC}`,
  // RTL and choosing between rotated or notRotated chart
  `${f.NonRotated}-${f.RTL}-${f.Stacked100}-${f.LegendLeft}-${f.CategoryAxis}-${f.OrderByFieldsASC}`,
  `${f.NonRotated}-${f.RTL}-${f.Stacked100}-${f.LegendRight}-${f.CategoryAxis}-${f.OrderByFieldsASC}`,
  `${f.Rotated}-${f.RTL}-${f.Stacked100}-${f.LegendTop}-${f.CategoryAxis}-${f.OrderByFieldsASC}`,
  `${f.Rotated}-${f.RTL}-${f.Stacked100}-${f.LegendBottom}-${f.CategoryAxis}-${f.OrderByFieldsASC}`,
  // Case of descending order for a CategoryAxis
  // SideBySide
  `${f.NonRotated}-${f.RTL}-${f.SideBySide}-${f.LegendTop}-${f.CategoryAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.RTL}-${f.SideBySide}-${f.LegendBottom}-${f.CategoryAxis}-${f.OrderByFieldsDESC}`,
  `${f.Rotated}-${f.RTL}-${f.SideBySide}-${f.LegendTop}-${f.CategoryAxis}-${f.OrderByFieldsDESC}`,
  `${f.Rotated}-${f.RTL}-${f.SideBySide}-${f.LegendBottom}-${f.CategoryAxis}-${f.OrderByFieldsDESC}`,
  // Stacked:
  // LTR and notRotated chart: done done
  `${f.NonRotated}-${f.LTR}-${f.Stacked}-${f.LegendRight}-${f.CategoryAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked}-${f.LegendLeft}-${f.CategoryAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked}-${f.LegendTop}-${f.CategoryAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked}-${f.LegendBottom}-${f.CategoryAxis}-${f.OrderByFieldsDESC}`,
  // RTL and choosing between rotated or notRotated chart
  `${f.NonRotated}-${f.RTL}-${f.Stacked}-${f.LegendLeft}-${f.CategoryAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.RTL}-${f.Stacked}-${f.LegendRight}-${f.CategoryAxis}-${f.OrderByFieldsDESC}`,
  `${f.Rotated}-${f.RTL}-${f.Stacked}-${f.LegendTop}-${f.CategoryAxis}-${f.OrderByFieldsDESC}`,
  `${f.Rotated}-${f.RTL}-${f.Stacked}-${f.LegendBottom}-${f.CategoryAxis}-${f.OrderByFieldsDESC}`,
  // Stacked100:
  // LTR and notRotated chart: done done
  `${f.NonRotated}-${f.LTR}-${f.Stacked100}-${f.LegendRight}-${f.CategoryAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked100}-${f.LegendLeft}-${f.CategoryAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked100}-${f.LegendTop}-${f.CategoryAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked100}-${f.LegendBottom}-${f.CategoryAxis}-${f.OrderByFieldsDESC}`,
  // RTL and choosing between rotated or notRotated chart
  `${f.NonRotated}-${f.RTL}-${f.Stacked100}-${f.LegendLeft}-${f.CategoryAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.RTL}-${f.Stacked100}-${f.LegendRight}-${f.CategoryAxis}-${f.OrderByFieldsDESC}`,
  `${f.Rotated}-${f.RTL}-${f.Stacked100}-${f.LegendTop}-${f.CategoryAxis}-${f.OrderByFieldsDESC}`,
  `${f.Rotated}-${f.RTL}-${f.Stacked100}-${f.LegendBottom}-${f.CategoryAxis}-${f.OrderByFieldsDESC}`,
  // Case of ascending order for a ValueAxis
  // SideBySide
  `${f.NonRotated}-${f.RTL}-${f.SideBySide}-${f.LegendTop}-${f.ValueAxis}-${f.OrderByFieldsASC}`,
  `${f.NonRotated}-${f.RTL}-${f.SideBySide}-${f.LegendBottom}-${f.ValueAxis}-${f.OrderByFieldsASC}`,
  `${f.Rotated}-${f.RTL}-${f.SideBySide}-${f.LegendTop}-${f.ValueAxis}-${f.OrderByFieldsASC}`,
  `${f.Rotated}-${f.RTL}-${f.SideBySide}-${f.LegendBottom}-${f.ValueAxis}-${f.OrderByFieldsASC}`,
  // Stacked:
  // LTR and notRotated chart
  `${f.NonRotated}-${f.LTR}-${f.Stacked}-${f.LegendRight}-${f.ValueAxis}-${f.OrderByFieldsASC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked}-${f.LegendLeft}-${f.ValueAxis}-${f.OrderByFieldsASC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked}-${f.LegendTop}-${f.ValueAxis}-${f.OrderByFieldsASC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked}-${f.LegendBottom}-${f.ValueAxis}-${f.OrderByFieldsASC}`,
  // RTL and choosing between rotated or notRotated chart
  `${f.NonRotated}-${f.RTL}-${f.Stacked}-${f.LegendLeft}-${f.ValueAxis}-${f.OrderByFieldsASC}`,
  `${f.NonRotated}-${f.RTL}-${f.Stacked}-${f.LegendRight}-${f.ValueAxis}-${f.OrderByFieldsASC}`,
  `${f.Rotated}-${f.RTL}-${f.Stacked}-${f.LegendTop}-${f.ValueAxis}-${f.OrderByFieldsASC}`,
  `${f.Rotated}-${f.RTL}-${f.Stacked}-${f.LegendBottom}-${f.ValueAxis}-${f.OrderByFieldsASC}`,
  // Stacked100:
  // LTR and notRotated chart
  `${f.NonRotated}-${f.LTR}-${f.Stacked100}-${f.LegendRight}-${f.ValueAxis}-${f.OrderByFieldsASC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked100}-${f.LegendLeft}-${f.ValueAxis}-${f.OrderByFieldsASC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked100}-${f.LegendTop}-${f.ValueAxis}-${f.OrderByFieldsASC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked100}-${f.LegendBottom}-${f.ValueAxis}-${f.OrderByFieldsASC}`,
  // RTL and choosing between rotated or notRotated chart
  `${f.NonRotated}-${f.RTL}-${f.Stacked100}-${f.LegendLeft}-${f.ValueAxis}-${f.OrderByFieldsASC}`,
  `${f.NonRotated}-${f.RTL}-${f.Stacked100}-${f.LegendRight}-${f.ValueAxis}-${f.OrderByFieldsASC}`,
  `${f.Rotated}-${f.RTL}-${f.Stacked100}-${f.LegendTop}-${f.ValueAxis}-${f.OrderByFieldsASC}`,
  `${f.Rotated}-${f.RTL}-${f.Stacked100}-${f.LegendBottom}-${f.ValueAxis}-${f.OrderByFieldsASC}`,
  // Case of descending order for a ValueAxis
  // SideBySide
  `${f.NonRotated}-${f.RTL}-${f.SideBySide}-${f.LegendTop}-${f.ValueAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.RTL}-${f.SideBySide}-${f.LegendBottom}-${f.ValueAxis}-${f.OrderByFieldsDESC}`,
  `${f.Rotated}-${f.RTL}-${f.SideBySide}-${f.LegendTop}-${f.ValueAxis}-${f.OrderByFieldsDESC}`,
  `${f.Rotated}-${f.RTL}-${f.SideBySide}-${f.LegendBottom}-${f.ValueAxis}-${f.OrderByFieldsDESC}`,
  // Stacked:
  // LTR and notRotated chart
  `${f.NonRotated}-${f.LTR}-${f.Stacked}-${f.LegendRight}-${f.ValueAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked}-${f.LegendLeft}-${f.ValueAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked}-${f.LegendTop}-${f.ValueAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked}-${f.LegendBottom}-${f.ValueAxis}-${f.OrderByFieldsDESC}`,
  // RTL and choosing between rotated or notRotated chart
  `${f.NonRotated}-${f.RTL}-${f.Stacked}-${f.LegendLeft}-${f.ValueAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.RTL}-${f.Stacked}-${f.LegendRight}-${f.ValueAxis}-${f.OrderByFieldsDESC}`,
  `${f.Rotated}-${f.RTL}-${f.Stacked}-${f.LegendTop}-${f.ValueAxis}-${f.OrderByFieldsDESC}`,
  `${f.Rotated}-${f.RTL}-${f.Stacked}-${f.LegendBottom}-${f.ValueAxis}-${f.OrderByFieldsDESC}`,
  // Stacked100:
  // LTR and notRotated chart
  `${f.NonRotated}-${f.LTR}-${f.Stacked100}-${f.LegendRight}-${f.ValueAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked100}-${f.LegendLeft}-${f.ValueAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked100}-${f.LegendTop}-${f.ValueAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.LTR}-${f.Stacked100}-${f.LegendBottom}-${f.ValueAxis}-${f.OrderByFieldsDESC}`,
  // RTL and choosing between rotated or notRotated chart
  `${f.NonRotated}-${f.RTL}-${f.Stacked100}-${f.LegendLeft}-${f.ValueAxis}-${f.OrderByFieldsDESC}`,
  `${f.NonRotated}-${f.RTL}-${f.Stacked100}-${f.LegendRight}-${f.ValueAxis}-${f.OrderByFieldsDESC}`,
  `${f.Rotated}-${f.RTL}-${f.Stacked100}-${f.LegendTop}-${f.ValueAxis}-${f.OrderByFieldsDESC}`,
  `${f.Rotated}-${f.RTL}-${f.Stacked100}-${f.LegendBottom}-${f.ValueAxis}-${f.OrderByFieldsDESC}`
]), Gn = "arcgis_charts_title_container", Sr = "arcgis_charts_subtitle_container", Xn = "arcgis_charts_footer_container", iu = "arcgis_charts_title", au = "arcgis_charts_subtitle", ou = "arcgis_charts_footer", Bi = "arcgis_charts_legend_container", ha = "arcgis_charts_legend_title", Dl = "arcgis_charts_axis_title_id", nu = "arcgis_charts_loader_container", su = "arcgis_charts_loader_spinner";
function ru(t) {
  const { root: e } = t, i = w(t.uid, "rtl") ?? !1, a = w(t.uid, "config"), o = a?.series[0], { start: n, end: s } = lu(i, o), r = a?.legend?.position ?? A.heatChart.legend.position, l = r === Y.Top || r === Y.Bottom;
  return Dc.new(e, {
    orientation: l ? "horizontal" : "vertical",
    startColor: n.color,
    endColor: s.color,
    visible: a?.legend?.visible,
    startOpacity: n.opacity,
    endOpacity: s.opacity
  });
}
function lu(t = !1, e) {
  const i = A.heatChart.gradientHeatRules, a = e.gradientRules?.colorList ?? [
    ...t ? [i.maxColor, i.minColor] : [i.minColor, i.maxColor]
  ], { color: o, opacity: n } = re(a[0]), { color: s, opacity: r } = re(a[1]);
  return {
    start: {
      color: o,
      opacity: n
    },
    end: {
      color: s,
      opacity: r
    }
  };
}
function up(t, e) {
  const i = w(t.uid, "rtl") ?? !1, o = w(t.uid, "config")?.series[0], { start: n, end: s } = lu(i, o);
  e.setAll({ startColor: n.color, endColor: s.color });
}
function cu(t, e) {
  const { root: i } = t, o = w(t.uid, "config")?.legend?.position ?? A.heatChart.legend.position;
  let n, s, r, l, c, u = !1;
  switch (o) {
    case Y.Left:
      s = A.heatChart.legend.chartPadding, u = !0, e.setAll({
        layout: i.verticalLayout,
        orientation: "vertical",
        paddingRight: A.heatChart.legend.legendPadding,
        width: A.heatChart.legend.size,
        height: Te
      }), t.leftAxesContainer.setAll({
        paddingLeft: A.heatChart.legend.legendPadding
      }), n = t.leftAxesContainer;
      break;
    case Y.Right:
      r = A.heatChart.legend.chartPadding, e.setAll({
        layout: i.verticalLayout,
        orientation: "vertical",
        paddingLeft: A.heatChart.legend.legendPadding,
        width: A.heatChart.legend.size,
        height: Te
      }), t.rightAxesContainer.setAll({
        paddingRight: A.heatChart.legend.legendPadding
      }), n = t.rightAxesContainer;
      break;
    case Y.Top:
      {
        c = A.heatChart.legend.chartPadding, u = !0, e.setAll({
          layout: i.horizontalLayout,
          orientation: "horizontal",
          paddingBottom: A.heatChart.legend.legendPadding,
          paddingTop: A.heatChart.legend.legendPadding,
          width: Te,
          height: A.heatChart.legend.size
        });
        const d = Ce({ childId: Gn, parent: t });
        d instanceof Gi && d.set("paddingBottom", A.heatChart.legend.chartPadding), n = t;
      }
      break;
    case Y.Bottom:
      {
        l = A.heatChart.legend.chartPadding, e.setAll({
          layout: i.horizontalLayout,
          orientation: "horizontal",
          paddingTop: A.heatChart.legend.legendPadding,
          width: Te,
          height: A.heatChart.legend.size
        }), t.bottomAxesContainer.setAll({
          paddingBottom: A.heatChart.legend.legendPadding
        });
        const d = Ce({ childId: Xn, parent: t });
        d instanceof Gi && d.set("paddingBottom", A.heatChart.legend.chartPadding), n = t.bottomAxesContainer;
      }
      break;
  }
  e.markDirty(), du(t, { chartPaddingTop: c, chartPaddingLeft: s, chartPaddingRight: r, chartPaddingBottom: l }), Za(() => {
    n && (u ? n.children.unshift(e) : n.children.push(e), t.markDirty(), e.markDirty(), n.markDirty());
  });
}
function du(t, e) {
  const { chartPaddingTop: i, chartPaddingLeft: a, chartPaddingRight: o, chartPaddingBottom: n } = e;
  t.setAll({
    paddingTop: i,
    paddingLeft: a,
    paddingRight: o,
    paddingBottom: n
  });
}
function uu(t) {
  const { series: e, legend: i, chart: a } = t, o = Dt({
    root: a.root,
    type: "number",
    intlOptions: {}
  }), n = () => {
    const r = e.getPrivate("valueLow"), l = e.getPrivate("valueHigh");
    r !== void 0 && l !== void 0 && (i.set("startValue", parseFloat(o.format(r))), i.set("endValue", parseFloat(o.format(l))));
  };
  e.events.on("datavalidated", () => {
    n();
  }), n();
  const s = w(a.uid, "config");
  fp(i, s?.legend);
}
function fp(t, e) {
  if (t !== void 0) {
    const i = {
      type: b.Text,
      visible: e?.visible,
      content: {
        ...e?.body,
        type: te.TS,
        text: " "
        // using a non empty string to kick in the adapter on `text`
      }
    };
    [t.startLabel, t.endLabel].forEach((a) => {
      Pt({ label: a, labelConfig: i, skipSettingXAndY: !0 });
    });
  }
}
function fu(t) {
  [t.bottomAxesContainer, t.rightAxesContainer, t.leftAxesContainer, t].forEach(
    (e) => {
      e.children.values.filter((a) => a instanceof Dc).forEach((a) => {
        e.children.removeValue(a), a.dispose();
      }), e.markDirty();
    }
  ), du(t, {});
}
function mp(t) {
  const e = t.series.values[0];
  fu(t);
  const i = ru(t);
  return uu({ series: e, legend: i, chart: t }), cu(t, i), i;
}
function gp(t) {
  const { chart: e, chartConfig: i } = t, { legend: a } = i, o = a !== void 0 && a.visible !== !1;
  fu(e);
  const n = e.series.values[0], s = i?.legend?.position ?? A.heatChart.legend.position;
  o && n !== void 0 && n instanceof Ee && s === Y.Bottom && Za(() => {
    const r = ru(e);
    up(e, r), cu(e, r), uu({ series: n, legend: r, chart: e });
  });
}
function mu(t) {
  const e = t.get("id");
  t.on("visible", (i, a) => {
    if (a) {
      const { chart: o } = a;
      if (o instanceof Ba) {
        const n = Ce({ childId: Bi, parent: o });
        n !== void 0 && n.dataItems?.forEach((s) => {
          s.get("id") === e && n.set("opacity", i ? 1 : A.legendProperties.legendLabelReducedOpacity);
        });
      }
    }
  });
}
function hp(t) {
  const e = t.target.dataItem;
  if (e?.dataContext !== void 0) {
    const { dataContext: i } = e, a = typeof i == "object" && i !== null && "component" in i ? i.component : i;
    if (a instanceof Ws) {
      const n = { visible: !a.get("visible") };
      Mi(a) || Mo(a) ? n.overlayType = he(a.uid, "type") : n.seriesId = a.get("id"), ed(n, a.root.dom);
    }
  }
}
function pp(t) {
  t.itemContainers.template.events.on(le.Click, hp);
}
function bp(t, e) {
  const i = w(e.uid, "rtl") ?? !1;
  t.itemContainers.template.setAll({ reverseChildren: i });
}
function gu(t) {
  const { chart: e, legend: i, chartConfig: a, hideEmptySeries: o } = t, n = z(a.series);
  if (e.series.length > 1 || n === b.PieSeries) {
    let s = [];
    const r = U(a.series);
    switch (n) {
      case b.BoxPlotSeries: {
        const l = qe(a);
        s = e.series.values.filter((c) => {
          let u = !1;
          return l ? u = c instanceof ge && !(c instanceof An) : u = c instanceof ua, u;
        });
        break;
      }
      case b.HistogramSeries: {
        s = e.series.values.filter((l) => {
          let c = !1;
          if (he(l.uid, "isOverlay")) {
            const u = a.series[0].type === b.HistogramSeries ? a.series[0].overlays : void 0, d = he(l.uid, "type");
            let m;
            switch (d) {
              case $e.Mean:
                m = u?.mean?.created;
                break;
              case $e.Median:
                m = u?.median?.created;
                break;
              case $e.Normal:
                m = u?.comparisonDistribution?.created;
                break;
              case $e.StdDev:
                m = u?.standardDeviation?.created;
                break;
            }
            c = m === !0;
          }
          return c;
        });
        break;
      }
      case b.PieSeries: {
        s = e.series.getIndex(0)?.dataItems ?? [];
        break;
      }
      case b.ComboLineAndBarSeries:
      case b.LineSeries:
      case b.RadarSeries:
      case b.BarSeries:
        s = e.series.values.filter((l) => {
          let c = !0;
          if (o !== !1) {
            const u = a.series.find((d) => d.id === l.get("id"));
            if (u !== void 0 && "y" in u && typeof u.y == "string") {
              const { x: d, y: m } = u, g = r === P.BarAndLineSplitByNoAggregation ? `${m}_${Ki({ where: u.query?.where, keepSurroundingQuotes: !1, escape: !1 })}` : m;
              c = l.data.values.some(
                (y) => Ys({ dataItem: y, x: d, y: g })
              );
            }
          }
          return c;
        });
        break;
      case b.ScatterSeries: {
        const l = Du(e);
        l !== void 0 && (s = [l]);
        break;
      }
    }
    i.data.setAll(s);
  }
}
function Ol(t) {
  let e = 0;
  return t.dataItems.forEach((i) => {
    const a = i.get("itemContainer").width();
    e = Math.max(a, e);
  }), Math.ceil(e);
}
function so(t, e) {
  const { root: i } = t, a = Ce({ childId: Bi, parent: t });
  if (a !== void 0) {
    const o = w(t.uid, "config"), n = w(t.uid, "rtl"), s = o?.title ? o.title.visible ?? !0 : !1, r = o?.subtitle ? o.subtitle.visible ?? !0 : !1, l = o?.footer ? o.footer.visible ?? !0 : !1, c = o?.legend ? o.legend.visible ?? !0 : !1, u = o?.legend?.title ? o.legend.title.visible ?? !0 : !1, d = Ce({ childId: Gn, parent: t }), m = d instanceof Gi && s ? d.height() : 0, g = Ce({ childId: Sr, parent: t }), h = g instanceof Gi && r ? g.height() : 0, y = Ce({ childId: Xn, parent: t }), p = y instanceof Gi && l ? y.height() : 0, S = Ce({ childId: ha, parent: a }), x = S instanceof yi && c && u ? S?.height() : 0, C = o?.legend?.position ?? A.legendProperties.position;
    let v;
    const F = e.get("verticalScrollbar");
    let T = Ae, k = Ae, $ = i.verticalLayout, O = Ae, D = Ae, R = Ae, M = Ae, N = 0, E;
    const W = e.height() + x;
    let H = 0, Z = 0, oe = 0, ie = 0, X, q;
    switch (C) {
      case Y.Left:
        $ = i.verticalLayout, O = Ke, R = Ke, D = Ke, M = Ke, E = void 0, T = Ke, k = Ke, H = a.width(), N = m + h, W < t.seriesContainer.height() && (N += t.seriesContainer.height() / 2 - W / 2), v = Ol(e), F?.width() !== void 0 && v && F.isVisible() && (v += F.width() + A.scrollbarPadding), n && (X = Te, q = v);
        break;
      case Y.Right:
        $ = i.verticalLayout, O = Te, R = Te, D = Ke, M = Ke, E = void 0, T = Ke, k = Ke, Z = a.width(), N = m + h, W < t.seriesContainer.height() && (N += t.seriesContainer.height() / 2 - W / 2), v = Ol(e), F?.width() !== void 0 && v && F.isVisible() && (v += F.width() + A.scrollbarPadding), n && (X = Te, q = v);
        break;
      case Y.Top:
        $ = i.gridLayout, O = Ae, R = Ae, D = Ke, M = Ke, E = Te, T = Ae, k = Ae, oe += W, N += m + h, v = void 0, n && (X = void 0);
        break;
      case Y.Bottom:
        $ = i.gridLayout, O = Ae, R = Ae, D = Te, M = Te, E = Te, T = Ae, k = Ae, ie = W, N = -ie - p, v = void 0, n && (X = void 0);
        break;
    }
    (v === void 0 || v > 0) && (e.setPrivate("width", v), n && e.itemContainers.template.setAll({
      centerX: X,
      dx: q
    })), e.setAll({ layout: $, x: T, centerX: k }), a.setAll({
      x: O,
      y: D,
      centerX: R,
      centerY: M,
      dy: N,
      width: E,
      height: 0
    }), t.chartContainer.setAll({
      paddingBottom: ie,
      paddingTop: oe,
      paddingLeft: H,
      paddingRight: Z
    }), E === void 0 && (a.setPrivate("width", void 0), a.markDirty()), t instanceof ti && eu(e, C);
  }
}
function yp(t) {
  const { chart: e, legend: i, legendContainer: a } = t, o = Ce({ childId: ha, parent: a });
  o && o.on("visible", () => {
    i.root.events.once(le.FrameEnded, () => {
      so(e, i);
    });
  }), a.events.on(le.BoundsChanged, () => {
    so(e, i);
  }), i.events.on(le.BoundsChanged, () => {
    so(e, i);
  }), e.seriesContainer.onPrivate("height", () => {
    so(e, i);
  });
}
function hu(t, e) {
  const i = Co({
    root: e.root,
    parent: e,
    index: 0,
    id: Xt(ha, e.uid)
  });
  return i.set("paddingTop", 10), vo({
    chart: t,
    label: i,
    labelType: ae.LegendTitle
  }), i;
}
function Sp(t, e) {
  e.markers.template.setAll({
    width: A.legendProperties.legendMarkersSize,
    height: A.legendProperties.legendMarkersSize
  }), e.labels.template.adapters.add("text", (i, a) => {
    let o = i;
    const n = a.dataItem?.component;
    n instanceof ht ? o = (a.dataItem?.dataContext?.[n.get("categoryField") ?? ""] ?? i)?.toString() : n instanceof Ws && (o = n.get("name"));
    const s = w(t.uid, "config");
    if (s !== void 0) {
      const { legend: r } = s, l = { ...r?.body, type: te.TS, text: o };
      o = ft({ textSymbol: l, format: "amChartsV5" });
    }
    return o;
  });
}
function xp(t, e) {
  e.seriesContainer.onPrivate("height", (i) => {
    let a = 0;
    const o = w(e.uid, "config"), n = o?.legend, s = Ce({ childId: Bi, parent: e });
    if (s !== void 0) {
      const l = Ce({ childId: ha, parent: s });
      l !== void 0 && n?.visible !== !1 && n?.title?.visible !== !1 && (a = l.height());
    }
    let r = o?.legend?.maxHeight ?? Number.NaN;
    Number.isFinite(r) || (o?.legend?.position === Y.Top || o?.legend?.position === Y.Bottom ? r = A.legendProperties.maxHeight : typeof i == "number" && (r = i - a)), t.set("maxHeight", r);
  });
}
function Cp(t, e, i) {
  t.events.on(le.DataValidated, () => {
    t.dataItems.length > 0 && pu(t, e, i);
  });
}
function vp(t) {
  let e;
  if (t !== void 0) {
    const i = w(t?.uid, "config");
    e = w(t.uid, "rtl") && (i?.legend?.position === Y.Top || i?.legend?.position === Y.Bottom);
  }
  return e ?? !1;
}
function Lp(t) {
  let e = "";
  if (t instanceof Se) {
    const i = w(t.uid, "config"), a = jt(i), o = a ? f.Rotated : f.NonRotated, n = zt(i);
    let s = f.SideBySide;
    n === Ie.Stacked ? s = f.Stacked : n === Ie.Stacked100 && (s = f.Stacked100);
    const r = w(t.uid, "rtl") ? f.RTL : f.LTR;
    let l;
    switch (i?.legend?.position) {
      case Y.Left:
        l = f.LegendLeft;
        break;
      case Y.Top:
        l = f.LegendTop;
        break;
      case Y.Bottom:
        l = f.LegendBottom;
        break;
      case Y.Right:
      default:
        l = f.LegendRight;
        break;
    }
    const c = a ? t.yAxes.getIndex(0) : t.xAxes.getIndex(0);
    let u;
    c instanceof tt ? u = f.DateAxis : c instanceof we ? u = f.ValueAxis : u = f.CategoryAxis;
    const m = i?.orderOptions?.data?.orderBy === Ln.Descending ? f.OrderByFieldsDESC : f.OrderByFieldsASC;
    e = `${o}-${r}-${s}-${l}-${u}-${m}`;
  }
  return e;
}
function Fp(t) {
  const e = Lp(t);
  return tu.has(e);
}
function pu(t, e, i) {
  switch (i) {
    case b.HistogramSeries:
    case b.PieSeries:
      t.set("reverseChildren", vp(e));
      break;
    case b.BarSeries:
    case b.LineSeries:
    case b.RadarSeries:
    case b.ComboLineAndBarSeries:
      t.set("reverseChildren", Fp(e));
      break;
  }
}
function Ap(t, e) {
  const i = Ce({ childId: Bi, parent: t });
  if (i !== void 0) {
    const a = Ce({ childId: ha, parent: i }) ?? hu(t, i);
    if (e !== void 0) {
      const { title: o, visible: n } = e, { legendTitle: s } = A.legendProperties;
      o !== void 0 ? (Pt({
        label: a,
        labelConfig: { ...o, visible: n !== !1 && o.visible !== !1 },
        defaults: { ...s, verticalCenter: ee.Top }
      }), vi({
        chart: t,
        label: a,
        labelType: ae.LegendTitle
      })) : Re(a, !1);
    }
  }
}
function Tp(t, e = !1) {
  const i = e ? A.legendProperties.roundedMarkerRadius : A.legendProperties.rectangleMarkerRadius;
  t.markerRectangles.template.setAll({
    cornerRadiusTL: i,
    cornerRadiusTR: i,
    cornerRadiusBL: i,
    cornerRadiusBR: i
  });
}
function kp(t) {
  const { legend: e, legendConfig: i, chartType: a, seriesConfig: o, chart: n } = t;
  if (e !== void 0) {
    const s = {
      type: b.Text,
      visible: i?.visible,
      content: {
        ...i?.body,
        type: te.TS,
        text: " "
        // using a non empty string to kick in the adapter on `text`
      }
    };
    if (a === b.PieSeries) {
      const r = Ce({ childId: Bi, parent: n });
      r !== void 0 && Ce({ childId: ha, parent: r }) !== void 0 && Qd({
        legend: e,
        seriesConfig: o,
        webChartLegend: i,
        chart: n
      });
    }
    Pt({ label: e.labels.template, labelConfig: s }), e.labels.template.setAll({ x: void 0, y: void 0, paddingRight: 5 });
  }
}
function Ip(t, e) {
  e === !0 && t.itemContainers.each((i) => {
    i.events.disableType(le.Click);
  });
}
function Rl(t) {
  const { chart: e, seriesConfig: i, isHeatChart: a } = t, { root: o } = e;
  let n;
  if (a)
    n = mp(e);
  else {
    const s = Gi.new(o, {
      id: Xt(Bi, e.uid),
      layout: o.verticalLayout
    });
    n = Fn.new(o, { verticalScrollbar: Fs.new(o, { orientation: "vertical" }) }), e instanceof ti ? sp(n) : n.valueLabels.template.setAll({ forceHidden: !0, textAlign: "left" }), Sp(e, n), hu(e, s), pp(n), bp(n, e), yp({ chart: e, legend: n, legendContainer: s }), xp(n, e), Cp(n, e, z(i)), s.children.push(n), e.children.push(s);
  }
  return n;
}
function wp(t) {
  const { chart: e, legend: i, showLegend: a } = t, o = Ce({ childId: Bi, parent: e });
  o && (Re(o, a), Re(i, a));
}
function $p(t) {
  const { chart: e, showLegend: i, legendConfig: a } = t;
  if (a) {
    const { title: o, visible: n } = a, s = o !== void 0 && n !== !1 && o.visible !== !1, r = Ce({ childId: Bi, parent: e });
    if (r) {
      const l = Ce({ childId: ha, parent: r });
      l && (o ? Re(l, s) : Re(l, i));
    }
  }
}
function bu(t) {
  const { chart: e, chartConfig: i, legend: a, heatChartLegendUpdatedNeeded: o, hideEmptySeries: n, seriesConfig: s, isHeatChart: r } = t, { legend: l, series: c } = i;
  if (r && o)
    gp({
      chart: e,
      chartConfig: i
    });
  else if (a instanceof Fn && a !== void 0 && Ce({ childId: Bi, parent: e }) !== void 0) {
    const d = Bc(c) && l !== void 0 && l.visible !== !1;
    if (wp({ chart: e, legend: a, showLegend: d }), $p({ chart: e, showLegend: d, legendConfig: l }), d) {
      Tp(a, l?.roundMarkers), kp({
        legend: a,
        legendConfig: l,
        chartType: z(c),
        seriesConfig: s,
        chart: e
      }), pu(a, e, z(c)), gu({ chart: e, legend: a, chartConfig: i, hideEmptySeries: n }), Ap(e, l), so(e, a);
      const m = w(e.uid, "options");
      Ip(a, m?.disableTogglingLegendItems), e instanceof ti && dp({ legend: a, chart: e, seriesConfig: s, legendConfig: l });
    }
  }
}
function yu(t) {
  const { axesConfig: e, currentSeries: i, tooltipValueFormat: a } = t, { root: o, chart: n } = i;
  if (n) {
    const s = e?.[1]?.valueFormat, r = e?.[0].valueFormat, l = w(n.uid, "formatLocale");
    if (s?.type === b.NumberAxisFormat) {
      const c = Dt({
        root: o,
        type: s.type,
        formatLocale: l,
        intlOptions: s.intlOptions
      });
      Pe(i.uid, {
        tooltipValueYNumberFormatCallback: (u) => c.format(u, a?.intlOptions ?? s.intlOptions)
      });
    }
    if (r?.type === b.NumberAxisFormat) {
      const c = Dt({
        root: o,
        type: r.type,
        formatLocale: l,
        intlOptions: r.intlOptions
      });
      Pe(i.uid, {
        tooltipValueXNumberFormatCallback: (u) => c.format(u, a?.intlOptions ?? r.intlOptions)
      });
    }
  }
}
function li(t, e) {
  return e != null && e !== "" ? e : t;
}
function Su(t, e) {
  let i;
  switch (t) {
    case Wt.Average: {
      i = e.statistics.mean;
      break;
    }
    case Wt.ContinuousPercentile: {
      i = e.statistics.median;
      break;
    }
    case Wt.Sum: {
      i = e.statistics.sum;
      break;
    }
    case Wt.Minimum: {
      i = e.statistics.minimum;
      break;
    }
    case Wt.Maximum: {
      i = e.statistics.maximum;
      break;
    }
    case Wt.Variance: {
      i = e.statistics.variance;
      break;
    }
    case Wt.DiscretePercentile: {
      i = e.statistics.discretePercentile;
      break;
    }
    case Wt.NoAggregation: {
      i = e.statistics.noAggregation;
      break;
    }
    case Wt.Count:
    default: {
      i = e.statistics.count;
      break;
    }
  }
  return i;
}
function xr(t) {
  const { config: e, fieldName: i = "", utilsStrings: a } = t, o = e.series[0].query?.outStatistics?.[0].statisticType ?? kc.statisticType, n = Su(o, a);
  return Ra(a.statistics.aggregation, {
    statistics: n,
    fieldName: i
  });
}
function xu(t) {
  const { config: e, fieldList: i, objectIdField: a, seriesIndex: o, isStacked100: n, utilsStrings: s } = t;
  let r = "";
  const l = e.series[o].name, c = e.series[o], u = [c.y].flat()[0], d = e.axes, m = U(e.series), g = a ?? Na.outStatistics.onStatisticField, h = c.query?.outStatistics?.[0].onStatisticField ?? g, y = De(i, h), p = c.query?.outStatistics?.[0].statisticType ?? kc.statisticType, S = Su(p, s);
  return m === P.BarAndLineNoAggregation ? r = l ?? De(i, u) : m === P.BarAndLineSplitByNoAggregation ? r = De(i, u) : (r = p === Wt.Count && h === g ? s.statistics.count : Ra(s.statistics.aggregation, {
    statistics: S,
    fieldName: y ?? l
  }), m === P.BarAndLineMonoField && !n && (r = li(r, d[1].title?.content?.text))), r;
}
function Cu(t) {
  return un(t.uid.toString(), Md);
}
function Yn(t) {
  return t != null && !t.isDisposed();
}
function Dp(t) {
  const e = mo(t), { r: i, g: a, b: o } = e;
  return { r: i, g: a, b: o };
}
function en(t) {
  const { r: e, g: i, b: a, a: o = 1 } = t, n = Math.round((1 - o) * 255 + o * e), s = Math.round((1 - o) * 255 + o * i), r = Math.round((1 - o) * 255 + o * a);
  return 0.299 * n + 0.587 * s + 0.114 * r > 128;
}
function vu(t) {
  const e = Ka(t);
  t.columns.template.set("tooltip", e), t.columns.template.setAll({
    tooltipText: " ",
    tooltipPosition: "fixed"
  }), t.columns.template.adapters.remove("tooltipText"), t.columns.template.adapters.add(
    "tooltipText",
    (i, a) => pa(a, t)
  );
}
function Op(t) {
  const { axes: e, seriesConfig: i, series: a, fieldList: o, utilsStrings: n } = t, { dataTooltipVisible: s } = i;
  let r;
  const l = w(a.chart?.uid ?? 0, "rtl") ?? !1, c = bt(l);
  return s === !1 ? r = (u, d, m) => "" : r = (u, d, m) => {
    const g = De(o, i.x), h = li(g, e?.[0].title?.content?.text), y = li(n?.statistics.count ?? "", e?.[1]?.title?.content?.text ?? ""), p = he(
      a.uid,
      "tooltipValueXNumberFormatCallback"
    ), S = he(
      a.uid,
      "tooltipValueYNumberFormatCallback"
    ), x = p ? p(d) : d, C = p ? p(m) : m, v = S ? S(u) : u;
    return `[bold]${h}${c} [/]${x} - ${C}
[bold]${y}${c} [/]${v}`;
  }, r;
}
function Rp(t) {
  const { seriesConfig: e, series: i, tooltip: a } = t, { dataTooltipVisible: o } = e;
  if (o !== !1) {
    const n = he(
      i.uid,
      "histogramTooltipFormatter"
    );
    if (n !== void 0) {
      const s = a.dataItem;
      if (s !== void 0) {
        const r = s.dataContext;
        return n(s.get("valueY") ?? 0, r.minValue, r.maxValue);
      }
    }
  }
  return "";
}
function Lu(t) {
  const e = Ka(t);
  t.columns.template.set("tooltip", e), t.columns.template.setAll({
    tooltipText: " ",
    tooltipPosition: "fixed"
  }), t.columns.template.adapters.add("tooltipText", (i, a) => pa(a, t));
}
function Bp(t) {
  const { series: e, tooltipFormatter: i, axesConfig: a, seriesConfig: o } = t;
  yu({
    axesConfig: a,
    currentSeries: e,
    tooltipValueFormat: o.dataTooltipValueFormat
  }), Pe(e.uid, {
    histogramTooltipFormatter: i ?? Op(t)
  });
}
function Mp(t, e) {
  let i = (h, y, p) => "";
  const {
    numericValueFormat: a,
    percentValueFormat: o,
    dataTooltipValueFormat: n,
    dataTooltipPercentFormat: s,
    displayCategoryOnTooltip: r,
    displayNumericValueOnTooltip: l,
    displayPercentageOnTooltip: c,
    valuePrefix: u,
    valueSuffix: d,
    percentagePrefix: m,
    percentageSuffix: g
  } = e;
  return i = (h, y, p) => {
    let S = "";
    const { chart: x } = t;
    if (x) {
      const v = yr({
        pieChart: x,
        valueIntlOptions: (n ?? a)?.intlOptions,
        percentageIntlOptions: (s ?? o)?.intlOptions,
        displayNumericValue: l ?? A.pieChart.displayNumericValueOnTooltip,
        displayPercentage: c ?? A.pieChart.displayPercentageOnTooltip,
        valuePrefix: u,
        valueSuffix: d,
        percentagePrefix: m,
        percentageSuffix: g
      })("", y, p), F = !ye(h) && (r ?? A.pieChart.displayCategoryOnTooltip);
      if (F && (S = `[bold]${h}[/]`), !ye(v)) {
        const T = tr(v);
        S = F ? `${S}
${T}` : T;
      }
    }
    return S;
  }, i;
}
function Np(t) {
  const e = t.get("tooltip");
  if (e !== void 0) {
    let i = t.get("fill");
    i instanceof wc && (i = i.get("fill")), e.get("background")?.set("fill", i);
  }
}
function Pp(t) {
  const { pieSeries: e, tooltip: i } = t;
  let a = "";
  const { chart: o } = e;
  if (o !== void 0 && i !== void 0) {
    const n = w(o.uid, "config"), { dataTooltipVisible: s } = n?.series[0] ?? {};
    if (s !== !1) {
      const r = he(
        e.uid,
        "pieChartTooltipFormatter"
      );
      if (r) {
        const l = i.dataItem;
        if (l !== void 0) {
          const c = l, u = c.get("category") ?? "", d = l.dataContext;
          let m = si(d);
          m === void 0 && (m = u);
          const g = c.get("value"), h = c.get("valuePercentTotal");
          typeof g == "number" && g !== 0 && n?.series?.[0]?.dataTooltipVisible !== !1 ? (i.set("disabled", !1), Np(c.get("slice")), a = r(u, g, h, m)) : i.set("disabled", !0);
        }
      }
    } else
      return;
  }
  return a;
}
function Fu(t) {
  const e = t.slices.template, i = Ka(t);
  e.setAll({
    tooltip: i,
    tooltipText: " ",
    tooltipPosition: "fixed"
  }), e.adapters.remove("tooltipText"), e.adapters.add("tooltipText", (a, o) => {
    let n = " ";
    try {
      const s = o.get("tooltip");
      s && (s.dataItem = o.dataItem, n = pa(s, t));
    } catch {
    }
    return n;
  }), e.set("tooltipText", " ");
}
function Vp(t) {
  const { series: e, seriesConfig: i, tooltipFormatter: a } = t;
  Pe(e.uid, {
    pieChartTooltipFormatter: a ?? Mp(e, i)
  });
}
function Bl(t) {
  const { value: e, formatLocale: i, unit: a, config: o, utilsStrings: n } = t;
  let s = { label: "", value: e.toString() };
  switch (a) {
    case Ht.DayOfWeek:
      s = {
        label: n.dayOfWeek,
        value: Gd({
          weekdayNumber: e,
          firstDayOfWeek: "firstDayOfWeek" in o ? o.firstDayOfWeek : A.heatChartFirstDayOfWeek,
          locale: i
        })
      };
      break;
    case Ht.MonthOfYear:
      s = {
        label: n.monthOfYear,
        value: Xd({
          monthNumber: e,
          locale: i
        })
      };
      break;
    case Ht.HourOfDay:
      s = {
        label: n.hourOfDay,
        value: Hd({
          hour: e,
          locale: i
        })
      };
      break;
    case Ht.DayOfMonth:
      s = {
        label: n.dayOfMonth,
        value: typeof e == "string" ? e : e?.toString() ?? ""
      };
      break;
    case Ht.DayOfYear:
      s = {
        label: n?.dayOfYear,
        value: typeof e == "string" ? e : e?.toString() ?? ""
      };
      break;
    case Ht.MinuteOfDay:
      s = {
        label: n?.minuteOfDay,
        value: typeof e == "string" ? e : e?.toString() ?? ""
      };
      break;
    case Ht.WeekOfYear:
      s = {
        label: n?.weekOfYear,
        value: typeof e == "string" ? e : e?.toString() ?? ""
      };
      break;
    case Ht.QuarterOfYear:
      s = {
        label: n?.quarterOfYear,
        value: typeof e == "string" ? e : e?.toString() ?? ""
      };
      break;
  }
  return s;
}
function Ep(t) {
  const { columnSeries: e, seriesConfig: i, utilsStrings: a, fieldList: o } = t;
  return (n, s, r) => {
    let l = "", c = n;
    const u = w(e.chart?.uid ?? 0, "rtl"), d = w(e.chart?.uid ?? 0, "config");
    if (c !== null) {
      if (e.chart) {
        const x = Dt({
          root: e.chart.root,
          type: "number",
          intlOptions: {}
        });
        c = parseFloat(x.format(n));
      }
    } else
      c = d?.series[0].emptyCells?.text ?? A.heatChart.emptyCells?.text ?? "";
    const m = w(e.chart?.uid ?? 0, "config"), g = bt(u ?? !1), h = xr({
      config: m,
      fieldName: De(o, i.query?.outStatistics?.[0].onStatisticField ?? ""),
      utilsStrings: a
    }), y = w(e.chart?.uid ?? 0, "formatLocale");
    let p = { label: i.x, value: s }, S = { label: i.y, value: r };
    if (i.xTemporalBinning !== void 0) {
      const { label: x, value: C } = Bl({
        value: Number(s),
        config: m,
        formatLocale: y,
        unit: i.xTemporalBinning.unit,
        utilsStrings: a
      });
      !ye(x) && !ye(C) && (p = { label: x, value: C });
    }
    if (i.yTemporalBinning !== void 0) {
      const { label: x, value: C } = Bl({
        value: Number(r),
        config: m,
        formatLocale: y,
        unit: i.yTemporalBinning.unit,
        utilsStrings: a
      });
      !ye(x) && !ye(C) && (S = { label: x, value: C });
    }
    return ye(l) && (l = `[bold]${p.label}${g} [/]${p.value}
[bold]${S.label}${g} [/]${S.value}
[bold]${h}${g}[/] ${c} [/]]`), l;
  };
}
function zp(t) {
  const { heatSeries: e, tooltip: i } = t;
  let a = "";
  const { chart: o } = e;
  if (o !== void 0 && i !== void 0) {
    const n = w(o.uid, "config"), { dataTooltipVisible: s } = n?.series[0] ?? {};
    if (s !== !1) {
      const r = he(
        e.uid,
        "heatChartTooltipFormatter"
      );
      if (r) {
        const l = i.dataItem;
        if (l !== void 0) {
          const c = l.dataContext;
          if (n?.series?.[0]?.dataTooltipVisible !== !1) {
            const u = c?.[Me.valueField] ?? null, d = c?.[Me.xField], m = c?.[Me.yField];
            a = r(u, d, m);
          }
        }
      }
    } else
      return;
  }
  return He(a);
}
function Au(t) {
  const e = Ka(t);
  t.columns.template.set("tooltip", e), t.columns.template.setAll({
    tooltipText: " ",
    tooltipPosition: "fixed"
  }), t.columns.template.adapters.remove("tooltipText"), t.columns.template.adapters.add(
    "tooltipText",
    (i, a) => pa(a, t)
  );
}
function Wp(t) {
  const { series: e, seriesConfig: i, tooltipFormatter: a, utilsStrings: o, fieldList: n } = t;
  Pe(e.uid, {
    heatChartTooltipFormatter: a ?? Ep({ columnSeries: e, seriesConfig: i, utilsStrings: o, fieldList: n })
  });
}
function Ml(t, e) {
  if (e !== void 0) {
    const i = Dp(e);
    i !== void 0 && t.label.setAll({
      fill: en({ r: i.r, g: i.g, b: i.b, a: 1 }) ? mo("#000000") : mo("#ffffff")
    });
  }
}
function Tu(t) {
  t.label.setAll({
    paddingTop: 4,
    paddingBottom: 4
  });
}
function ku(t, e) {
  const { dataTooltipStyleReversed: i, dataTooltipStyle: a } = A;
  if (e === !0) {
    const o = t.get("background")?.get("fill");
    o !== void 0 && (Ml(t, t.get("background")?.get("fill")?.toCSS()), i?.color !== void 0 && o.toCSSHex() !== re(i.color).color.toCSSHex() && t.get("background")?.setAll({
      fill: re(i.color).color,
      stroke: o,
      strokeWidth: i.outline?.width ?? Number.NaN
    }));
  } else
    Ml(t, t.get("background")?.get("fill")?.toCSS()), t.setAll({ getStrokeFromSprite: !0, getFillFromSprite: !0 }), t.get("background")?.setAll({
      strokeWidth: a?.outline?.width ?? Number.NaN,
      stroke: re(a?.outline?.color).color
    });
}
function Nl(t, e) {
  if (t.get("tooltip") === void 0) {
    const i = Ka(e);
    t.set("tooltip", i), t.setAll({
      tooltipText: " ",
      tooltipPosition: "fixed"
    }), t.adapters.remove("tooltipText"), t.adapters.add("tooltipText", (a, o) => pa(o, e));
  }
}
function Ka(t) {
  const { root: e, chart: i } = t, a = za.new(e, {});
  return a.label.setAll({
    oversizedBehavior: "wrap",
    maxWidth: A.tooltipWidth
  }), a.adapters.add("visible", (o, n) => (o && wu(n, t), o)), Iu(a, i), a;
}
function Cr(t, e) {
  const { chart: i } = e, a = za.new(t, {});
  return a.label.setAll({
    oversizedBehavior: "wrap",
    maxWidth: A.tooltipWidth
  }), a.adapters.add("visible", (o, n) => (o && wu(n, e), o)), Iu(a, i), a.adapters.remove("tooltipText"), a.adapters.add("tooltipText", (o, n) => pa(n, e)), a;
}
function Iu(t, e) {
  if (t) {
    const i = w(e?.uid ?? 0, "rtl");
    t.label.set("direction", i ? "rtl" : "ltr"), Tu(t), t.get("background")?.setAll({
      fillOpacity: kn
      // Adjust transparency for fill
    });
  }
}
function wu(t, e) {
  const { chart: i } = e;
  if (i && t) {
    const a = w(i.uid, "config");
    if (a) {
      const { seriesConfig: o } = jn(e, a);
      if (o) {
        const { dataTooltipReverseColor: n } = o;
        ku(t, n);
      }
    }
  }
}
function Hp(t) {
  const { seriesConfig: e, series: i, tooltip: a, isRotated: o } = t, n = he(
    i.uid,
    "barAndLineTooltipFormatter"
  );
  if (n !== void 0) {
    const s = a.dataItem;
    if (s !== void 0) {
      const r = s.get("valueX"), l = s.get("valueY"), c = s.get("valueXTotalPercent"), u = s.get("valueYTotalPercent"), d = o ? r : l;
      let m;
      o && typeof c == "number" ? m = c : !o && typeof u == "number" && (m = u), m && (m /= 100);
      const g = s.dataContext ?? {}, h = w(i.chart?.uid ?? 0, "config"), y = w(i.chart?.uid ?? 0, "rendererFieldNames"), p = oi({
        value: g[e.x],
        dataContext: g,
        useRendererLabel: yo(h, y)
      });
      let S = si(g);
      S === void 0 && (S = p);
      const x = g[A.dateBinningRange];
      if (S !== void 0 || d !== void 0 || m !== void 0 || x !== void 0)
        return n({
          seriesName: i.get("name") ?? e.name,
          xValue: p,
          originalXValue: S,
          dateBinningRange: x,
          statValue: d,
          percentValue: m
        });
    }
  }
}
function Pl(t, e) {
  if (t instanceof za)
    t.set("forceHidden", e);
  else {
    const i = t.get("tooltip");
    i && i.set("forceHidden", e);
  }
}
function pa(t, e) {
  let i;
  const { chart: a } = e;
  if (a !== void 0) {
    const o = w(a.uid, "config"), { seriesConfig: n } = jn(e, o), { dataTooltipVisible: s } = o?.series[0] ?? {};
    if (s === !1 || !n)
      i = "", Pl(t, !0);
    else
      switch (Pl(t, !1), n.type) {
        case b.ScatterSeries:
          e instanceof ge && (i = _p({
            seriesConfig: n,
            markerSeries: e,
            tooltip: t
          }));
          break;
        case b.BarSeries:
        case b.LineSeries:
        case b.RadarSeries:
          i = Hp({
            seriesConfig: n,
            series: e,
            tooltip: t,
            isRotated: o?.rotated ?? !1
          });
          break;
        case b.HistogramSeries:
          i = Rp({
            seriesConfig: n,
            series: e,
            tooltip: t
          });
          break;
        case b.HeatSeries:
          i = zp({
            heatSeries: e,
            tooltip: t
          });
          break;
        case b.PieSeries:
          e instanceof ht && t instanceof za && (i = Pp({
            pieSeries: e,
            tooltip: t
          }));
          break;
      }
  }
  return i ?? "";
}
function Gp(t) {
  const { series: e, dateRange: i, xAxisValueFormat: a } = t;
  let o;
  const n = w(
    e.chart?.uid ?? Number.NaN,
    "timeIntervalInfo"
  );
  if (i !== void 0 && i.length > 0) {
    let s = {};
    switch (n?.unit) {
      case xe.Second:
        s = {
          month: "numeric",
          day: "numeric",
          year: "numeric",
          hour: "numeric",
          minute: "numeric",
          second: "numeric"
        };
        break;
      case xe.Minute:
        s = {
          month: "numeric",
          day: "numeric",
          year: "numeric",
          hour: "numeric",
          minute: "numeric"
        };
        break;
      case xe.Hour:
        s = {
          month: "numeric",
          day: "numeric",
          year: "numeric",
          hour: "numeric",
          minute: "numeric"
        };
        break;
      case xe.Day:
      case xe.Week:
      case xe.Month:
      case xe.Year:
        s = {
          month: "numeric",
          day: "numeric",
          year: "numeric"
        };
        break;
    }
    s.timeZone = a.intlOptions.timeZone;
    const r = new Date(i[0]), l = new Date(i[1]), { root: c } = e;
    if (!Number.isNaN(r.valueOf()) && e.chart !== void 0) {
      const u = w(e.chart.uid, "formatLocale"), d = Dt({
        root: c,
        type: b.DateAxisFormat,
        formatLocale: u,
        intlOptions: s
      }), m = d.format(r, s);
      if (o = m, !Number.isNaN(l.valueOf())) {
        const g = d.format(l, s);
        g !== m && (o = `${o} - ${g}`);
      }
    }
  }
  return o?.toString() ?? "";
}
function Xp(t) {
  const {
    seriesConfig: e,
    xAxisValueFormat: i,
    setTimeBinningInfoWhenNotProvided: a,
    dataTooltipValueFormat: o,
    dataTooltipDateFormat: n,
    series: s,
    xValue: r,
    dateBinningRange: l
  } = t, { root: c } = s;
  let u;
  const d = w(s.chart?.uid ?? 0, "formatLocale");
  return /* case 1: time binning chart */ Ha({
    seriesConfig: e,
    xAxisValueFormatType: i?.type,
    setTimeBinningInfoWhenNotProvided: a
  }) && l !== void 0 && i?.type === b.DateAxisFormat ? u = Gp({
    series: s,
    dateRange: l,
    xAxisValueFormat: i
  }) : mi(i) && r !== void 0 ? u = Ea({
    root: c,
    value: r,
    valueFormat: n ?? i,
    formatLocale: d
  }) : typeof r == "number" && Lt(i) ? u = Ea({
    root: c,
    value: r,
    valueFormat: o ?? i,
    formatLocale: d
  }) : u = r, u?.toString() ?? "";
}
function Yp(t) {
  const {
    isStacked100: e,
    series: i,
    statValue: a,
    percentValue: o,
    yAxisValueFormat: n,
    dataTooltipValueFormat: s,
    dataTooltipPercentFormat: r
  } = t, l = i.chart?.uid ?? 0, { root: c } = i;
  let u = s;
  u === void 0 && (Lt(n) && n ? (u = n, e && (u.intlOptions.style = "decimal")) : u = Us());
  const d = w(l, "formatLocale"), m = a !== void 0 ? Ea({
    root: c,
    value: a,
    valueFormat: u,
    formatLocale: d
  }) : "";
  let g = "";
  if (e && o !== void 0 && c !== void 0) {
    let h = r;
    h === void 0 && (h = Nc(), h.intlOptions.minimumFractionDigits = 2, h.intlOptions.maximumFractionDigits = 2), g = Ea({
      root: c,
      value: o,
      valueFormat: h,
      formatLocale: d
    });
  }
  return { formattedStatValue: m, formattedPercentValue: g };
}
function Up(t) {
  const { utilsStrings: e, fieldList: i, queryObject: a, series: o, seriesConfig: n, seriesIndex: s, setTimeBinningInfoWhenNotProvided: r } = t, { chart: l } = o, { dataTooltipDateFormat: c, dataTooltipPercentFormat: u, dataTooltipValueFormat: d } = n;
  let m = () => "";
  if (l !== void 0) {
    const g = w(l.uid, "config");
    if (g !== void 0) {
      const { dataTooltipVisible: h } = n, y = o instanceof ge ? n.markerVisible : void 0;
      if (h !== !1 && y !== !1) {
        const p = g.axes, S = p[0].valueFormat, x = p[1].valueFormat, C = U(g.series), v = zt(g) === Ie.Stacked100, F = pt(a)?.objectIdField, T = De(i, n.x), k = li(T, p[0].title?.content.text), $ = xu({
          config: g,
          fieldList: i,
          objectIdField: F,
          seriesIndex: s,
          utilsStrings: e,
          isStacked100: v
        }), O = w(l.uid, "rtl"), D = bt(O ?? !1);
        m = (R) => {
          const { seriesName: M, statValue: N, percentValue: E, xValue: V, dateBinningRange: W } = R, H = Xp({
            seriesConfig: n,
            xAxisValueFormat: S,
            dataTooltipValueFormat: d,
            dataTooltipDateFormat: c,
            setTimeBinningInfoWhenNotProvided: r,
            series: o,
            xValue: V,
            dateBinningRange: W
          }), { formattedStatValue: Z, formattedPercentValue: oe } = Yp({
            isStacked100: v,
            yAxisValueFormat: x,
            dataTooltipValueFormat: d,
            dataTooltipPercentFormat: u,
            series: o,
            statValue: N,
            percentValue: E
          }), ie = [`[bold]${k}${D} [/]${H}`];
          switch (C) {
            case P.BarAndLineFromFields: {
              ie.pop();
              const X = xr({
                config: g,
                fieldName: De(i, H ?? ""),
                utilsStrings: e
              });
              ie.push(`[bold]${X}${D} [/]${Z}`);
              break;
            }
            case P.BarAndLineMonoField:
            case P.BarAndLineNoAggregation:
            case P.BarAndLineMultiFields:
              ie.push(`[bold]${$}${D} [/]${Z}`);
              break;
            case P.BarAndLineSplitByNoAggregation:
            case P.BarAndLineSplitBy:
              {
                const X = ki(n.query?.where, !1), q = Mc({
                  value: De(i, X)
                });
                ie.push(
                  `[bold]${q}${D} [/]${M}
[bold]${$}${D} [/]${Z}`
                );
              }
              break;
          }
          return v && ie.push(`[bold]${e.statistics.percent}${D} [/]${oe}`), ie.join(`
`);
        };
      }
    }
  }
  return m;
}
function vr(t) {
  const { series: e, tooltipFormatter: i } = t;
  Pe(e.uid, {
    barAndLineTooltipFormatter: i ?? Up(t)
  });
}
function jp(t, e) {
  switch (!0) {
    case (t === b.HistogramSeries && e instanceof Ee): {
      Lu(e);
      break;
    }
    case (t === b.PieSeries && e instanceof ht): {
      const i = he(e.uid, "tooltipCallback");
      i && i.dispose();
      const a = e.events.on(le.DataValidated, () => {
        Fu(e);
      });
      Pe(e.uid, { tooltipCallback: a });
      break;
    }
    case (t === b.HeatSeries && e instanceof Ee): {
      Au(e);
      break;
    }
    case ((t === b.ComboLineAndBarSeries || t === b.BarSeries) && e instanceof Ee): {
      vu(e);
      break;
    }
    case ((t === b.ComboLineAndBarSeries || t === b.LineSeries) && e instanceof ge): {
      const i = he(e.uid, "bulletTemplate");
      i && Nl(i, e);
      break;
    }
    case (t === b.ScatterSeries && e instanceof ge): {
      const i = he(e.uid, "bulletTemplate");
      i && Zp(i, e);
      break;
    }
    case (t === b.RadarSeries && e instanceof ge): {
      const i = he(e.uid, "bulletTemplate");
      i && Nl(i, e);
      break;
    }
  }
}
function qp(t) {
  const { axesConfig: e, seriesConfig: i, series: a, fieldList: o } = t, { dataTooltipVisible: n } = i;
  let s;
  const { chart: r } = a, l = r?.uid !== void 0 ? w(r.uid, "rtl") : !1, c = bt(l ?? !1);
  return n === !1 ? s = (u, d, m, g) => "" : s = (u, d, m, g) => {
    const h = De(o, i.x), y = ye(e?.[0].title?.content?.text) ? h : e?.[0].title?.content?.text, p = De(o, i.y), S = ye(e?.[1]?.title?.content?.text) ? p : e?.[1]?.title?.content?.text, x = he(
      a.uid,
      "tooltipValueXNumberFormatCallback"
    ), C = x ? x(u) : u, v = he(
      a.uid,
      "tooltipValueYNumberFormatCallback"
    ), F = v ? v(d) : d;
    let T = `[bold]${y}${c} [/]${C}
[bold]${S}${c} [/]${F}`;
    if (m !== void 0 && i.sizePolicy?.field !== void 0) {
      const k = De(o, i.sizePolicy?.field), $ = v ? v(m) : m;
      T += `
[bold]${k}${c} [/]${$}`;
    }
    return i.additionalTooltipFields?.forEach((k) => {
      const $ = De(o, k), O = o?.find((M) => M.name === k), D = g?.[k];
      let R = "";
      if (D != null && D !== void 0 && O)
        if (tg(O) && typeof D == "number")
          R = String(v ? v(D) : D);
        else if (ig(O)) {
          const M = new Date(D), N = r ? w(r.uid, "formatLocale") : void 0;
          R = new Intl.DateTimeFormat(N, {}).format(M);
        } else O.type === Eg.String && typeof D == "string" && (R = D);
      T += l ? `
${R}[bold]${$}${c} [/]` : `
[bold]${$}${c} [/]${R}`;
    }), T;
  }, s;
}
function _p(t) {
  const { seriesConfig: e, markerSeries: i, tooltip: a } = t, { x: o, y: n, sizePolicy: s, dataTooltipVisible: r } = e, { field: l } = s ?? {};
  if (r !== !1) {
    const c = he(
      i.uid,
      "scatterplotTooltipFormatter"
    );
    if (!a.isHidden() && c) {
      const { dataItem: u } = a;
      if (u) {
        const d = u.dataContext;
        if (d) {
          const m = o in d && typeof d[o] == "number" ? Number(d[o]) : Number.NaN, g = n in d && typeof d[n] == "number" ? Number(d[n]) : Number.NaN, h = l && l in d && typeof d[l] == "number" ? Number(d[l]) : void 0;
          return c(m, g, h, d);
        }
      }
    }
  }
}
function Zp(t, e) {
  const i = Ka(e);
  t.set("tooltip", i), t.setAll({
    tooltipText: " ",
    tooltipPosition: "fixed"
  }), t.adapters.add("tooltipText", (a, o) => pa(o, e));
}
function Kp(t) {
  const { axesConfig: e, series: i, seriesConfig: a, tooltipFormatter: o } = t;
  yu({
    axesConfig: e,
    currentSeries: i,
    tooltipValueFormat: a.dataTooltipValueFormat
  }), Pe(i.uid, {
    scatterplotTooltipFormatter: o ?? qp(t)
  });
}
function Qp(t) {
  const { series: e, seriesConfig: i, newMin: a, newMax: o } = t, n = e.get("heatRules")?.[0];
  let s = n === void 0 && i.sizePolicy !== void 0 || n !== void 0 && i.sizePolicy === void 0;
  if (!s && n !== void 0) {
    const r = n.min === a && n.max === o, l = e.get("valueField") === i.sizePolicy?.field, c = i.sizePolicy?.scaleType === Ui.Linear && n.logarithmic !== !0 || i.sizePolicy?.scaleType === Ui.Logarithmic && n.logarithmic === !0;
    s = !(r && l && c);
  }
  return s;
}
function Jp(t, e) {
  const { sizePolicy: i } = t, a = e.get("heatRules")?.[0], o = he(e.uid, "bulletTemplate");
  if (o !== void 0)
    if (i !== void 0) {
      const { scaleType: n, field: s, minSize: r, maxSize: l } = i, c = Pc(), u = t.markerSymbol?.size ?? js().size ?? 1, d = (r ?? c.minSize) / u, m = (l ?? c.maxSize) / u;
      a !== void 0 ? Qp({ series: e, seriesConfig: t, newMin: d, newMax: m }) && (a.min = d, a.max = m, a.logarithmic = n === Ui.Logarithmic, e.set("valueField", s)) : e.setAll({
        valueField: s,
        calculateAggregates: !0,
        heatRules: [
          {
            target: o,
            key: "scale",
            min: d,
            max: m,
            dataField: "value",
            // this is a static value to be kept in sync with the series.valueField from the creation step
            logarithmic: n === Ui.Logarithmic
          }
        ]
      });
    } else
      e.get("heatRules")?.pop(), e.setAll({
        valueField: void 0,
        calculateAggregates: !1
      });
}
function Mi(t) {
  return t.get("id") === A.overlayId.scatterplotTrendLine;
}
function $u(t) {
  return t.series.values.find((e) => !Mi(e));
}
function Du(t) {
  return t.series.values.find((e) => Mi(e));
}
function eb(t) {
  const { root: e, xAxis: i, yAxis: a, seriesConfig: o } = t, { x: n, y: s } = o, r = ge.new(e, {
    xAxis: i,
    yAxis: a,
    valueXField: n,
    valueYField: s,
    layer: A.zIndexes.scatterplotTrendLine
  });
  return r.set("id", A.overlayId.scatterplotTrendLine), Pe(r.uid, {
    type: $e.Trendline
  }), r;
}
function tb(t, e) {
  const i = Wa.new({});
  Pe(t.uid, { bulletTemplate: i }), t.bullets.push((a) => {
    const o = ui.new(
      a,
      {
        nonScalingStroke: !0,
        // this avoids the border to scale with the marker when using heat rules (bubble plot), which was leading to an opacity glitch (see https://help.amcharts.com/hc/en-us/requests/99558)
        tooltip: Cr(a, t),
        tooltipText: " "
      },
      i
    );
    return _t(o, e?.selectionTheme), Zt(o, t), Hu(o, t), Ti.new(a, {
      sprite: o
    });
  });
}
function ib(t) {
  const { root: e, chartConfig: i, seriesConfig: a, xAxis: o, yAxis: n, options: s } = t, { x: r, y: l, id: c } = a, u = [], d = ge.new(e, {
    xAxis: o,
    yAxis: n,
    valueXField: r,
    valueYField: l,
    id: c,
    opacity: 0,
    // to avoid showing the line
    valueField: "value",
    // necessary for bubble plot / heat rules. See `updateSizePolicy()`
    maskBullets: !1,
    layer: A.zIndexes.bulletMarkers
  });
  d.strokes.template.set("forceHidden", !0), tb(d, s), eo(d, i), u.push(d);
  const m = eb({
    root: e,
    xAxis: o,
    yAxis: n,
    seriesConfig: a
  });
  return mu(m), u.push(m), d.appear(), u;
}
function ab(t) {
  const { root: e, trendLineSeries: i, data: a, valueFormat: o, defaultR2Value: n, chartConfig: s } = t, { chart: r } = i, l = s.series[0], c = l.overlays?.trendLine, u = c?.symbol ?? {
    type: te.SLS
  }, d = c?.created === !0 && c.visible !== !1;
  if (a !== void 0) {
    const m = A.scatterplotSeries, g = r !== void 0 ? w(r.uid, "formatLocale") : void 0, { x: h, y } = l;
    i.setAll({
      valueXField: h,
      valueYField: y
    }), i.data.setAll(a.trendLinePoints ?? A.scatterplotSeries.trendLinePoints);
    const p = Number.isFinite(a.r2) ? Ea({
      root: e,
      value: a.r2 ?? m.r2,
      valueFormat: o,
      formatLocale: g
    }) : void 0, S = p !== void 0 ? `R = ${p}` : n;
    i.set("name", S);
  }
  u.color === void 0 && (u.color = ai({ colorIndex: 1 })), Yt({
    element: i,
    lineSymbol: u,
    visible: d
  });
}
function ob(t) {
  const { root: e, chartConfig: i, markerSeries: a } = t, o = a.chart;
  if (o) {
    const n = i.series[0], s = Ii(i);
    let r, l;
    const c = js(), u = /* @__PURE__ */ new Set();
    a.dataItems.forEach((m) => {
      const g = m.bullets?.[0]?.get("sprite");
      if (g !== void 0) {
        const h = Ft({
          dataItem: m?.dataContext,
          seriesConfig: n,
          chartSubType: P.NonSpecific,
          colorMatch: s
        }), y = mt({
          root: e,
          element: g,
          seriesSymbol: n.markerSymbol ?? c,
          rendererSymbol: h,
          colorMatch: s
        });
        r = y.symbolWithColorInfo, l = y.stylingInfo, co(g, l), u.add(JSON.stringify(l));
      }
    }), r = u.size > 1 ? void 0 : r;
    const d = /* @__PURE__ */ new Map();
    d.set(0, r), Bt({
      data: d,
      htmlContainer: e.dom,
      chartId: a.chart?.get("id"),
      colorMatchApplied: to(o)
    });
  }
}
function nb(t) {
  const { dataWasUpdated: e, seriesWereReinitialized: i, data: a, series: o, chartConfig: n, loaderHandle: s } = t;
  if ((e === !0 || i === !0) && a) {
    const { x: r, y: l } = n.series[0];
    o.setAll({
      valueXField: r,
      valueYField: l
    }), o.events.once(le.DataValidated, () => {
      s.hideLoader();
    }), o.data.setAll(a.dataItems);
  }
}
function sb(t) {
  const {
    root: e,
    chartConfig: i,
    seriesConfig: a,
    options: o,
    fieldList: n,
    series: s,
    trendLineSeries: r,
    data: l,
    dataWasUpdated: c,
    seriesWereReinitialized: u,
    loaderHandle: d,
    utilsStrings: m
  } = t, { axes: g } = i, { tooltipFormatter: h } = o ?? {};
  s.set("id", a.id), Re(s.bulletsContainer, a.visible), ab({
    root: e,
    trendLineSeries: r,
    chartConfig: i,
    data: l,
    valueFormat: In(),
    defaultR2Value: m.notAvailable
  }), Jp(a, s), Ni(t) && Pi({
    // TODO: Remove the type assertion and correct the typings
    styleCallback: ob,
    callbackProps: { root: e, chartConfig: i, markerSeries: s, dataWasUpdated: c },
    series: s,
    seriesConfig: a
  }), Kp({
    axesConfig: g,
    seriesConfig: a,
    series: s,
    fieldList: n,
    tooltipFormatter: h
  }), nb({
    dataWasUpdated: c,
    seriesWereReinitialized: u,
    data: l,
    series: s,
    chartConfig: i,
    loaderHandle: d
  });
}
function rb(t) {
  t.series.each((e) => {
    e instanceof ge ? e.dataItems.forEach((i) => {
      const a = i.bullets?.[0];
      a && ut({
        element: a.get("sprite"),
        selected: !1,
        backToDefaultState: !0
      });
    }) : e instanceof Ee ? e.columns.each((i) => {
      ut({
        element: i,
        selected: !1,
        backToDefaultState: !0
      });
    }) : e instanceof ht && e.slices.each((i) => {
      ut({
        element: i,
        selected: !1,
        backToDefaultState: !0
      });
    });
  });
}
function Zi(t) {
  const { chart: e, selectionSource: i } = t, a = w(
    e.uid,
    "currentSelectionDataItems"
  );
  de(e.uid, {
    currentSelectionDataItems: void 0,
    currentSelectionOIDs: void 0,
    currentSelectionIndexes: void 0,
    computedSelectionDataItems: void 0,
    computedSelectionIndexes: void 0,
    pendingSelectionQueries: !1
  }), Yn(e) && rb(e), a && Xa({
    data: {
      selectionSource: i ?? Ne.ClearSelection
    },
    htmlContainer: e.root.dom
  });
}
function Ou(t) {
  const e = t?.selection.width();
  return e !== void 0 && e > 0 && e !== 2e7;
}
function Zt(t, e) {
  t.events.on(le.PointerUp, async (i) => {
    const { chart: a } = e;
    if (a) {
      const o = a.get("cursor");
      if (!Ou(o)) {
        const n = w(e.chart?.uid ?? Number.NaN, "actionMode");
        if (!w(
          e.chart?.uid ?? Number.NaN,
          "filterBySelection"
        ) && n !== K.None && n !== K.Zoom) {
          const r = i.target, l = tp(i, e);
          ut({
            element: r,
            selected: Ri(r.uid, "selected") !== !0
            // switching the bullet state
          }), l && a.series.each((c) => {
            c instanceof ge ? c.dataItems.forEach((u) => {
              const d = u.bullets?.[0]?.get("sprite");
              d !== r && ut({ element: d, selected: !1 });
            }) : c instanceof Ee ? c.columns.each((u) => {
              u !== r && ut({ element: u, selected: !1 });
            }) : c instanceof ht && c.slices.each((u) => {
              u !== r && ut({ element: u, selected: !1 });
            });
          }), await Fr(a, Ne.SelectionByClick);
        }
      }
    }
  });
}
function Vl(t, e) {
  let i = Number.NaN, a = Number.NaN;
  const o = e.get("renderer") instanceof $t, n = t.getPrivate(o ? "downPositionX" : "downPositionY"), s = t.getPrivate(o ? "positionX" : "positionY");
  return n !== void 0 && s !== void 0 && (i = n * (o ? e.width() : e.height()), a = s * (o ? e.width() : e.height())), { coord1: i, coord2: a };
}
function lb(t) {
  if (t.get("background")?.events.on(le.Click, () => {
    Zi({ chart: t });
  }), t instanceof Se) {
    const e = t.get("cursor");
    t.plotContainer.events.on(le.PointerUp, () => {
      Ou(e) || Zi({ chart: t });
    });
  }
}
function cb(t) {
  const { series: e, cursorBounds: i, multiSelect: a } = t, o = w(e.chart?.uid ?? NaN, "config"), n = z(o?.series);
  e.columns.each((s) => {
    const r = s.get("x"), l = s.get("y"), c = s.height() < 0 && n !== b.HeatSeries, u = c ? Math.abs(s.height()) : s.height();
    if (typeof r == "number" && typeof l == "number") {
      const d = c ? l - u : l, m = {
        left: r,
        right: r + s.width(),
        top: d,
        bottom: d + u
      };
      if (n === b.HeatSeries) {
        const y = m.top;
        m.top = m.bottom, m.bottom = y;
      }
      const h = !(m.left > i.right || m.right < i.left || m.top > i.bottom || m.bottom < i.top) || a && Ri(s.uid, "selected") === !0;
      ut({ element: s, selected: h });
    }
  });
}
function db(t) {
  const { series: e, cursorBounds: i, multiSelect: a } = t;
  e.dataItems.forEach((o) => {
    const n = o.bullets?.[0]?.get("sprite");
    if (n) {
      const s = o.bullets?.[0]?.get("sprite").get("x"), r = o.bullets?.[0]?.get("sprite").get("y"), c = typeof s == "number" && typeof r == "number" && s >= i.left && s <= i.right && r >= i.top && r <= i.bottom || a && Ri(n.uid, "selected") === !0;
      ut({ element: n, selected: c });
    }
  });
}
function ub(t) {
  const { cursor: e, xAxis: i, yAxis: a } = t, o = e.get("behavior"), { coord1: n, coord2: s } = Vl(e, i), { coord1: r, coord2: l } = Vl(e, a), c = {
    left: n > s ? s : n,
    right: n > s ? n : s,
    top: r < l ? r : l,
    bottom: r < l ? l : r
  };
  return o === "selectX" ? (c.top = Number.NEGATIVE_INFINITY, c.bottom = Number.POSITIVE_INFINITY) : o === "selectY" && (c.right = Number.POSITIVE_INFINITY, c.left = Number.NEGATIVE_INFINITY), c;
}
function fb(t) {
  t.get("cursor")?.events.on(le.SelectEnded, async (i) => {
    const a = w(t.uid, "actionMode");
    if (a === K.MultiSelection || a === K.MultiSelectionWithCtrlKey) {
      const o = t.xAxes.getIndex(0), n = t.yAxes.getIndex(0);
      if (o && n) {
        const s = t.get("cursor"), r = ub({ cursor: s, xAxis: o, yAxis: n }), l = Zd(i);
        t.series.each((c) => {
          !Mi(c) && !Mo(c) && (c instanceof Ee || c instanceof ge) && (c instanceof Ee ? cb({ series: c, cursorBounds: r, multiSelect: l }) : c instanceof ge && db({ series: c, cursorBounds: r, multiSelect: l }));
        }), Re(s.selection, !1), await Fr(t, Ne.SelectionByRange);
      }
    }
  });
}
function Ru(t) {
  const { numberFormatter: e, dataLabelsConfigContent: i, stackedType: a, externalDataLabelFormatter: o } = t;
  return (n, s) => {
    let r = a === Ie.Stacked100 && s !== void 0 ? s : n;
    return e.get("numberFormat").style === "percent" && (r /= 100), ft({
      textSymbol: {
        ...i,
        text: e.format(r)
      },
      format: o === void 0 ? "amChartsV5" : "html"
    });
  };
}
function mb(t, e) {
  const i = t.dataItem;
  let a;
  switch (e) {
    case b.LineSeries:
    case b.ScatterSeries:
      a = i.get("point");
      break;
    case b.HistogramSeries:
    case b.BarSeries:
    case b.HeatSeries:
      a = i.get("graphics");
      break;
  }
  const o = a ?? t, n = a?.x ?? o?.get("x") ?? 0, s = a?.y ?? o?.get("y") ?? 0;
  return { x: n, y: s };
}
function Bu(t) {
  const { label: e, chart: i, seriesType: a } = t, o = (s) => {
    if (i instanceof Se) {
      const r = mb(s, a), l = i.plotContainer, c = l.x(), u = l.y(), d = r.x < c || r.x > c + l.width() || r.y < u || r.y > u + l.height();
      s.setAll({
        visible: !d,
        forceHidden: d
      });
    }
  }, n = Ye((s, r) => {
    r && o(r);
  }, A.debounceTime);
  e.on("x", n), e.on("y", n);
}
function gb(t) {
  const { series: e, label: i, isHeatChart: a } = t;
  i.adapters.add("y", (o, n) => {
    const { chart: s } = e, r = s !== void 0 ? w(s.uid, "isRotated") : !1;
    let l = typeof o == "number" ? o : o?.value;
    const c = n.dataItem;
    if (c !== void 0 && l !== void 0 && l !== null) {
      const u = c?.get("valueY"), d = n.localBounds().bottom;
      if (r !== !0) {
        const m = A.dataLabelNegative?.paddingTop ?? 0;
        if (e.get("stacked") || a)
          if (u < 0)
            l += d - m;
          else {
            const h = a ? A.heatChartLabelPadding.paddingTop : 0;
            l += d / 2 + h;
          }
      } else {
        const m = A.rotatedChartPadding?.paddingTop ?? 0;
        l += d / 2 + m;
      }
    }
    return l;
  }), i.adapters.add("x", (o, n) => {
    const { chart: s } = e, r = s !== void 0 ? w(s.uid, "isRotated") : !1;
    let l = typeof o == "number" ? o : o?.value;
    const c = n.dataItem;
    if (c !== void 0 && l !== void 0 && l !== null && r === !0) {
      const u = c?.get("valueX"), m = n.width() / 2, g = A.rotatedChartPadding?.paddingRight ?? 0, h = m + g;
      e.get("stacked") || (u < 0 ? l -= h : l += h);
    }
    return l;
  });
}
function hb(t) {
  const { series: e, isRotated: i, dataLabelsConfig: a, externalDataLabelFormatter: o } = t;
  e.bullets.push(() => {
    const n = e.get("stacked"), s = Ti.new(e.root, {
      locationY: !n && !i ? 1 : void 0,
      locationX: !n && i ? 1 : void 0,
      sprite: yi.new(e.root, {
        text: i ? "{valueX}" : "{valueY}",
        populateText: !0,
        centerY: Te,
        centerX: Ke,
        // remove padding so if they fit in the label, it shows
        paddingBottom: 0,
        paddingTop: 0,
        paddingRight: 0,
        paddingLeft: 0,
        fill: re(a?.content.color).color,
        fontSize: a?.content.font?.size
      })
    }), r = s.get("sprite");
    if (r) {
      const l = r;
      bb({
        dataLabel: l,
        series: e,
        externalDataLabelFormatter: o
      }), Nu({
        ...t,
        dataLabel: l,
        dataLabelFormatter: Ru
      });
    }
    return s;
  });
}
function Lr(t, e = 1) {
  t.bullets.removeIndex(e);
}
function Mu(t) {
  const { textBackgroundColor: e, chartBackgroundColor: i, fillOpacity: a } = t;
  let o;
  return en({ r: e.r, g: e.g, b: e.b, a }) ? o = en({
    r: i.r,
    g: i.g,
    b: i.b,
    a
  }) ? re(A.darkTextColor).color : i : o = en({
    r: i.r,
    g: i.g,
    b: i.b,
    a
  }) ? i : re(A.lightTextColor).color, o;
}
function pb(t) {
  const { dataLabel: e, labelConfigColor: i, seriesColor: a, backgroundColor: o, autoInverseDataLabelTextColor: n, isHeatChart: s } = t, r = o ?? re(A.backgroundColor).color;
  n === !0 && a && e.adapters.add("fill", (l, c, u) => {
    const d = i ?? c.text.get("fill"), m = (c.dataItem?.component).get("stacked");
    let g = d;
    if (d && (m || s)) {
      const h = c.dataItem.get("graphics"), y = h?.get("fillOpacity");
      g = Mu({
        textBackgroundColor: h?.get("fill") ?? a,
        chartBackgroundColor: r,
        fillOpacity: y
      });
    }
    return g;
  });
}
function bb(t) {
  const { dataLabel: e, series: i, externalDataLabelFormatter: a } = t;
  e.adapters.remove("text"), e.adapters.remove("html");
  const o = a !== void 0 ? "html" : "text";
  e.adapters.add(o, (n, s) => {
    let r = n ?? "";
    const l = s.dataItem, c = he(
      i.uid,
      i instanceof Ee ? "barSeriesDataLabelFormatter" : "lineSeriesDataLabelFormatter"
    );
    if (c !== void 0 && i.chart && l) {
      const u = w(i.chart.uid, "isRotated"), d = u === !0 ? l.get("valueX") : l.get("valueY"), m = u === !0 ? l.get("valueXTotalPercent") : l.get("valueYTotalPercent"), g = i.get("valueYShow") === "valueYTotalPercent" || i.get("valueXShow") === "valueXTotalPercent";
      r = c(g ? m : d);
    }
    return o === "html" ? He(r) : r;
  });
}
function Un(t) {
  const {
    series: e,
    seriesConfig: i,
    dataLabel: a,
    labelDefaults: o,
    dataLabelsConfig: n,
    yAxisValueFormat: s,
    stackedType: r,
    isRotated: l,
    seriesType: c,
    defaultDataLabelFormatter: u,
    externalDataLabelFormatter: d
  } = t, { chart: m } = e;
  if (a !== void 0) {
    let g = d;
    const h = n?.content ?? { type: te.TS };
    if (d === void 0 && u !== void 0 && s?.type === b.NumberAxisFormat && m) {
      const C = w(m.uid, "formatLocale"), v = Dt({
        root: m.root,
        type: s.type,
        formatLocale: C,
        intlOptions: s.intlOptions
      });
      g = u({
        numberFormatter: v,
        dataLabelsConfigContent: h,
        stackedType: r,
        externalDataLabelFormatter: d
      });
    }
    let y;
    switch (c) {
      case b.BarSeries:
        y = "barSeriesDataLabelFormatter";
        break;
      case b.LineSeries:
        y = "lineSeriesDataLabelFormatter";
        break;
      case b.HistogramSeries:
        y = "histogramDataLabelFormatter";
        break;
      case b.ScatterSeries:
        y = "scatterplotDataLabelFormatter";
        break;
      case b.HeatSeries:
        y = "heatChartDataLabelFormatter";
        break;
    }
    y !== void 0 && Pe(e.uid, {
      [y]: g
    }), n !== void 0 && (c === b.HeatSeries ? n.content.text = "{value}" : n.content.text = l === !0 ? "{valueX}" : "{valueY}", n.visible = n.visible !== !1), Pt({
      label: a,
      labelConfig: n,
      defaults: o ?? A.dataLabel,
      skipSettingText: !0
    });
    const p = e.get("stacked"), S = p && c === b.BarSeries && i?.hideOversizedStackedLabels !== !1, x = !p && c === b.BarSeries && i?.hideOversizedSideBySideLabels === !0;
    x || S ? a.setAll({
      oversizedBehavior: "hide",
      maxWidth: void 0,
      // 100 is an arbitrary value to stop amCharts from automatically setting the maxHeight
      // of the data label to the column height (for series in side-by-side mode).
      // In stacked mode though, oversized data labels are the ones that do not fit within both
      // column height and width, therefore, we set the maxHeight to undefined so that
      // amCharts can calculate it automatically.
      // see https://devtopia.esri.com/WebGIS/arcgis-web-components/issues/5843
      maxHeight: x ? 100 : void 0
    }) : a.setAll({
      oversizedBehavior: "none"
    });
  }
}
function yb(t) {
  const { series: e, labelDefaults: i, externalDataLabelFormatter: a } = t;
  e.dataItems.forEach((o) => {
    const n = o.bullets?.[1];
    if (n) {
      n.set("locationY", e.get("stacked") ? void 0 : 1);
      const s = n.get("sprite");
      s && Un({
        ...t,
        dataLabel: s,
        labelDefaults: i,
        defaultDataLabelFormatter: Ru,
        externalDataLabelFormatter: a
      });
    }
  });
}
function Nu(t) {
  const {
    series: e,
    dataLabelsConfig: i,
    autoInverseDataLabelTextColor: a,
    externalDataLabelFormatter: o,
    labelDefaults: n,
    seriesType: s,
    dataLabel: r,
    isHeatChart: l,
    dataLabelFormatter: c
  } = t;
  r && (e.chart && i?.visible && Bu({ label: r, chart: e.chart, seriesType: s }), gb({ series: e, label: r, isHeatChart: l }), Un({
    ...t,
    dataLabel: r,
    labelDefaults: n,
    defaultDataLabelFormatter: c,
    externalDataLabelFormatter: o
  }), pb({
    dataLabel: r,
    labelConfigColor: re(i?.content.color).color,
    seriesColor: e.get("fill"),
    backgroundColor: e.chart?.get("background")?.get("fill"),
    autoInverseDataLabelTextColor: a,
    isHeatChart: l
  }));
}
function Pu(t) {
  const { series: e, dataLabelsConfig: i } = t, a = i?.visible, o = e.bullets.hasIndex(1);
  a !== !0 ? o && Lr(e) : (o || hb(t), yb(t));
}
function Sb(t) {
  const { series: e, dataLabelsConfig: i, labelDefaults: a, externalDataLabelFormatter: o, seriesType: n } = t;
  e.bullets.push(() => {
    const s = Ti.new(e.root, {
      locationY: 1,
      sprite: yi.new(e.root, {
        populateText: !0,
        oversizedBehavior: "hide",
        centerY: Te,
        centerX: Ae,
        paddingBottom: 0,
        paddingTop: 0,
        paddingRight: 0,
        paddingLeft: 0,
        fill: re(i?.content.color).color,
        fontSize: i?.content.font?.size
      })
    }), r = s.get("sprite");
    return r && (xb({
      dataLabel: r,
      series: e,
      externalDataLabelFormatter: o
    }), e.chart && i?.visible && Bu({ label: r, chart: e.chart, seriesType: n }), Un({
      ...t,
      dataLabel: r,
      labelDefaults: a,
      defaultDataLabelFormatter: Vu
    })), s;
  });
}
function xb(t) {
  const { dataLabel: e, series: i, externalDataLabelFormatter: a } = t;
  e.adapters.remove("text"), e.adapters.remove("html");
  const o = a !== void 0 ? "html" : "text";
  e.adapters.add(o, (n, s) => {
    let r = n ?? "";
    const l = he(
      i.uid,
      "histogramDataLabelFormatter"
    ), c = s.dataItem;
    if (c && "dataContext" in c && c.dataContext !== void 0 && l !== void 0) {
      const { count: u, minValue: d, maxValue: m } = c.dataContext;
      r = l(u, d, m);
    }
    return o === "html" ? He(r) : r;
  });
}
function Vu(t) {
  const { numberFormatter: e, dataLabelsConfigContent: i, externalDataLabelFormatter: a } = t;
  return (o, n, s) => ft({
    textSymbol: {
      ...i,
      text: e.format(o)
    },
    format: a === void 0 ? "amChartsV5" : "html"
  });
}
function Cb(t) {
  const { series: e, labelDefaults: i, externalDataLabelFormatter: a } = t;
  e.dataItems.forEach((o) => {
    const n = o.bullets?.[0];
    if (n) {
      const s = n.get("sprite");
      s && Un({
        ...t,
        dataLabel: s,
        labelDefaults: i,
        defaultDataLabelFormatter: Vu,
        externalDataLabelFormatter: a
      });
    }
  });
}
function Eu(t) {
  const { series: e, dataLabelsConfig: i } = t, a = i?.visible, o = e.bullets.hasIndex(0);
  a !== !0 ? o && Lr(e, 0) : (o || Sb(t), Cb(t));
}
function Mo(t) {
  return [
    A.overlayId.histogramMean,
    A.overlayId.histogramMedian,
    A.overlayId.histogramStdDev,
    A.overlayId.histogramNormalDistribution
  ].includes(t.get("id") ?? "");
}
function vb(t) {
  let e = "";
  switch (t) {
    case $e.Mean:
      e = A.overlayId.histogramMean;
      break;
    case $e.Median:
      e = A.overlayId.histogramMedian;
      break;
    case $e.StdDev:
      e = A.overlayId.histogramStdDev;
      break;
    case $e.Normal:
      e = A.overlayId.histogramNormalDistribution;
      break;
  }
  return e;
}
function Lb(t) {
  const { series: e, seriesConfig: i, colorMatch: a, rendererSymbol: o } = t, { root: n } = e, s = e.chart;
  if (s) {
    const r = i.fillSymbol ?? Vc(), c = mt({
      root: e.root,
      element: e.columns.template,
      seriesSymbol: r,
      rendererSymbol: o,
      colorMatch: a,
      isChartFillSymbol: !0
    }).symbolWithColorInfo;
    if (c !== void 0) {
      const u = /* @__PURE__ */ new Map();
      u.set(0, c), Bt({
        data: u,
        htmlContainer: n.dom,
        chartId: s.get("id"),
        colorMatchApplied: to(s)
      });
    }
  }
}
function Fb(t) {
  const { series: e, data: i, dataWasUpdated: a, seriesWereReinitialized: o, loaderHandle: n } = t;
  i && (a === !0 || o === !0) && (e.events.once(le.DataValidated, () => {
    n.hideLoader();
  }), e.data.setAll(i.bins));
}
function Yo(t) {
  const { root: e, xAxis: i, yAxis: a, type: o, utilsStrings: n } = t, s = ge.new(e, {
    id: vb(o),
    valueXField: "x",
    valueYField: "y",
    xAxis: i,
    yAxis: a,
    visible: !1
  });
  return o === $e.Normal && Ja(s, n.overlays.normal), Pe(s.uid, { isOverlay: !0, type: o }), s.set("connect", !1), s.appear(), s;
}
function Ab(t) {
  const { root: e, seriesConfig: i, xAxis: a, yAxis: o, options: n, chartConfig: s } = t, { id: r, name: l } = i, c = Ee.new(e, {
    id: r,
    name: l,
    xAxis: a,
    yAxis: o,
    categoryXField: ho.Start,
    valueYField: ho.Count,
    maskBullets: !1
  });
  return _t(c.columns.template, n?.selectionTheme), Zt(c.columns.template, c), c.columns.template.setAll({
    width: Te
  }), Eu({
    yAxisValueFormat: s.axes?.[1]?.valueFormat,
    series: c,
    seriesConfig: i,
    seriesType: b.HistogramSeries,
    dataLabelsConfig: i.dataLabels,
    externalDataLabelFormatter: n?.dataLabelFormatter
  }), eo(c, s), c.appear(), c;
}
function Tb(t) {
  const { root: e, seriesConfig: i, xAxis: a, xAxisForOverlaySeries: o, yAxis: n, utilsStrings: s, options: r, chartConfig: l } = t, c = [], u = Ab({ root: e, seriesConfig: i, xAxis: a, yAxis: n, options: r, chartConfig: l });
  return c.push(u), Lu(u), o && (c.push(
    Yo({
      root: e,
      xAxis: o,
      yAxis: n,
      type: $e.Mean,
      utilsStrings: s
    })
  ), c.push(
    Yo({
      root: e,
      xAxis: o,
      yAxis: n,
      type: $e.Median,
      utilsStrings: s
    })
  ), c.push(
    Yo({
      root: e,
      xAxis: o,
      yAxis: n,
      type: $e.StdDev,
      utilsStrings: s
    })
  ), c.push(
    Yo({
      root: e,
      xAxis: o,
      yAxis: n,
      type: $e.Normal,
      utilsStrings: s
    })
  )), c;
}
function kb(t) {
  const { lineSeries: e, overlayConfig: i, data: a, utilsStrings: o } = t;
  if (!i)
    Re(e, !1);
  else {
    const { symbol: n, created: s, visible: r } = i, l = he(e.uid, "type"), c = n ?? { type: te.SLS };
    if (i.symbol?.color === void 0 && (c.color = ai({
      colorIndex: nn(l),
      histogramOverlays: !0
    })), Yt({
      element: e,
      lineSymbol: c,
      visible: s === !0 && r !== !1
    }), a && "bins" in a) {
      const m = a.bins.map((v) => v.count), g = Math.max(...m), { mean: h, stddev: y, median: p } = a, S = h - y, x = h + y;
      let C = [];
      switch (l) {
        case $e.Mean:
          C = [
            { x: h, y: 0 },
            { x: h, y: g }
          ];
          break;
        case $e.Median:
          C = [
            { x: p, y: 0 },
            { x: p, y: g }
          ];
          break;
        case $e.StdDev:
          C = [
            { x: S, y: 0 },
            { x: S, y: g },
            { x: null, y: null },
            // inserting null stats to create a gap between the 2 stddev lines
            { x, y: 0 },
            { x, y: g }
          ];
          break;
      }
      e.data.setAll(C);
    }
    let d = e.data.getIndex(0)?.x;
    if (l === $e.StdDev && (d = a?.stddev ?? he(e.uid, "stddev"), Pe(e.uid, { stddev: d })), typeof d == "number") {
      let m = l;
      switch (l) {
        case $e.Mean:
          m = o.overlays.mean;
          break;
        case $e.Median:
          m = o.overlays.median;
          break;
        case $e.StdDev:
          m = o.overlays.stdDev;
          break;
      }
      const g = w(e.chart?.uid ?? Number.NaN, "formatLocale"), h = Ea({
        root: e.root,
        value: d,
        valueFormat: In(),
        formatLocale: g
      }), y = `${m}: ${h}`;
      Ja(e, y);
    }
  }
}
function Ib(t) {
  const { lineSeries: e, overlayConfig: i, data: a, numberOfPoints: o } = t;
  if (!i)
    Re(e, !1);
  else {
    const { symbol: n, created: s, visible: r } = i, l = n ?? { type: te.SLS };
    if (i?.symbol?.color === void 0 && (l.color = ai({
      colorIndex: nn($e.Normal),
      histogramOverlays: !0
    })), Yt({
      element: e,
      lineSymbol: l,
      visible: s === !0 && r !== !1
    }), a && "bins" in a) {
      const { mean: u, stddev: d, min: m, max: g } = a, h = _d(a.bins), y = jd(
        m,
        g,
        o ?? A.histogramSeries.normalDistribNumberOfPoints
      ).map(
        (p) => ({
          x: p,
          y: qd({
            x: p,
            mean: u,
            stddev: d,
            scalingFactor: h
          })
        })
      );
      e.data.setAll(y);
    }
  }
}
async function wb(t) {
  const {
    series: e,
    chartConfig: i,
    seriesConfig: a,
    seriesWereReinitialized: o,
    dataWasUpdated: n,
    queryObject: s,
    chartRenderer: r,
    data: l,
    loaderHandle: c
  } = t;
  Re(e, a.visible), Ja(e, a.name);
  const u = pt(s), d = td({
    chartRenderer: r,
    queryObject: s
  }), m = r ?? u?.renderer, g = $o(r, u?.renderer);
  let h;
  if (Qi({ chartConfig: i, queryObject: s })) {
    const y = await id({
      seriesConfig: [a],
      dataItem: {},
      renderer: m,
      rendererOrigin: r !== void 0 ? cn.ChartRenderer : cn.LayerRenderer,
      rendererType: g,
      chartSubType: P.NonSpecific,
      graphicTemplate: d
    });
    h = y.rendererSymbol, de(e.chart?.uid ?? Number.NaN, { colorMatchApplied: y.colorMatchApplied });
  }
  Ni(t) && Pi({
    // TODO: Remove the type assertion and correct the typings
    styleCallback: Lb,
    callbackProps: { ...t, rendererSymbol: h },
    series: e,
    seriesConfig: a
  }), Fb({
    series: e,
    seriesWereReinitialized: o,
    dataWasUpdated: n,
    data: l,
    loaderHandle: c
  });
}
async function $b(t) {
  const {
    allChartSeries: e,
    seriesConfig: i,
    data: a,
    utilsStrings: o,
    fieldList: n,
    axes: s,
    options: r,
    dataLabelFormatter: l,
    chartConfig: c
  } = t, { tooltipFormatter: u } = r ?? {};
  for (let d = 0; d < e.length; d++) {
    const m = e[d];
    if (m instanceof ge && he(m.uid, "isOverlay")) {
      const g = he(m.uid, "type");
      if (g === $e.Normal)
        Ib({
          lineSeries: m,
          overlayConfig: i.overlays?.comparisonDistribution,
          data: a
        });
      else {
        let h;
        switch (g) {
          case $e.Mean:
            h = i.overlays?.mean;
            break;
          case $e.Median:
            h = i.overlays?.median;
            break;
          case $e.StdDev:
            h = i.overlays?.standardDeviation;
            break;
        }
        kb({
          lineSeries: m,
          overlayConfig: h,
          data: a,
          utilsStrings: o
        });
      }
    } else m instanceof Ee && (m.set("id", i.id), await wb({ ...t, series: m }), Eu({
      series: m,
      yAxisValueFormat: c.axes?.[1]?.valueFormat,
      seriesConfig: i,
      seriesType: b.HistogramSeries,
      dataLabelsConfig: i.dataLabels,
      externalDataLabelFormatter: l
    }), Bp({
      axes: s,
      series: m,
      seriesConfig: i,
      fieldList: n,
      tooltipFormatter: u,
      utilsStrings: o,
      axesConfig: c.axes
    }));
  }
}
function Db(t) {
  let e = "";
  return t instanceof Gs ? e = t.get("categoryXField") ?? t.get("valueXField") ?? "" : t instanceof ht && (e = t.get("categoryField") ?? ""), e;
}
function Ob(t) {
  let e = "";
  return t instanceof Gs ? e = t.get("categoryYField") ?? t.get("valueYField") ?? "" : t instanceof ht && (e = t.get("categoryField") ?? ""), e;
}
function No(t) {
  let e = "";
  const { chart: i } = t;
  return i !== void 0 && (e = w(i.uid, "isRotated") === !0 ? Db(t) : Ob(t)), e;
}
function Rb(t) {
  Ec(), ad(t.root.dom), Zi({ chart: t });
}
function Bb(t) {
  const { chart: e, chartType: i, showMean: a } = t;
  return e.series.values.filter(
    (n) => !Mi(n) && !Mo(n) && (i !== b.BoxPlotSeries || !a || a && he(n.uid, "isBoxPlotMeanLineSeries"))
  ).every((n) => he(n.uid, "isSelectionApplied") === !0);
}
function Mb(t) {
  t.series.each((e) => Pe(e.uid, { isSelectionApplied: void 0 }));
}
function Nb(t) {
  let e = [];
  if (!Mi(t) && !Mo(t))
    switch (!0) {
      case t instanceof ht:
        e = t.slices.values;
        break;
      case t instanceof Ee:
        const { chart: i } = t;
        if (i) {
          const a = w(i.uid, "config");
          if (a) {
            const o = z(a?.series);
            let n = [];
            o === b.HistogramSeries ? n = [ho.Count] : o === b.HeatSeries ? n = [Me.valueField] : n = wi(a?.series, [t.get("id") ?? ""]), e = t.columns.values.filter((s) => {
              let r = !1;
              const l = s.dataItem?.dataContext;
              return l && (r = n.some((c) => c in l && Number.isFinite(l[c]))), r;
            });
          }
        }
        break;
      case t instanceof ge:
        e = Array.from(t.dataItems.values());
        break;
    }
  return e;
}
function zu(t, e) {
  const i = w(t.uid, "actionMode");
  (i === K.MonoSelection || i === K.None) && e.length > 1 ? Zi({ chart: t }) : e.forEach((o) => {
    ut({ element: o, selected: !0 });
  });
}
function Pb(t, e) {
  const i = [], a = [], o = w(t.uid, "config"), n = w(t.uid, "queryObject"), s = Oi(o), r = wi(o?.series ?? []), l = U(o?.series), c = z(o?.series);
  return t.series.each((u, d) => {
    if (o && u.get("visible") === !0 && u.get("id") !== A.overlayId.scatterplotTrendLine) {
      const m = o.series[0].x, g = No(u), h = e.get(d);
      if (h !== void 0) {
        let y;
        if (u instanceof ge && (y = u.dataItems.map((p) => p?.bullets?.[0]?.get("sprite")).filter((p) => p !== void 0)), y !== void 0) {
          const { indexesToSelect: p } = h;
          y.forEach((S, x) => {
            if (p === void 0 || p.includes(x)) {
              const C = Li({
                dataContext: S.dataItem?.dataContext,
                yList: r,
                yAxisField: g,
                xAxisField: m,
                chartType: c,
                chartSubType: l,
                showOutliers: s,
                isFeatureCollectionLayer: Si(n)
              });
              C !== void 0 && i.push(C), a.push(S);
            } else
              ut({ element: S, selected: !1 });
          });
        }
      }
    }
  }), zu(t, a), i;
}
function Vb(t) {
  const {
    chart: e,
    chartConfig: i,
    options: a,
    elementsToApplySelectionTo: o,
    selectionDataItems: n,
    layerOidField: s,
    xAxisField: r,
    yAxisField: l,
    splitBy: c
  } = t, u = z(i.series), d = U(i.series), m = Oi(i), g = w(e.uid, "queryObject"), h = [], y = [], p = [], S = wi(i.series);
  return o.forEach((x, C) => {
    const v = x instanceof go || x instanceof Ma ? x : x.bullets?.[0]?.get("sprite");
    if (v !== void 0) {
      let F = x instanceof go || x instanceof Ma ? v.dataItem?.dataContext : x.dataContext;
      if (F !== void 0 && u === b.BoxPlotSeries && F[A.boxPlot.boxPlotOutlierId] !== !0 && (F = Li({
        dataContext: F,
        yAxisField: l,
        yList: S,
        xAxisField: r,
        splitBy: c,
        chartType: u,
        chartSubType: d,
        showOutliers: m,
        isFeatureCollectionLayer: Si(g)
      })), Hn({
        elementDataContext: F,
        options: a,
        selectionDataItems: n,
        layerOidField: s,
        xAxisField: r,
        yAxisField: l,
        chartType: u,
        splitBy: c,
        chartSubType: d,
        showOutliers: m
      }))
        if (h.push(v), y.push(C), v?.dataItem instanceof ta && F !== void 0)
          p.push(F);
        else {
          const k = /* @__PURE__ */ new Set();
          u === b.PieSeries && Di(F) ? (Bo({
            groupOfSlicesDataContext: F
          }) ?? []).forEach((O) => {
            n.forEach((D) => {
              br({
                layerOidField: s,
                sliceDataContext: O,
                selectionDataContext: D,
                xAxisField: r
              }) && k.add(O);
            });
          }) : k.add(F), Array.from(k)?.forEach(($) => {
            const O = Li({
              dataContext: $,
              yAxisField: l,
              yList: S,
              xAxisField: r,
              splitBy: c,
              chartType: u,
              chartSubType: d,
              showOutliers: m,
              isFeatureCollectionLayer: Si(g)
            });
            O !== void 0 && p.push(O);
          });
        }
      else
        ut({ element: v, selected: !1 });
    }
  }), zu(e, h), { selectedIndexes: y, newSelectionDataItems: p };
}
function Eb(t) {
  const {
    series: e,
    seriesIndex: i,
    queryObject: a,
    dataWasUpdated: o,
    sortChanged: n,
    groupOfSlicesWasUpdated: s,
    xAxisField: r,
    yAxisField: l,
    splitBy: c,
    rotationChanged: u
  } = t, { chart: d } = e;
  if (d instanceof Ba) {
    const m = w(d.uid, "options"), { filterBySelection: g, selectionData: h, returnSelectionIndexes: y, returnSelectionOIDs: p } = m ?? {}, { selectionIndexes: S } = h ?? {}, x = w(d.uid, "config"), C = qe(x), v = z(x?.series), F = U(x?.series), T = Nb(e);
    if (g !== !0 && x !== void 0) {
      let k;
      a !== void 0 && (k = pt(a).objectIdField);
      const $ = w(
        d.uid,
        "currentSelectionDataItems"
      );
      let O = !1, D = !1, R, M = !1;
      if (T?.[0] !== void 0) {
        if (m?.viewExtentUpdated !== !0) {
          R = m?.selectionData?.selectionItems ?? $;
          const N = w(
            d.uid,
            "currentSelectionIndexes"
          );
          M = rd({
            itemsA: R,
            itemsB: $,
            isPieFromFields: F === P.PieFromFields,
            x: r,
            y: l,
            outStatisticFieldName: x.series[0].query?.outStatistics?.[0]?.outStatisticFieldName
          });
          const E = S?.keys.length !== N?.keys.length || !fo(S, N);
          O = n === !0 || o === !0 || s === !0 || u === !0 || R !== void 0 && M;
          let V = !0;
          if (S !== void 0 && S.size > 0) {
            const { indexesToSelect: W } = S.get(i ?? 0) ?? {};
            V = W !== void 0 && W[0] === void 0;
          }
          D = o === !0 || s === !0 || u === !0 || !V && E;
        }
        if (O && R !== void 0 && R.length > 0) {
          const { selectedIndexes: N, newSelectionDataItems: E } = Vb({
            chart: d,
            chartConfig: x,
            options: m,
            elementsToApplySelectionTo: T,
            selectionDataItems: R,
            layerOidField: k,
            xAxisField: r,
            yAxisField: l,
            splitBy: c
          });
          let V = w(d.uid, "computedSelectionDataItems") ?? [];
          if (V.push(...E), x.series.length > 1 && F !== P.BarAndLineNoAggregation && F !== P.BarAndLineSplitByNoAggregation && (V = ld({
            data: V,
            x: x.series[0].x,
            splitByField: ki(x.series[0].query?.where)
          })), de(d.uid, { computedSelectionDataItems: V }), y === !0) {
            const W = Array.from(new Set(N));
            let H = w(
              d.uid,
              "computedSelectionIndexes"
            );
            H === void 0 && (H = /* @__PURE__ */ new Map()), W.length === T.length ? H.set(i ?? 0, {}) : H.set(i ?? 0, { indexesToSelect: W }), de(d.uid, { computedSelectionIndexes: H });
          }
        } else if (S !== void 0 && D)
          R = Pb(d, S);
        else {
          const N = (E) => {
            const V = E.dataItem?.dataContext;
            return Hn({
              elementDataContext: V,
              options: m,
              selectionDataItems: R ?? $ ?? [],
              layerOidField: k,
              xAxisField: r,
              yAxisField: l,
              chartType: v,
              splitBy: c,
              chartSubType: F
            });
          };
          T.forEach((E) => {
            const V = E instanceof go || E instanceof Ma ? E : E.bullets?.[0]?.get("sprite");
            V !== void 0 && ut({
              element: V,
              selected: Ri(V.uid, "selected") === !0 || N(V)
            });
          });
        }
      }
      if (Pe(e.uid, { isSelectionApplied: !0 }), Bb({ chart: d, chartType: v, showMean: C }) && (Mb(d), M || D)) {
        let N = w(d.uid, "computedSelectionDataItems") ?? R;
        N = Array.from(
          new Set(N?.map((V) => JSON.stringify(V)))
        ).map((V) => JSON.parse(V)), R !== void 0 && de(d.uid, { currentSelectionDataItems: N }), h?.selectionOIDs !== void 0 && de(d.uid, { currentSelectionOIDs: h.selectionOIDs });
        let E;
        if (y === !0 && (E = w(d.uid, "computedSelectionIndexes") ?? S, E !== void 0 && de(d.uid, { currentSelectionIndexes: E })), N === void 0 || N.length === 0)
          Zi({ chart: d, selectionSource: Ne.ProgrammaticSelection });
        else {
          const V = {
            selectionItems: N,
            selectionSource: Ne.ProgrammaticSelection
          };
          y === !0 && (V.selectionIndexes = E), p !== !1 && (V.selectionOIDs = h?.selectionOIDs ?? w(d.uid, "currentSelectionOIDs")), Xa({
            data: V,
            seriesConfig: x.series,
            htmlContainer: d.root.dom
          });
        }
        de(d.uid, { computedSelectionIndexes: void 0, computedSelectionDataItems: void 0 });
      }
    }
  }
}
async function zb(t) {
  const { chart: e, options: i, dataWasUpdated: a, data: o, chartConfig: n, queryObject: s, errorStrings: r } = t, l = w(e.uid, "currentSelectionOIDs"), c = w(e.uid, "queryConfig");
  if (!w(e.uid, "filterBySelection")) {
    const d = await sd({
      chartConfig: n,
      queryConfig: c,
      chartData: o,
      currentSelectionOIDs: l,
      dataWasUpdated: a,
      queryObject: s,
      options: i,
      errorStrings: r
    });
    d !== void 0 && i !== void 0 && (i.selectionData = { ...i?.selectionData, selectionItems: d }), e.series.values.filter((m) => !Mi(m) && !Mo(m)).forEach((m) => {
      const { seriesConfig: g, seriesIndex: h } = jn(m, n);
      if (g) {
        const y = g.x, p = g.type === b.BoxPlotSeries || g.type === b.HeatSeries ? g.y.toString() : No(m), S = g.query?.where ?? "";
        Wb({
          callbackProps: { ...t, series: m, seriesIndex: h, xAxisField: y, yAxisField: p, splitBy: S },
          series: m,
          seriesConfig: g
        });
      }
    });
  }
}
async function Fr(t, e) {
  const i = w(t.uid, "config"), a = w(t.uid, "queryObject");
  if (i) {
    const o = w(t.uid, "options"), n = z(i.series), s = U(i.series), r = Oi(i), l = wi(i.series), c = i.series[0].x, u = _s(a), d = pt(a), g = qs(d).dateFieldsTimeZone, h = i.series[0].type === b.HeatSeries ? i.outTimeZone : void 0;
    let y;
    a !== void 0 && (y = (await qt(a)).find((S) => S.name === c)?.type);
    try {
      const p = /* @__PURE__ */ new Set(), S = [], x = /* @__PURE__ */ new Map(), C = [];
      let v = [], F = 0;
      if (t.series.each(async (T, k) => {
        const { seriesConfig: $ } = jn(T, i), O = $?.query?.where ?? "", D = $?.type === b.BoxPlotSeries ? $.y.toString() : No(T);
        let R;
        T instanceof ge ? R = T.dataItems : T instanceof Ee ? R = T.columns.values : T instanceof ht && (R = T.slices.values), R?.forEach((M, N) => {
          const E = M instanceof go || M instanceof Ma ? M : M.bullets?.[0]?.get("sprite");
          if (E !== void 0 && Ri(E.uid, "selected") === !0) {
            F += 1;
            let V = M instanceof go || M instanceof Ma ? M.dataItem?.dataContext : M.dataContext;
            if (V !== void 0) {
              if (V = Li({
                dataContext: V,
                yAxisField: D,
                yList: l,
                xAxisField: c,
                splitBy: O,
                chartType: n,
                chartSubType: s,
                showOutliers: r,
                isFeatureCollectionLayer: Si(a)
              }), p.has(JSON.stringify(V)) || (p.add(JSON.stringify(V)), S.push(V)), N !== void 0) {
                const H = x.get(k)?.indexesToSelect ?? [];
                H.push(N), x.set(k, {
                  indexesToSelect: Array.from(new Set(H))
                });
              }
              const W = V[Na.uniqueIdsName] !== void 0 ? [V[Na.uniqueIdsName]].flat() : [];
              if (W.length > 0)
                v.push(...W);
              else if (o?.returnSelectionOIDs !== !1) {
                const H = od({
                  dataContext: V,
                  options: o,
                  xAxisField: c,
                  yAxisField: D ?? "",
                  splitBy: O,
                  xAxisFieldType: y,
                  chartConfig: i,
                  outTimeZone: h,
                  dataTimeZone: g,
                  runsOnClientQueryEngine: u
                });
                C.push(H);
              }
            }
          }
        });
      }), F === 0)
        Zi({ chart: t, selectionSource: e });
      else {
        if (o?.returnSelectionOIDs !== !1 && a !== void 0 && C.length > 0) {
          const $ = { ...w(t.uid, "queryConfig") };
          delete $.groupByFieldsForStatistics, delete $.orderByFields, delete $.outStatistics;
          const O = await nd({
            whereList: C,
            queryObject: a,
            queryConfig: $
          });
          if (C.length === F)
            v = O;
          else
            for (let D = 0; D < O.length; D += 1)
              v.push(O[D]);
        }
        v = Array.from(new Set(v)), de(t.uid, {
          currentSelectionDataItems: S,
          currentSelectionOIDs: v,
          currentSelectionIndexes: x
        });
        const T = {
          selectionItems: S,
          selectionSource: e
        };
        o?.returnSelectionIndexes === !0 && (T.selectionIndexes = x), o?.returnSelectionOIDs !== !1 && (T.selectionOIDs = v), Xa({
          data: T,
          seriesConfig: i?.series,
          htmlContainer: t.root.dom
        });
      }
    } catch (p) {
      de(t.uid, { pendingSelectionQueries: !1 });
      const { httpStatus: S } = p instanceof wn ? p.details.details : p.details ?? {};
      if (S === 429)
        Rb(t);
      else
        throw p;
    }
    de(t.uid, { pendingSelectionQueries: !1 });
  }
}
function Qa(t, e) {
  const { y: i, query: a } = e, n = U(t.series) === P.BarAndLineSplitByNoAggregation ? `${i.toString()}_${Ki({ where: a?.where, keepSurroundingQuotes: !1, escape: !1 })}` : [i].flat()[0], s = A.xAxisField, r = t.rotated === !0 ? "categoryYField" : "categoryXField", l = t.rotated === !0 ? "valueYField" : "valueXField", c = t.axes?.[0]?.valueFormat.type === b.CategoryAxisFormat ? r : l, u = t.rotated === !0 ? "valueXField" : "valueYField";
  return { xField: s, yField: n, xAxisField: c, yAxisField: u };
}
function Ni(t) {
  const {
    chartConfig: e,
    seriesWereReinitialized: i,
    dataWasUpdated: a,
    colorMatchChanged: o,
    seriesStyleChanged: n,
    sortChanged: s,
    groupOfSlicesUpdateNeeded: r
  } = t, l = e.series.length === 1, c = z(e.series), u = (i || a || o || n) ?? !1;
  let d = !1;
  switch (c) {
    case b.BarSeries:
      d = (l && s) ?? !1;
      break;
    case b.PieSeries:
      d = (r || s) ?? !1;
      break;
  }
  return d || u;
}
function Wu(t) {
  const { series: e, callbackInfo: i, seriesConfig: a } = t, o = (s) => {
    const { type: r, callbackProps: l } = s;
    r === "selection" ? Eb(l) : (Re(e, a.visible), s.styleCallback(l));
  }, n = w(e.chart?.uid ?? Number.NaN, "config");
  switch (!0) {
    case e instanceof An:
      e.events.once(le.DataValidated, () => o(i));
      break;
    case e instanceof Ee:
      {
        const s = e.root.events.on(le.FrameEnded, () => {
          e.columns.length === e.dataItems.length && (s.dispose(), o(i));
        });
      }
      break;
    case e instanceof ge:
      {
        const s = he(e.uid, "bulletTemplate");
        if (s)
          if (z(n?.series ?? [a]) === b.ScatterSeries) {
            const l = e.root.events.on(le.FrameEnded, () => {
              s.entities.length === e.data.length && e.dataItems[e.dataItems.length - 1]?.bullets?.[0]?.get("sprite") && (l.dispose(), o(i));
            });
          } else {
            const l = e.root.events.on(le.FrameEnded, () => {
              const c = No(e) ?? "", u = n?.series[0]?.x ?? "";
              e.dataItems.filter((m) => {
                const g = m.dataContext;
                return c in g && u in g && g[u] !== void 0;
              }).every(
                (m) => !Number.isFinite(m.dataContext[c]) || m?.bullets?.[0]?.get("sprite")
              ) && (l.dispose(), o(i));
            });
            i.type === "style" && o(i);
          }
      }
      break;
    default:
      o(i);
      break;
  }
}
function Wb(t) {
  const { series: e, callbackProps: i, seriesConfig: a } = t;
  Wu({
    callbackInfo: { callbackProps: i, type: "selection" },
    series: e,
    seriesConfig: a
  });
}
function Pi(t) {
  const { series: e, styleCallback: i, callbackProps: a, seriesConfig: o } = t;
  Wu({
    callbackInfo: { styleCallback: i, callbackProps: a, type: "style" },
    series: e,
    seriesConfig: o
  });
}
function Hb(t) {
  let e;
  return t && t.series.length > 0 && (e = t.series.values.map((i) => i.get("visible") !== !1 ? `${i.get("id")}` : "").filter((i) => i !== "")), e;
}
function Ar(t) {
  const { series: e, chartConfig: i, isRotated: a } = t, o = zt(i), n = i.series[0], s = e.chart?.xAxes.getIndex(0), r = e.chart?.yAxes.getIndex(0), l = a && (o === Ie.Stacked || o === Ie.Stacked100) ? r : s;
  switch (o) {
    case Ie.Stacked: {
      e.setAll({
        stacked: !0,
        valueYShow: "valueYWorking",
        valueXShow: "valueXWorking",
        baseAxis: l
      }), e instanceof ge && e.set(
        "stackToNegative",
        n.stackNegativeValuesToBaseline ?? A.lineSeries.stackNegativeValuesToBaseline
      );
      break;
    }
    case Ie.Stacked100: {
      e.setAll({ stacked: !0, baseAxis: l }), a === !0 ? (e.setAll({ valueXShow: "valueXTotalPercent" }), s instanceof we && s.set("calculateTotals", !0)) : (e.setAll({ valueYShow: "valueYTotalPercent" }), r instanceof we && r.set("calculateTotals", !0));
      break;
    }
    case Ie.Side:
    default: {
      e.setAll({
        stacked: !1,
        valueYShow: "valueYWorking",
        valueXShow: "valueXWorking"
      });
      break;
    }
  }
}
function Ja(t, e) {
  t.set("name", e);
}
function Gb(t) {
  const { chart: e, chartType: i, rotated: a, assignToSecondValueAxis: o } = t, n = e.xAxes.getIndex(0), s = e.yAxes.getIndex(0), r = [n, s, e.xAxes.getIndex(1) ?? e.yAxes.getIndex(1)];
  let l, c;
  a !== !0 ? (l = r[0], c = o === !0 && r[2] ? r[2] : r[1]) : (l = o === !0 && r[2] ? r[2] : r[0], c = r[1]);
  const u = i === b.HistogramSeries ? e.xAxes.getIndex(1) : void 0;
  return {
    xAxis: l,
    xAxisForHistogramOverlaySeries: u,
    yAxis: c
  };
}
function eo(t, e) {
  const { series: i } = e, a = z(i);
  switch (!0) {
    case t instanceof Ee:
      t.columns.template.setAll({ focusable: !0, hoverOnFocus: !0 }), a === b.HeatSeries ? t.columns.template.set("ariaLabel", jb()) : t.columns.template.set("ariaLabel", dn());
      break;
  }
}
function Xb(t, e) {
  let i = !1;
  const a = $u(t), o = e.series[0];
  if (a && o.type === b.ScatterSeries) {
    const n = a.get("heatRules")?.[0];
    i = n === void 0 && o.sizePolicy !== void 0 || n !== void 0 && o.sizePolicy === void 0 || a.get("valueField") !== o.sizePolicy?.field;
  }
  return i;
}
function Yb(t) {
  const { chart: e, chartConfig: i, updateNeededDetails: a, seriesFilteredOut: o } = t;
  let n = !1;
  switch (z(i.series)) {
    case b.BarSeries:
    case b.LineSeries:
    case b.RadarSeries:
    case b.ComboLineAndBarSeries:
    case b.BoxPlotSeries:
      n = o || a?.common.numberOfSeriesChanged === !0 || e.series.length !== i.series.length;
      break;
    case b.ScatterSeries:
      n = Xb(e, i);
      break;
  }
  return n;
}
function Tr(t) {
  const { chartConfig: e, series: i, seriesIndex: a, subtypeInfo: o, fieldList: n } = t, s = e.series[a];
  if (s) {
    const r = U(e.series);
    let l = s.name;
    if (r === P.BarAndLineSplitBy || r === P.BarAndLineSplitByNoAggregation) {
      const c = ki(s.query?.where);
      l = Zs({
        subtypeInfo: o,
        fieldList: n,
        fieldName: c,
        fieldValueToMatch: l
      }) ?? l;
    }
    Ja(i, l);
  }
}
function jn(t, e) {
  const i = z(e?.series);
  let a, o;
  return e?.series.forEach((n, s) => {
    let r = !1;
    i !== b.BoxPlotSeries || t instanceof ua ? r = t.get("id") === n.id : t instanceof An ? r = t.get("id")?.replace(`_${me.Top}`, "") === n.id || t.get("id")?.replace(`_${me.Median}`, "") === n.id || t.get("id")?.replace(`_${me.Bottom}`, "") === n.id : t instanceof ge && (r = t.get("id")?.replace(`_${me.Outliers}`, "") === n.id), r && (a = n, o = s);
  }), { seriesConfig: a, seriesIndex: o };
}
function Ub(t, e) {
  const { chart: i } = e;
  if (i instanceof Se) {
    const a = {
      x: t.get("x") ?? 0,
      y: t.get("y") ?? 0
    }, o = i.plotContainer, n = o.x(), s = o.y(), r = a.x < n || a.x > n + o.width() || a.y < s || a.y > s + o.height();
    t.set("forceHidden", r);
  }
}
function Hu(t, e) {
  const i = Ye((a, o) => {
    o !== void 0 && Ub(o, e);
  }, A.debounceTime);
  t.on("x", i), t.on("y", i);
}
function to(t, e) {
  let i = e;
  i === void 0 && (i = w(t.uid, "config"));
  const a = w(t.uid, "colorMatchApplied") ?? !1;
  return (i?.colorMatch ?? !1) && a;
}
function jb() {
  return `{${Me.xField}} {${Me.yField}} {${Me.valueField}}`;
}
function Gu(t) {
  const { root: e, intlOptions: i, formatLocale: a, overridePercentMultiplication: o } = t, n = Dt({
    root: e,
    intlOptions: i,
    type: b.NumberAxisFormat,
    formatLocale: a
  });
  return (s) => {
    let r = `${s}`;
    if (n !== void 0 && s !== null && !(s instanceof Date)) {
      let l = typeof s == "number" ? s : _c(s, n.get("intlLocales"));
      o === !0 && i.style === "percent" && (l /= 100), r = n.format(l);
    } else s instanceof Date && (r = s.toLocaleString(void 0, i));
    return r;
  };
}
function qb(t) {
  const { axis: e, intlOptions: i, overridePercentMultiplication: a, valueAxisFormatter: o } = t, { chart: n, root: s } = e, r = n !== void 0 ? w(n.uid, "formatLocale") : void 0, l = o ?? Gu({
    root: s,
    intlOptions: i,
    formatLocale: r,
    overridePercentMultiplication: a
  });
  return _a(e.uid, {
    numberFormatter: l
  }), l;
}
function _b(t) {
  const { chart: e, formatOptions: i, isNonAggregatedChart: a } = t, { root: o } = e;
  return (s) => {
    let r = s ?? "";
    const l = w(e.uid, "formatLocale"), c = w(e.uid, "config");
    if (typeof s == "number" && i.type === b.NumberAxisFormat)
      r = Gu({
        root: o,
        intlOptions: i.intlOptions,
        formatLocale: l
      })(s);
    else if (a === !0 && i.type === b.DateAxisFormat)
      r = Dt({
        root: o,
        type: b.DateAxisFormat,
        intlOptions: i.intlOptions,
        formatLocale: l
      }).format(r, i.intlOptions);
    else if (i.type === b.CategoryAxisFormat) {
      const u = U(c?.series);
      if ([
        P.BoxPlotMonoField,
        P.BoxPlotMultiFields,
        P.BoxPlotMonoFieldAndSplitBy,
        P.BoxPlotMultiFieldsAndSplitBy,
        P.BarAndLineFromFields
      ].includes(u) && typeof s == "string") {
        const g = w(e.uid, "fieldList");
        s = De(g, s);
      }
      const { characterLimit: m } = i;
      r = s?.toString() ?? "", !ye(r) && r !== A.htmlEmptyContent && (r = cd({ stringToTruncate: r, characterLimit: m }));
    }
    return r.toString();
  };
}
function Zb(t) {
  const { chart: e, isXAxis: i = !0, formatOptions: a } = t, { root: o } = e;
  return (s) => {
    let r = s ?? "";
    const l = w(e.uid, "formatLocale"), c = w(e.uid, "config");
    if (c && c.series[0].type === b.HeatSeries) {
      const u = zm(c.series[0], i);
      if (u && s !== void 0 && s !== "") {
        if (a.type === b.DateAxisFormat && a.intlOptions)
          switch (u.unit) {
            case Ht.DayOfWeek:
              r = Gd({
                weekdayNumber: Number(s),
                format: a.intlOptions,
                firstDayOfWeek: "firstDayOfWeek" in c ? c.firstDayOfWeek : void 0,
                locale: l
              });
              break;
            case Ht.MonthOfYear:
              r = Xd({
                monthNumber: Number(s),
                format: a.intlOptions,
                locale: l
              });
              break;
            case Ht.HourOfDay:
              r = Hd({
                hour: Number(s),
                format: a.intlOptions,
                locale: l
              });
              break;
          }
      } else if (s !== void 0 && s !== "") {
        if (a.type === b.DateAxisFormat)
          r = Dt({
            root: o,
            type: b.DateAxisFormat,
            intlOptions: a.intlOptions,
            formatLocale: l
          }).format(r, a.intlOptions);
        else if (a.type === b.CategoryAxisFormat && (r = s?.toString() ?? "", !ye(r) && r !== A.htmlEmptyContent)) {
          const { characterLimit: d } = a;
          r = cd({ stringToTruncate: r, characterLimit: d });
        }
      }
    }
    return r.toString();
  };
}
function Kb(t, e) {
  const i = { ...ni(e) }, a = [
    "year",
    "month",
    "day",
    "hour",
    "minute",
    "second"
  ], o = {}, n = {}, s = Ym.new(i.timeZone);
  t.root.timezone?.name !== s.name && (t.root.timezone = s);
  for (let r = 0; r < a.length; r += 1) {
    const l = a[r], c = r === 0 ? l : a[r - 1], u = e?.formatPerDateTimeUnit?.[l] ?? i, d = e?.formatPerDateTimeUnit?.[c];
    u && Object.values(u).find((m) => m !== void 0 && (typeof m != "string" || !ye(m))) && (o[l] = u, n[l] = d ?? u);
  }
  Object.keys(o).length > 0 && t.set("dateFormats", o), Object.keys(n).length > 0 && t.set("periodChangeDateFormats", n);
}
function El(t) {
  const { axis: e, valueFormat: i, chartType: a } = t, o = wr({
    isXAxis: !0,
    chartType: a,
    valueFormat: i
  }), n = mi(i) && e instanceof tt, s = Lt(i) && e instanceof we && !(e instanceof tt), r = o && e instanceof Ct;
  return !n && !s && !r;
}
function Xu(t) {
  const { dataContext: e, defaultValue: i, chartUID: a } = t;
  let o = si(e);
  const n = w(a, "config"), s = w(a, "rendererFieldNames"), r = z(n?.series), l = U(n?.series);
  if (r === b.BoxPlotSeries && (l === P.BoxPlotMonoField || l === P.BoxPlotMultiFields || l === P.BoxPlotMonoFieldAndSplitBy || l === P.BoxPlotMultiFieldsAndSplitBy))
    o = e?.[Ks];
  else if (r === b.HistogramSeries)
    o = e?.[ho.Start];
  else if (r === b.BarSeries && n !== void 0) {
    const c = n.series?.[0]?.nullCategory;
    o = o === null && c?.text !== void 0 ? c.text : oi({
      value: i ?? "",
      dataContext: e,
      useRendererLabel: yo(n, s)
    });
  } else
    o = oi({
      value: i ?? "",
      dataContext: e,
      useRendererLabel: yo(n, s)
    });
  return { labelValue: o, originalLabelValue: si(e) };
}
function Qb(t, e) {
  const { chart: i } = t;
  if (i !== void 0) {
    const a = t.get("renderer").labels.template;
    a.adapters.remove("text"), a.adapters.remove("html");
    const o = e !== void 0 ? "html" : "text";
    a.adapters.add(o, (n, s) => {
      let r = n;
      const l = _i(t.uid, "labelFormatter");
      if (!At(s.uid, "isGuide") && l !== void 0) {
        let u, d;
        switch (!0) {
          case t instanceof tt:
          case t instanceof we:
            u = s.dataItem?._settings?.value;
            break;
          case t instanceof Ct:
            {
              let m = n;
              const g = s.dataItem?.dataContext, h = w(t.chart?.uid ?? NaN, "config");
              if (z(h?.series) === b.HeatSeries) {
                const x = Fi(t.get("renderer")) ? g?.[Me.xField] : g?.[Me.yField];
                typeof x == "string" && (m = x);
              }
              const p = Xu({
                dataContext: g,
                defaultValue: m,
                chartUID: i.uid
              });
              u = p.labelValue, d = p.originalLabelValue;
            }
            break;
        }
        u !== void 0 && (r = l(u, d), o === "html" && (r = He(r)));
      }
      return r;
    }), a.adapters.add(o, (n, s) => {
      let r = n;
      const l = w(i.uid, "config");
      if (!At(s.uid, "isGuide") && l !== void 0) {
        const u = l.rotated ?? !1, d = Fi(t.get("renderer"), u), m = l.axes?.[d ? 0 : 1], g = {
          type: te.TS,
          ...m?.labels.content,
          text: n
        };
        r = ft({
          textSymbol: g,
          format: o === "text" ? "amChartsV5" : "html"
        });
      }
      return r;
    }), o === "html" && a.set("html", A.htmlEmptyContent);
  }
}
function Jb(t) {
  const { axis: e, isRotated: i, chartConfig: a } = t;
  if (e instanceof Ct || e instanceof tt) {
    const o = a.orderOptions?.data?.orderBy === Ln.Descending;
    let n = i === !0;
    o && e instanceof tt && (n = !n), e.get("renderer").set("inversed", n);
  }
}
async function ey(t) {
  const {
    axis: e,
    isXAxis: i,
    chartType: a,
    formatOptions: o,
    isNonAggregatedChart: n,
    overridePercentMultiplication: s,
    externalAxisLabelFormatter: r,
    errorStrings: l
  } = t, { chart: c } = e;
  if (c !== void 0) {
    const u = wr({
      isXAxis: i,
      chartType: a,
      valueFormat: o
    }), d = e instanceof we && !(e instanceof tt) && Lt(o), m = e instanceof tt && mi(o), g = e instanceof Ct && u;
    if (!(d || m || g))
      await fa("mismatchAxisAndValueFormat", l);
    else {
      Qb(e, r);
      let y = r;
      r === void 0 && (a === b.HeatSeries ? y = Zb({
        chart: c,
        isXAxis: i,
        formatOptions: o
      }) : g ? y = _b({
        chart: c,
        formatOptions: o,
        isNonAggregatedChart: n
      }) : d ? y = qb({
        axis: e,
        intlOptions: o.intlOptions,
        overridePercentMultiplication: s,
        valueAxisFormatter: r
      }) : m && Kb(e, o)), _a(e.uid, { labelFormatter: y });
    }
  }
}
function ty(t) {
  const {
    chart: e,
    chartConfig: { axes: i, rotated: a, series: o },
    rotationChanged: n,
    axisLabelsBehaviorChanged: s,
    timeIntervalInfoWasReset: r
  } = t, l = z(o), c = a === !0 ? 1 : 0, u = a === !0 ? 0 : 1, d = i?.[c]?.valueFormat, m = i?.[u]?.valueFormat, g = e.xAxes.getIndex(0), h = e.yAxes.getIndex(0), y = g === void 0 || n || d !== void 0 && El({
    axis: g,
    valueFormat: d,
    chartType: l
  }), p = h === void 0 || n || m !== void 0 && El({ axis: h, valueFormat: m, chartType: l });
  return r || s?.[0] || s?.[1] || y || p;
}
function Fi(t, e) {
  return t instanceof $t && e !== !0 || t instanceof qi && e === !0 || t instanceof fi;
}
function qn(t) {
  return t instanceof $t;
}
function iy(t) {
  return t instanceof qi;
}
function ay(t) {
  let e = !1;
  if (t !== void 0) {
    const i = w(t.uid, "config");
    if (i !== void 0) {
      const a = Do({ chartConfig: i }), { stackedMinY: o, stackedMaxY: n } = ag({
        seriesConfig: i.series,
        filteredData: t.series.getIndex(0)?.data.values ?? [],
        filteredSeriesIds: a
      });
      e = o < 0 || n < 0;
    }
  }
  return e;
}
function Yu(t) {
  const { axis: e, isSecondValueAxis: i, data: a } = t, { chart: o } = e;
  let n = !0;
  if (o !== void 0) {
    const s = w(o.uid, "config"), r = w(o.uid, "isRotated");
    if (s !== void 0) {
      const l = Fi(e.get("renderer"), r);
      let c = 0;
      l || (c = i === !0 ? 2 : 1);
      const { isLogarithmic: u } = s.axes?.[c] ?? {};
      if (u === !0) {
        const d = Do({ chartConfig: s, isSecondValueAxis: i }), m = a !== void 0 && "dataItems" in a ? $i(a) : void 0, { minY: g, maxY: h, minX: y, maxX: p } = $n({
          chartConfig: s,
          chartData: m ?? o.series.getIndex(0)?.data.values ?? [],
          filteredSeriesIds: d
        }), S = l ? y : g, x = l ? p : h;
        Number.isFinite(S) && S !== Number.MAX_SAFE_INTEGER && Number.isFinite(x) && x !== Number.MIN_SAFE_INTEGER && (n = S > 0 && x > 0);
      }
    }
  }
  return n;
}
function oy(t) {
  const { axis: e, isLogarithmic: i, isSecondValueAxis: a } = t;
  (e instanceof tt || e instanceof we) && e.setAll({
    logarithmic: i === !0 && Yu({ axis: e, isSecondValueAxis: a }),
    // zero values could mess up log calculations
    // https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Avoiding_zero_values
    treatZeroAs: i === !0 ? 1e-3 : 0,
    // don't allow decimals in log scale
    maxPrecision: i === !0 ? 0 : void 0
  });
}
function ny(t, e) {
  if (t instanceof we) {
    const { integerOnlyValues: i, valueFormat: a } = e, o = Qc(a) ? a.intlOptions.maximumFractionDigits : void 0;
    t.set("maxPrecision", i === !0 || o === 0 ? 0 : Number.NaN);
  }
}
function Uu(t, e) {
  const { chart: i } = e, a = za.new(t, { forceHidden: !0 });
  return e.set("tooltip", a), a.adapters.add("labelText", (o, n) => {
    let s = o ?? "";
    const r = _i(e.uid, "labelFormatter");
    if (!n.isHidden() && r && i) {
      const { label: l } = n, c = l.get("text") ?? "";
      if (e instanceof we) {
        const u = Number.parseFloat(c.replace(/,/gu, ""));
        s = r(Number.isNaN(u) ? c : u, o);
      } else if (e instanceof Ct) {
        const u = l.dataItem?.dataContext, d = Xu({ dataContext: u, defaultValue: o, chartUID: i.uid });
        s = r(d.labelValue ?? c, o ?? d.originalLabelValue);
      }
    }
    return s;
  }), a;
}
function sy(t) {
  const { root: e, axis: i, displayCursorTooltip: a } = t;
  (i.get("tooltip") ?? Uu(e, i)).set("forceHidden", a !== !0);
}
function ry(t) {
  const { axis: e, timeIntervalInfo: i, dateBaseInterval: a } = t;
  if (e instanceof tt) {
    let { size: o, unit: n } = i ?? {};
    if (n || ({ size: o, unit: n } = a ?? {}), o !== void 0 && n !== void 0) {
      let s;
      switch (n) {
        case xe.Second:
          s = "second";
          break;
        case xe.Minute:
          s = "minute";
          break;
        case xe.Hour:
          s = "hour";
          break;
        case xe.Day:
          s = "day";
          break;
        case xe.Week:
          s = "week";
          break;
        case xe.Month:
          s = "month";
          break;
        case xe.Year:
          s = "year";
          break;
      }
      s !== void 0 && e.set("baseInterval", { timeUnit: s, count: o });
    }
  }
}
function ly(t, e) {
  let { buffer: i } = e ?? {};
  return i ??= A.buffer, t instanceof we && !(t instanceof tt) && !i;
}
function cy(t, e) {
  let i = !1;
  return t instanceof we && !(t instanceof tt) && (i = ly(t, e), t.set("strictMinMax", i)), i;
}
function zl(t, e) {
  let i;
  if (!t || t <= 0)
    i = 1;
  else {
    const o = (e ? Math.ceil : Math.floor)(Math.log10(t));
    i = Math.pow(10, o);
  }
  return i;
}
function dy(t) {
  const { axis: e, minimumFromConfig: i, maximumFromConfig: a, data: o, isSecondValueAxis: n } = t;
  let s = i, r = a;
  const { chart: l } = e;
  if (l !== void 0) {
    const c = w(l.uid, "config"), u = c?.rotated;
    if (l instanceof Se && c !== void 0) {
      const d = z(c?.series), m = zt(c), g = Fi(e.get("renderer"), u), h = Hb(l), y = Do({ chartConfig: c, isSecondValueAxis: n, seriesIds: h }), p = $i(o), S = $n({
        chartConfig: c,
        // using either the provided data (at creation or after a data update) or the current series data
        chartData: p ?? l.series.getIndex(0)?.data.values ?? [],
        filteredSeriesIds: y
      }), { minX: x, maxX: C, minY: v, maxY: F } = S, [T, k] = g ? [x ?? Number.NaN, C ?? Number.NaN] : [v, F];
      d === b.BarSeries || d === b.HistogramSeries && !g || d === b.ComboLineAndBarSeries || (d === b.LineSeries || d === b.RadarSeries) && m === Ie.Stacked && !g ? (s = Math.min(T, 0), r = Math.max(k, 0)) : (s = T, r = k);
    }
    s = i ?? s, r = a ?? r;
  }
  return { min: s, max: r };
}
function uy(t) {
  const { axis: e, axisConfig: i, minimumFromConfig: a, maximumFromConfig: o, isLogarithmic: n, chartType: s, data: r, isSecondValueAxis: l } = t;
  if (e instanceof we || e instanceof tt)
    if (cy(e, i)) {
      let u = Number.isNaN(a) ? void 0 : a, d = Number.isNaN(o) ? void 0 : o;
      if (
        // If both the min and max from the config are valid, we directly assign them.
        // Otherwise, if strictMinMax is true, we add some logic to consider the chart's data
        !Number.isFinite(a) || !Number.isFinite(o)
      ) {
        const m = dy({
          axis: e,
          data: r,
          minimumFromConfig: u,
          maximumFromConfig: d,
          isSecondValueAxis: l
        });
        u = !n || Number.isFinite(a) ? m.min : zl(m.min, !1) ?? Number.NaN, d = !n || Number.isFinite(o) ? m.max : zl(m.max, !0) ?? Number.NaN;
      }
      u = u ?? Number.NaN, d = d ?? Number.NaN, Number.isNaN(u) || Number.isNaN(d) || u < d ? e.setAll({ min: u, max: d }) : e.setAll({ min: Number.NaN, max: Number.NaN }), s === b.GaugeSeries && e.markDirty();
    } else
      e.setAll({ min: Number.NaN, max: Number.NaN });
}
function bn(t, e) {
  if (t !== void 0) {
    const i = w(t.uid, "config"), a = zt(i), o = ay(t);
    if (i !== void 0 && (a !== Ie.Stacked100 || o)) {
      const n = z(i?.series), s = t.xAxes.getIndex(0), r = i.axes?.[0], l = i.axes?.[1], c = i.axes?.[2], u = t.yAxes.getIndex(0), d = t.xAxes.getIndex(1) ?? t.yAxes.getIndex(1);
      [
        { axis: s, axisConfig: r },
        { axis: u, axisConfig: l },
        {
          axis: d,
          axisConfig: n === b.HistogramSeries ? r : c,
          isSecondValueAxis: n !== b.HistogramSeries
        }
      ].forEach((m) => {
        const { axis: g, axisConfig: h, isSecondValueAxis: y } = m;
        if (g !== void 0) {
          const {
            minimum: p,
            maximum: S,
            buffer: x,
            isLogarithmic: C
          } = h ?? {};
          uy({
            axis: g,
            axisConfig: h,
            data: e,
            chartType: n,
            minimumFromConfig: p,
            maximumFromConfig: S,
            isLogarithmic: C,
            isSecondValueAxis: y
          });
        }
      });
    } else a === Ie.Stacked100 && (jt(i) ? t.xAxes : t.yAxes).each((r) => {
      r instanceof we && r.setAll({ min: 0, max: 100 });
    });
  }
}
function fy(t) {
  t.get("renderer").grid.template.adapters.add("strokeWidth", (e, i) => {
    const a = _i(
      t.uid,
      "zeroGridLine"
    ), o = a?.displayZeroLine === !0;
    let n = a?.strokeWidth ?? A.lineWidth;
    return i.get("themeTags")?.includes("base") && o && (n = (n === 0 ? 1 : n) * 1.5), n;
  }), t.get("renderer").grid.template.adapters.add("strokeOpacity", (e, i) => {
    const a = _i(
      t.uid,
      "zeroGridLine"
    ), o = a?.displayZeroLine === !0;
    let n = a?.visible === !0 ? e : 0;
    return i.get("themeTags")?.includes("base") && o && (n = 1), n;
  });
}
function kr(t) {
  t.on("visible", () => {
    t.chart instanceof Se && bn(t.chart);
  }), t.events.on(le.DataValidated, () => {
    t.chart instanceof Se && bn(t.chart);
  });
}
function my(t) {
  let e = 0;
  return t.dataItems.forEach((i) => {
    const a = i.get("label");
    a !== void 0 && At(a.uid, "isGuide") !== !0 && a.getText() !== void 0 && a.height() > e && a.isVisible() && (e = a.height());
  }), e;
}
function Wl(t, e) {
  if (e) {
    const { chart: i } = e;
    if (i) {
      const a = w(i.uid, "isRotated"), o = w(i.uid, "config"), n = z(o?.series), s = [], r = (l, c) => {
        if (l instanceof we) {
          const u = l.get("renderer") instanceof fi;
          s.push({
            isXAxis: Fi(l.get("renderer"), a),
            isSecondValueAxis: c === 1 && n !== b.HistogramSeries,
            // histogram have 2 x-axes but it's not what we consider as "second value axis"
            minimum: u ? l.get("min") : l.getPrivate("min"),
            maximum: u ? l.get("max") : l.getPrivate("max")
          });
        }
      };
      i.xAxes.each(r), i.yAxes.each(r), s.length > 0 && s.every((l) => Number.isFinite(l.minimum) && Number.isFinite(l.maximum)) && dd(s, i.root.dom);
    }
  }
}
function ju(t) {
  t.ghostLabel?.set("forceHidden", !0);
}
function Hl(t) {
  const { axis: e, start: i, end: a } = t;
  e.zoom(i ?? 0, a ?? 1);
}
function Gl(t) {
  t !== void 0 && t.setAll({ start: 0, end: 1 });
}
function gy(t) {
  t instanceof Se && (t.xAxes.each((e) => Hl({ axis: e })), t.yAxes.each((e) => Hl({ axis: e })), Gl(t.get("scrollbarX")), Gl(t.get("scrollbarY")));
}
function hy(t) {
  const { axis: e, guide: i, guideIndex: a } = t, { root: o, chart: n } = e, s = i.get("axisFill");
  s?.set("tooltip", za.new(o, { autoTextColor: !1 }));
  const r = s?.get("tooltip");
  if (r !== void 0 && n !== void 0) {
    r.label.setAll({
      oversizedBehavior: "wrap"
    }), r.label.adapters.add(
      "maxWidth",
      () => Math.min(A.tooltipWidth, n.seriesContainer.width())
    ), r.get("background")?.set("fillOpacity", kn);
    const l = w(n.uid, "rtl");
    r.label.set("direction", l ? "rtl" : "ltr");
  }
  if (s !== void 0) {
    s.adapters.add("tooltipText", (c, u) => {
      let d = c;
      const { dataItem: m } = u;
      if (!(e.get("renderer") instanceof fi)) {
        const g = _i(
          e.uid,
          "guideTooltipFormatter"
        );
        if (g !== void 0 && m instanceof Um) {
          let h, y;
          switch (!0) {
            case e instanceof tt:
            case e instanceof we:
              h = m.get("value"), y = m.get("endValue");
              break;
            case e instanceof Ct:
              h = m.get("category"), y = m.get("endCategory");
              break;
          }
          d = g({
            guideName: Ih(m.uid, "name") ?? "",
            start: h ?? "",
            end: y,
            // TODO: not pass guideEnd if undefined or null? or let guideTooltipFormatter() handle
            guideIndex: a
          });
        }
      }
      return d ?? "";
    });
    const l = s.getTooltip();
    l && (Tu(l), l.adapters.add("x", (c, u) => {
      const { chart: d } = e;
      if (d && u) {
        const m = w(d.uid, "config"), g = w(d.uid, "isRotated");
        if (m) {
          const y = !Fi(e.get("renderer"), g) ? 1 : 0, S = m?.axes?.[y]?.guides?.[a];
          if (S) {
            const { tooltipReverseColor: x } = S;
            ku(u, x);
          }
        }
      }
      return c;
    }));
  }
}
function py(t, e) {
  return (i) => {
    const { guideName: a, start: o, end: n } = i, { chart: s, root: r } = t;
    let l = "";
    if (s !== void 0) {
      const c = w(s.uid, "config"), u = w(s.uid, "isRotated"), m = !Fi(t.get("renderer"), u) ? 1 : 0, h = c?.axes?.[m]?.guides;
      let y = o, p = n;
      if (t instanceof tt) {
        let F;
        if (s !== void 0) {
          const T = w(t.chart?.uid ?? Number.NaN, "formatLocale");
          F = Dt({
            root: t.root,
            type: b.DateAxisFormat,
            // iLocale: chart.language.locale, // TODO: iLocale
            // intlOptions,
            formatLocale: T
          });
          const k = c?.axes?.[0]?.valueFormat?.type === b.DateAxisFormat ? c.axes[0].valueFormat.intlOptions : void 0;
          y = F.format(o, k), n !== void 0 && (p = F.format(n, k));
        }
      } else if (t instanceof we && !(o instanceof Date) && !(n instanceof Date)) {
        const F = h?.find((O) => O.name === a), { start: T, end: k } = qu(t, F);
        Number.isFinite(T) && (y = T), Number.isFinite(k) && (p = k);
        const $ = _i(t.uid, "numberFormatter") ?? ((O) => $c.new(r, {}).format(O));
        y = $(y), p !== void 0 && (p = $(p));
      } else t instanceof Ct && (y = o, p = n);
      const S = y.toString(), x = p?.toString() ?? "";
      !ye(x) && S !== x ? l = Ra(e.guideTooltipLabel, {
        guideStart: S,
        guideEnd: x
      }) : l = S;
      const C = w(s.uid, "rtl"), v = bt(C ?? !1);
      l = `${a}${v} ${l}`;
    }
    return l;
  };
}
function by(t) {
  const { axis: e, guideTooltipFormatter: i, utilsStrings: a } = t;
  _a(e.uid, {
    guideTooltipFormatter: i ?? py(e, a)
  });
}
function Xl(t) {
  const { inputValue: e, axis: i, axisMin: a, axisMax: o } = t;
  let n = e;
  if (e != null)
    switch (!0) {
      case i instanceof tt:
        n = e;
        break;
      case i instanceof Ct:
        n = e.toString();
        break;
      case i instanceof we:
        if (typeof e != "number") {
          const s = e.toString().trim(), r = Rn(s);
          r !== void 0 ? a !== void 0 && o !== void 0 ? n = r / 100 * (o - a) + a : n = null : n = Number.parseFloat(s);
        }
        break;
    }
  return n;
}
function Ir(t, e) {
  return t.axisRanges?.values?.filter((a) => {
    const o = a.get("label"), n = At(o?.uid ?? Number.NaN, "isGuide") ?? !1, s = At(o?.uid ?? Number.NaN, "isGaugeAxisLabel") ?? !1;
    let r = !1;
    switch (e) {
      case ce.Ticks:
        r = !n;
        break;
      case ce.Guides:
        r = n;
        break;
      case ce.GaugeTicksWithLabels:
        r = s && "value" in a && a.value !== void 0;
        break;
    }
    return r;
  }) ?? [];
}
function yy(t) {
  const { axis: e, guideConfig: i, above: a } = t, o = i !== void 0, n = e.axisRanges.length, s = e.axisRanges.insertIndex(n, e.makeDataItem({ above: a }));
  o && (a === !0 && s.get("axisFill")?.setAll({ layer: A.zIndexes.guide }), Xh({ guide: s, axis: e, guideLabelConfig: i?.label }));
  const r = s.get("axisFill");
  r !== void 0 && r.setAll({ disabled: !0, fillOpacity: 1 });
  const l = s.get("grid");
  return l !== void 0 && o && l.set("strokeOpacity", 0), s;
}
function Sy(t) {
  const { axis: e, guideIndex: i, guideConfig: a } = t, o = yy({ axis: e, guideConfig: a, above: a?.above });
  hy({ axis: e, guide: o, guideIndex: i });
  const n = o.get("tick"), s = o.get("label"), r = o.get("grid");
  n !== void 0 && n.set("disabled", !0), s !== void 0 && s.set("inside", !0), r !== void 0 && r.set("disabled", !0);
}
function xy(t, e) {
  const a = Ir(t, ce.Guides).length, n = (e?.length ?? a) - a;
  for (let s = 0; s < n; s += 1)
    Sy({ axis: t, guideIndex: s, guideConfig: e?.[s] });
}
function Cy(t, e) {
  const { start: i, end: a } = e;
  let o = i !== null ? i : void 0, n = a !== null ? a : void 0;
  const { chart: s } = t, r = w(s?.uid ?? Number.NaN, "config");
  if (r !== void 0) {
    const l = ir(r), c = t.data.values, d = c.find(
      (m) => m[A.originalCategoryValue] === i
    )?.[l];
    if ((typeof d == "string" || typeof d == "number" || d instanceof Date) && (o = d), n !== void 0)
      for (let m = c.length - 1; m >= 0; m -= 1) {
        const g = c[m], h = g[l];
        if (g[A.originalCategoryValue] === a && (typeof h == "string" || typeof h == "number" || h instanceof Date)) {
          n = h;
          break;
        }
      }
  }
  return { modifiedStart: o, modifiedEnd: n };
}
function qu(t, e) {
  const { start: i, end: a } = e ?? {};
  let o;
  if (e !== void 0 && i !== void 0 && i !== null) {
    const n = t instanceof we ? t.get("min") : void 0, s = t instanceof we ? t.get("max") : void 0, r = Xl({ inputValue: i, axis: t, axisMin: n, axisMax: s }), l = e.style?.type === te.SFS && a !== null && a !== void 0 ? Xl({ inputValue: a, axis: t, axisMin: n, axisMax: s }) : r;
    o = {
      isValidGuide: r != null && (a === void 0 || l != null),
      start: r,
      end: l
    };
  } else
    o = { isValidGuide: !1, start: void 0, end: void 0 };
  return o;
}
function vy(t) {
  const { axis: e, guide: i, guideConfig: a } = t, { start: o, end: n } = a;
  if (o !== void 0) {
    const { chart: s } = e;
    let r;
    if (e instanceof Ct && s instanceof Se && w(s.uid, "isNonAggregatedChart") === !0) {
      const { modifiedStart: l, modifiedEnd: c } = Cy(e, a);
      r = { isValidGuide: !0, start: l ?? o, end: c ?? n };
    } else
      r = qu(e, a);
    if (r.isValidGuide) {
      let l, c;
      switch (!0) {
        case e instanceof tt:
        case e instanceof we:
          l = "value", c = "endValue";
          break;
        case e instanceof Ct:
          l = "category", c = "endCategory";
          break;
      }
      l !== void 0 && r.start !== void 0 && i.setAll({ [l]: r.start }), c !== void 0 && r.end !== void 0 && i.setAll({ [c]: r.end });
    }
  }
}
function Ly(t) {
  const { axis: e, guide: i, guideConfig: a } = t;
  if (i) {
    const o = i.get("axisFill"), n = i.get("label");
    if (a !== void 0) {
      wh(i.uid, { name: a.name }), Re(i, a.visible), vy({ axis: e, guide: i, guideConfig: a }), a.style.type === te.SLS ? na({
        element: o,
        fillSymbol: { type: te.SFS, color: a.style?.color, outline: a.style },
        visible: a.visible
      }) : a.style.type === te.SFS && na({ element: o, fillSymbol: a.style, visible: a.visible }), Yh({ axis: e, guide: i, guideConfig: a, guideType: a.style.type }), i.get("axisFill")?.setAll({ layer: a.above ? A.zIndexes.guide : 0 });
      const { chart: s } = e;
    } else
      o !== void 0 && o.set("disabled", !0), n !== void 0 && n.set("disabled", !0);
  }
}
function Fy(t) {
  const { axis: e, guideConfigs: i, guideTooltipFormatter: a, utilsStrings: o } = t;
  if (i !== void 0) {
    const n = Ir(e, ce.Guides);
    i.forEach((s, r) => {
      Ly({ axis: e, guide: n[r], guideConfig: s });
    }), by({ axis: e, guideTooltipFormatter: a, utilsStrings: o });
  }
}
function Ay(t) {
  const { axis: e, tickOrGuide: i, numberOfElementsToBeDeleted: a } = t, o = [];
  let n = e.axisRanges.length - 1, s = a;
  for (; s > 0 && n >= 0; ) {
    const r = e.axisRanges.getIndex(n);
    r !== void 0 && (At(r.get("label")?.uid ?? Number.NaN, "isGuide") ?? !1) === !0 && i === ce.Guides && (o.push(r), s -= 1), n -= 1;
  }
  for (let r = 0; r < o.length; r += 1)
    e.axisRanges.removeValue(o[r]);
}
function Yl(t, e) {
  const a = Ir(t, ce.Guides).length, o = e?.length ?? 0, n = a - o;
  Ay({
    axis: t,
    numberOfElementsToBeDeleted: n,
    tickOrGuide: ce.Guides
  });
}
function Ty(t) {
  const { axis: e, guideConfigs: i, anyGuideAboveChanged: a } = t;
  a && Yl(e), xy(e, i), Fy(t), Yl(e, i);
}
function _u(t) {
  return t.getCellWidthPosition() * t.width();
}
function ky(t, e) {
  const i = t.get("renderer");
  if (t !== void 0) {
    let a = Number.NaN;
    if (e === ke.Wrap) {
      let o = Number.MAX_SAFE_INTEGER;
      i.labels.each((s) => {
        At(s.uid, "isGuide") !== !0 && s.width() > 0 && (o = Math.min(
          o,
          s.innerWidth()
        ));
      });
      const n = t instanceof tt ? t.width() / A.maxNumberOfXAxisLabelsInWrapModeForDateAxis : t.width() / A.maxNumberOfXAxisLabelsInWrapMode;
      a = Math.max(o, n);
    } else if (e === ke.Hide) {
      let o = Number.MIN_SAFE_INTEGER;
      i.labels.each((n) => {
        At(n.uid, "isGuide") !== !0 && n.width() > 0 && (o = Math.max(
          o,
          n.innerWidth()
        ));
      }), a = o + 2;
    }
    Number.isFinite(a) && a > A.shortestMinGridDistance && i.set("minGridDistance", a);
  }
}
function Iy(t) {
  const { axis: e, chartType: i, labelConfig: a, isSecondValueAxis: o, tickSpacing: n } = t;
  let { horizontalAxisLabelsBehavior: s } = t;
  s === void 0 && (s = i !== b.HistogramSeries ? ke.Rotate : ke.Hide);
  const r = e.get("renderer");
  let l = r.get("minGridDistance");
  if (typeof n == "number" && Number.isFinite(n))
    l = n;
  else if (i !== b.RadarSeries)
    if (r instanceof fi)
      l = A.gauge.gaugeMinGridDistance;
    else if (e instanceof we)
      l = r instanceof $t ? A.xAxisMinGridDistance : A.yAxisMinGridDistance;
    else if (r instanceof $t)
      if (o === !0)
        l = A.secondRotatedValueAxisMinGridDistance;
      else if (s === ke.Rotate) {
        const c = a.content.font?.size ?? A.generalFontSize, u = e instanceof Ct ? A.categoryAxisLabelPadding : A.axisLabelPadding;
        l = c * u;
      } else if (s === ke.Wrap || s === ke.Hide) {
        let c = _i(
          e.uid,
          "minGridDistanceCallbackDisposer"
        );
        c !== void 0 && c.dispose(), c = e.events.on(le.BoundsChanged, () => {
          ky(e, s);
        }), _a(e.uid, { minGridDistanceCallbackDisposer: c });
      } else s === ke.Stagger ? l = A.staggerMinGridDistance : l = e instanceof Ct ? A.xCategoryAxisMinGridDistance : A.xAxisMinGridDistance;
    else
      l = e instanceof Ct ? A.yCategoryAxisMinGridDistance : A.yAxisMinGridDistance;
  r.set("minGridDistance", l);
}
function Ul(t = 1, e) {
  e.get("renderer").labels.template.set("maxWidth", _u(e) * t);
}
function jl(t, e = 1) {
  t.get("renderer").labels.template.setAll({
    oversizedBehavior: "wrap",
    paddingLeft: 0.5,
    paddingRight: 0.5,
    textAlign: "center"
  }), t.events.on(le.BoundsChanged, () => Ul(e, t)), Ul(e, t);
}
function wy(t) {
  const e = t.get("renderer").labels.template;
  e.adapters.add("rotation", (i, a) => {
    const o = At(a.uid, "isGuide") !== !0 ? _i(t.uid, "rotation") ?? 0 : i ?? 0;
    return e.set("centerX", o === 0 ? Ae : Te), o;
  });
}
function ql(t) {
  if (t?.chart !== void 0) {
    const e = t.get("renderer");
    if (w(t.chart.uid, "config")?.axes?.[0].labels !== void 0 && e.labels.length > 1) {
      const o = e.labels.getIndex(0)?.get("rotation");
      let n = 0;
      e.labels.each((l) => {
        if (At(l.uid, "isGuide") !== !0 && l.width() > 0) {
          const c = o === A.rotatedAxisLabel.rotation ? Math.sqrt(l.innerHeight() ** 2 + l.innerWidth() ** 2) : l.innerWidth();
          c > n && (n = c);
        }
      });
      const r = _u(t) >= n + 5;
      if (!r && o === 0 || r && o === A.rotatedAxisLabel.rotation) {
        const l = r ? A.axisLabel.rotation : A.rotatedAxisLabel.rotation;
        e.labels.template.setAll({
          rotation: l,
          centerX: r ? Ae : Te,
          centerY: Ke,
          paddingTop: r ? A.axisLabel.paddingTop : A.rotatedAxisLabel.paddingTop,
          paddingLeft: r ? A.axisLabel.paddingLeft : A.rotatedAxisLabel.paddingLeft,
          paddingRight: r ? A.axisLabel.paddingRight : A.rotatedAxisLabel.paddingRight
        }), _a(t.uid, { rotation: l });
      }
    }
  }
}
function _l(t) {
  const e = t.get("renderer");
  wy(t), e.labels.template.setAll({ oversizedBehavior: "hide" }), t.events.on(le.BoundsChanged, () => ql(t)), ql();
}
function Zl(t) {
  if (t && w(t.chart?.uid ?? Number.NaN, "config")?.axes?.[0].labels?.visible !== !1) {
    let a = 0;
    t.dataItems.forEach((o, n) => {
      const s = o.get("label");
      s !== void 0 && At(s.uid, "isGuide") !== !0 && s.getText() !== void 0 && s.width() > 0 && n % 2 === 0 && s.innerHeight() > a && (a = s.innerHeight());
    }), a = Math.round(a), a > 0 && (t.dataItems.filter((o) => {
      const n = o.get("tick"), s = o.get("label");
      return n !== void 0 && s !== void 0 && At(s.uid, "isGuide") !== !0 && s.getText() !== void 0 && s.width() > 0;
    }).forEach((o, n) => {
      const s = o.get("tick"), r = o.get("label"), l = n % 2 === 1;
      s && s.set("length", l ? a + 5 : A.axisTickLength), r && r.set("dy", l ? a : 0);
    }), a && t.get("renderer").labels.template.get("paddingBottom") !== a + 5 && t.get("renderer").labels.template.set("paddingBottom", a + 5));
  }
}
function $y(t) {
  t.get("renderer").labels.template.set("oversizedBehavior", "wrap"), t.events.on(le.BoundsChanged, () => Zl(t)), Zl(t);
}
function Dy(t) {
  t.get("renderer").labels.template.setAll({
    oversizedBehavior: "wrap",
    maxWidth: A.yAxisLabelMaxWidth,
    textAlign: "end"
  });
}
function Oy(t) {
  const {
    axis: e,
    horizontalAxisLabelsBehavior: i,
    verticalAxisLabelsBehavior: a,
    axisLabelsBehaviorChanged: o,
    labelConfig: n,
    chartType: s
  } = t, r = e.get("renderer");
  if (!(r instanceof fi))
    if (qn(r) && o?.[0] === !0)
      switch (s === b.HistogramSeries && i === void 0 ? ke.Hide : i) {
        case ke.Hide:
          break;
        case ke.Stagger:
          $y(e), jl(e, 2);
          break;
        case ke.Wrap:
          jl(e);
          break;
        case ke.Rotate:
          _l(e);
          break;
        default:
          n.content.angle !== null && n.content.angle === void 0 && _l(e);
          break;
      }
    else iy(r) && a !== ke.Hide && Dy(e);
}
function Ry(t) {
  const { renderer: e, axisConfig: i, labelConfig: a } = t;
  switch (i.labelsOrientation) {
    case ul.Horizontal:
      e.labels.template.setAll({ textType: "adjusted" }), e.labels.template.remove("radius");
      break;
    case ul.Radial:
      e.labels.template.setAll({ textType: "radial", radius: 35 }), a.content.verticalAlignment = ee.Middle;
      break;
    default:
      e.labels.template.setAll({ textType: "circular" }), e.labels.template.remove("radius");
  }
}
function By(t) {
  const {
    axis: e,
    axisConfig: { labels: i },
    horizontalAxisLabelsBehavior: a,
    verticalAxisLabelsBehavior: o,
    axisLabelsBehaviorChanged: n,
    chartType: s
  } = t, r = { ...i }, l = e.get("renderer"), c = l?.get("opposite");
  qn(l) ? (r.content.horizontalAlignment = se.Center, r.content.verticalAlignment = c ? ee.Bottom : ee.Top) : (r.content.horizontalAlignment = c ? se.Left : se.Right, r.content.verticalAlignment = ee.Middle), l instanceof fi ? Ry({ renderer: l, axisConfig: t.axisConfig, labelConfig: i }) : r.content.angle = r.content.angle ?? l.labels.template.get("rotation"), Pt({
    label: l.labels.template,
    labelConfig: r
  }), Oy({
    axis: e,
    horizontalAxisLabelsBehavior: a,
    verticalAxisLabelsBehavior: o,
    labelConfig: i,
    axisLabelsBehaviorChanged: n,
    chartType: s
  });
}
function My(t) {
  const { axis: e, isHorizontalAxis: i, label: a } = t, { chart: o } = e;
  if (o) {
    const n = i ? "width" : "height", s = i ? ae.XAxisTitle : ae.YAxisTitle;
    vi({ chart: o, label: a, labelType: s }), e.onPrivate(
      n,
      Ye(() => vi({ chart: o, label: a, labelType: s }), A.debounceTime)
    );
  }
}
function Lo(t) {
  const { value: e, axisMin: i, axisMax: a } = t;
  let o = Number.NaN;
  const n = a - i;
  return n !== 0 && (o = (e - i) / n), o;
}
function Is(t) {
  return t != null && t !== 0;
}
function Zu(t) {
  const {
    minimum: e,
    maximum: i,
    labelsIncrement: a,
    minimumValueConversion: o,
    maximumValueConversion: n
  } = t;
  let s = e ?? G.gauge.axisMinimum, r = i ?? G.gauge.axisMaximum;
  s = pl(s, o), r = pl(r, n);
  const l = Is(a);
  let c = Is(a) ? a : Math.abs(r - s) / G.gauge.numberOfLabelIntervals, u = l ? Math.round(Math.abs(r - s) / c) : G.gauge.numberOfLabelIntervals;
  if (l)
    if (u > G.gauge.maximumNumberOfLabelIntervals)
      c = Math.abs(r - s), u = 1;
    else {
      const d = s + u * c;
      d < r ? (u += 1, r = s + u * c) : d > r && (r = d);
    }
  return {
    min: s,
    max: r,
    labelsIncrement: c,
    numberOfIntervals: u
  };
}
function Ku(t) {
  const { axisConfig: e, axisMin: i, axisMax: a } = t;
  typeof i == "number" && typeof a == "number" && a - i !== 0 && e.guides?.forEach((n) => {
    const { start: s, end: r } = n;
    typeof s == "number" && (n.start = Lo({ value: s, axisMin: i, axisMax: a })), typeof r == "number" && (n.end = Lo({ value: r, axisMin: i, axisMax: a }));
  });
}
function Ny(t) {
  const { featureIndex: e, chartData: i, chartConfig: a } = t, { minimumFromField: o, maximumFromField: n } = a?.axes?.[0] ?? {};
  let s, r;
  if (e >= 0 && e < i.length) {
    const l = i[e];
    typeof o == "string" && !ye(o) && Number.isFinite(l[o]) && (s = l[o]), typeof n == "string" && !ye(n) && Number.isFinite(l[n]) && (r = l[n]);
  }
  return { minimumFromData: s, maximumFromData: r };
}
function Py(t) {
  const { featureIndex: e, chartData: i, x: a } = t;
  let o = -1;
  if (e >= 0 && e < i.length) {
    const n = i[e];
    a !== void 0 && !ye(a) && Number.isFinite(n[a]) && (o = n[a]);
  }
  return o;
}
async function Qu(t) {
  const { featureIndex: e = 0, chartData: i, queryConfig: a, chartConfig: o, queryObject: n } = t, { axes: s, series: r } = o, l = Qs(o), { minimum: c, maximum: u } = s?.[0] ?? {}, { x: d } = r?.[0] ?? {}, m = G.gauge;
  let g, h;
  l ? { minimumFromData: g, maximumFromData: h } = Ny({
    featureIndex: e,
    chartData: i,
    chartConfig: o
  }) : n !== void 0 && a !== void 0 && ({ minimumFromData: g, maximumFromData: h } = await Sg({
    queryObject: n,
    chartConfig: o,
    queryConfig: a
  }));
  const y = g ?? c ?? m.axisMinimum, p = h ?? u ?? m.axisMaximum, S = Py({ chartData: i, featureIndex: e, x: d });
  return { minimum: y, maximum: p, dataValue: S };
}
function Vy(t) {
  const { oldConfig: e, axisMax: i, min: a, max: o, labelsIncrement: n, numberOfIntervals: s, valueFormat: r, minimumFromField: l } = t, c = Ya(r);
  let u = !0;
  if (e !== void 0) {
    const {
      minimum: d,
      minimumFromField: m,
      labelsIncrement: g,
      valueFormat: h
    } = e.axes[0], y = h?.intlOptions?.style !== r?.intlOptions?.style, p = Is(g) ? g !== n : s !== G.gauge.numberOfLabelIntervals;
    u = y || a !== d || l !== m || !c && o !== i || p;
  }
  return u;
}
function Ey(t) {
  const { x: e, data: i, chart: a, valueFormat: o, minimum: n, maximum: s } = t;
  let r = Number.NaN;
  if (i !== void 0 && e !== void 0) {
    const l = i.find((u) => e in u), c = Number.parseFloat(l[e]);
    Number.isFinite(c) && (r = c, de(a.uid, { gaugeData: r }));
  } else {
    const l = w(a.uid, "gaugeData");
    Number.isFinite(l) && (r = l);
  }
  return Ya(o) && n !== void 0 && s !== void 0 && n !== null && s !== null && r !== null && s - n !== 0 && (r = Lo({
    value: r,
    axisMin: n,
    axisMax: s
  })), r;
}
function zy(t, e) {
  let i = e ?? null;
  if (e != null) {
    const a = t.xAxes.getIndex(0), o = w(t.uid, "config"), n = a.get("min") ?? o?.axes?.[0].minimum ?? A.gauge.axisMinimum, s = a.get("max") ?? o?.axes?.[0].maximum ?? A.gauge.axisMaximum;
    e < n ? i = n : e > s && (i = s);
  }
  return i ?? void 0;
}
function Wy(t) {
  const { root: e } = t, i = As.new(e, {
    radius: gt(100)
  }), a = t.makeDataItem({
    value: 0,
    bullet: Jm.new(e, {
      sprite: i
    })
  });
  return t.createAxisRange(a), a.get("grid")?.set("visible", !1), a.get("tick")?.set("visible", !1), i;
}
function Hy(t) {
  const { chart: e, axis: i, needleConfig: a, gaugeValue: o } = t, n = i.axisRanges.values.find(
    (r) => r.get("bullet")?.get("sprite") instanceof As
  ), s = n?.get("bullet")?.get("sprite");
  if (n && s instanceof As) {
    const { startWidth: r, endWidth: l, innerRadius: c } = A.gaugeNeedle;
    na({ element: s.hand, fillSymbol: a?.symbol }), na({ element: s.pin, fillSymbol: a?.symbol }), n.set("value", zy(e, o)), s.pin.set("visible", a?.displayPin === !0), s.setAll({
      visible: a?.visible ?? !0,
      innerRadius: gt(a?.innerRadius ?? c),
      bottomWidth: a?.startWidth ?? r,
      topWidth: a?.endWidth ?? l
    });
  }
}
function Gy(t, e) {
  const i = Number.isFinite(e?.innerRadius) ? e?.innerRadius : A.gauge.innerRadius;
  typeof i == "number" && Number.isFinite(i) && t.set("innerRadius", gt(i));
}
function Xy(t, e) {
  const i = Number.isFinite(e?.startAngle) ? e?.startAngle : A.gauge.startAngle, a = Number.isFinite(e?.endAngle) ? e?.endAngle : A.gauge.endAngle;
  typeof i == "number" && Number.isFinite(i) && t.set("startAngle", i), typeof a == "number" && Number.isFinite(a) && t.set("endAngle", a);
}
async function Yy(t) {
  const { chart: e, chartConfig: i, data: a, queryObject: o, xAxisLabelFormatter: n, utilsStrings: s, errorStrings: r } = t, { axes: l, series: c } = i, u = Qs(i), { featureIndex: d, x: m } = c[0], g = l?.[0], h = e.xAxes.getIndex(0), y = { ...g };
  if (h instanceof we && h.get("renderer") instanceof fi && y !== void 0 && a && "dataItems" in a) {
    const { valueFormat: p, needle: S } = y;
    Gy(e, i), Xy(e, i);
    const x = await Qu({
      featureIndex: d,
      chartData: a.dataItems,
      chartConfig: i,
      queryObject: o,
      queryConfig: w(e.uid, "queryConfig")
    });
    y.minimum = x.minimum, y.maximum = x.maximum;
    const { min: C, max: v } = Zu(y), F = { ...y };
    Ya(p) ? (F.minimum = 0, F.maximum = 1, Ku({
      axisConfig: F,
      axisMin: y.minimum,
      axisMax: y.maximum
    })) : (F.minimum = C, F.maximum = v), await $r({
      chartConfig: i,
      axis: h,
      axisConfig: F,
      externalAxisLabelFormatter: n,
      utilsStrings: s,
      errorStrings: r
    });
    const T = u ? x?.dataValue : Ey({
      x: m,
      data: a.dataItems,
      chart: e,
      minimum: y.minimum,
      maximum: y.maximum,
      valueFormat: p
    });
    Hy({
      chart: e,
      axis: h,
      needleConfig: S,
      gaugeValue: T
    });
  }
}
async function Uy(t) {
  const { chart: e, axesConfig: i, errorStrings: a } = t, { root: o } = e;
  await Ji({ chartType: b.GaugeSeries, axesConfig: i, errorStrings: a });
  const n = e.xAxes.push(
    we.new(o, {
      min: 0,
      max: 100,
      renderer: fi.new(o, {})
    })
  );
  Wy(n), ju(n);
}
async function jy(t) {
  const {
    chart: e,
    chartConfig: i,
    axisLabelsBehaviorChanged: a,
    data: o,
    yAxisLabelFormatter: n,
    guideTooltipFormatter: s,
    utilsStrings: r,
    errorStrings: l
  } = t, { horizontalAxisLabelsBehavior: c, verticalAxisLabelsBehavior: u, axes: d } = i, m = b.HistogramSeries, g = e.xAxes.getIndex(0), h = e.yAxes.getIndex(0);
  await Ji({
    chartType: m,
    axesConfig: d,
    errorStrings: l
  }), [
    { axis: g, axisConfig: d?.[0] },
    { axis: h, axisConfig: d?.[1] }
  ].forEach(async (y) => {
    const { axis: p, axisConfig: S } = y;
    p !== void 0 && S !== void 0 && await $r({
      axis: p,
      data: o,
      axisConfig: S,
      horizontalAxisLabelsBehavior: c,
      verticalAxisLabelsBehavior: u,
      axisLabelsBehaviorChanged: a,
      utilsStrings: r,
      chartConfig: i,
      externalAxisLabelFormatter: n,
      guideTooltipFormatter: s,
      errorStrings: l
    });
  }), bn(e, o);
}
async function qy(t) {
  const { chart: e, axesConfig: i, x: a, errorStrings: o } = t, { root: n } = e, s = b.HistogramSeries;
  await Ji({ chartType: s, axesConfig: i, errorStrings: o });
  const r = { root: n, x: a, chartType: s }, l = i?.[0]?.valueFormat, c = i?.[1]?.valueFormat;
  if (l !== void 0 && c !== void 0) {
    const u = Xi({
      ...r,
      axes: e.xAxes,
      valueFormat: l,
      axisRenderer: $t.new(n, {}),
      isXAxis: !0,
      x: a
    }), d = Xi({
      ...r,
      axes: e.xAxes,
      valueFormat: l,
      axisRenderer: $t.new(n, {}),
      isAxisForHistogramOverlaySeries: !0,
      isXAxis: !0,
      x: a
    });
    Xi({
      ...r,
      axes: e.yAxes,
      valueFormat: c,
      axisRenderer: qi.new(n, {}),
      isXAxis: !1,
      x: a
    }), u && (u.get("renderer").grid.template.set("location", 0), u.get("renderer").ticks.template.set("location", 0), u.get("renderer").labels.template.set("location", 0)), d && (d.set("visible", !1), d.get("renderer").grid.template.set("visible", !1), d.get("renderer").ticks.template.set("visible", !1), d.get("renderer").labels.template.set("visible", !1));
  }
}
function wr(t) {
  const { isXAxis: e, chartType: i, valueFormat: a, isAxisForHistogramOverlaySeries: o } = t;
  return i === b.HeatSeries || e && (Oo(a) || i === b.HistogramSeries && !o || i === b.BarSeries && Lt(a));
}
function Ju(t, e) {
  return e ? `${Dl}_x_${t.uid}` : `${Dl}_y_${t.uid}`;
}
function ef(t, e) {
  const i = w(t.chart?.uid ?? Number.NaN, "config"), a = jt(i) ? 1 : 0, o = i?.axes?.[a]?.title?.content?.verticalAlignment, n = my(t);
  let s = n;
  switch (o) {
    case ee.Baseline:
    case ee.Middle:
      s = n / 2;
      break;
    case ee.Bottom:
      s = Math.min(n, 0);
      break;
    case ee.Top:
  }
  e?.set("dy", s);
}
function _y(t) {
  t instanceof we && (t.onPrivate("min", Wl), t.onPrivate("max", Wl));
}
function Zy(t) {
  const { axis: e, isHorizontalAxis: i, isSecondValueAxis: a } = t, { root: o } = e, n = i ? { ...A.xAxisTitleLabel, verticalCenter: ee.Top } : A.yAxisTitleLabel, s = Co({ root: o, id: Ju(e, i), defaults: n });
  return e.get("renderer") instanceof qi && a !== !0 || e.get("renderer") instanceof $t && a === !0 ? e.children.unshift(s) : e.children.push(s), i && a !== !0 && e.events.on(
    le.BoundsChanged,
    Ye(() => {
      ef(e, s);
    }, A.debounceTime)
  ), My({ axis: e, isHorizontalAxis: i, label: s }), s;
}
function Xi(t) {
  const {
    root: e,
    axes: i,
    isXAxis: a,
    valueFormat: o,
    axisRenderer: n,
    isSecondValueAxis: s = !1,
    chartType: r,
    x: l,
    isAxisForHistogramOverlaySeries: c
  } = t;
  let u;
  if (wr({ isXAxis: a, chartType: r, valueFormat: o, isAxisForHistogramOverlaySeries: c }) && !s) {
    let d;
    switch (r) {
      case b.HeatSeries:
        d = a ? Me.xField : Me.yField;
        break;
      case b.HistogramSeries:
        d = ho.Start;
        break;
      case b.BoxPlotSeries:
        d = l;
        break;
      default:
        d = A.xAxisField;
        break;
    }
    d && (u = i.push(Ct.new(e, { categoryField: d, renderer: n })));
  } else if (mi(o))
    u = i.push(tt.new(e, { strictMinMax: !0, baseInterval: { timeUnit: "day", count: 1 }, renderer: n }));
  else if (Lt(o) && (u = i.push(we.new(e, { strictMinMax: !0, renderer: n })), s && u instanceof we)) {
    const d = i.getIndex(0);
    d instanceof we && u.set("syncWithAxis", d);
  }
  if (u !== void 0 && !c) {
    fy(u), Uu(e, u);
    const d = r === b.HistogramSeries || r === b.HeatSeries ? 0 : 0.1, m = r === b.HistogramSeries || r === b.HeatSeries ? 1 : 0.9;
    u.get("renderer").setAll({ cellStartLocation: d, cellEndLocation: m }), ju(u), _y(u), qn(u.get("renderer")) ? u.get("renderer").labels.template.set(
      s ? "paddingBottom" : "paddingTop",
      A.axisLabelSpacing.horizontalAxisLabelPaddingTop
    ) : n instanceof qi && u.get("renderer").labels.template.set(
      s ? "paddingLeft" : "paddingRight",
      A.axisLabelSpacing.verticalAxisLabelSidePadding
    );
  }
  return u;
}
function Ky(t) {
  const { axis: e, data: i, chartType: a } = t;
  if (i !== void 0) {
    const o = $i(i);
    if (a !== b.HeatSeries)
      e.data.setAll(o ?? []);
    else {
      const n = (l, c) => {
        const u = c?.map(
          (d) => l in d ? d[l] : void 0
        );
        return Array.from(new Set(u)).map((d) => ({ [l]: d }));
      }, s = e.get("renderer") instanceof qi ? Me.yField : Me.xField, r = n(s, o);
      e.data.setAll(r);
    }
  }
}
function Qy(t) {
  const { axis: e, axisTitleConfig: i, isSecondValueAxis: a } = t, o = e.get("renderer"), { chart: n } = e, s = qn(o), r = Ce({ childId: Ju(e, s), parent: e, useChildId: !0 }) ?? Zy({ axis: e, isHorizontalAxis: s, isSecondValueAxis: a });
  if (r instanceof yi) {
    const l = s ? { ...A.xAxisTitleLabel, verticalCenter: ee.Top } : A.yAxisTitleLabel;
    if (Pt({ label: r, labelConfig: i, defaults: l }), s && a !== !0 && ef(e, r), n) {
      const c = { chart: n, label: r, labelType: s ? ae.XAxisTitle : ae.YAxisTitle };
      vi(c);
    }
  }
}
async function $r(t) {
  const {
    axis: e,
    data: i,
    axisConfig: a,
    timeIntervalInfo: o,
    horizontalAxisLabelsBehavior: n,
    verticalAxisLabelsBehavior: s,
    axisLabelsBehaviorChanged: r,
    anyGuideAboveChanged: l,
    isNonAggregatedChart: c,
    isSecondValueAxis: u,
    chartConfig: d,
    externalAxisLabelFormatter: m,
    guideTooltipFormatter: g,
    utilsStrings: h,
    errorStrings: y
  } = t, {
    visible: p,
    lineSymbol: S,
    title: x,
    labels: C,
    isLogarithmic: v,
    grid: F,
    displayCursorTooltip: T,
    displayZeroLine: k,
    valueFormat: $,
    guides: O,
    tickSpacing: D,
    dateBaseInterval: R
  } = a, { root: M } = e, N = z(d.series), E = zt(d), V = d.rotated, W = e.get("renderer");
  _a(e.uid, {
    zeroGridLine: { displayZeroLine: k, strokeWidth: F?.width ?? A.lineWidth, visible: F !== void 0 }
  }), oy({ axis: e, isLogarithmic: v, isSecondValueAxis: u }), await ey({
    axis: e,
    isXAxis: Fi(e.get("renderer"), V),
    chartType: N,
    formatOptions: $,
    isNonAggregatedChart: c,
    overridePercentMultiplication: E === Ie.Stacked100,
    externalAxisLabelFormatter: m,
    errorStrings: y
  }), Jb({ axis: e, isRotated: V, chartConfig: d }), ry({ axis: e, timeIntervalInfo: o, dateBaseInterval: R }), Yt({
    element: W,
    lineSymbol: { color: [...A.color], ...S ?? wo() },
    visible: p
  }), Yt({ element: W.ticks.template, lineSymbol: S, visible: p }), Yt({ element: W.grid.template, lineSymbol: F, visible: p }), F === void 0 && (e.get("renderer").grid.template.set("strokeWidth", A.lineWidth), e.markDirtyValues()), By({
    axis: e,
    axisConfig: a,
    chartType: N,
    horizontalAxisLabelsBehavior: n,
    verticalAxisLabelsBehavior: s,
    axisLabelsBehaviorChanged: r
  }), Qy({ axis: e, axisTitleConfig: x, isSecondValueAxis: u }), ny(e, a), Iy({
    axis: e,
    chartType: N,
    labelConfig: C,
    horizontalAxisLabelsBehavior: n,
    isSecondValueAxis: u,
    tickSpacing: D
  }), sy({ root: M, axis: e, displayCursorTooltip: T }), Ty({ axis: e, guideConfigs: O, guideTooltipFormatter: g, anyGuideAboveChanged: l, utilsStrings: h }), Ky({ axis: e, data: i, chartType: N });
}
async function Jy(t) {
  const { chart: e, errorStrings: i } = t, { root: a } = e, o = w(e.uid, "config");
  if (o) {
    const { x: n } = o.series[0], { rotated: s, axes: r } = o, l = z(o.series);
    await Ji({ chartType: l, axesConfig: r, errorStrings: i });
    const c = { root: a, x: n, chartType: l }, u = s === !0 ? r?.[1] : r?.[0], d = s === !0 ? r?.[0] : r?.[1], m = u?.valueFormat, g = d?.valueFormat;
    if (m !== void 0 && g !== void 0 && (Xi({
      ...c,
      axes: e.xAxes,
      valueFormat: m,
      axisRenderer: $t.new(a, {}),
      isXAxis: s !== !0,
      x: n
    }), Xi({
      ...c,
      axes: e.yAxes,
      valueFormat: g,
      axisRenderer: qi.new(a, {}),
      isXAxis: s === !0,
      x: n
    }), r?.[2] !== void 0)) {
      const h = s === !0 ? $t : qi;
      Xi({
        ...c,
        axes: s === !0 ? e.xAxes : e.yAxes,
        valueFormat: r[2]?.valueFormat,
        axisRenderer: h.new(a, { opposite: !0 }),
        isSecondValueAxis: !0,
        isXAxis: s === !0,
        x: n
      });
    }
  }
}
async function eS(t) {
  const { chart: e, chartType: i, axesConfig: a, x: o, errorStrings: n } = t, { root: s } = e, r = a?.[0], l = a?.[1];
  if (await Ji({ chartType: i, axesConfig: a, errorStrings: n }), r?.valueFormat !== void 0 && l?.valueFormat !== void 0) {
    const c = { root: s, x: o, chartType: i };
    Xi({
      ...c,
      axes: e.xAxes,
      valueFormat: r.valueFormat,
      axisRenderer: fi.new(s, {}),
      isXAxis: !0,
      x: o
    }), Xi({
      ...c,
      axes: e.yAxes,
      valueFormat: l.valueFormat,
      axisRenderer: Qm.new(s, {}),
      isXAxis: !1,
      x: o
    });
  }
}
async function tf(t) {
  const { chart: e, chartConfig: i, errorStrings: a } = t, { axes: o } = i, { x: n } = i.series[0], s = z(i.series);
  switch (e.xAxes.clear(), e.yAxes.clear(), s) {
    case b.GaugeSeries:
      e instanceof ji && await Uy({ chart: e, axesConfig: o, errorStrings: a });
      break;
    case b.HistogramSeries:
      await qy({ chart: e, axesConfig: o, x: n, errorStrings: a });
      break;
    case b.HeatSeries:
    case b.BarSeries:
    case b.ComboLineAndBarSeries:
    case b.ScatterSeries:
    case b.LineSeries:
    case b.BoxPlotSeries:
      await Jy({ chart: e, errorStrings: a });
      break;
    case b.RadarSeries:
      e instanceof ji && await eS({ chart: e, axesConfig: o, chartType: s, x: n, errorStrings: a });
      break;
  }
}
async function tS(t) {
  const {
    chart: e,
    chartConfig: i,
    axisLabelsBehaviorChanged: a,
    anyGuideAboveChanged: o,
    data: n,
    timeIntervalInfo: s,
    xAxisLabelFormatter: r,
    yAxisLabelFormatter: l,
    secondaryYAxisLabelFormatter: c,
    guideTooltipFormatter: u,
    utilsStrings: d,
    errorStrings: m
  } = t, {
    horizontalAxisLabelsBehavior: g,
    verticalAxisLabelsBehavior: h,
    axes: y,
    rotated: p
  } = i, S = z(i.series), x = w(e.uid, "isNonAggregatedChart"), C = e.xAxes.getIndex(0), v = e.yAxes.getIndex(0), F = e.xAxes.getIndex(1) ?? e.yAxes.getIndex(1);
  await Ji({ chartType: S, axesConfig: y, errorStrings: m });
  const T = y?.[p === !0 ? 1 : 0], k = y?.[p === !0 ? 0 : 1];
  [
    {
      axis: C,
      axisConfig: T,
      externalAxisLabelFormatter: p !== !0 ? r : l
    },
    {
      axis: v,
      axisConfig: k,
      externalAxisLabelFormatter: p !== !0 ? l : r
    },
    {
      axis: F,
      axisConfig: y?.[2],
      axisLabelFormatter: c,
      isSecondValueAxis: !0
    }
  ].forEach(async ($) => {
    const { axis: O, axisConfig: D, externalAxisLabelFormatter: R, isSecondValueAxis: M } = $;
    O !== void 0 && !O.isDisposed() && D !== void 0 && await $r({
      axis: O,
      data: n,
      timeIntervalInfo: s,
      axisConfig: D,
      horizontalAxisLabelsBehavior: g,
      verticalAxisLabelsBehavior: h,
      axisLabelsBehaviorChanged: a,
      anyGuideAboveChanged: o,
      isNonAggregatedChart: x,
      isSecondValueAxis: M,
      utilsStrings: d,
      chartConfig: i,
      externalAxisLabelFormatter: R,
      guideTooltipFormatter: u,
      errorStrings: m
    });
  }), bn(e, n);
}
async function af(t) {
  const { chart: e, chartConfig: i } = t, a = z(i.series);
  a === b.GaugeSeries && e instanceof ji ? await Yy(t) : a === b.HistogramSeries ? await jy(t) : await tS(t);
}
function iS(t, e) {
  const i = re(A.backgroundColor);
  e.set(
    "background",
    zs.new(t, {
      fill: i.color,
      fillOpacity: i.opacity
    })
  );
}
function of(t, e) {
  const i = re(e ?? A.backgroundColor);
  t.get("background")?.setAll({ fill: i.color, fillOpacity: i.opacity });
}
const fe = {
  SelectXY: "selectXY",
  SelectX: "selectX",
  SelectY: "selectY",
  ZoomXY: "zoomXY",
  ZoomX: "zoomX",
  ZoomY: "zoomY",
  None: "none"
};
function nf(t) {
  const { actionMode: e, cursorRange: i, isRotated: a } = t;
  let o = fe.None;
  switch (i) {
    case fs.MultiAxes:
      e === K.MultiSelectionWithCtrlKey || e === K.MultiSelection ? o = fe.SelectXY : e === K.Zoom && (o = fe.ZoomXY);
      break;
    case fs.XAxis:
      e === K.MultiSelectionWithCtrlKey || e === K.MultiSelection ? o = a === !0 ? fe.SelectY : fe.SelectX : e === K.Zoom && (o = a === !0 ? fe.ZoomY : fe.ZoomX);
      break;
    case fs.YAxis:
      e === K.MultiSelectionWithCtrlKey || e === K.MultiSelection ? o = a === !0 ? fe.SelectX : fe.SelectY : e === K.Zoom && (o = a === !0 ? fe.ZoomX : fe.ZoomY);
      break;
  }
  return o;
}
function sf(t, e) {
  const i = z(e.series);
  return t instanceof Se && i !== b.GaugeSeries;
}
function aS(t, e) {
  const i = A.cursorCrosshair.style, a = {
    type: te.SLS,
    style: e?.style ?? i.style,
    color: e?.color ?? i.color,
    width: e?.width ?? i.width
  }, o = t.get("cursor")?.lineX, n = t.get("cursor")?.lineY;
  Yt({ element: o, lineSymbol: a }), Yt({ element: n, lineSymbol: a });
}
function rf(t) {
  const { root: e, chart: i, config: a } = t;
  let o;
  if (sf(i, a)) {
    const n = i instanceof ji ? Oc : Rc;
    o = i.set("cursor", n.new(e, {})), fb(i);
  }
  return o;
}
function lf(t) {
  const { root: e, chart: i, cursorCrosshair: a, config: o } = t;
  if (sf(i, o)) {
    const n = i.get("cursor") ?? rf({ root: e, chart: i, config: o });
    n && (aS(i, a?.style), n.lineX.set(
      "visible",
      a?.verticalLineVisible ?? A.cursorCrosshair.verticalLineVisible
    ), n.lineY.set(
      "visible",
      a?.horizontalLineVisible ?? A.cursorCrosshair.horizontalLineVisible
    ));
  }
}
function oS(t) {
  const { chart: e, enabled: i } = t, a = i ? "pointer" : "default";
  e instanceof Ba && e.series.each((o) => {
    switch (!0) {
      case o instanceof Ee:
        o.columns.template.set("cursorOverStyle", a);
        break;
      case o instanceof ge:
        const n = he(o.uid, "bulletTemplate");
        n !== void 0 && !Mi(o) && n.set("cursorOverStyle", a);
        break;
      case o instanceof ht:
        o.slices.template.setAll({ cursorOverStyle: a });
        break;
    }
  });
}
function nS(t) {
  const { chart: e, actionMode: i, cursorRange: a } = t, o = w(e.uid, "isRotated"), n = w(e.uid, "config"), s = z(n?.series), r = s === b.ScatterSeries, l = (s === b.LineSeries || s === b.RadarSeries) && Lt(n?.axes?.[0]?.valueFormat), c = (s === b.LineSeries || s === b.RadarSeries) && Oo(n?.axes?.[0]?.valueFormat), u = (s === b.LineSeries || s === b.RadarSeries) && mi(n?.axes?.[0]?.valueFormat);
  let d, m = !1;
  const g = i ?? w(e.uid, "actionMode") ?? A.actionMode;
  if (w(e.uid, "filterBySelection") === !0)
    d = fe.None, m = !1;
  else if (a !== void 0)
    d = nf({ actionMode: g, cursorRange: a, isRotated: o });
  else
    switch (g) {
      case K.Zoom:
        r || l || u ? d = fe.ZoomXY : d = o === !0 ? fe.ZoomY : fe.ZoomX, m = !1;
        break;
      case K.MultiSelection:
      case K.MultiSelectionWithCtrlKey:
        c ? d = o === !0 ? fe.SelectY : fe.SelectX : d = fe.SelectXY, m = !0;
        break;
      case K.MonoSelection:
        d = fe.None, m = !0;
        break;
      case K.None:
        d = fe.None, m = !1;
        break;
    }
  e instanceof Se && e.get("cursor") !== void 0 && d !== void 0 && e.get("cursor")?.set("behavior", d), oS({ chart: e, enabled: m });
}
function sS(t, e) {
  e !== void 0 && (e.width !== void 0 && t.set("width", Il(e.width)), e.height !== void 0 && t.set("height", Il(e.height)), e.paddingTop !== void 0 && t.set("paddingTop", e.paddingTop), e.paddingBottom !== void 0 && t.set("paddingBottom", e.paddingBottom));
}
function ws(t) {
  const { root: e, defaults: i, parent: a, id: o, index: n } = t, s = Gi.new(e, {});
  return sS(s, i), a !== void 0 && a.children.insertIndex(n ?? a.children.length, s), o !== void 0 && s.set("id", o), s;
}
function $s(t, e) {
  e ? t.hide() : t.show();
}
function rS(t, e) {
  const i = ws({
    root: t,
    defaults: A.headerContainer,
    parent: e,
    id: Xt(Gn, e.uid),
    index: 0
  }), a = ws({
    root: t,
    defaults: A.headerContainer,
    parent: e,
    id: Xt(Sr, e.uid),
    index: 1
  }), o = Co({
    root: t,
    parent: i,
    defaults: A.titleLabel,
    id: Xt(iu, i.uid)
  }), n = Co({
    root: t,
    parent: a,
    defaults: A.subtitleLabel,
    id: Xt(au, a.uid)
  });
  vo({
    chart: e,
    label: o,
    labelType: ae.ChartTitle
  }), vo({
    chart: e,
    label: n,
    labelType: ae.ChartSubTitle
  });
}
function cf(t, e) {
  const { title: i, subtitle: a } = e ?? {}, o = Ce({ childId: Gn, parent: t });
  if (o !== void 0) {
    const s = Ce({ childId: iu, parent: o });
    s !== void 0 && (Pt({
      label: s,
      labelConfig: i,
      defaults: A.titleLabel
    }), vi({
      chart: t,
      label: s,
      labelType: ae.ChartTitle
    }), $s(o, s.get("disabled") === !0 || (i?.content.text ?? "") === ""));
  }
  const n = Ce({ childId: Sr, parent: t });
  if (n !== void 0) {
    const s = Ce({ childId: au, parent: n });
    s !== void 0 && (Pt({
      label: s,
      labelConfig: a,
      defaults: A.subtitleLabel
    }), vi({
      chart: t,
      label: s,
      labelType: ae.ChartSubTitle
    }), $s(
      n,
      s.get("disabled") === !0 || (a?.content.text ?? "") === ""
    ));
  }
}
function lS(t) {
  const { root: e } = t, i = ws({
    root: e,
    defaults: A.footerContainer,
    parent: t,
    id: Xt(Xn, t.uid)
  }), a = Co({
    root: e,
    parent: i,
    id: Xt(ou, i.uid)
  });
  vo({
    chart: t,
    label: a,
    labelType: ae.ChartFooter
  });
}
function df(t, e) {
  const i = Ce({ childId: Xn, parent: t });
  if (i !== void 0) {
    const a = Ce({ childId: ou, parent: i });
    a !== void 0 && (Pt({
      label: a,
      labelConfig: e,
      defaults: A.footer
    }), vi({
      chart: t,
      label: a,
      labelType: ae.ChartFooter
    }), $s(i, a.get("disabled") || (e?.content.text ?? "") === ""));
  }
}
function uf(t) {
  const e = t?.curtainColor ?? A.backgroundColor, i = `rgba(${e[0]}, ${e[1]}, ${e[2]}, 1)`, a = Zg({ r: e[0], g: e[1], b: e[2] }) ? A.darkTextColor : A.lightTextColor, o = `rgba(${a[0]}, ${a[1]}, ${a[2]}, ${a[3] / 255})`;
  return { backgroundCSSColor: i, textCSSColor: o };
}
function cS(t) {
  const { root: e, parent: i, curtainColor: a } = t, o = re(a ?? A.backgroundColor), n = Gi.new(e, {
    id: Xt(nu, i.uid),
    width: Te,
    height: Te,
    interactive: !0,
    // avoids elements tooltips to bubble up through the curtain
    layer: 1e3,
    // assigns a layer to the container: See issue: https://devtopia.esri.com/WebGIS/arcgis-web-components/issues/4195
    background: zs.new(e, {
      fill: o.color,
      fillOpacity: o.opacity
    })
  });
  return i.children.push(n), n;
}
function dS(t) {
  const { root: e, parent: i, spinnerColor: a } = t, o = re(a ?? A.loaderSpinnerColor), n = ui.new(e, {
    id: Xt(su, i.uid),
    centerX: Ae,
    centerY: Ae,
    x: Ae,
    y: Ae,
    svgPath: "M2.2 16A13.81 13.81 0 0 1 14 2.362v1.01a12.8 12.8 0 1 0 4 0v-1.01A13.792 13.792 0 1 1 2.2 16z",
    stroke: o.color,
    strokeWidth: 2
  });
  return i.children.push(n), n;
}
function uS(t) {
  return t.animate({
    from: 0,
    to: 360,
    key: "rotation",
    loops: Number.MAX_SAFE_INTEGER,
    duration: A.loaderRotationSpeed
  });
}
function fS(t, e) {
  const i = cS({
    root: t,
    parent: t.container,
    curtainColor: e?.loaderColors?.curtainColor
  }), a = dS({
    root: t,
    parent: i,
    spinnerColor: e?.loaderColors?.spinnerColor
  }), o = uS(a);
  return { loaderSpinner: a, loaderContainer: i, spinnerAnimation: o };
}
function mS(t) {
  const { root: e, chart: i, options: a } = t, { loaderContainer: o, spinnerAnimation: n } = fS(e, a);
  function s() {
    n.stop(), o !== void 0 && (Re(o, !1), i instanceof Se && i.zoomOutButton.set("disabled", !1));
  }
  s();
  function r(l) {
    l && (n.play(), o !== void 0 && (Re(o), i instanceof Se && i.zoomOutButton.set("disabled", !0)));
  }
  return { hideLoader: s, showLoader: r };
}
function gS(t) {
  const { chart: e, updateOptions: i, chartModal: a } = t, { root: o } = e, n = Ce({ childId: nu, parent: o.container });
  if (n) {
    const s = re(
      i?.loaderColors?.curtainColor ?? A.backgroundColor
    );
    n.get("background")?.setAll({ fill: s.color, fillOpacity: s.opacity });
    const r = re(
      i?.loaderColors?.spinnerColor ?? A.loaderSpinnerColor
    );
    Ce({ childId: su, parent: n })?.set("stroke", r.color);
  }
  if (a) {
    const s = i?.loaderColors, { backgroundCSSColor: r, textCSSColor: l } = uf(s);
    a.getPrivate("content").style.backgroundColor = r, a.getPrivate("wrapper").style.backgroundColor = r, a.getPrivate("content").style.color = l;
  }
}
function hS(t, e) {
  t.events.once(le.FrameEnded, () => {
    Ua(t.dom), e();
  });
}
function ff(t) {
  if (!(t instanceof ji) && t instanceof Se) {
    const { root: e } = t, i = Fs.new(e, {
      orientation: "horizontal",
      visible: !1,
      marginTop: 0
    }), a = Fs.new(e, {
      orientation: "vertical",
      visible: !1
    });
    t.setAll({ scrollbarX: i, scrollbarY: a });
  }
}
function pS(t, e) {
  if (e !== void 0) {
    const i = re(e), a = e[3] / 255, o = a / 2;
    [
      { element: t.get("background"), specificOpacity: o },
      { element: t.startGrip.get("background") },
      { element: t.endGrip.get("background") },
      { element: t.thumb }
    ].forEach((n) => {
      const { element: s, specificOpacity: r } = n;
      s !== void 0 && s.setAll({ fill: i.color, fillOpacity: r ?? a });
    }), [
      { element: t.get("background"), stateName: "default", specificOpacity: o },
      {
        element: t.startGrip.get("background"),
        stateName: "default"
      },
      { element: t.startGrip.get("background"), stateName: "hover" },
      { element: t.startGrip.get("background"), stateName: "down" },
      { element: t.endGrip.get("background"), stateName: "default" },
      { element: t.endGrip.get("background"), stateName: "hover" },
      { element: t.endGrip.get("background"), stateName: "down" },
      { element: t.thumb, stateName: "default" },
      { element: t.thumb, stateName: "hover" },
      { element: t.thumb, stateName: "down" }
    ].forEach((n) => {
      const { element: s, stateName: r, specificOpacity: l } = n;
      (s?.states.lookup(r) ?? s?.states.create(r, {}))?.setAll({ fill: i.color, fillOpacity: l ?? a });
    });
  }
}
function bS(t, e) {
  typeof e == "number" && Number.isFinite(e) && (t.get("orientation") === "horizontal" ? t.setAll({ height: e, minHeight: e }) : t.setAll({ width: e, minWidth: e }));
}
function yS(t, e) {
  if (typeof e == "number" && Number.isFinite(e)) {
    const a = e / 30;
    t.startGrip.set("scale", a), t.endGrip.set("scale", a);
  }
}
function Kl(t, e) {
  typeof e == "number" && Number.isFinite(e) && (t.get("orientation") === "horizontal" ? t.set("marginBottom", e) : t.set("marginLeft", e), t.markDirtyBounds());
}
function mf(t) {
  const { chart: e, scrollbarXConfig: i, scrollbarYConfig: a } = t;
  if (!(e instanceof ji) && e instanceof Se) {
    const o = w(e.uid, "isRotated");
    (e.get("scrollbarX") === void 0 || e.get("scrollbarY") === void 0) && ff(e);
    const n = e.get("scrollbarX"), s = e.get("scrollbarY");
    [n, s].forEach((r) => {
      if (r !== void 0) {
        const l = r.get("orientation") === "horizontal" && o !== !0 || r.get("orientation") === "vertical" && o === !0 ? i : a, c = l?.visible !== !0;
        if (Re(r, !c), l !== void 0 && !c) {
          const { width: u, color: d, gripSize: m, margin: g } = l;
          Kl(r, g ?? u ?? A.scrollbarPadding), pS(r, d), yS(r, m), bS(r, u);
        } else
          Kl(r, 0);
      }
    });
  }
}
function SS(t) {
  Pu(t);
}
function Ql(t) {
  return t.get("legendDataItem")?.get("marker").children.getIndex(0);
}
function xS(t, e) {
  t.columns.each((i) => {
    (i.dataItem?.dataContext)[e] === 0 && i.set("strokeOpacity", 0);
  });
}
function CS(t) {
  const { root: e, chartConfig: i, seriesConfig: a, xAxis: o, yAxis: n, options: s } = t, { id: r, name: l } = a, { xField: c, yField: u, xAxisField: d, yAxisField: m } = Qa(i, a), g = xg(i), h = Ee.new(e, {
    id: r,
    name: l,
    stacked: g,
    xAxis: o,
    yAxis: n,
    [d]: c,
    [m]: u,
    maskBullets: !1
  });
  _t(h.columns.template, s?.selectionTheme);
  const y = Wa.new({});
  return Pe(h.uid, { bulletTemplate: y }), Zt(h.columns.template, h), h.bullets.push((p) => {
    const S = ui.new(p, {}, y);
    return Ti.new(p, {
      sprite: S
    });
  }), h.columns.template.set("width", gt(100)), kr(h), vu(h), mu(h), eo(h, i), h.appear(), h;
}
function vS(t) {
  const { series: e, seriesConfig: i, seriesIndex: a, numberOfSeries: o, chartSubType: n, colorMatch: s, rendererType: r } = t, l = e.root, c = No(e), u = /* @__PURE__ */ new Set();
  let d, m;
  const g = i.fillSymbol, h = {
    root: l,
    seriesConfig: i,
    seriesIndex: a,
    seriesSymbol: g,
    isChartFillSymbol: !0
  };
  let y = {};
  const p = zc(a);
  if (e.columns.length === 0 ? y = mt({
    root: l,
    seriesIndex: a,
    colorMatch: s,
    seriesSymbol: g ?? p,
    element: ui.new(l, {}),
    isChartFillSymbol: !0
  }) : e.columns.each((S) => {
    const x = S.dataItem?.dataContext;
    if (Number.isFinite(x?.[c])) {
      m = Ft({
        dataItem: x,
        seriesConfig: i,
        chartSubType: n,
        colorMatch: s,
        rendererType: r
      });
      const v = (x[A.xAxisField] === A.nullValue && i.nullCategory?.symbol !== void 0 ? i.nullCategory.symbol : g) ?? p;
      y = mt({
        ...h,
        seriesSymbol: v,
        element: S,
        colorMatch: s,
        rendererSymbol: m
      }), co(S, y.stylingInfo), u.add(JSON.stringify(y.symbolWithColorInfo));
    }
  }), o > 1) {
    const S = Ql(e);
    if (S !== void 0)
      mt({
        ...h,
        seriesSymbol: g ?? p,
        element: S,
        colorMatch: s,
        rendererSymbol: m
      }), co(S, y.stylingInfo);
    else if (e.chart instanceof Se) {
      const x = e.chart.children.values.find((C) => C instanceof Fn);
      x !== void 0 && x.events.once(le.BoundsChanged, () => {
        co(Ql(e), y.stylingInfo);
      });
    }
    mt({
      ...h,
      seriesSymbol: y.symbolWithColorInfo ?? g ?? p,
      element: e,
      colorMatch: s,
      rendererSymbol: m,
      keepCurrentVisibility: !0
      // we prevent the series visibility to be reset, for instance when the series has been hidden from the legend
    }), mt({
      ...h,
      seriesSymbol: y.symbolWithColorInfo ?? g ?? p,
      element: e.columns.template,
      colorMatch: s,
      rendererSymbol: m
    });
  }
  return u.size <= 1 && (d = y.symbolWithColorInfo ?? g), xS(e, c), d;
}
function LS(t) {
  const { series: e, seriesSymbolMapForEvent: i, seriesIndexMapper: a, seriesIndex: o, colorMatch: n, rendererType: s } = t, r = t.seriesConfig, l = e.chart;
  if (l !== void 0) {
    const c = w(l.uid, "config"), u = c?.series.length ?? 0, d = U(c?.series), m = vS({
      series: e,
      seriesConfig: r,
      seriesIndex: o,
      numberOfSeries: u,
      chartSubType: d,
      colorMatch: n,
      rendererType: s
    });
    i.set(a?.get(r.id) ?? o, m), i.size === u && Bt({
      data: i,
      htmlContainer: e.root.dom,
      chartId: l.get("id"),
      colorMatchApplied: to(l)
    });
  }
}
function FS(t) {
  const {
    columnSeries: e,
    data: i,
    seriesIndex: a,
    chartConfig: o,
    dataWasUpdated: n,
    seriesWereReinitialized: s,
    rotationChanged: r,
    timeZoneChanged: l,
    sortChanged: c,
    loaderHandle: u
  } = t, d = o.series[a];
  if (i && d?.type === b.BarSeries && (r === !0 || n === !0 || c === !0 || l || s === !0)) {
    const { xField: m, yField: g, xAxisField: h, yAxisField: y } = Qa(o, d);
    e.setAll({
      [h]: m,
      [y]: g
    }), e.events.once(le.DataValidated, () => {
      u.hideLoader();
    }), e.data.setAll(i.dataItems);
  }
}
function AS(t) {
  const {
    series: e,
    data: i,
    chartConfig: a,
    options: o,
    seriesIndex: n,
    dataWasUpdated: s,
    rotationChanged: r,
    timeZoneChanged: l,
    queryObject: c,
    utilsStrings: u,
    seriesWereReinitialized: d,
    autoInverseDataLabelTextColor: m,
    subtypeInfo: g,
    fieldList: h,
    sortChanged: y,
    loaderHandle: p
  } = t, S = a.series[n], x = a.rotated, C = a.axes;
  let v;
  C?.[1] && (v = C[1]), e.set("id", S.id), Ar({
    series: e,
    chartConfig: a,
    isRotated: x
  }), SS({
    seriesType: b.BarSeries,
    series: e,
    seriesConfig: S,
    isRotated: x,
    dataLabelsConfig: S.dataLabels,
    autoInverseDataLabelTextColor: m,
    yAxisValueFormat: v?.valueFormat,
    externalDataLabelFormatter: o?.dataLabelFormatter
  }), FS({
    columnSeries: e,
    data: i,
    seriesIndex: n,
    chartConfig: a,
    dataWasUpdated: s,
    timeZoneChanged: l,
    seriesWereReinitialized: d,
    rotationChanged: r,
    sortChanged: y,
    loaderHandle: p
  }), vr({
    series: e,
    seriesConfig: S,
    fieldList: h,
    queryObject: c,
    seriesIndex: n,
    tooltipFormatter: o?.tooltipFormatter,
    utilsStrings: u
  }), Ni(t) && Pi({
    // TODO: Remove the type assertion and correct the typings
    styleCallback: LS,
    callbackProps: t,
    series: e,
    seriesConfig: S
  }), Tr({
    chartConfig: a,
    series: e,
    seriesIndex: n,
    subtypeInfo: g,
    fieldList: h
  });
}
function TS(t) {
  const { chartConfig: e, seriesConfig: i } = t, a = jt(e), o = e.showOutliers, n = e.standardizeValues, s = qe(e), { y: r } = i, l = ar(e), c = U(l.series), u = s ? void 0 : i?.query?.where, d = {
    y: c === P.BoxPlotMultiFieldsAndCategory && typeof r == "string" ? r : void 0,
    chartSubType: c,
    splitBy: u,
    showOutliers: o,
    standardizeValues: po(c) ? n : !1
  }, m = _n({
    chartConfig: e,
    seriesConfig: i,
    key: J.ThirdQuartile
  });
  return {
    properties: {
      ...m.properties,
      low: be({
        ...d,
        key: J.Min
      }),
      open: be({
        ...d,
        key: J.FirstQuartile
      }),
      high: be({
        ...d,
        key: J.Max
      })
    },
    dataFields: {
      ...m.dataFields,
      low: a ? "lowValueXField" : "lowValueYField",
      open: a ? "openValueXField" : "openValueYField",
      high: a ? "highValueXField" : "highValueYField"
    }
  };
}
function kS(t) {
  const {
    candleStickSeries: e,
    data: i,
    rotationChanged: a,
    sortChanged: o,
    dataWasUpdated: n,
    seriesWereReinitialized: s,
    loaderHandle: r
  } = t;
  (a === !0 || n === !0 || o === !0 || s === !0) && (e.events.once(le.DataValidated, () => {
    r.hideLoader();
  }), e.data.setAll(i?.dataItems ?? []));
}
function IS(t) {
  const { candleStickSeries: e, seriesConfig: i, seriesIndex: a, chartSubType: o, colorMatch: n, showMean: s, rendererType: r } = t, { root: l } = e, c = i.fillSymbol ?? Js(a);
  let u = {};
  const d = {
    root: l,
    seriesConfig: i,
    seriesIndex: a,
    colorMatch: n,
    isChartFillSymbol: !0
  };
  e.columns.length === 0 ? u = mt({
    ...d,
    seriesSymbol: c,
    element: ui.new(l, {})
  }) : e.columns.each((m) => {
    u = mt({
      ...d,
      seriesSymbol: c,
      element: m,
      rendererSymbol: s ? void 0 : Ft({
        dataItem: m.dataItem?.dataContext,
        seriesConfig: i,
        chartSubType: o,
        colorMatch: n,
        rendererType: r
      })
    });
  }), mt({
    ...d,
    seriesSymbol: u?.symbolWithColorInfo ?? c,
    element: e.columns.template,
    colorMatch: n
  });
}
function wS(t) {
  const { candleStickSeries: e, seriesConfig: i } = t;
  Ja(e, i.name), kS(t), Ni(t) && Pi({
    // TODO: Remove the type assertion and correct the typings
    styleCallback: IS,
    callbackProps: t,
    series: e,
    seriesConfig: i
  });
}
function $S(t) {
  const { root: e, xAxis: i, yAxis: a, chartConfig: o, seriesIndex: n, options: s } = t, r = o.series[n];
  let l;
  if (r.type === b.BoxPlotSeries) {
    const c = TS({ chartConfig: o, seriesConfig: r });
    l = ua.new(e, {
      id: r.id,
      xAxis: i,
      yAxis: a,
      [c.dataFields.low]: c.properties.low,
      [c.dataFields.open]: c.properties.open,
      [c.dataFields.high]: c.properties.high,
      [c.dataFields.value]: c.properties.value,
      [c.dataFields.category]: c.properties.category
    }), l.columns.template.setAll({ themeTags: [], width: gt(80) }), _t(l.columns.template, s?.selectionTheme), Zt(l.columns.template, l);
  }
  return l;
}
function DS(t) {
  const { chartConfig: e, seriesConfig: i } = t, a = U(e.series), { showOutliers: o, standardizeValues: n } = e, { y: s } = i, r = i?.query?.where, l = ar(e), c = _n({
    chartConfig: l,
    seriesConfig: i,
    key: J.Average
  }), u = be({
    y: a === P.BoxPlotMultiFieldsAndCategory && typeof s == "string" ? s : void 0,
    chartSubType: a,
    splitBy: r,
    showOutliers: o,
    standardizeValues: po(a) ? n : !1,
    key: J.Average
  });
  return c.properties.value = u, c;
}
function OS(t) {
  const { meanLineSeries: e, data: i, rotationChanged: a, sortChanged: o, dataWasUpdated: n, seriesWereReinitialized: s } = t;
  (a === !0 || n === !0 || o === !0 || s === !0) && e.data.setAll(i?.meanLines ?? []);
}
function RS(t) {
  const { meanLineSeries: e, seriesConfig: i, data: a, dataWasUpdated: o, sortChanged: n, rotationChanged: s, seriesWereReinitialized: r } = t;
  Ja(e, i?.name), OS({
    meanLineSeries: e,
    data: a,
    dataWasUpdated: o,
    sortChanged: n,
    rotationChanged: s,
    seriesWereReinitialized: r
  });
}
function BS(t) {
  const { root: e, xAxis: i, yAxis: a, chartConfig: o, seriesIndex: n, options: s } = t, r = o.series[n];
  let l;
  if (r.type === b.LineSeries) {
    const c = DS({ chartConfig: o, seriesConfig: r });
    l = ge.new(e, {
      id: r.id,
      xAxis: i,
      yAxis: a,
      [c.dataFields.value]: c.properties.value,
      [c.dataFields.category]: c.properties.category
    }), l.appear();
    const u = Wa.new({});
    Pe(l.uid, { bulletTemplate: u }), l.bullets.push((d) => {
      const m = ui.new(
        d,
        {
          tooltipText: " ",
          // necessary to trigger the adapter
          focusable: !0
          // necessary for accessibility on bullets
        },
        u
      ), g = Ti.new(d, {
        sprite: m
      });
      return _t(m, s?.selectionTheme), l && Zt(m, l), g;
    }), Pe(l.uid, { isBoxPlotMeanLineSeries: !0 });
  }
  return l;
}
function MS(t, e) {
  return t.get("id") === `${e}_${me.Outliers}`;
}
function NS(t) {
  const { chartConfig: e, seriesConfig: i } = t;
  return _n({
    chartConfig: e,
    seriesConfig: i,
    key: J.Outlier
  });
}
function PS(t) {
  const { outlierSeries: e, data: i, rotationChanged: a, sortChanged: o, dataWasUpdated: n, seriesWereReinitialized: s } = t;
  (a === !0 || n === !0 || o === !0 || s === !0) && e.data.setAll(i?.outliers ?? []);
}
function VS(t, e) {
  return (t ?? A.boxPlot.boxPlotOutliersVisibility) && e !== !1;
}
function ES(t) {
  const { outlierSeries: e, chartSubType: i, seriesConfig: a, colorMatch: o, showOutliers: n } = t;
  if (he(e.uid, "bulletTemplate") && a.type === b.BoxPlotSeries) {
    const l = a.fillSymbol, c = {
      type: te.SMS,
      style: xt.Circle,
      color: l?.color,
      size: A.boxPlot.boxPlotOutliersSize
    };
    e.dataItems.forEach((u) => {
      const d = u.bullets?.[0]?.get("sprite");
      if (d !== void 0) {
        const m = Ft({
          dataItem: u.dataContext,
          seriesConfig: a,
          chartSubType: i,
          colorMatch: o
        });
        mt({
          root: e.root,
          seriesSymbol: c,
          element: d,
          colorMatch: o,
          rendererSymbol: m
        });
      }
    });
  }
  const r = VS(n, a.visible);
  Re(e, r);
}
function zS(t) {
  const { outlierSeries: e, data: i, seriesConfig: a, sortChanged: o, dataWasUpdated: n, rotationChanged: s, seriesWereReinitialized: r } = t;
  e && a.type === b.BoxPlotSeries && (PS({
    outlierSeries: e,
    data: i,
    rotationChanged: s,
    sortChanged: o,
    dataWasUpdated: n,
    seriesWereReinitialized: r
  }), Ni(t) && Pi({
    // TODO: Remove the type assertion and correct the typings
    styleCallback: ES,
    callbackProps: t,
    series: e,
    seriesConfig: a
  }));
}
function WS(t) {
  const { root: e, xAxis: i, yAxis: a, chartConfig: o, seriesIndex: n, options: s } = t, r = o.series[n];
  let l;
  if (r.type === b.BoxPlotSeries) {
    const c = NS({ chartConfig: o, seriesConfig: r });
    l = ge.new(e, {
      id: `${r.id}_${me.Outliers}`,
      xAxis: i,
      yAxis: a,
      [c.dataFields.value]: c.properties.value,
      [c.dataFields.category]: c.properties.category
    }), l.strokes.template.set("forceHidden", !0);
    const u = Wa.new({});
    Pe(l.uid, { bulletTemplate: u }), l.bullets.push((d) => {
      const m = ui.new(
        d,
        {
          tooltipText: " ",
          // necessary to trigger the adapter
          focusable: !0
          // necessary for accessibility on bullets
        },
        u
      ), g = Ti.new(d, {
        sprite: m
      });
      return _t(m, s?.selectionTheme), l && Zt(m, l), jS({ outlierSeries: l, bullet: g, seriesConfigId: r.id }), g;
    }), Pe(l.uid, { isBoxPlotOutliersSeries: !0 }), l.appear();
  }
  return l;
}
function gf(t) {
  const { data: e, colorMatch: i, chartSubType: a, rendererType: o } = t;
  return e !== void 0 && i && o !== void 0 && (a === P.BoxPlotMultiFields && (o === hs.UniqueValue || o === hs.PieChart) || a === P.BoxPlotMonoFieldAndCategory && o === hs.UniqueValue) && e.some(
    (n) => Object.keys(n).some((s) => s.includes(G.rendererSymbolField))
  );
}
function HS(t) {
  const { chartConfig: e, seriesConfig: i, type: a } = t;
  let o = "";
  switch (a) {
    case me.Top:
      o = J.Max;
      break;
    case me.Median:
      o = J.Median;
      break;
    case me.Bottom:
      o = J.Min;
      break;
  }
  return _n({
    chartConfig: e,
    seriesConfig: i,
    key: o
  });
}
function GS(t) {
  const { stepLineSeries: e, data: i, rotationChanged: a, sortChanged: o, dataWasUpdated: n, seriesWereReinitialized: s } = t;
  (a === !0 || n === !0 || o === !0 || s === !0) && e.data.setAll(i?.dataItems ?? []);
}
function XS(t) {
  const { stepLineSeries: e, data: i, seriesConfig: a, seriesIndex: o, colorMatch: n, chartSubType: s, rendererType: r } = t;
  if (a.type === b.BoxPlotSeries) {
    const { root: l } = e, c = gf({
      data: i.dataItems,
      colorMatch: n,
      chartSubType: s,
      rendererType: r
    }), u = (a.fillSymbol ?? Js(o)).color, d = {
      type: te.SLS,
      width: A.boxPlot.boxPlotLineWidth,
      color: c ? A.boxPlot.boxPlotWhiskersColor : u
    };
    mt({
      root: l,
      seriesIndex: o,
      seriesSymbol: d,
      element: e,
      colorMatch: n
    });
  }
}
function YS(t) {
  const { stepLineSeries: e, data: i, seriesConfig: a, rotationChanged: o, sortChanged: n, dataWasUpdated: s, seriesWereReinitialized: r } = t, l = a.visible !== !1;
  e !== void 0 && a.type === b.BoxPlotSeries && (Re(e, l), Ni(t) && Pi({
    // TODO: Remove the type assertion and correct the typings
    styleCallback: XS,
    callbackProps: t,
    series: e,
    seriesConfig: a
  }), GS({
    stepLineSeries: e,
    data: i,
    rotationChanged: o,
    sortChanged: n,
    dataWasUpdated: s,
    seriesWereReinitialized: r
  }));
}
function bs(t) {
  const { root: e, xAxis: i, yAxis: a, chartConfig: o, seriesIndex: n, type: s, options: r } = t, l = o.series[n];
  let c;
  if (l.type === b.BoxPlotSeries) {
    const u = HS({ chartConfig: o, seriesConfig: l, type: s });
    c = An.new(e, {
      id: `${l.id}_${s}`,
      xAxis: i,
      yAxis: a,
      noRisers: !0,
      [u.dataFields.value]: u.properties.value,
      [u.dataFields.category]: u.properties.category
    }), _t(c.strokes.template, r?.selectionTheme), Zt(c.strokes.template, c);
  }
  return c;
}
function _n(t) {
  const { chartConfig: e, seriesConfig: i, key: a } = t, o = jt(e), n = e.showOutliers, s = e.standardizeValues, r = qe(e), l = U(e.series), { x: c, y: u } = i, d = r ? void 0 : i?.query?.where, m = {
    y: l === P.BoxPlotMultiFieldsAndCategory && typeof u == "string" ? u : void 0,
    chartSubType: l,
    splitBy: d,
    showOutliers: n,
    standardizeValues: po(l) ? s : !1
  }, g = l === P.BoxPlotMonoField || l === P.BoxPlotMultiFields || l === P.BoxPlotMonoFieldAndSplitBy || l === P.BoxPlotMultiFieldsAndSplitBy ? Ks : c;
  return {
    dataFields: {
      value: o ? "valueXField" : "valueYField",
      category: o ? "categoryYField" : "categoryXField"
    },
    properties: {
      value: be({
        key: a,
        ...m
      }),
      category: g
    }
  };
}
function US(t, e) {
  return t.series.values.find((i) => MS(i, e));
}
function hf(t, e) {
  const i = t.series.values.find(
    (n) => n.get("id") === `${e}_${me.Top}`
  ), a = t.series.values.find(
    (n) => n.get("id") === `${e}_${me.Median}`
  ), o = t.series.values.find(
    (n) => n.get("id") === `${e}_${me.Bottom}`
  );
  return { topStepLineSeries: i, medianStepLineSeries: a, bottomStepLineSeries: o };
}
function pf(t) {
  return t !== P.BoxPlotMonoField && t !== P.BoxPlotMultiFields && t !== P.BoxPlotMonoFieldAndCategory;
}
function bf(t) {
  const { chart: e, candleSeriesIndex: i, numberOfCandleStickSeries: a } = t;
  let o, n;
  const s = w(e.uid, "config");
  if (s) {
    const r = jt(s), l = qe(s), c = r ? e.yAxes.getIndex(0)?.get("renderer") : e.xAxes.getIndex(0)?.get("renderer"), u = c?.get("cellStartLocation"), d = c?.get("cellEndLocation");
    if (u && d) {
      const m = u / (l ? 1 : s.series.length);
      o = u + i / a * (d - u) + m, n = u + (i + 1) / a * (d - u) - m;
    }
  }
  return { startLocation: o, endLocation: n };
}
function jS(t) {
  const { outlierSeries: e, bullet: i, seriesConfigId: a } = t;
  if (e) {
    const { chart: o } = e;
    if (o) {
      const n = w(o.uid, "config");
      if (n) {
        const s = U(n.series);
        if (pf(s)) {
          const r = o.series.values.filter((c) => c instanceof ua), l = r?.findIndex((c) => c.get("id") === a);
          if (l && l !== -1 && r[l]) {
            const { startLocation: u, endLocation: d } = bf({
              chart: o,
              candleSeriesIndex: l,
              numberOfCandleStickSeries: r.length
            });
            u !== void 0 && d !== void 0 && i.set("locationX", (u + d) / 2);
          }
        }
      }
    }
  }
}
function qS(t) {
  const e = w(t.uid, "config");
  if (e) {
    const i = U(e.series), a = e.series.length, n = jt(e) ? t.yAxes.getIndex(0)?.get("renderer") : t.xAxes.getIndex(0)?.get("renderer"), s = n?.get("cellStartLocation"), r = n?.get("cellEndLocation");
    if (s && r) {
      const l = t.series.values.filter((c) => c instanceof ua);
      l.forEach((c, u) => {
        const { topStepLineSeries: d, medianStepLineSeries: m, bottomStepLineSeries: g } = hf(
          t,
          c.get("id") ?? ""
        );
        if (pf(i)) {
          const { startLocation: h, endLocation: y } = bf({
            chart: t,
            candleSeriesIndex: u,
            numberOfCandleStickSeries: l.length
          });
          [d, m, g].forEach((p) => {
            p !== void 0 && (p.set("stepWidth", gt(60 / a)), h && y && p.set("locationX", (h + y) / 2));
          });
        } else
          [d, m, g].forEach((h) => {
            h !== void 0 && h.setAll({
              stepWidth: gt(60 / a)
            });
          });
      });
    }
  }
}
function _S(t) {
  const { chartConfig: e, seriesIndex: i } = t, a = e.series[i], o = z([a]), n = [];
  if (o === b.BoxPlotSeries)
    [
      $S(t),
      bs({
        ...t,
        type: me.Top
      }),
      bs({
        ...t,
        type: me.Median
      }),
      bs({
        ...t,
        type: me.Bottom
      }),
      WS(t)
    ].forEach((s) => {
      s && n.push(s);
    });
  else if (o === b.LineSeries) {
    const s = BS(t);
    s && n.push(s);
  }
  return n;
}
function ZS(t) {
  const { chart: e, chartConfig: i, series: a, seriesConfig: o } = t;
  if (e && i)
    if (qS(e), a instanceof ua && o.type === b.BoxPlotSeries) {
      a.set("id", o.id);
      const n = a.get("id") ?? "";
      wS({ ...t, series: a, seriesConfig: o, candleStickSeries: a });
      const { topStepLineSeries: s, medianStepLineSeries: r, bottomStepLineSeries: l } = hf(
        e,
        n
      ), c = [
        me.Top,
        me.Median,
        me.Bottom
      ];
      [s, r, l].forEach((d, m) => {
        d && (d.set("id", `${o.id}_${c[m]}`), YS({ ...t, stepLineSeries: d }));
      });
      const u = US(e, n);
      u && (u.set("id", `${o.id}_${me.Outliers}`), zS({ ...t, outlierSeries: u }));
    } else a instanceof ge && o.type === b.LineSeries && RS({ ...t, meanLineSeries: a });
}
function yf(t) {
  const { chart: e, chartData: i, chartConfig: a } = t;
  if (e && i?.length > 1 && a?.showMean === !0) {
    const o = a.series[0].x ?? A.originalCategoryValue, n = w(e.uid, "boxPlotMeanLinesData");
    if (n !== void 0 && n.length > 1) {
      const s = [];
      for (const r of i) {
        const l = n.find(
          (c) => o in c && c[o] === r[o]
        );
        l !== void 0 && s.push(l);
      }
      de(e.uid, { boxPlotMeanLinesData: s });
    }
  }
}
function KS(t) {
  const { dataLabel: e, series: i, externalDataLabelFormatter: a } = t;
  e.adapters.remove("text"), e.adapters.remove("html");
  const o = a !== void 0 ? "html" : "text";
  e.adapters.add(o, (n, s) => {
    let r = n ?? "";
    const l = s.dataItem, c = he(
      i.uid,
      "heatChartDataLabelFormatter"
    ), u = w(i.chart?.uid ?? NaN, "config");
    if (c !== void 0 && l) {
      const d = l.get("value"), m = l.get("categoryX"), g = l.get("categoryY");
      d === null ? r = u?.series[0].emptyCells?.text ?? A.heatChart.emptyCells?.text ?? "" : d !== void 0 && (r = c(d, m, g));
    }
    return o === "html" ? He(r) : r;
  });
}
function QS(t) {
  const { numberFormatter: e, dataLabelsConfigContent: i } = t;
  return (a) => ft({
    textSymbol: {
      ...i,
      text: e.format(a)
    },
    format: "amChartsV5"
  });
}
function JS(t) {
  const { series: e, dataLabelsConfig: i, externalDataLabelFormatter: a } = t;
  e.bullets.push(() => {
    const o = Ti.new(e.root, {
      sprite: yi.new(e.root, {
        text: "{value}",
        populateText: !0,
        centerY: Te,
        centerX: Ke,
        // remove padding so if they fit in the label, it shows
        paddingBottom: 0,
        paddingTop: 0,
        paddingRight: 0,
        paddingLeft: 0,
        fill: re(i?.content.color).color,
        fontSize: i?.content.font?.size,
        oversizedBehavior: "hide"
      })
    }), n = o.get("sprite");
    if (n) {
      const s = n;
      KS({
        dataLabel: s,
        series: e,
        externalDataLabelFormatter: a
      }), Nu({
        ...t,
        dataLabel: s,
        isHeatChart: !0,
        dataLabelFormatter: QS
      }), s.set("oversizedBehavior", "hide"), s.set("maxWidth", void 0), s.set("maxHeight", void 0);
    }
    return o;
  });
}
function ex(t) {
  const { series: e, dataLabelsConfig: i } = t, a = i?.visible;
  e.bullets.hasIndex(0) && Lr(e, 0), a === !0 && JS(t);
}
function tx(t) {
  const { root: e, xAxis: i, yAxis: a, options: o, chartConfig: n } = t, s = Ee.new(e, {
    calculateAggregates: !0,
    stroke: re(A.backgroundColor).color,
    clustered: !1,
    xAxis: i,
    yAxis: a,
    categoryXField: Me.xField,
    // TODO: see fetchFinishedHeatChartData() - should we make those fields dynamic based on the config?
    categoryYField: Me.yField,
    // TODO: see fetchFinishedHeatChartData() - should we make those fields dynamic based on the config?
    valueField: Me.valueField
  });
  return s.columns.template.setAll({
    tooltipText: `x: {${Me.xField}}
y: {${Me.yField}}
Value: {${Me.valueField}}`,
    width: Te,
    height: Te
  }), Au(s), eo(s, n), _t(s.columns.template, o?.selectionTheme), Zt(s.columns.template, s), s;
}
function ix(t) {
  const { columnSeries: e, data: i, loaderHandle: a } = t;
  i && (e.events.once(le.DataValidated, () => {
    a.hideLoader();
  }), e.data.setAll(i.dataItems));
}
function ax(t) {
  const { columnSeries: e, seriesConfig: i } = t, { gradientHeatRules: a } = A.heatChart, { gradientRules: o } = i, n = i.emptyCells?.symbol ?? A.heatChart.emptyCells?.symbol, s = o?.colorList?.[0] ?? a.minColor, r = o?.colorList?.[1] ?? a.maxColor, l = o?.outsideRangeLowerColor ?? a.outsideRangeLowerColor, c = o?.outsideRangeUpperColor ?? a.outsideRangeUpperColor, { minValue: u, maxValue: d } = o ?? {}, { color: m, opacity: g } = re(s), { color: h, opacity: y } = re(r), p = re(l), S = re(c);
  e.set("heatRules", [
    {
      target: e.columns.template,
      dataField: "value",
      key: "fill",
      customFunction: (x, C, v, F) => {
        if (x instanceof ui) {
          let T, k;
          Number.isFinite(F) ? typeof u == "number" && F < u ? { color: T, opacity: k } = p : typeof d == "number" && F > d ? { color: T, opacity: k } = S : (T = jm.interpolate((F - C) / (v - C), m, h, "rgb"), k = g + (F - C) / (v - C) * (y - g)) : na({ element: x, fillSymbol: n }), T && x.set("fill", T), k !== void 0 && x.set("fillOpacity", k);
        }
      }
    }
  ]);
}
function ox(t, e) {
  e ? Yt({ element: t.columns.template, lineSymbol: e }) : t.columns.template.setAll({
    strokeOpacity: 0,
    strokeWidth: 0
  });
}
function nx(t) {
  const {
    series: e,
    data: i,
    loaderHandle: a,
    dataWasUpdated: o,
    sortChanged: n,
    timeZoneChanged: s,
    seriesWereReinitialized: r,
    seriesConfig: l,
    autoInverseDataLabelTextColor: c,
    options: u
  } = t, d = o === !0 || n === !0 || s || r === !0;
  e.set("id", l.id), Wp(t), ox(e, l.gridLine), (!l.heatRulesType || l.heatRulesType === Wm.Gradient) && ax({
    columnSeries: e,
    seriesConfig: l
  }), d && ix({
    columnSeries: e,
    data: i,
    loaderHandle: a
  }), ex({
    seriesType: b.HeatSeries,
    series: e,
    seriesConfig: l,
    dataLabelsConfig: l.dataLabels,
    yAxisValueFormat: {
      intlOptions: {},
      type: "number"
    },
    autoInverseDataLabelTextColor: c,
    externalDataLabelFormatter: u?.dataLabelFormatter
  });
}
function sx(t) {
  Pu(t);
}
function Dr(t) {
  const { isLineSmoothed: e, isRadarLineSeries: i, isRotated: a } = t;
  let o = i ? Kg : Qg;
  return e && (o = i ? Jg : a ? eh : th), o;
}
function rx(t) {
  const { series: e, seriesConfig: i, chartSubType: a, colorMatch: o, rendererType: n } = t;
  let s;
  for (const r of e.dataItems) {
    const l = r.dataContext;
    if (s = Ft({
      seriesConfig: i,
      dataItem: l,
      chartSubType: a,
      colorMatch: o,
      rendererType: n
    }), s !== void 0)
      break;
  }
  return s;
}
function lx(t) {
  const { series: e, seriesConfig: i, seriesIndex: a, chartSubType: o, colorMatch: n, rendererType: s } = t, r = e.root, l = rx({
    series: e,
    seriesConfig: i,
    chartSubType: o,
    colorMatch: n,
    rendererType: s
  }), c = mt({
    root: r,
    seriesIndex: a,
    seriesSymbol: i.lineSymbol ?? Wc(a),
    element: e,
    colorMatch: n,
    rendererSymbol: l
  });
  return Re(e, i.visible), c.symbolWithColorInfo;
}
function cx(t) {
  const { series: e, seriesIndex: i, chartSubType: a, seriesConfig: o, colorMatch: n, lineColor: s } = t;
  let r = !1, l;
  const c = he(e.uid, "bulletTemplate");
  if (c !== void 0) {
    o.markerVisible !== !1 && o.visible !== !1 ? e.bulletsContainer.show() : e.bulletsContainer.hide();
    let { markerSymbol: u } = o;
    u === void 0 && (u = Hc(), u.color = s), n ? u.color = s : u.color ??= s;
    const d = Ft({
      dataItem: e.dataItems[0]?.dataContext,
      seriesConfig: o,
      chartSubType: a,
      colorMatch: n
    });
    d && d.outline && (u.outline ??= d.outline, u.outline.color = d.outline.color), Ud({
      element: c,
      markerSymbol: u
    });
    const m = /* @__PURE__ */ new Set();
    let g;
    e.dataItems.forEach((h) => {
      const y = h.bullets?.[0]?.get("sprite");
      if (y !== void 0) {
        const p = Ft({
          dataItem: h?.dataContext,
          seriesConfig: o,
          chartSubType: a,
          colorMatch: n
        }), S = mt({
          root: e.root,
          seriesIndex: i,
          seriesSymbol: u,
          element: y,
          colorMatch: n,
          rendererSymbol: p
        });
        l = S.symbolWithColorInfo, g = S.stylingInfo, co(y, g), m.add(JSON.stringify(g));
      }
    }), r = m.size > 1;
  }
  return r ? void 0 : l;
}
function dx(t, e) {
  if (t.showArea === !0)
    if (t.areaColor !== void 0) {
      const { color: i, opacity: a } = re(t.areaColor);
      e.set("fill", i), e.fills.template.setAll({ fillOpacity: a, visible: !0 });
    } else
      e.set("fill", e.get("stroke")), e.fills.template.setAll({
        fillOpacity: A.lineSeries.areaOpacity,
        visible: !0
      });
  else
    e.fills.template.set("visible", !1);
}
function Sf(t) {
  const {
    series: e,
    seriesConfig: i,
    seriesIndex: a,
    numberOfSeries: o,
    colorMatch: n,
    rendererType: s,
    chartSubType: r,
    seriesIndexMapper: l,
    seriesSymbolMapForEvent: c,
    isRotated: u
  } = t, d = e.root, m = e.chart;
  if (m) {
    const g = e instanceof Hs;
    Re(e, i.visible);
    const h = Dr({
      isRadarLineSeries: g,
      isLineSmoothed: i.lineSmoothed,
      isRotated: u
    });
    e.set("curveFactory", h);
    const y = lx({
      series: e,
      seriesConfig: i,
      seriesIndex: a,
      chartSubType: r,
      colorMatch: n,
      rendererType: s
    }), p = cx({
      series: e,
      seriesConfig: i,
      seriesIndex: a,
      chartSubType: r,
      colorMatch: n,
      lineColor: y.color
    });
    c.set(l?.get(i.id) ?? a, {
      lineSymbol: y,
      markerSymbol: p
    }), dx(i, e), c.size === o && (Bt({
      data: Ge(c),
      htmlContainer: d.dom,
      chartId: e.chart?.get("id"),
      colorMatchApplied: to(m)
    }), c.clear());
  }
}
function ux(t) {
  const { root: e, chartConfig: i, xAxis: a, yAxis: o, seriesConfig: n, options: s } = t, { id: r, name: l } = n, { xField: c, yField: u, xAxisField: d, yAxisField: m } = Qa(i, n), g = ge.new(e, {
    id: r,
    name: l,
    xAxis: a,
    yAxis: o,
    [d]: c,
    [m]: u,
    maskBullets: !1,
    curveFactory: Dr({
      isRadarLineSeries: !1,
      isLineSmoothed: n.lineSmoothed,
      isRotated: i.rotated
    })
  });
  g.appear();
  const h = Wa.new({});
  return Pe(g.uid, { bulletTemplate: h }), g.bullets.push((y) => {
    const p = ui.new(
      y,
      {
        focusable: !0,
        // necessary for accessibility on bullets
        role: A.aria.defaultChartItemRole,
        // assigning role to bullets
        ariaLabel: dn(),
        // adding aria label to bullets
        hoverOnFocus: !0,
        // necessary for tooltip to show on focus
        tooltip: Cr(y, g),
        tooltipText: " ",
        // necessary to trigger the adapter
        layer: A.zIndexes.bulletMarkers
      },
      h
    );
    return _t(p, s?.selectionTheme), Zt(p, g), Hu(p, g), Ti.new(y, { sprite: p });
  }), kr(g), eo(g, i), g;
}
function fx(t) {
  const {
    lineSeries: e,
    data: i,
    seriesIndex: a,
    chartConfig: o,
    dataWasUpdated: n,
    seriesWereReinitialized: s,
    rotationChanged: r,
    timeZoneChanged: l,
    sortChanged: c,
    loaderHandle: u
  } = t, d = o.series[a];
  if (i !== void 0 && a >= 0 && a < o.series.length && d.type === b.LineSeries && (r === !0 || n === !0 || l || s === !0 || c === !0)) {
    const { xField: m, yField: g, xAxisField: h, yAxisField: y } = Qa(o, d);
    e.setAll({ [h]: m, [y]: g }), e.events.once(le.DataValidated, () => {
      u.hideLoader();
    }), e.data.setAll(i.dataItems);
  }
}
function mx(t) {
  const {
    series: e,
    seriesConfig: i,
    seriesIndex: a,
    numberOfSeries: o,
    colorMatch: n,
    rendererType: s,
    seriesIndexMapper: r,
    seriesSymbolMapForEvent: l
  } = t, { chart: c } = e;
  if (c !== void 0) {
    const u = w(c.uid, "config"), d = w(c.uid, "isRotated") ?? !1, m = U(u?.series);
    Sf({
      series: e,
      seriesConfig: i,
      seriesIndex: a,
      numberOfSeries: o,
      colorMatch: n,
      chartSubType: m,
      rendererType: s,
      seriesIndexMapper: r,
      seriesSymbolMapForEvent: l,
      isRotated: d
    });
  }
}
function gx(t, e) {
  const { connectLines: i, temporalBinning: a } = e, o = a?.nullPolicy;
  t.set("connect", i !== !1 && o !== Ic.Null);
}
function hx(t) {
  const {
    series: e,
    data: i,
    chartConfig: a,
    options: o,
    seriesIndex: n,
    dataWasUpdated: s,
    queryObject: r,
    subtypeInfo: l,
    fieldList: c,
    utilsStrings: u,
    rotationChanged: d,
    seriesWereReinitialized: m,
    timeZoneChanged: g,
    sortChanged: h,
    loaderHandle: y
  } = t, p = a.series[n], S = a.rotated, x = a.axes;
  let C;
  x?.[1] && (C = x[1]), e.set("id", p.id), sx({
    seriesType: b.LineSeries,
    series: e,
    seriesConfig: p,
    isRotated: S,
    dataLabelsConfig: p.dataLabels,
    yAxisValueFormat: C?.valueFormat,
    externalDataLabelFormatter: o?.dataLabelFormatter
  }), Ar({ series: e, chartConfig: a, isRotated: S }), gx(e, p), fx({
    lineSeries: e,
    seriesIndex: n,
    data: i,
    chartConfig: a,
    dataWasUpdated: s,
    rotationChanged: d,
    seriesWereReinitialized: m,
    timeZoneChanged: g,
    sortChanged: h,
    loaderHandle: y
  }), vr({
    series: e,
    seriesConfig: p,
    fieldList: c,
    queryObject: r,
    seriesIndex: n,
    tooltipFormatter: o?.tooltipFormatter,
    utilsStrings: u
  }), Ni(t) && Pi({
    // TODO: Remove the type assertion and correct the typings
    styleCallback: mx,
    callbackProps: t,
    series: e,
    seriesConfig: p
  }), Tr({ chartConfig: a, series: e, seriesIndex: n, subtypeInfo: l, fieldList: c });
}
function px(t) {
  t.labels.template.adapters.add("text", (e, i) => {
    let a = e;
    const o = he(
      t.uid,
      "pieChartDataLabelFormatter"
    );
    if (o) {
      const n = i.dataItem;
      if (n) {
        const s = n?.get("valuePercentTotal"), r = n?.get("value"), l = n?.get("category") ?? e ?? "";
        a = o(l, r, s);
      }
    }
    return a;
  });
}
function bx(t) {
  const e = t.dataItem?.component;
  let i;
  if (e instanceof ht) {
    const a = w(e.chart?.uid ?? Number.NaN, "config");
    if (a !== void 0 && a.series[0].type === b.PieSeries) {
      const o = a.series[0].dataLabelsInside ?? A.pieChart.dataLabelsInside, n = re(a?.series[0].dataLabels?.content?.color).color, s = e.chart?.get("background")?.get("fill") ?? re(A.backgroundColor).color, l = w(e.chart?.uid ?? Number.NaN, "options")?.autoInverseDataLabelTextColor ?? G.options.autoInverseDataLabelTextColor, u = t.dataItem?.dataContext?.[G.pieChart.technicalFieldSliceId], m = e.slices.values.find(
        (h) => (h.dataItem?.dataContext)[G.pieChart.technicalFieldSliceId] === u
      )?.get("fill") ?? re(a.series[0].fillSymbol?.color).color, g = n ?? t.text.get("fill");
      i = g, g && m && l && o && (i = Mu({ textBackgroundColor: m, chartBackgroundColor: s }));
    }
  }
  return i;
}
function yx(t) {
  const e = t.labels.template;
  e.set("cursorOverStyle", "pointer"), e.setAll({
    cursorOverStyle: "pointer",
    maxWidth: A.pieChart.dataLabels.maxWidth ?? Number.NaN,
    oversizedBehavior: A.pieChart.dataLabels.wrap ?? !0 ? "wrap" : "none",
    centerX: Ae,
    centerY: Ae
  }), px(t), e.adapters.add(
    "fill",
    (i, a, o) => bx(a)
  );
}
function Sx(t, e) {
  const {
    numericValueFormat: i,
    percentValueFormat: a,
    displayNumericValueOnDataLabel: o,
    displayCategoryOnDataLabel: n,
    displayPercentageOnDataLabel: s,
    valuePrefix: r,
    valueSuffix: l,
    percentagePrefix: c,
    percentageSuffix: u,
    dataLabelsCharacterLimit: d
  } = e, { chart: m } = t;
  let g;
  if (m) {
    const h = yr({
      pieChart: m,
      valueIntlOptions: i?.intlOptions,
      percentageIntlOptions: a?.intlOptions,
      displayNumericValue: o ?? A.pieChart.displayNumericValueOnDataLabel,
      displayPercentage: s ?? A.pieChart.displayPercentageOnDataLabel,
      valuePrefix: r,
      valueSuffix: l,
      percentagePrefix: c,
      percentageSuffix: u
    }), y = or(d), p = bt(
      w(t.chart?.uid ?? Number.NaN, "rtl") ?? !1,
      " "
    );
    g = (S, x, C) => {
      const v = h(S, x, C), T = n ?? A.pieChart.displayCategoryOnDataLabel ? y(S) : "";
      let k = ye(T) ? "" : `${T}${p}`;
      return k = `${k}${v}`, e.dataLabels?.content !== void 0 && (k = ft({
        textSymbol: { ...e.dataLabels.content, text: k },
        format: "amChartsV5",
        defaults: {
          ...A.pieChart.dataLabels,
          wrap: e.optimizeDataLabelsOverlapping ?? A.pieChart.dataLabels.wrap
        }
      })), k;
    };
  }
  return g;
}
function xx(t) {
  const { pieSeries: e, seriesConfig: i, dataLabelFormatter: a } = t, { dataLabels: o } = i, n = i.dataLabelsOffset ?? A.pieChart.dataLabelsOffset, s = i.dataLabelsInside ?? A.pieChart.dataLabelsInside;
  Pe(e.uid, {
    pieChartDataLabelFormatter: a ?? Sx(e, i)
  }), Pt({
    label: e.labels.template,
    labelConfig: o,
    defaults: {
      ...A.pieChart.dataLabels,
      wrap: i.optimizeDataLabelsOverlapping ?? A.pieChart.alignDataLabels
    }
  }), e.set(
    "alignLabels",
    !s && (i.alignDataLabels ?? A.pieChart.alignDataLabels)
  ), e.labels.template.set("forceHidden", !o?.visible);
  const r = e.labels.template.get("radius"), l = e.labels.template.get("baseRadius");
  s && l !== gt(60) ? e.labels.template.setAll({
    radius: void 0,
    baseRadius: gt(60),
    textType: "regular"
  }) : s || (e.labels.template.setAll({ baseRadius: Te, textType: "adjusted" }), n !== void 0 && Number.isFinite(n) && r !== n && e.labels.template.set("radius", n));
}
let ys;
function Cx(t) {
  const { root: e, dataContext: i, seriesConfig: a, isGroupOfSlices: o, sliceFromConfig: n, dataIndex: s, colorMatch: r } = t, l = U([a]), c = Ma.new(e, {});
  c.dataItem = {
    dataContext: i
  };
  const u = n?.fillSymbol, d = o ? {
    ...A.pieChart.sliceGrouping.fillSymbol,
    ...a.sliceGrouping?.fillSymbol
  } : Ge(u ?? a.fillSymbol), m = Ft({
    dataItem: i,
    seriesConfig: a,
    chartSubType: l,
    colorMatch: r
  }), { symbolWithColorInfo: g } = mt({
    root: e,
    element: c,
    seriesSymbol: d ?? on(),
    seriesIndex: s,
    rendererSymbol: m,
    colorMatch: r,
    isChartFillSymbol: !0
  });
  return g;
}
function Jl(t, e) {
  const {
    root: i,
    x: a,
    isNonAggregatedChart: o,
    objectIdField: n,
    isPieFromFields: s,
    seriesConfig: r,
    fieldList: l,
    labelUpdateNeeded: c,
    colorMatch: u,
    utilsStrings: d
  } = e, m = [];
  let g, h;
  return t.forEach((y, p) => {
    const S = Od({
      dataContext: y,
      x: a,
      isNonAggregatedChart: o,
      dataIndex: p,
      objectIdField: n,
      isPieFromFields: s
    });
    y[A.pieChart.technicalFieldSliceId] = S;
    const x = gn(r.slices, S), C = Di(y), v = Cx({
      root: i,
      dataContext: y,
      seriesConfig: r,
      isGroupOfSlices: C,
      sliceFromConfig: x,
      dataIndex: p,
      colorMatch: u
    }), F = Rd({
      dataContext: y,
      sliceFromConfig: x,
      isGroupOfSlices: C,
      seriesConfig: r,
      fieldList: l,
      isPieFromFields: s,
      labelUpdateNeeded: c,
      colorMatch: u,
      utilsStrings: d
    }), T = {
      sliceId: S,
      label: F,
      fillSymbol: v
    };
    T.originalLabel = x?.originalLabel ?? (y?.[A.originalCategoryValue] !== void 0 ? y?.[A.originalCategoryValue] : T.label), C ? (h = y[A.pieChart.technicalFieldGroupedSlices], r.sliceGrouping !== void 0 && (g = {
      sliceId: r.sliceGrouping.sliceId,
      percentageThreshold: r.sliceGrouping.percentageThreshold,
      label: F,
      originalLabel: r.sliceGrouping.originalLabel ?? F,
      fillSymbol: v
    })) : m.push(T);
  }), { slices: m, groupOfSlicesSymbols: g, groupOfSlices: h };
}
async function xf(t) {
  const { data: e } = t, i = e && "dataItems" in e ? e.dataItems : [], { root: a, chartConfig: o, queryObject: n, usePopupTemplateFieldsInfo: s, labelUpdateNeeded: r, utilsStrings: l } = t, c = o.series[0], { x: u } = c, d = !ud({ chartConfig: o }), g = U([c]) === P.PieFromFields, y = pt(n).objectIdField, p = await qt(n, s), S = {
    root: a,
    x: u,
    isNonAggregatedChart: d,
    objectIdField: y,
    isPieFromFields: g,
    seriesConfig: c,
    fieldList: p,
    labelUpdateNeeded: r,
    colorMatch: Ii(o),
    utilsStrings: l
  }, { slices: x, groupOfSlicesSymbols: C, groupOfSlices: v } = Jl(
    i,
    S
  ), { slices: F } = Jl(v ?? [], S);
  return {
    slices: x,
    groupedSlices: F,
    groupOfSlices: C
  };
}
function vx(t, e) {
  const { ticks: i } = e, a = i?.visible === !1 || e.dataLabelsInside === !0 || e.dataLabels === void 0 || e.dataLabels?.visible === !1 || e.dataLabelsOffset !== void 0 && e.dataLabelsOffset <= 0;
  t.ticks.template.setAll({
    visible: !a,
    // set crisp to false so ticks match v4 pie charts
    // see: https://www.amcharts.com/docs/v5/reference/tick/#crisp_setting
    crisp: !1
  });
  const o = i?.lineSymbol ?? wo({ color: Gc });
  a && (o.width = 0), Yt({
    element: t.ticks.template,
    lineSymbol: o,
    visible: !a
  });
}
function Lx(t) {
  const { series: e, pieSlicesSymbols: i, seriesConfig: a } = t;
  e.slices.each((o, n) => {
    const s = o.dataItem?.dataContext, r = gr({
      dataContext: s,
      pieSlicesSymbols: i,
      seriesConfig: a
    });
    na({
      element: o,
      fillSymbol: r,
      defaultToColorFromRamp: !0,
      colorRampIndex: n,
      isChartFillSymbol: !0
    });
  });
}
function Fx(t) {
  const {
    series: e,
    data: i,
    seriesConfig: a,
    dataWasUpdated: o,
    sortChanged: n,
    seriesWereReinitialized: s,
    loaderHandle: r,
    labelUpdateNeeded: l
  } = t, { x: c, y: u } = a, d = U([a]), m = d === P.PieFromFields ? ii : c;
  if (i && (o === !0 || s === !0 || n === !0))
    e.setAll({
      categoryField: m,
      valueField: d === P.PieFromFields ? wa : u
    }), e.events.once(le.DataValidated, () => {
      r.hideLoader();
    }), e.data.setAll(i.dataItems);
  else if (i && l) {
    const g = i.dataItems;
    e.dataItems.forEach((y, p) => {
      const S = g[p];
      typeof S[m] == "string" && y.set("category", S[m]);
    }), e.markDirty();
  }
}
function Ax(t, e) {
  const { innerRadius: i } = e;
  t.set("innerRadius", i ? gt(i) : 0);
}
function Tx(t, e) {
  const { startAngle: i, endAngle: a } = e;
  t.setAll({
    startAngle: i ?? A.pieChart.min,
    endAngle: a ?? 360 + (t.get("startAngle") ?? 0)
  });
}
function kx(t) {
  const { root: e, seriesConfig: i, options: a, chart: o } = t, { id: n, name: s, x: r, y: l } = i, c = U([i]), u = ht.new(e, {
    id: n,
    name: s,
    categoryField: c === P.PieFromFields ? ii : r,
    valueField: c === P.PieFromFields ? wa : l
  });
  return yx(u), Fu(u), u.slices.template.states.create("hover", {
    scale: 1,
    // Prevent scaling on hover
    stateAnimationDuration: 0
    // Remove animation
  }), _t(u.slices.template, a?.selectionTheme), Zt(u.slices.template, u), u.appear(), o instanceof ti && wx(o, u), u;
}
function Ix(t) {
  const {
    series: e,
    seriesConfig: i,
    seriesWereReinitialized: a,
    dataWasUpdated: o,
    sortChanged: n,
    data: s,
    options: r,
    loaderHandle: l,
    labelUpdateNeeded: c,
    utilsStrings: u
  } = t, { dataLabelFormatter: d, tooltipFormatter: m } = r ?? {};
  e.set("id", i.id), Fx({
    series: e,
    seriesConfig: i,
    seriesWereReinitialized: a,
    dataWasUpdated: o,
    sortChanged: n,
    data: s,
    loaderHandle: l,
    labelUpdateNeeded: c
  }), Ni(t) && Pi({
    // TODO: Remove the type assertion and correct the typings
    styleCallback: Lx,
    callbackProps: t,
    series: e,
    seriesConfig: i
  }), Ax(e, i), Tx(e, i), vx(e, i), Vp({
    series: e,
    seriesConfig: i,
    tooltipFormatter: m
  }), xx({
    pieSeries: e,
    seriesConfig: i,
    dataLabelFormatter: d
  });
}
function wx(t, e) {
  if (!t.isDisposed()) {
    const i = t.radius();
    de(t.uid, { pieChartRadius: i });
    const a = () => {
      const o = gt(
        w(t.uid, "pieChartRadius") ?? A.pieChart.chartOptimizedRadius
      );
      let n = o;
      const r = t.series?.values?.[0] ?? e, l = w(t.uid, "config");
      if (l !== void 0) {
        const { series: c } = l, {
          optimizeDataLabelsOverlapping: u,
          alignDataLabels: d,
          dataLabelsOffset: m = A.pieChart.dataLabelsOffset,
          dataLabels: g,
          dataLabelsInside: h
        } = c[0];
        if (g?.visible === !0 && d === !0 && u === !0 && h !== !0) {
          const S = A.pieChart.chartOptimizedRadius / 100, x = 500, C = 150, v = 0.6, F = 0.5, T = 1, k = t.chartContainer.width() - m * 2, $ = Math.max(k - C, 0) / (x - C), O = $ < 1 ? (
            // case 1: the container width is less than the radiusContainerWidthBreakpoint - we want to scale the radius down.
            Math.max($ ** T * v, 0.4)
          ) : (
            // case 2: the container width is at or more than the radiusContainerWidthBreakpoint - ramp up radius to the max radius
            Math.min($ ** F * v, S)
          );
          n = gt(O * 100);
        } else
          n = gt(A.pieChart.chartRadius);
        o.value.toFixed(1) !== n.value.toFixed(1) && (de(t.uid, { pieChartRadius: n.percent }), ys && clearTimeout(ys), ys = Za(() => {
          const p = t.chartContainer.height();
          t.chartContainer.set("height", p + 0.1), t.set("radius", n), t.markDirty(), r.markDirty(), t.root.resize(), t.root.events.off("frameended", a), $x(t);
        })), r instanceof ht && r.labels.template.set(
          "maxWidth",
          Dx(l?.series[0], t)
        );
      }
      return n;
    };
    t.root.events.on("frameended", a), a();
  }
}
function $x(t) {
  Za(() => {
    t.chartContainer.set("height", gt(100)), t.root.resize();
  });
}
function Dx(t, e) {
  let i = A.pieChart.dataLabels.maxWidth ?? 100;
  if (t != null) {
    const {
      alignDataLabels: a,
      dataLabelsOffset: o = A.pieChart.dataLabelsOffset,
      optimizeDataLabelsOverlapping: n,
      dataLabels: s,
      dataLabelsInside: r
    } = t;
    if (s?.visible === !0 && a === !0 && r !== !0 && n === !0) {
      const l = e.radius(), c = e.chartContainer.width(), u = e.chartContainer.height(), d = l * Math.min(c, u), m = 5, g = Math.floor((c - d) / 2) - m - o;
      i = Math.min(g, i - m);
      const h = 30;
      i < h && (i = h);
    }
  }
  return i;
}
function Ox(t) {
  const { root: e, chartConfig: i, xAxis: a, yAxis: o, seriesConfig: n, options: s } = t, { id: r, name: l } = n, { xField: c, yField: u, xAxisField: d, yAxisField: m } = Qa(i, n), g = Hs.new(e, {
    id: r,
    name: l,
    xAxis: a,
    yAxis: o,
    [d]: c,
    [m]: u,
    curveFactory: Dr({
      isRadarLineSeries: !0,
      isLineSmoothed: n.lineSmoothed,
      isRotated: i.rotated
    }),
    layer: A.zIndexes.bulletMarkers
  });
  g.appear();
  const h = Wa.new({});
  return Pe(g.uid, { bulletTemplate: h }), g.bullets.push((y) => {
    const p = ui.new(
      y,
      { tooltip: Cr(y, g), tooltipText: " " },
      h
    );
    return _t(p, s?.selectionTheme), Zt(p, g), Ti.new(y, { sprite: p });
  }), kr(g), eo(g, i), g;
}
function Rx(t) {
  const {
    radarLineSeries: e,
    data: i,
    seriesIndex: a,
    chartConfig: o,
    dataWasUpdated: n,
    seriesWereReinitialized: s,
    timeZoneChanged: r,
    loaderHandle: l
  } = t, c = o.series[a];
  if (i !== void 0 && c?.type === b.RadarSeries && (n || r || s)) {
    const { xField: u, yField: d, xAxisField: m, yAxisField: g } = Qa(o, c);
    e.setAll({ [m]: u, [g]: d }), e.events.once(le.DataValidated, () => {
      l.hideLoader();
    }), e.data.setAll(i.dataItems);
  }
}
function Bx(t) {
  const {
    series: e,
    seriesConfig: i,
    seriesIndex: a,
    numberOfSeries: o,
    colorMatch: n,
    rendererType: s,
    seriesIndexMapper: r,
    seriesSymbolMapForEvent: l
  } = t, { chart: c } = e;
  if (c !== void 0) {
    const u = w(c.uid, "config"), d = w(c.uid, "isRotated") ?? !1, m = U(u?.series);
    Sf({
      series: e,
      seriesConfig: i,
      seriesIndex: a,
      numberOfSeries: o,
      colorMatch: n,
      chartSubType: m,
      rendererType: s,
      seriesIndexMapper: r,
      seriesSymbolMapForEvent: l,
      isRotated: d
    });
  }
}
function Mx(t) {
  const {
    series: e,
    data: i,
    seriesWereReinitialized: a,
    chartConfig: o,
    options: n,
    seriesIndex: s,
    dataWasUpdated: r,
    timeZoneChanged: l,
    fieldList: c,
    queryObject: u,
    subtypeInfo: d,
    loaderHandle: m,
    utilsStrings: g
  } = t, h = o.series[s];
  e.set("id", h.id), Ar({ series: e, chartConfig: o, isRotated: !1 }), vr({
    series: e,
    seriesConfig: h,
    fieldList: c,
    queryObject: u,
    seriesIndex: s,
    tooltipFormatter: n?.tooltipFormatter,
    utilsStrings: g
  }), Ni(t) && Pi({
    // TODO: Remove the type assertion and correct the typings
    styleCallback: Bx,
    callbackProps: t,
    series: e,
    seriesConfig: h
  }), Tr({ chartConfig: o, series: e, seriesIndex: s, subtypeInfo: d, fieldList: c }), Rx({
    radarLineSeries: e,
    data: i,
    seriesIndex: s,
    chartConfig: o,
    dataWasUpdated: r,
    timeZoneChanged: l,
    seriesWereReinitialized: a,
    loaderHandle: m
  });
}
async function Or(t) {
  const { chart: e, chartConfig: i, options: a, utilsStrings: o } = t, { rotated: n } = i, { root: s } = e, r = z(i.series);
  e.series.clear();
  const l = [], c = { root: s, chartConfig: i, options: a, chart: e, utilsStrings: o };
  let u = [];
  for (let d = 0; d < i.series.length; d += 1) {
    const m = i.series[d], { assignToSecondValueAxis: g, type: h } = m, y = e instanceof Se ? Gb({ chart: e, chartType: r, rotated: n, assignToSecondValueAxis: g }) : void 0, { xAxis: p, xAxisForHistogramOverlaySeries: S, yAxis: x } = y ?? {};
    switch (!0) {
      case h === b.HeatSeries: {
        p && x && u.push(
          tx({
            ...c,
            xAxis: p,
            yAxis: x
          })
        );
        break;
      }
      case r === b.BoxPlotSeries: {
        p && x && (h === b.BoxPlotSeries || h === b.LineSeries) && u.push(
          ..._S({
            ...c,
            xAxis: p,
            yAxis: x,
            seriesIndex: d,
            seriesConfig: m,
            chartConfig: i
          })
        );
        break;
      }
      case h === b.HistogramSeries: {
        p && x && u.push(
          ...Tb({
            ...c,
            seriesConfig: m,
            xAxis: p,
            xAxisForOverlaySeries: S,
            yAxis: x
          })
        );
        break;
      }
      case h === b.PieSeries: {
        u.push(
          kx({
            ...c,
            seriesConfig: m
          })
        );
        break;
      }
      case (r === b.ComboLineAndBarSeries || r === b.BarSeries || r === b.LineSeries): {
        p && x && (h === b.BarSeries ? u.push(
          CS({
            ...c,
            seriesConfig: m,
            xAxis: p,
            yAxis: x
          })
        ) : h === b.LineSeries && u.push(
          ux({
            ...c,
            seriesConfig: m,
            xAxis: p,
            yAxis: x
          })
        ));
        break;
      }
      case h === b.RadarSeries: {
        p && x && u.push(
          Ox({
            ...c,
            seriesConfig: m,
            xAxis: p,
            yAxis: x
          })
        );
        break;
      }
      case h === b.ScatterSeries: {
        p && x && u.push(
          ...ib({
            ...c,
            seriesConfig: m,
            xAxis: p,
            yAxis: x
          })
        );
        break;
      }
    }
    u = [...u, ...await Promise.all(l)].flat();
  }
  u.forEach((d) => {
    d instanceof Gs && d.setPrivate("doNotUpdateLegend", !0);
  }), e.series.pushAll(u);
}
async function Zn(t) {
  const {
    chart: e,
    chartConfig: i,
    options: a,
    data: o,
    seriesIndexMapper: n,
    dataWasUpdated: s,
    sortChanged: r,
    seriesWereReinitialized: l,
    rotationChanged: c,
    colorMatchChanged: u,
    seriesStyleChanged: d,
    timeZoneChanged: m,
    pieSlicesSymbols: g,
    queryObject: h,
    loaderHandle: y,
    utilsStrings: p,
    errorStrings: S,
    groupOfSlicesUpdateNeeded: x,
    labelUpdateNeeded: C
  } = t, { chartRenderer: v } = i, { root: F } = e, { series: T } = i, k = z(i.series), $ = U(i.series), O = e.series.values, D = Ii(i), R = i.series.length, M = /* @__PURE__ */ new Map(), N = Xc(h), E = await qt(h, a?.usePopupTemplateFieldsInfo), V = pt(h), W = $o(v, V.renderer), H = l || s || r || c, Z = {
    root: F,
    chartConfig: i,
    queryObject: h,
    options: a,
    colorMatch: D,
    dataWasUpdated: s,
    sortChanged: r,
    seriesWereReinitialized: l,
    subtypeInfo: N,
    fieldList: E,
    rendererType: W,
    dataLabelFormatter: a?.dataLabelFormatter,
    utilsStrings: p,
    chartSubType: $,
    loaderHandle: y,
    autoInverseDataLabelTextColor: a?.autoInverseDataLabelTextColor ?? A.options.autoInverseDataLabelTextColor
  }, oe = {
    ...Z,
    numberOfSeries: R,
    rotationChanged: c,
    colorMatchChanged: u,
    seriesStyleChanged: d,
    seriesIndexMapper: n,
    seriesSymbolMapForEvent: M,
    timeZoneChanged: m
  };
  for (let ie = 0; ie < T.length; ie++) {
    const X = T[ie];
    let q = O[ie];
    const Fe = X.type;
    switch (!0) {
      case k === b.HeatSeries: {
        q instanceof Ee && e instanceof Se && X.type === b.HeatSeries && nx({
          ...oe,
          series: q,
          data: o,
          seriesConfig: X
        });
        break;
      }
      case k === b.BoxPlotSeries: {
        q = O.find((Jt) => Jt.get("id") === X.id), e instanceof Se && (q instanceof ua || q instanceof ge) && (Fe === b.BoxPlotSeries || Fe === b.LineSeries) && ZS({
          ...oe,
          chart: e,
          series: q,
          data: o,
          seriesIndex: ie,
          seriesConfig: X,
          chartConfig: i,
          showMean: qe(i),
          showOutliers: Oi(i)
        });
        break;
      }
      case Fe === b.HistogramSeries: {
        q instanceof Ee && e instanceof Se && bg(o) && await $b({
          ...oe,
          series: q,
          allChartSeries: O,
          data: o,
          seriesIndex: ie,
          seriesConfig: X,
          chartRenderer: v,
          axes: i.axes
        });
        break;
      }
      case Fe === b.PieSeries: {
        q instanceof ht && e instanceof ti && ms(o) && Ix({
          ...Z,
          series: q,
          seriesConfig: X,
          data: o,
          pieSlicesSymbols: g,
          groupOfSlicesUpdateNeeded: x,
          seriesStyleChanged: d,
          colorMatchChanged: u,
          labelUpdateNeeded: C
        });
        break;
      }
      case (k === b.ComboLineAndBarSeries || k === b.BarSeries || k === b.LineSeries):
        e instanceof Se && ms(o) && (Fe === b.BarSeries && q instanceof Ee ? AS({
          ...oe,
          series: q,
          data: o,
          seriesIndex: ie,
          seriesConfig: X
        }) : Fe === b.LineSeries && q instanceof ge && hx({
          ...oe,
          series: q,
          seriesIndex: ie,
          seriesConfig: X,
          data: o
        }));
        break;
      case Fe === b.ScatterSeries: {
        q = $u(e);
        const Jt = Du(e);
        q instanceof ge && Jt instanceof ge && pg(o) && sb({
          ...oe,
          series: q,
          seriesConfig: X,
          trendLineSeries: Jt,
          data: o
        });
        break;
      }
      case Fe === b.RadarSeries: {
        q instanceof Hs && e instanceof ji && ms(o) && Mx({
          ...oe,
          series: q,
          data: o,
          seriesIndex: ie,
          seriesConfig: X,
          chartConfig: i
        });
        break;
      }
    }
    H && k && q && jp(k, q);
  }
  await zb({
    chart: e,
    options: a,
    dataWasUpdated: s,
    data: o,
    chartConfig: i,
    queryObject: h,
    errorStrings: S
  });
}
function Rr(t) {
  const { data: e, seriesConfig: i, utilsStrings: a } = t, o = i[0], n = e?.reduce((g, h) => {
    let y = h[wa] ?? h[o.y];
    return Number.isFinite(y) || (y = 0), y + g;
  }, 0), s = o?.sliceGrouping?.percentageThreshold ?? 0, r = [];
  let l, c = 0;
  const u = e?.find((g) => g[ei.defaultGroupOfSlicesId] === !0)?.[G.pieChart.technicalFieldGroupedSlices] ?? [], m = [...e, ...u].filter((g) => {
    let h = !0;
    const y = g[wa] ?? g[o.y];
    if (Number.isFinite(y)) {
      const p = y / n * 100;
      g[G.pieChart.technicalFieldSlicePercent] = p, p <= s && g[ei.defaultGroupOfSlicesId] !== !0 && (c += y, r.push(g), h = !1);
    } else g[ei.defaultGroupOfSlicesId] !== !0 && (r.push(g), h = s === 0 || s === void 0);
    return g[ei.defaultGroupOfSlicesId] === !0 && (l = g, h = !1), h;
  });
  if (s > 0 && r.length > 0) {
    const g = c / n * 100, h = U(i) === P.PieFromFields, y = {
      ...l,
      [ei.defaultGroupOfSlicesId]: !0,
      [h ? ii : o.x]: o.sliceGrouping?.label ?? a?.pieChart.defaultSliceGroupingLabel,
      [h ? wa : o.y]: c,
      [G.pieChart.technicalFieldSlicePercent]: g,
      [G.pieChart.technicalFieldGroupedSlices]: r
    };
    m.push(y);
  }
  return m;
}
function Nx(t) {
  const { chart: e, seriesConfig: i, utilsStrings: a, data: o } = t, n = e.series.getIndex(0);
  let s;
  return n && (s = Rr({ data: o, seriesConfig: i, utilsStrings: a }), n?.data.setAll(s)), s;
}
function Px(t) {
  const { chart: e, data: i, seriesConfig: a, utilsStrings: o } = t, n = e.series.getIndex(0);
  let s;
  return n && i && "dataItems" in i && (s = Rr({
    data: i.dataItems,
    seriesConfig: a,
    utilsStrings: o
  }), n?.data.setAll(s)), s;
}
function Vx(t) {
  Mi(t) || t.dataItems.forEach((e) => {
    const i = e.bullets?.[0];
    if (i) {
      const a = i.get("sprite"), o = Ri(a.uid, "selected") !== !0;
      ut({ element: a, selected: o });
    }
  });
}
function Ex(t) {
  t.columns.each((e) => {
    const i = Ri(e.uid, "selected") !== !0;
    ut({ element: e, selected: i });
  });
}
function zx(t) {
  t.slices.each((e) => {
    const i = Ri(e.uid, "selected") !== !0;
    ut({ element: e, selected: i });
  });
}
async function Wx(t) {
  if (Yn(t)) {
    const e = w(t.uid, "actionMode");
    e !== K.MonoSelection && e !== K.None && (t.series.each((i) => {
      switch (!0) {
        case i instanceof Ee:
          Ex(i);
          break;
        case i instanceof ge:
          Vx(i);
          break;
        case i instanceof ht:
          zx(i);
          break;
      }
    }), await Fr(t, Ne.ProgrammaticSelection));
  }
}
function Hx(t) {
  const e = qm.new(t, {});
  return e.getPrivate("content").classList.add("arcgis-charts-modal"), e;
}
function ec(t) {
  let e = "";
  for (let i = 0; i < t.length; i += 1) {
    const a = t[i];
    e += `<li>${a.message}</li>`;
  }
  return `<ol>${e}</ol>`;
}
function Cf(t) {
  t.set("content", void 0), t.cancel();
}
function Br(t) {
  const { chartModal: e, message: i, title: a, closable: o } = t;
  e.set(
    "content",
    a !== void 0 ? `<div class="arcgis-charts-modal-header">${a}</div><br />${i}<br />` : `${i}`
  ), o && e.events.once(le.Opened, () => {
    const n = document.createElement("input");
    n.type = "button", n.value = "OK", n.addEventListener("click", () => {
      e.close();
    }), e.getPrivate("content").appendChild(n);
  }), e.open();
}
async function vf(t) {
  const { chartModal: e, chartConfig: i, createMessage: a, status: o, errorStrings: n } = t, { schemaErrors: s, customErrors: r, warnings: l } = o;
  if (e !== void 0) {
    let c, u;
    i === void 0 ? (u = a === void 0 ? n.modalHeaders.newChart : void 0, c = a ?? n.errors.newChartRequest) : s.length > 0 ? (u = n.modalHeaders.error, c = n.errors.simpleError) : r.length > 0 ? (u = n.modalHeaders.error, c = ec(r)) : l.length > 0 && (u = n.modalHeaders.warning, c = `<p>${n.errors.warningRequest}</p>${ec(l)}`), (c !== void 0 || u !== void 0) && Br({ chartModal: e, message: c, title: u, closable: !1 });
  }
}
async function Kn(t) {
  const { chart: e, chartModal: i, chartConfig: a, invalidType: o, elementCount: n, seriesCount: s, errorStrings: r } = t, l = w(e.uid, "queryObject"), c = w(e.uid, "options"), u = w(e.uid, "formatLocale"), d = a !== void 0 && Ha({
    seriesConfig: a.series[0],
    xAxisValueFormatType: Bn(a)
  }), m = await fd({
    invalidType: o,
    elementCount: n,
    seriesCount: s,
    chartLimits: c?.chartLimits,
    filterBySelection: c?.filterBySelection,
    queryObject: l,
    formatLocale: u,
    isTemporalLineChart: d,
    errorStrings: r
  });
  md(m, e.root.dom), i && c?.showUIMessages !== !1 && Yn(e) && Br({
    chartModal: i,
    title: m.header,
    message: m.message,
    closable: !1
  });
}
async function Lf(t) {
  const { chart: e, chartModal: i, data: a, errorStrings: o } = t;
  if (e instanceof Se) {
    const n = w(e.uid, "isRotated"), s = [];
    [
      { axis: e.xAxes.getIndex(0) },
      { axis: e.yAxes.getIndex(0) },
      { axis: e.xAxes.getIndex(1), isSecondValueAxis: !0 },
      { axis: e.yAxes.getIndex(1), isSecondValueAxis: !0 }
    ].forEach((r) => {
      const { axis: l, isSecondValueAxis: c } = r;
      if (l !== void 0) {
        const u = Fi(l.get("renderer"), n);
        Yu({ axis: l, isSecondValueAxis: c, data: a }) || s.push(
          Kn({
            chart: e,
            chartModal: i,
            invalidType: u ? bi.NegativeValueInXAxisLogScale : bi.NegativeValueInYAxisLogScale,
            errorStrings: o
          })
        );
      }
    }), await Promise.all(s);
  }
}
async function Ff(t) {
  const { chart: e, chartModal: i, chartConfig: a, data: o, errorStrings: n } = t, s = w(e.uid, "options"), r = $i(o);
  (i?.get("content") === void 0 || i?.get("content") === "") && Yc({
    chartConfig: a,
    nullAsValid: s?.nullAsValid,
    dataSet: r
  }) && await Kn({
    chart: e,
    chartModal: i,
    invalidType: bi.EmptyDataSet,
    chartConfig: a,
    errorStrings: n
  });
}
function Gx(t) {
  const { chart: e, chartModal: i, message: a, heading: o, options: n } = t;
  i !== void 0 && !e.isDisposed() && (a !== void 0 ? Br({
    chartModal: i,
    message: a,
    title: o,
    closable: n?.closable ?? !1
  }) : Cf(i));
}
function Af(t) {
  const { chart: e, data: i, config: a, hideEmptySeries: o } = t, n = a.series.length, s = Ge(a);
  let r = !1;
  if (o && e instanceof Se && n > 1) {
    const l = z(a?.series), c = U(a?.series), u = /* @__PURE__ */ new Set();
    switch (l) {
      case b.ComboLineAndBarSeries:
      case b.BarSeries:
      case b.RadarSeries:
      case b.LineSeries: {
        s.series.forEach((m) => {
          let g = "";
          "y" in m && (g = Array.isArray(m.y) ? m.y[0] : m.y, c === P.BarAndLineSplitByNoAggregation && (g = `${g}_${Ki({ where: m.query?.where, keepSurroundingQuotes: !1, escape: !1 })}`), Array.isArray(i) && i.some(
            (y) => Ys({ dataItem: y, x: m.x, y: g })
          ) && u.add(m));
        });
        break;
      }
      case b.BoxPlotSeries:
        break;
    }
    const d = Array.from(u.values());
    r = d.length > 0 && d.length < n, r ? (de(e.uid, { unfilteredConfig: Ge(a) }), s.series = d, de(e.uid, { config: Ge(s) })) : de(e.uid, { unfilteredConfig: void 0 });
  }
  return de(e.uid, { seriesFilteredOut: r }), { seriesFilteredOut: r, updatedConfig: s };
}
function Xx(t, e) {
  let i = !1;
  const a = t.series, o = e.series, n = z(o), s = (d, m) => d.filter((g) => g.type === m).flatMap((g) => {
    const h = [];
    switch (m) {
      case b.BarSeries:
      case b.HistogramSeries:
        h.push(g.fillSymbol);
        break;
      case b.LineSeries:
      case b.RadarSeries:
        h.push(
          g.lineSymbol,
          g.markerSymbol
        );
        break;
      case b.ScatterSeries:
        h.push(g.markerSymbol);
        break;
      case b.PieSeries:
        const y = g;
        y.slices?.forEach((p) => {
          h.push(p.fillSymbol);
        }), y.sliceGrouping && h.push(y.sliceGrouping.fillSymbol);
        break;
    }
    return (g.type === b.BarSeries || g.type === b.LineSeries || g.type === b.RadarSeries) && g.nullCategory?.symbol !== void 0 && h.push(g.nullCategory.symbol), h;
  });
  let r, l;
  n === b.ComboLineAndBarSeries ? (r = s(a, b.BarSeries).concat(
    s(a, b.LineSeries)
  ), l = s(o, b.BarSeries).concat(
    s(o, b.LineSeries)
  )) : (r = s(a, a[0].type), l = s(o, o[0].type));
  const c = !fo(r, l);
  let u = !1;
  switch (n) {
    case b.LineSeries:
    case b.RadarSeries:
    case b.ComboLineAndBarSeries:
      u = o.filter(
        (d) => d.type === b.LineSeries || d.type === b.RadarSeries
      ).some((d) => {
        const m = a.find((g) => g.id === d.id);
        return (d.showArea ?? A.lineSeries.showArea) !== (m?.showArea ?? A.lineSeries.showArea) || (d.lineSmoothed ?? A.lineSeries.lineSmoothed) !== (m?.lineSmoothed ?? A.lineSeries.lineSmoothed) || (d.markerVisible ?? A.lineSeries.markerVisible) !== (m?.markerVisible ?? A.lineSeries.markerVisible) || d.showArea && !fo(d.areaColor, m?.areaColor);
      });
      break;
  }
  return i = c || u, i;
}
function Yx(t, e) {
  for (let i = 0; i < e.length; i += 1) {
    const a = e[i][0], o = e[i][1], n = t.length;
    a >= 0 && a < n && o >= 0 && o < n && t.swap(e[i][0], e[i][1]);
  }
}
function Ux() {
  _m(Fh);
}
function jx(t) {
  t.dispose();
}
async function qx(t, e) {
  const { root: i } = t, { t9nLocale: a } = Tn(e ?? document.documentElement), o = Dn(e ?? document.documentElement), n = await Uh(a);
  i.locale = n, de(t.uid, {
    locale: a,
    formatLocale: o,
    rtl: Xs(e ?? document.documentElement) === "rtl"
  });
}
function Ds(t) {
  const { chart: e, actionMode: i, cursorRange: a } = t;
  if (Yn(e)) {
    const o = i ?? w(e.uid, "actionMode") ?? A.actionMode;
    de(e.uid, { actionMode: o }), o === K.None && Zi({ chart: e, selectionSource: Ne.ClearSelection }), nS({ chart: e, actionMode: o, cursorRange: a });
  }
}
function _x(t) {
  return Zm.rootElements.find((e) => e.dom === t)?.dispose(), Km.new(t);
}
function Zx(t, e) {
  t.container.children.clear();
  const i = z(e?.series);
  let a;
  switch (i) {
    case b.RadarSeries:
    case b.GaugeSeries:
      a = ji;
      break;
    case b.PieSeries:
      a = ti;
      break;
    default:
      a = Se;
      break;
  }
  return t.container.children.push(
    a.new(t, {
      id: `${e?.id}`,
      layout: t.verticalLayout,
      paddingBottom: A.chartPadding,
      paddingTop: A.chartPadding,
      paddingRight: A.chartPadding,
      paddingLeft: A.chartPadding
    })
  );
}
async function Kx(t) {
  const {
    chart: e,
    chartConfig: i,
    data: a,
    dataWasUpdated: o,
    sortChanged: n,
    slicesConfigChangedSinceLastUpdate: s,
    chartRendererChanged: r,
    colorMatchChanged: l,
    options: c,
    queryObject: u,
    loaderHandle: d,
    utilsStrings: m,
    errorStrings: g,
    groupOfSlicesUpdateNeeded: h,
    seriesConfig: y,
    seriesStyleChanged: p
  } = t;
  let S = a, x = !1;
  if (e && (o || h)) {
    const T = Px({
      chart: e,
      data: a,
      seriesConfig: y,
      utilsStrings: m
    });
    T !== void 0 && (x = !0, S = { dataItems: T });
  }
  const C = o || s || r || l, v = await xf({
    root: e.root,
    data: S,
    chartConfig: i,
    queryObject: u,
    labelUpdateNeeded: C,
    usePopupTemplateFieldsInfo: c?.usePopupTemplateFieldsInfo,
    utilsStrings: m
  }), F = S && "dataItems" in S ? S.dataItems : [];
  Wn({ data: F, newChartConfig: i, pieSlicesSymbols: v }), await Zn({
    chart: e,
    chartConfig: i,
    options: c,
    data: S,
    dataWasUpdated: o,
    sortChanged: n,
    queryObject: u,
    pieSlicesSymbols: v,
    loaderHandle: d,
    utilsStrings: m,
    errorStrings: g,
    groupOfSlicesUpdateNeeded: h,
    seriesStyleChanged: p,
    colorMatchChanged: l,
    labelUpdateNeeded: C
  }), xi({
    data: S,
    seriesConfig: y,
    htmlContainer: e.root.dom
  }), Bt({
    data: v,
    htmlContainer: e.root.dom,
    chartId: e.get("id"),
    colorMatchApplied: to(e)
  }), x && de(e.uid, { data: S });
}
async function Qx(t) {
  const {
    chart: e,
    chartConfig: i,
    data: a,
    anyGuideAboveChanged: o,
    dataWasUpdated: n,
    updateNeededDetails: s,
    seriesIndexMapper: r,
    seriesFilteredOut: l,
    sortChanged: c,
    options: u,
    queryObject: d,
    rotationChanged: m,
    colorMatchChanged: g,
    seriesStyleChanged: h,
    timeZoneChanged: y,
    timeIntervalInfoWasReset: p,
    loaderHandle: S,
    utilsStrings: x,
    errorStrings: C
  } = t;
  let { axisLabelsBehaviorChanged: v } = t;
  const F = ty({
    chart: e,
    chartConfig: i,
    rotationChanged: m,
    axisLabelsBehaviorChanged: v,
    timeIntervalInfoWasReset: p
  }), T = F || Yb({ chart: e, chartConfig: i, updateNeededDetails: s, seriesFilteredOut: l });
  F && (await tf({ chart: e, chartConfig: i, errorStrings: C }), v = [!0, !0]), T && (e.series.clear(), await Or({ chart: e, chartConfig: i, options: u, utilsStrings: x })), await af({
    chart: e,
    chartConfig: i,
    queryObject: d,
    data: a,
    timeIntervalInfo: a?.timeIntervalInfo ?? w(e.uid, "timeIntervalInfo"),
    axisLabelsBehaviorChanged: v,
    anyGuideAboveChanged: o,
    xAxisLabelFormatter: u?.xAxisLabelFormatter,
    yAxisLabelFormatter: u?.yAxisLabelFormatter,
    secondaryYAxisLabelFormatter: u?.secondaryYAxisLabelFormatter,
    guideTooltipFormatter: u?.guideTooltipFormatter,
    gaugeInnerLabelFormatter: u?.gaugeInnerLabelFormatter,
    utilsStrings: x,
    errorStrings: C
  }), await Zn({
    chart: e,
    chartConfig: i,
    options: u,
    data: a,
    dataWasUpdated: n,
    sortChanged: c,
    seriesIndexMapper: r,
    seriesWereReinitialized: T,
    rotationChanged: m,
    colorMatchChanged: g,
    seriesStyleChanged: h,
    timeZoneChanged: y,
    queryObject: d,
    loaderHandle: S,
    utilsStrings: x,
    errorStrings: C
  }), mf({
    chart: e,
    scrollbarXConfig: i.axes?.[0]?.scrollbar,
    scrollbarYConfig: i.axes?.[1]?.scrollbar
  });
}
async function Jx(t) {
  const { chart: e, queryObject: i, legend: a, chartModal: o, loaderHandle: n, updateProps: s } = t, { newChartConfig: r, updateOptions: l, t9nStrings: c } = s, { utilsStrings: u, errorStrings: d } = c, { root: m } = e, {
    createMessage: g,
    layer: h,
    view: y,
    usePopupTemplateFieldsInfo: p
  } = l ?? {};
  if (r === void 0)
    throw new Error();
  let S = r, x = w(e.uid, "config");
  const C = w(e.uid, "initialized");
  if (e.isDisposed() || C === !1 || !gd(x, S))
    throw new wn(ro.ChartDisposed);
  S !== void 0 && !hi(S) && (S = sn({
    chartConfig: S,
    queryObject: h
  })), S = await an(S, h);
  const v = x === void 0;
  x ??= S;
  const F = await er({
    input: S,
    queryObject: h,
    allowUsingObjectIdStat: l?.allowUsingObjectIdStat
  });
  if (F.valid) {
    x !== void 0 && hd(x, S) && (S = Mn(S, m.dom));
    const T = U(S.series), k = z(S.series), $ = rn(w(e.uid, "queryObject"));
    let O = i;
    (h !== void 0 || hi(S)) && (O = await bo({ layer: h, view: y, chartConfig: S }), de(e.uid, { queryObject: O }));
    const D = jt(S), R = w(e.uid, "filterBySelection"), M = w(e.uid, "seriesFilteredOut"), N = w(e.uid, "unfilteredConfig");
    de(e.uid, {
      config: Ge(S),
      options: l,
      isNonAggregatedChart: !Pn(T),
      isRotated: D,
      filterBySelection: l?.filterBySelection
    }), gS({ chart: e, updateOptions: l, chartModal: o });
    const E = await qt(O, p);
    let { dataUpdateNeeded: V, updateNeededDetails: W } = Nn({
      forceDataUpdate: l?.dataUpdated || v,
      options: l,
      oldConfig: M ? N : x,
      newConfig: S,
      formerFilterBySelection: R,
      timeIntervalInfo: w(e.uid, "data")?.timeIntervalInfo,
      currentSelectionDataItems: w(e.uid, "currentSelectionDataItems"),
      currentSelectionOIDs: w(e.uid, "currentSelectionOIDs"),
      currentSelectionIndexes: w(e.uid, "currentSelectionIndexes"),
      fieldList: E
    });
    const H = rn(O);
    V = V || $ !== H;
    const Z = Cg(x, S), oe = pd(x, S), ie = bd(x, S), X = Xx(x, S), q = nr(x, S), Fe = vg(x, S), Jt = yd(x, S), gi = sr({
      oldConfig: M ? N : x,
      newConfig: S,
      dataUpdateNeeded: V
    }), Ue = Lg(x, r) || Fg(x, r), La = Sd({
      oldConfig: x,
      newConfig: S,
      rotationChanged: oe
    }), Fa = x.series, Be = S.series;
    let Ve;
    if (V) {
      n.showLoader(l?.hideLoaderAnimation !== !0), Ve = await ja({
        chartConfig: S,
        queryObject: O,
        options: l,
        currentChartData: w(e.uid, "data"),
        currentSelectionOIDs: w(e.uid, "currentSelectionOIDs"),
        currentSelectionDataItems: w(e.uid, "currentSelectionDataItems"),
        binnedServerData: w(e.uid, "binnedServerData"),
        fieldList: E,
        errorStrings: d,
        abortKey: Cu(e)
      });
      const { data: ct, queryConfig: us, valid: Om, count: ll, invalidType: Rm } = Ve;
      de(e.uid, {
        queryConfig: us,
        initialized: !0,
        elementCount: ll,
        boxPlotMeanLinesData: ct !== void 0 && "meanLines" in ct ? ct.meanLines : void 0,
        timeIntervalInfo: ct !== void 0 && "timeIntervalInfo" in ct ? ct.timeIntervalInfo : void 0
      }), Om ? (xi({ data: ct, seriesConfig: S.series, htmlContainer: m.dom }), Cf(o)) : (await Kn({
        chart: e,
        chartModal: o,
        invalidType: Rm,
        elementCount: ll,
        seriesCount: S.series.length,
        chartConfig: S,
        errorStrings: d
      }), n.hideLoader());
    }
    if (e instanceof Ba) {
      const ct = xd(Fa, Be);
      ct.length > 0 && (Yx(e.series, ct), a instanceof Fn && gu({
        chart: e,
        legend: a,
        chartConfig: S,
        hideEmptySeries: l?.hideEmptySeries
      }));
    }
    const pe = Ve?.data ?? w(e.uid, "data"), it = $i(pe), It = e instanceof ti ? Bd(
      Fa,
      Be
    ) : !1;
    (gi || It) && (Ga({
      arrayToSort: it,
      chartConfig: S,
      fieldList: E,
      isTimeBinningSeries: Ha({
        seriesConfig: Uc(r),
        xAxisValueFormatType: Bn(r),
        setTimeBinningInfoWhenNotProvided: l?.setTimeBinningInfoWhenNotProvided
      })
    }), k === b.BoxPlotSeries && yf({
      chart: e,
      chartData: V ? it : pe,
      chartConfig: S
    }), de(e.uid, { fieldList: E }), pe && "dataItems" in pe && (pe.dataItems = it)), (V || gi) && xi({ data: pe, seriesConfig: S.series, htmlContainer: m.dom });
    const oa = Ts({ oldConfig: x, newConfig: S }), Aa = /* @__PURE__ */ new Map();
    S.series.forEach((ct, us) => {
      Aa.set(ct.id, us);
    });
    const Dm = Qi({ chartConfig: S, queryObject: O }), nl = qe(S), sl = Af({
      chart: e,
      data: nl ? pe : it,
      config: S,
      hideEmptySeries: l?.hideEmptySeries ?? A.options.hideEmptySeries
    });
    if (S = sl.updatedConfig, pe && "dataItems" in pe && (V || q)) {
      const ct = await qa({
        data: nl && "meanLines" in pe && pe.meanLines !== void 0 ? pe.meanLines : pe.dataItems,
        chartConfig: S,
        queryObject: O,
        allowColorMatch: Dm
      });
      pe.dataItems = ct.dataItems, de(e.uid, {
        colorMatchApplied: ct.colorMatchApplied,
        rendererFieldNames: ct.rendererFieldNames
      });
    }
    l?.filterBySelection || de(e.uid, { data: pe }), of(e, S.background), cf(e, { title: S.title, subtitle: S.subtitle }), df(e, S.footer), lf({
      root: m,
      chart: e,
      cursorCrosshair: S.cursorCrosshair,
      config: S
    });
    const rl = z(S.series);
    switch (rl) {
      case b.PieSeries: {
        e instanceof ti && await Kx({
          chart: e,
          chartConfig: S,
          options: l,
          data: pe,
          dataWasUpdated: V,
          slicesConfigChangedSinceLastUpdate: oa,
          chartRendererChanged: q,
          sortChanged: gi,
          queryObject: O,
          seriesConfig: S.series,
          loaderHandle: n,
          colorMatchChanged: ie,
          utilsStrings: u,
          errorStrings: d,
          groupOfSlicesUpdateNeeded: It,
          seriesStyleChanged: X
        });
        break;
      }
      case b.HeatSeries:
      case b.BarSeries:
      case b.LineSeries:
      case b.ComboLineAndBarSeries:
      case b.ScatterSeries:
      case b.RadarSeries:
      case b.GaugeSeries:
      case b.HistogramSeries:
      case b.BoxPlotSeries:
      case b.HeatSeries:
        e instanceof Se && await Qx({
          chart: e,
          chartConfig: S,
          options: l,
          data: pe,
          dataWasUpdated: V,
          seriesIndexMapper: Aa,
          updateNeededDetails: W,
          seriesFilteredOut: sl.seriesFilteredOut,
          sortChanged: gi,
          axisLabelsBehaviorChanged: La,
          anyGuideAboveChanged: Z,
          rotationChanged: oe,
          colorMatchChanged: ie,
          seriesStyleChanged: X,
          timeZoneChanged: Fe,
          timeIntervalInfoWasReset: Jt,
          queryObject: O,
          loaderHandle: n,
          utilsStrings: u,
          errorStrings: d
        });
        break;
    }
    e instanceof Ba && bu({
      chart: e,
      chartConfig: S,
      legend: a,
      hideEmptySeries: l?.hideEmptySeries,
      seriesConfig: S.series,
      isHeatChart: rl === b.HeatSeries,
      heatChartLegendUpdatedNeeded: Ue
    }), Ds({ chart: e, actionMode: l?.actionMode, cursorRange: l?.cursorRange }), V || n.hideLoader(), await Ff({ chart: e, chartModal: o, chartConfig: S, data: pe, errorStrings: d }), await Lf({ chart: e, chartModal: o, data: pe, errorStrings: d });
  } else s.updateOptions?.showUIMessages !== !1 && await vf({
    chartModal: o,
    chartConfig: S,
    createMessage: g,
    status: F,
    errorStrings: d
  });
  ea(F, m.dom);
}
async function eC(t) {
  const { chart: e, data: i, chartConfig: a, options: o, queryObject: n, loaderHandle: s, utilsStrings: r, errorStrings: l } = t;
  await Or({ chart: e, chartConfig: a, options: o, utilsStrings: r });
  let c = i, u = !1;
  const d = a.series;
  if (e) {
    const h = i && "dataItems" in i ? i.dataItems : [], y = Nx({
      chart: e,
      data: h,
      seriesConfig: d,
      utilsStrings: r
    });
    y !== void 0 && (u = !0, c = { dataItems: y });
  }
  const m = await xf({
    root: e.root,
    data: c,
    chartConfig: a,
    queryObject: n,
    labelUpdateNeeded: !0,
    usePopupTemplateFieldsInfo: o?.usePopupTemplateFieldsInfo,
    utilsStrings: r
  }), g = c && "dataItems" in c ? c.dataItems : [];
  Wn({ data: g, newChartConfig: a, pieSlicesSymbols: m }), await Zn({
    chart: e,
    chartConfig: a,
    options: o,
    data: c,
    dataWasUpdated: !0,
    pieSlicesSymbols: m,
    queryObject: n,
    loaderHandle: s,
    utilsStrings: r,
    errorStrings: l
  }), xi({
    data: c,
    seriesConfig: d,
    htmlContainer: e.root.dom
  }), Bt({
    data: m,
    htmlContainer: e.root.dom,
    chartId: e.get("id"),
    colorMatchApplied: to(e)
  }), u && de(e.uid, { data: c });
}
async function tC(t) {
  const {
    chart: e,
    data: i,
    chartConfig: a,
    options: o,
    queryObject: n,
    loaderHandle: s,
    seriesIndexMapper: r,
    utilsStrings: l,
    errorStrings: c
  } = t;
  ff(e), mf({
    chart: e,
    scrollbarXConfig: a.axes?.[0]?.scrollbar,
    scrollbarYConfig: a.axes?.[1]?.scrollbar
  }), await tf({ chart: e, chartConfig: a, errorStrings: c }), await af({
    chart: e,
    chartConfig: a,
    queryObject: n,
    axisLabelsBehaviorChanged: [!0, !0],
    data: i,
    timeIntervalInfo: i?.timeIntervalInfo,
    xAxisLabelFormatter: o?.xAxisLabelFormatter,
    yAxisLabelFormatter: o?.yAxisLabelFormatter,
    secondaryYAxisLabelFormatter: o?.secondaryYAxisLabelFormatter,
    guideTooltipFormatter: o?.guideTooltipFormatter,
    gaugeInnerLabelFormatter: o?.gaugeInnerLabelFormatter,
    utilsStrings: l,
    errorStrings: c
  }), await Or({ chart: e, chartConfig: a, options: o, utilsStrings: l }), await Zn({
    chart: e,
    chartConfig: a,
    seriesIndexMapper: r,
    options: o,
    data: i,
    dataWasUpdated: !0,
    timeZoneChanged: !0,
    queryObject: n,
    loaderHandle: s,
    utilsStrings: l,
    errorStrings: c
  });
}
async function iC(t) {
  const { chartContainer: e, chartConfig: i, options: a, globalOptions: o, t9nStrings: n } = t, { errorStrings: s, utilsStrings: r } = n, { layer: l, view: c, createMessage: u } = a ?? {};
  Ux(), e == null && await fa("divNode", s);
  let d;
  i !== void 0 && (hi(i) ? d = i : d = sn({ chartConfig: i, queryObject: l })), d = await an(d, l);
  let m;
  (hi(d) || l !== void 0) && (m = await bo({ chartConfig: d, layer: l, view: c }));
  const g = _x(e);
  $h(g, o?.enableResponsiveFeatures);
  const h = Zx(g, d);
  await qx(h, e);
  let y;
  const p = mS({ root: g, chart: h, options: a }), S = Hx(g);
  Dh(g, o?.useAnimatedCharts);
  const x = await er({
    input: d,
    queryObject: m,
    allowUsingObjectIdStat: a?.allowUsingObjectIdStat
  });
  if (x.valid && !h.isDisposed()) {
    d = Mn(d, e), p.showLoader(a?.hideLoaderAnimation !== !0);
    const v = p.hideLoader, F = U(d.series), T = jt(d);
    de(h.uid, {
      options: a,
      filterBySelection: a?.filterBySelection,
      config: d,
      queryObject: m,
      isNonAggregatedChart: !Pn(F),
      isRotated: T
    }), rf({ root: g, chart: h, config: d }), lf({
      root: g,
      chart: h,
      cursorCrosshair: d.cursorCrosshair,
      config: d
    });
    const { title: k, subtitle: $, footer: O } = d;
    rS(g, h), cf(h, { title: k, subtitle: $ }), lS(h), df(h, O), iS(g, h), of(h, d.background);
    const D = await qt(m, a?.usePopupTemplateFieldsInfo);
    de(h.uid, { fieldList: D });
    const {
      data: R,
      queryConfig: M,
      valid: N,
      invalidType: E,
      count: V
    } = await ja({
      chartConfig: d,
      queryObject: m,
      options: a,
      fieldList: D,
      errorStrings: s,
      abortKey: Cu(h)
    });
    if (!N)
      await Kn({
        chart: h,
        chartModal: S,
        invalidType: E,
        elementCount: V,
        seriesCount: d.series.length,
        chartConfig: i,
        errorStrings: s
      }), p.hideLoader();
    else {
      de(h.uid, {
        options: a,
        queryConfig: M,
        initialized: N,
        elementCount: V,
        boxPlotMeanLinesData: R !== void 0 && "meanLines" in R ? R.meanLines : void 0,
        timeIntervalInfo: R !== void 0 && "timeIntervalInfo" in R ? R.timeIntervalInfo : void 0
      });
      const W = /* @__PURE__ */ new Map();
      d.series.forEach((X, q) => {
        W.set(X.id, q);
      });
      const H = $i(R), Z = qe(d);
      if (d = Af({
        chart: h,
        hideEmptySeries: a?.hideEmptySeries ?? A.options.hideEmptySeries,
        data: Z ? R : H,
        config: d
      }).updatedConfig, R && "dataItems" in R) {
        const X = await qa({
          data: Z && "meanLines" in R && R.meanLines !== void 0 ? R.meanLines : R.dataItems,
          queryObject: m,
          chartConfig: d,
          allowColorMatch: Qi({ chartConfig: d, queryObject: m })
        });
        R.dataItems = X.dataItems, de(h.uid, {
          colorMatchApplied: X.colorMatchApplied,
          rendererFieldNames: X.rendererFieldNames
        });
      }
      de(h.uid, { queryConfig: M, initialized: N, elementCount: V, data: R });
      const oe = U(d.series);
      z(d.series) === b.BoxPlotSeries && oe !== P.BoxPlotMonoField && oe !== P.BoxPlotMonoFieldAndSplitBy && (Ga({ arrayToSort: H, chartConfig: d, fieldList: D }), yf({
        chart: h,
        chartData: H,
        chartConfig: d
      })), xi({ data: R, seriesConfig: d.series, htmlContainer: e }), hS(g, v), h instanceof Se ? await tC({
        chart: h,
        data: {
          ...R,
          dataItems: H,
          // get the updated mean lines data from the memory storage that was sorted earlier
          meanLines: w(h.uid, "boxPlotMeanLinesData")
        },
        chartConfig: d,
        options: a,
        queryObject: m,
        loaderHandle: p,
        utilsStrings: r,
        errorStrings: s
      }) : h instanceof ti && await eC({
        chart: h,
        data: R,
        chartConfig: d,
        options: a,
        queryObject: m,
        loaderHandle: p,
        utilsStrings: r,
        errorStrings: s
      }), h instanceof Ba && (y = Rl({
        chart: h,
        seriesConfig: d.series,
        isHeatChart: z(d.series) === b.HeatSeries
      }), bu({
        chart: h,
        chartConfig: d,
        legend: y,
        hideEmptySeries: a?.hideEmptySeries,
        seriesConfig: d.series
      })), Ds({ chart: h, actionMode: a?.actionMode, cursorRange: a?.cursorRange }), lb(h);
    }
    await Ff({ chart: h, chartModal: S, chartConfig: d, data: R, errorStrings: s }), await Lf({ chart: h, chartModal: S, data: R, errorStrings: s });
  } else
    de(h.uid, { initialized: !1 }), !h.isDisposed() && a?.showUIMessages !== !1 && await vf({
      chartModal: S,
      chartConfig: d,
      createMessage: u,
      status: x,
      errorStrings: s
    });
  ea(x, g.dom);
  function C() {
    gy(h);
  }
  return {
    update: async (v) => {
      y === void 0 && (y = Rl({ chart: h, seriesConfig: v.newChartConfig.series })), await Jx({ chart: h, queryObject: m, legend: y, chartModal: S, loaderHandle: p, updateProps: v });
    },
    dispose: () => jx(g),
    notify: (v, F, T) => Gx({ chartModal: S, chart: h, message: v, heading: F, options: T }),
    resetZoom: C,
    clearSelection: () => Zi({ chart: h }),
    switchSelection: async () => await Wx(h),
    exportImage: async (v) => await ap({ root: g, exportOptions: v }),
    setActionMode: (v, F) => Ds({ chart: h, actionMode: v, cursorRange: F })
  };
}
const yn = /* @__PURE__ */ new Map();
function Mt(t) {
  t !== void 0 && yn.delete(t);
}
function ba(t, e) {
  const i = yn.get(t) ?? {};
  yn.set(t, { ...i, ...e });
}
function ya(t, e) {
  return yn.get(t)?.[e];
}
function aC(t, e) {
  return ya(t, e);
}
function oC(t, e) {
  ba(t, e);
}
function nC(t, e) {
  return ya(t, e);
}
function sC(t, e) {
  ba(t, e);
}
function I(t, e) {
  return ya(t, e);
}
function j(t, e) {
  ba(t, e);
}
function _(t, e) {
  return ya(t, e);
}
function We(t, e) {
  ba(t, e);
}
function nt(t, e) {
  return ya(t, e);
}
function et(t, e) {
  ba(t, e);
}
function rC(t, e) {
  return ya(t, e);
}
function lC(t, e) {
  ba(t, e);
}
function je(t, e) {
  return ya(t, e);
}
function ci(t, e) {
  ba(t, e);
}
const L = {
  ...G
};
async function cC(t = Tn(document.documentElement).t9nLocale) {
  let e = await import("@amcharts/amcharts4/lang/en_US.js");
  switch (t) {
    case "ar":
      e = await import("@amcharts/amcharts4/lang/ar.js");
      break;
    case "bs":
      e = await import("@amcharts/amcharts4/lang/bs_BA.js");
      break;
    case "bg":
      e = await import("../../chunks/bg_BG2.js");
      break;
    case "ca":
      e = await import("@amcharts/amcharts4/lang/ca_ES.js");
      break;
    case "cs":
      e = await import("@amcharts/amcharts4/lang/cs_CZ.js");
      break;
    case "da":
      e = await import("@amcharts/amcharts4/lang/da_DK.js");
      break;
    case "de":
      e = await import("@amcharts/amcharts4/lang/de_DE.js");
      break;
    case "el":
      e = await import("@amcharts/amcharts4/lang/el_GR.js");
      break;
    case "es":
      e = await import("@amcharts/amcharts4/lang/es_ES.js");
      break;
    case "et":
      e = await import("@amcharts/amcharts4/lang/et_EE.js");
      break;
    case "fi":
      e = await import("@amcharts/amcharts4/lang/fi_FI.js");
      break;
    case "fr":
      e = await import("@amcharts/amcharts4/lang/fr_FR.js");
      break;
    case "he":
      e = await import("@amcharts/amcharts4/lang/he_IL.js");
      break;
    case "hr":
      e = await import("@amcharts/amcharts4/lang/hr_HR.js");
      break;
    case "hu":
      e = await import("@amcharts/amcharts4/lang/hu_HU.js");
      break;
    case "id":
      e = await import("@amcharts/amcharts4/lang/id_ID.js");
      break;
    case "it":
      e = await import("@amcharts/amcharts4/lang/it_IT.js");
      break;
    case "ja":
      e = await import("@amcharts/amcharts4/lang/ja_JP.js");
      break;
    case "ko":
      e = await import("@amcharts/amcharts4/lang/ko_KR.js");
      break;
    case "lt":
      e = await import("@amcharts/amcharts4/lang/lt_LT.js");
      break;
    case "lv":
      e = await import("@amcharts/amcharts4/lang/lv_LV.js");
      break;
    case "no":
      e = await import("@amcharts/amcharts4/lang/nb_NO.js");
      break;
    case "nl":
      e = await import("@amcharts/amcharts4/lang/nl_NL.js");
      break;
    case "pl":
      e = await import("@amcharts/amcharts4/lang/pl_PL.js");
      break;
    case "pt-BR":
      e = await import("@amcharts/amcharts4/lang/pt_BR.js");
      break;
    case "pt-PT":
      e = await import("@amcharts/amcharts4/lang/pt_PT.js");
      break;
    case "ro":
      e = await import("@amcharts/amcharts4/lang/ro_RO.js");
      break;
    case "ru":
      e = await import("@amcharts/amcharts4/lang/ru_RU.js");
      break;
    case "sr":
      e = await import("@amcharts/amcharts4/lang/sr_RS.js");
      break;
    case "sk":
      e = await import("@amcharts/amcharts4/lang/sk_SK.js");
      break;
    case "sv":
      e = await import("@amcharts/amcharts4/lang/sv_SE.js");
      break;
    case "th":
      e = await import("@amcharts/amcharts4/lang/th_TH.js");
      break;
    case "tr":
      e = await import("@amcharts/amcharts4/lang/tr_TR.js");
      break;
    case "uk":
      e = await import("@amcharts/amcharts4/lang/uk_UA.js");
      break;
    case "vi":
      e = await import("@amcharts/amcharts4/lang/vi_VN.js");
      break;
    case "zh-CN":
      e = await import("@amcharts/amcharts4/lang/zh_Hans.js");
      break;
    case "zh-HK":
      e = await import("@amcharts/amcharts4/lang/zh_Hant.js");
      break;
    case "zh-TW":
      e = await import("@amcharts/amcharts4/lang/zh_Hant.js");
      break;
  }
  const i = (await qc(t)).customAmchartsStrings;
  return { ...e.default, ...i };
}
function Ot(t) {
  const { type: e, iLocale: i, formatLocale: a = Dn(document.documentElement) } = t;
  let o;
  switch (e) {
    case b.NumberAxisFormat: {
      o = new Ad(), o.language.locale = i, o.intlLocales = a;
      break;
    }
    case b.DateAxisFormat: {
      o = new Fd(), o.language !== void 0 && (o.language.locale = i), o.intlLocales = a;
      break;
    }
  }
  return o;
}
function Os(t) {
  const { axis: e, valueFormat: i, chartType: a } = t, o = rr({
    isXAxis: !0,
    chartType: a,
    valueFormat: i
  }), n = mi(i) && e instanceof ze, s = Lt(i) && e instanceof ve && !(e instanceof ze), r = o && e instanceof lt;
  return !n && !s && !r;
}
function Mr(t, e) {
  let i = typeof e == "number" ? `${e}` : e;
  const a = nt(t.uid, "numberFormatter");
  return a !== void 0 && (i = a(e)), ye(i) && (i = L.htmlEmptyContent), He(i);
}
function dC(t) {
  t.renderer.labels.template.html = L.htmlEmptyContent, t.renderer.labels.template.adapter.add(
    "htmlOutput",
    (i, a) => Mr(t, a?.dataItem?.value ?? i),
    0
  );
}
function Tf(t) {
  const { axis: e, defaultOutput: i, dataItem: a } = t;
  let o = i;
  const n = nt(e.uid, "categoryFormatter"), s = nt(e.uid, "numberFormatter");
  if ((s !== void 0 || n !== void 0) && a instanceof Pa) {
    const r = I(e.chart.uid, "config"), l = I(e.chart.uid, "rendererFieldNames");
    let c = oi({
      value: a.category,
      dataContext: a.dataContext,
      useRendererLabel: yo(r, l),
      config: r
    });
    if (typeof c == "number" && s !== void 0)
      o = s(c);
    else if (n !== void 0) {
      const u = U(r?.series);
      if ([
        P.BoxPlotMonoField,
        P.BoxPlotMultiFields,
        P.BoxPlotMonoFieldAndSplitBy,
        P.BoxPlotMultiFieldsAndSplitBy,
        P.BarAndLineFromFields
      ].includes(u) && typeof c == "string") {
        const g = I(e.chart.uid, "fieldList");
        c = De(g, c);
      }
      let m = si(a.dataContext);
      m === void 0 && (m = c), o = n(c, m);
    }
  }
  return ye(o) && (o = L.htmlEmptyContent), He(o);
}
function uC(t) {
  t.renderer.labels.template.html = L.htmlEmptyContent, t.renderer.labels.template.adapter.add(
    "htmlOutput",
    (i, a) => Tf({
      axis: t,
      defaultOutput: i,
      dataItem: a?.dataItem
    }),
    0
  );
}
function fC(t) {
  const { axis: e, defaultOutput: i, dataItem: a } = t;
  let o = i;
  const n = nt(e.uid, "dateFormatter");
  return n !== void 0 && a instanceof Vn && (o = n(a.value ?? i)), ye(o) && (o = L.htmlEmptyContent), He(o);
}
function mC(t) {
  t.renderer.labels.template.adapter.add(
    "htmlOutput",
    (i, a) => fC({
      axis: t,
      dataItem: a?.dataItem,
      defaultOutput: i
    }),
    0
  ), t.renderer.labels.template.adapter.disableKey("htmlOutput");
}
function gC(t) {
  t.renderer.labels.template.adapter.add(
    "htmlOutput",
    (i) => {
      let a = i;
      const o = nt(t.uid, "fontStyleCallback");
      return o !== void 0 && (a = o(a)), He(a);
    },
    1
  );
}
function hC(t) {
  t instanceof ve && !(t instanceof ze) ? dC(t) : t instanceof lt ? uC(t) : t instanceof ze && mC(t), gC(t);
}
function pC(t) {
  const { axis: e, formatOptions: i, dateAxisFormatter: a } = t;
  if (et(e.uid, { dateFormatter: a }), a === void 0) {
    e.renderer.labels.template.adapter.isEnabled("htmlOutput") && (e.renderer.labels.template.adapter.disableKey("htmlOutput"), e.renderer.labels.each((s) => {
      s.element instanceof ih && s.element.removeChildren();
    }));
    const o = { ...ni(i) }, n = [
      "year",
      "month",
      "day",
      "hour",
      "minute",
      "second"
    ];
    e.timezone !== o.timeZone && (e.setPropertyValue("timezone", o.timeZone), e.chart.validateData()), e.dateFormatter.timezone = o.timeZone, delete o.timeZone;
    for (let s = 0; s < n.length; s += 1) {
      const r = n[s], l = s === 0 ? r : n[s - 1], c = i?.formatPerDateTimeUnit?.[r] ?? o, u = i?.formatPerDateTimeUnit?.[l];
      ka(c) || (e.dateFormats.setKey(r, c), e.periodChangeDateFormats.setKey(r, u ?? c));
    }
    e.dateFormats.getKey("day") || e.dateFormats.setKey("day", L.dayDefaultFormat), e.periodChangeDateFormats.getKey("day") || e.periodChangeDateFormats.setKey("day", L.dayDefaultFormat), e.dateFormats.getKey("week") || e.dateFormats.setKey("week", e.dateFormats.getKey("day") ?? L.weekDefaultFormat), e.periodChangeDateFormats.getKey("week") || e.periodChangeDateFormats.setKey(
      "week",
      e.periodChangeDateFormats.getKey("day") ?? L.weekDefaultFormat
    ), e.invalidateLabels();
  } else
    e.renderer.labels.template.html = L.htmlEmptyContent, e.renderer.labels.template.adapter.enableKey("htmlOutput");
}
function bC(t, e, i, a) {
  const o = Ot({
    type: b.NumberAxisFormat,
    iLocale: e,
    formatLocale: i
  });
  return o.numberFormat = t, (n) => {
    let s = 0;
    return n instanceof Date ? n.toLocaleString(void 0, t) : (s = typeof n != "string" ? n ?? 0 : _c(n, o.intlLocales), a === !0 && t.style === "percent" && (s /= 100), o.format(s));
  };
}
function tc(t) {
  const { axis: e, formatOptions: i, overridePercentMultiplication: a, valueAxisFormatter: o } = t, n = ni(i), s = I(e.chart.uid, "formatLocale");
  et(e.uid, {
    numberFormatter: o ?? bC(
      n,
      e.chart.language.locale,
      s,
      a
    )
  });
}
function yC(t) {
  const { axis: e, formatOptions: i, categoryAxisFormatter: a } = t, o = a !== void 0 ? a : or(i.characterLimit);
  et(e.uid, { categoryFormatter: o });
}
function SC(t) {
  const { axis: e, labelsTextSymbol: i, axisValueFormatter: a } = t, n = I(e.chart.uid, "config")?.horizontalAxisLabelsBehavior;
  if (et(e.uid, { axisLabelsBehavior: n }), a !== void 0)
    et(e.uid, { fontStyleCallback: void 0 });
  else if (nt(e.uid, "fontStyleCallback") === void 0) {
    const s = (r) => {
      const l = nt(e.uid, "axisLabelsBehavior");
      return ft({
        textSymbol: i,
        placeholderString: r,
        format: "html",
        axisLabelsBehavior: l,
        defaults: { maxWidth: e.renderer.labels.template.maxWidth }
      });
    };
    et(e.uid, { fontStyleCallback: s });
  }
}
async function xC(t) {
  const {
    axis: e,
    isXAxis: i,
    formatOptions: a,
    labelsTextSymbol: o,
    overridePercentMultiplication: n,
    chartType: s,
    axisValueFormatter: r,
    errorStrings: l
  } = t, c = rr({
    isXAxis: i,
    chartType: s,
    valueFormat: a
  });
  let u = !1;
  !(e instanceof ze) && Lt(a) ? tc({
    axis: e,
    formatOptions: a,
    overridePercentMultiplication: n,
    valueAxisFormatter: r
  }) : e instanceof ze && mi(a) ? pC({
    axis: e,
    formatOptions: a,
    dateAxisFormatter: r
  }) : e instanceof lt ? Oo(a) || c ? (yC({
    axis: e,
    formatOptions: a,
    categoryAxisFormatter: r
  }), et(e.uid, { numberFormatter: void 0 })) : Lt(a) ? (tc({
    axis: e,
    formatOptions: a,
    overridePercentMultiplication: n,
    valueAxisFormatter: r
  }), et(e.uid, { categoryFormatter: void 0 })) : u = !0 : u = !0, u && await fa("mismatchAxisAndValueFormat", l), SC({ axis: e, labelsTextSymbol: o, axisValueFormatter: r }), e.invalidateLabels();
}
const B = {
  Ready: "ready",
  Hidden: "hidden",
  Shown: "shown",
  Hit: "hit",
  DoubleHit: "doublehit",
  Up: "up",
  SelectEnded: "selectended",
  Over: "over",
  Out: "out",
  SizeChanged: "sizechanged",
  VisibilityChanged: "visibilitychanged",
  PositionChanged: "positionchanged",
  Validated: "validated",
  DataItemsValidated: "dataitemsvalidated",
  Inited: "inited",
  Opened: "opened",
  Closed: "closed",
  ChildAdded: "childadded",
  DataRangeChanged: "datarangechanged",
  LayoutValidated: "layoutvalidated"
};
function Q(t, e) {
  e === !1 && !t.isHiding ? (t.visible = !1, t.hide()) : t.isShowing || (t.visible = !0, t.show());
}
function CC(t, e) {
  for (let i = 0; i < e.length; i += 1) {
    const a = e[i][0], o = e[i][1], n = t.length;
    a >= 0 && a < n && o >= 0 && o < n && t.swap(e[i][0], e[i][1]);
  }
}
function kf(t, e) {
  let i;
  if (t !== void 0 && "rgb" in t && t.rgb !== void 0) {
    const a = t.rgb;
    if (a !== void 0) {
      const { r: o, g: n, b: s } = a;
      i = [o, n, s, 255];
    }
  }
  return i;
}
function sa(t) {
  const e = t ?? [0, 0, 0, 255];
  return new fn({
    a: e[3] / 255,
    b: e[2],
    g: e[1],
    r: e[0]
  });
}
function Oe(t) {
  return t.bullets.values.find(
    (i) => rC(i.uid, "isBulletMarker")
  );
}
function Po(t) {
  return un(t.uid.toString(), Md);
}
function kt(t) {
  return t != null && !t.isDisposed();
}
function Fo(t) {
  return (t.isShowing || t.visible) && !t.isHidden && !t.isHiding && !t.disabled && !t.__disabled;
}
function If(t, e) {
  return t.pixelX < 0 || t.pixelX > e?.plotContainer?.measuredWidth || t.pixelY < 0 || t.pixelY > e?.plotContainer?.measuredHeight;
}
function vC(t) {
  let e;
  return t.baseSprite instanceof ne || t.baseSprite instanceof Le ? e = t.baseSprite : (t instanceof Hg || t instanceof Gg) && (e = t.axis.chart), e;
}
function LC(t) {
  return kf(t.background.fill);
}
function FC(t) {
  const { fill: e, rotation: i, isLinePattern: a, chartBackgroundColor: o } = t;
  let n;
  return a !== !1 ? (n = new Td(), n.width = L.patternLineProperties.width ?? Number.NaN, n.height = L.patternLineProperties.height ?? Number.NaN, n.strokeWidth = L.patternLineProperties.strokeWidth ?? Number.NaN, n.stroke = e, n.rotation = i ?? Number.NaN) : (n = new kd(), n.rectWidth = L.patternRectProperties.rectWidth ?? Number.NaN, n.rectHeight = L.patternRectProperties.rectHeight ?? Number.NaN, n.width = L.patternRectProperties.width ?? Number.NaN, n.height = L.patternRectProperties.height ?? Number.NaN, n.fillOpacity = L.patternRectProperties.fillOpacity ?? Number.NaN, n.strokeWidth = L.patternRectProperties.strokeWidth ?? Number.NaN, n.fill = sa(o), n.stroke = e, n.rotation = i ?? Number.NaN), n;
}
function ic(t) {
  let e = Number.NaN;
  if (typeof t == "number")
    e = t;
  else if (t.includes("%")) {
    const i = Number.parseFloat(t.trim().replace("%", "").trim());
    Number.isFinite(i) && (e = ot(i));
  }
  return e;
}
function AC(t) {
  const { fill: e, style: i, chartBackgroundColor: a } = t;
  let o, n, s = !0;
  switch (i) {
    case dt.Horizontal: {
      n = 0;
      break;
    }
    case dt.Vertical: {
      n = 90;
      break;
    }
    case dt.ForwardDiagonal: {
      n = 45;
      break;
    }
    case dt.BackwardDiagonal: {
      n = 135;
      break;
    }
    case dt.DiagonalCross:
    case dt.Cross: {
      n = 0, s = !1;
      break;
    }
    case dt.Solid:
  }
  return n !== void 0 && (o = FC({ fill: e, rotation: n, isLinePattern: s, chartBackgroundColor: a })), o;
}
function rt(t, e) {
  let i;
  e !== void 0 && (i = sa(e));
  let a = i ?? new fn({ r: 0, g: 0, b: 0, a: 0 });
  if (t != null) {
    const [o, n, s, r] = t;
    a = new fn({ r: o, g: n, b: s, a: r / 255 });
  }
  return a;
}
function wf(t, e = 0) {
  return (t ?? e) % 360;
}
function TC(t, e) {
  return e !== !0 || t?.includes("Dot") === !0 ? "round" : "square";
}
function kC(t, e) {
  let i = "";
  const n = (e ?? 0) / 2, s = 0 - n, r = 0 + n, l = 0 - n, c = 0 + n;
  switch (t) {
    case xt.Circle:
      i = `M ${s},0 a ${n},${n} 0 1,0 ${n * 2},0 a ${n},${n} 0 1,0 ${-n * 2},0`;
      break;
    case xt.Cross:
      i = `M ${s},0 L ${r},0 M 0,${l} L 0,${c} E`;
      break;
    case xt.Diamond:
      i = `M ${s},0 L 0,${l} L ${r},0 L 0,${c} L ${s},0 Z`;
      break;
    case xt.Square:
      i = `M ${s},${c} L ${s},${l} L ${r},${l} L ${r},${c} L ${s},${c} Z`;
      break;
    case xt.Triangle:
      i = `M ${s},${c} L 0,${l} L ${r},${c} L ${s},${c} Z`;
      break;
    case xt.X:
      i = `M ${s},${c} L ${r},${l} M ${s},${l} L ${r},${c} E`;
      break;
  }
  return i;
}
function $f(t, e) {
  let i = "none";
  switch (t ?? e) {
    case se.Justify:
    case se.Center:
      i = "center";
      break;
    case se.Left:
      i = "left";
      break;
    case se.Right:
      i = "right";
      break;
  }
  return i;
}
function Nr(t, e) {
  let i = "middle";
  switch (t ?? e) {
    case se.Right:
      i = "left";
      break;
    case se.Left:
      i = "right";
      break;
    case se.Center:
    case se.Justify:
  }
  return i;
}
function IC(t, e) {
  let i = "none";
  switch (t ?? e) {
    case ee.Baseline:
    case ee.Middle:
      i = "middle";
      break;
    case ee.Top:
      i = "top";
      break;
    case ee.Bottom:
      i = "bottom";
      break;
  }
  return i;
}
function Df(t, e) {
  let i = ee.Middle;
  switch (t ?? e) {
    case ee.Top:
      i = "bottom";
      break;
    case ee.Bottom:
      i = "top";
      break;
    case ee.Baseline:
    case ee.Middle:
    default:
      i = "middle";
      break;
  }
  return i;
}
function wC(t, e) {
  const i = t ?? at.Solid, a = e ?? L.lineWidth, o = {
    [at.Solid]: "none",
    [at.Dot]: [1, a],
    [at.DashDotDot]: [4 * a, a, 1, a, 1, a],
    [at.Dash]: [4 * a, 3 * a],
    [at.DashDot]: [4 * a, 3 * a, 1, 3 * a],
    [at.Null]: "none"
  };
  return (o[i] ?? o[at.Null]).toString();
}
function Of(t, e) {
  const i = {
    stroke: rt(),
    strokeWidth: L.lineWidth,
    strokeDasharray: "",
    strokeLinecap: e !== !0 ? "round" : "square",
    strokeOpacity: Io
  };
  return t != null && (i.stroke = rt(t.color), i.strokeOpacity = 1, t.width !== void 0 && (i.strokeWidth = t.width), t.style !== void 0 && t.style !== at.Null && (i.strokeDasharray = wC(t.style, i.strokeWidth), i.strokeLinecap = TC(t.style, e))), i;
}
function Rf(t, e) {
  let i = t;
  const [a, o, n, s] = t?.color ?? e ?? L.color, r = [a, o, n, s];
  return i == null ? i = { type: te.SLS, color: r } : i.color === void 0 && (i.color = r), Of(i, !1);
}
function $C(t, e) {
  const { color: i, outline: a, style: o } = t, n = rt(i);
  return {
    pattern: AC({ fill: n, style: o, chartBackgroundColor: e }),
    fill: n,
    outline: Rf(a, i)
  };
}
function DC(t) {
  const { color: e, outline: i, xoffset: a, yoffset: o, style: n, size: s, angle: r } = t, l = n !== void 0 ? kC(n, s) : "", c = wf(r);
  return {
    path: l,
    fill: rt(e),
    outline: Rf(i, e),
    xOffset: a ?? 0,
    yOffset: o ?? 0,
    angle: c
  };
}
function Pr(t) {
  const { symbol: e, defaultToColorFromRamp: i, colorRampIndex: a, isChartFillSymbol: o = !1, chartBackgroundColor: n } = t;
  let s;
  if (i === !0) {
    const r = o ? kn : Io;
    if (e.color = e.color ?? ai({ colorIndex: a, opacity: r }), ln(e) || $a(e)) {
      const { outline: l } = e;
      l !== void 0 && (l.color = l?.color ?? ai({ colorIndex: a }), e.outline = { ...l });
    }
  }
  return $a(e) && (e.style ??= L.lineMarker.markerStyle, e.size ??= L.lineMarker.markerSize), Kc(e) ? s = Of(e, !0) : $a(e) ? s = DC(e) : ln(e) && (s = $C(e, n)), s;
}
function Sn(t, e, i) {
  const a = Nr(t.horizontalAlignment, i?.horizontalCenter), o = $f(t.horizontalAlignment, i?.align), n = Df(t.verticalAlignment, i?.verticalCenter), s = IC(t.verticalAlignment, i?.valign);
  return {
    fill: rt(t.color, L.color),
    fontFamily: t.font?.family ?? "Arial, Helvetica, sans-serif",
    fontSize: t.font?.size ?? L.generalFontSize,
    fontWeight: t.font?.weight ?? "400",
    textDecoration: t.font?.decoration ?? "none",
    align: o,
    valign: s,
    verticalCenter: n,
    horizontalCenter: a,
    text: ft({ textSymbol: t, format: "amChartsV4" }),
    angle: wf(t.angle, i?.rotation),
    xOffset: t.xoffset ?? i?.dx ?? 0,
    yOffset: t.yoffset ?? i?.dy ?? 0,
    backgroundFill: rt(t.backgroundColor),
    borderFill: rt(t.borderLineColor),
    borderWidth: t.borderLineSize ?? 1,
    haloSize: t.haloSize ?? -1,
    haloColor: rt(t.haloColor),
    rtl: t.rightToLeft ?? e,
    wrap: i?.wrap ?? !1,
    maxWidth: i?.maxWidth ?? Number.NaN
  };
}
function Bf(t, e, i) {
  i !== void 0 && t.tooltip !== void 0 && (t.tooltip.getFillFromObject = !1, t.tooltip.background.fill = e), t.fill = i ?? e, t.fillOpacity = zn(t.fill.toString()).alpha === 0 ? 0 : 1;
}
function Da(t, e) {
  t.stroke = e.stroke, t.strokeOpacity = e.stroke.alpha === 0 ? 0 : 1, t.strokeDasharray = e.strokeDasharray, t.strokeLinecap = e.strokeLinecap, t.strokeWidth = e.strokeWidth;
}
function Vr(t) {
  const { element: e, markerSymbol: i, visible: a, defaultToColorFromRamp: o, colorRampIndex: n } = t;
  let s;
  return i !== void 0 ? (s = Pr({
    symbol: { ...i, size: e.minWidth ?? i.size },
    defaultToColorFromRamp: o,
    colorRampIndex: n
  }), s !== void 0 && (e.path = s.path, e.rotation = s.angle, e.dx = s.xOffset, e.dy = s.yOffset, Bf(e, s.fill), Da(e, s.outline)), Q(e, a), e.disabled = a === !1) : e.disabled = !0, s;
}
function Ut(t) {
  const { element: e, lineSymbol: i, visible: a, defaultToColorFromRamp: o, colorRampIndex: n } = t;
  let s;
  return i !== void 0 ? (s = Pr({
    symbol: i,
    defaultToColorFromRamp: o,
    colorRampIndex: n
  }), s !== void 0 && Da(e, s), Q(e, a)) : Q(e, !1), s;
}
function Ao(t) {
  const { element: e, fillSymbol: i, visible: a, defaultToColorFromRamp: o, colorRampIndex: n, isChartFillSymbol: s } = t;
  let r, l;
  if (i !== void 0) {
    if (i.style === dt.Cross || i.style === dt.DiagonalCross) {
      const c = vC(e);
      c !== void 0 && (l = LC(c));
    }
    r = Pr({
      symbol: i,
      defaultToColorFromRamp: o,
      colorRampIndex: n,
      isChartFillSymbol: s,
      chartBackgroundColor: l
    }), r !== void 0 && (Bf(e, r.fill, r.pattern), Da(e, r.outline)), e.disabled = a === !1;
  } else
    e.disabled = !0;
  return r;
}
function Ai(t) {
  const { element: e, seriesIndex: i, colorMatch: a, seriesSymbol: o, isChartFillSymbol: n, rendererSymbol: s, seriesConfig: r } = t;
  let l, c;
  a === !0 && s && (l = Jc({
    rendererSymbol: s,
    seriesSymbol: o,
    colorIndex: i
  }));
  const u = {
    element: e,
    defaultToColorFromRamp: !0,
    colorRampIndex: i,
    seriesConfig: r
  }, d = l ?? { ...o };
  switch (o.type) {
    case te.SLS:
      c = Ut({
        ...u,
        lineSymbol: d
      });
      break;
    case te.SFS:
      c = Ao({
        ...u,
        fillSymbol: d,
        isChartFillSymbol: n
      });
      break;
    case te.SMS:
      c = Vr({
        ...u,
        markerSymbol: d
      });
      break;
  }
  return { symbolWithColorInfo: d, stylingInfo: c };
}
function ac(t, e) {
  if (e !== void 0) {
    const i = t.properties, { elementColor: a, elementOutlineColor: o, elementOutlineWidth: n, rotation: s, transformation: r } = e, { opacity: l, scale: c } = r ?? {};
    a !== void 0 && (i.fill = sa(a), i.fillOpacity = zn(i.fill.toString()).alpha === 0 ? 0 : 1), o !== void 0 && (i.stroke = sa(o)), n !== void 0 && (i.strokeWidth = n), s !== void 0 && (i.rotation = s), c !== void 0 && (i.scale = c), l !== void 0 && (i.fillOpacity = (i.fillOpacity ?? 1) * l, i.strokeOpacity = (i.strokeOpacity ?? 1) * l);
  }
}
function OC(t, e) {
  const i = L.cursorCrosshair.style, a = {
    type: te.SLS,
    style: e.style ?? i.style,
    color: e.color ?? i.color,
    width: e.width ?? i.width
  };
  Ut({ element: t.cursor.lineX, lineSymbol: a }), Ut({ element: t.cursor.lineY, lineSymbol: a });
}
function Mf(t) {
  !(t instanceof yt) && !(t instanceof Le) && (t.cursor = new vd());
}
function Nf(t, e) {
  if (!(t instanceof yt) && !(t instanceof Le)) {
    const i = t, a = i.cursor ?? new vd();
    e?.style !== void 0 && OC(i, e.style);
    const o = L.cursorCrosshair;
    a.lineX.disabled = o.verticalLineVisible ? e?.verticalLineVisible === !1 : e?.verticalLineVisible !== !0, a.lineY.disabled = o.horizontalLineVisible ? e?.horizontalLineVisible === !1 : e?.horizontalLineVisible !== !0, i.cursor = a;
  }
}
function RC(t) {
  return !(t instanceof yt) && t.cursor === void 0 && Mf(t), t.cursor;
}
function Rs(t, e) {
  const i = t.renderer.labels.template;
  i.events.hasListenersByType(B.Hit) && (i.cursorOverStyle = e), t.renderer.labels.each((a) => {
    a.cursorOverStyle = e;
  });
}
function BC(t) {
  const { chart: e, chartType: i, showMean: a, enabled: o } = t, n = o ? Gt.pointer : Gt.default;
  switch (i) {
    case b.HistogramSeries:
    case b.ComboLineAndBarSeries:
    // CT: for combo, we won't have a line with value x-axis
    case b.BarSeries:
    case b.PieSeries:
      e.series.each((s) => {
        (s instanceof Xe || s instanceof Nt) && (s.cursorOverStyle = n);
      });
      break;
    case b.BoxPlotSeries:
      e.series.each((s) => {
        let r = n;
        if (s instanceof ue) {
          const l = Oe(s);
          l !== void 0 && (a && _(s.uid, "isBoxPlotOutliersSeries") && (r = Gt.default), l.cursorOverStyle = r, l.clones.each((c) => {
            c.cursorOverStyle = r;
          }));
        } else
          s.cursorOverStyle = a ? Gt.default : n;
      });
      break;
    case b.LineSeries:
    case b.ScatterSeries:
      e.series.each((s) => {
        if (s instanceof ue && _(s.uid, "isOverlay") !== !0) {
          const r = Oe(s);
          r !== void 0 && (r.cursorOverStyle = n, r.clones.each((l) => {
            l.cursorOverStyle = n;
          }));
        }
      });
      break;
  }
}
function MC(t) {
  const { chart: e, actionMode: i, cursorRange: a } = t, o = I(e.uid, "isRotated"), n = I(e.uid, "config"), s = qe(n), r = z(n?.series), l = r === b.ScatterSeries, c = r === b.LineSeries && Lt(n?.axes?.[0]?.valueFormat), u = r === b.LineSeries && Oo(n?.axes?.[0]?.valueFormat), d = r === b.LineSeries && mi(n?.axes?.[0]?.valueFormat);
  let m, g = !1;
  const h = i ?? I(e.uid, "actionMode") ?? L.actionMode;
  if (I(e.uid, "filterBySelection") === !0)
    m = fe.None, g = !1;
  else if (a !== void 0)
    m = nf({ actionMode: h, cursorRange: a, isRotated: o });
  else
    switch (h) {
      case K.Zoom:
        l || c || d ? m = fe.ZoomXY : m = o === !0 ? fe.ZoomY : fe.ZoomX, g = !1;
        break;
      case K.MultiSelection:
      case K.MultiSelectionWithCtrlKey:
        u ? m = o === !0 ? fe.SelectY : fe.SelectX : m = fe.SelectXY, g = !0;
        break;
      case K.MonoSelection:
        m = fe.None, g = !0;
        break;
      case K.None:
        m = fe.None, g = !1;
        break;
    }
  e instanceof ne && e.cursor !== void 0 && m !== void 0 && (e.cursor.behavior = m), BC({ chart: e, chartType: r, enabled: g, showMean: s });
}
function Pf(t) {
  let e = "";
  return t instanceof Ci ? e = t.dataFields?.categoryX ?? t.dataFields?.dateX ?? t.dataFields?.valueX ?? "" : t instanceof Nt && (e = t.dataFields?.category ?? ""), e;
}
function Vf(t) {
  let e = "";
  return t instanceof Ci ? e = t.dataFields?.categoryY ?? t.dataFields?.dateY ?? t.dataFields?.valueY ?? "" : t instanceof Nt && (e = t.dataFields?.value ?? ""), e;
}
function Ef(t) {
  return I(t.chart.uid, "isRotated") === !0 ? Vf(t) : Pf(t);
}
function aa(t) {
  return I(t.chart.uid, "isRotated") === !0 ? Pf(t) : Vf(t);
}
function Qn(t, e = 0) {
  const i = I(t.chart.uid, "config");
  return z(i?.series, e);
}
function ra(t) {
  const { value: e, valueFormat: i, iLocale: a, formatLocale: o } = t;
  let n = e?.toString();
  const s = Ot({
    type: i.type,
    iLocale: a,
    formatLocale: o
  });
  return typeof e == "number" && i.type === b.NumberAxisFormat ? n = s.format(e, ni(i)) : (typeof e == "number" || e instanceof Date) && i.type === b.DateAxisFormat && (n = s.format(e, ni(i))), n;
}
function Rt(t) {
  const { chart: e, config: i } = t;
  let a = i;
  return i === void 0 && e !== void 0 && (a = I(e.uid, "config")), jt(a);
}
function NC(t) {
  t instanceof Ld && t.series.each((e) => {
    Mt(e.uid), e instanceof ue && Mt(Oe(e)?.uid), e.bullets.each((i) => {
      Mt(i.uid);
    }), e instanceof Xe && e.columns.template.children.each((i) => {
      Mt(i.uid);
    });
  }), t instanceof ne && [t.xAxes.getIndex(0), t.xAxes.getIndex(1), t.yAxes.getIndex(0), t.yAxes.getIndex(1)].forEach(
    (e) => {
      e !== void 0 && (Mt(e.uid ?? ""), e.axisRanges.each((i) => {
        Mt(i.label?.uid);
      }));
    }
  ), t instanceof yt && t.radarContainer.children.each((e) => {
    Mt(e.uid);
  }), t instanceof Le && t.series.getIndex(0)?.slices.each((e) => {
    Mt(e.uid);
  }), "cursor" in t && t.cursor instanceof Xg && Mt(t.cursor?.uid), "legend" in t && t.legend !== void 0 && (Mt(t.legend.uid), Mt(t.legend.valueLabels?.template?.uid)), Mt(t.uid);
}
function Uo(t) {
  return typeof t == "number" ? t : t.value;
}
async function PC(t) {
  const { chart: e, exportOptions: i } = t, { format: a, quality: o = 1, ...n } = i, s = o < 0 || o > 1 ? 1 : o, r = await e.exporting.getImage(a, {
    quality: s,
    ...n
  }), l = Kd(r), c = a === "jpg" ? "image/jpeg" : "image/png";
  return new File([l], `chart.${a}`, { type: c });
}
function Jn(t, e) {
  e !== void 0 && (e.marginBottom !== void 0 && (t.marginBottom = e.marginBottom), e.marginTop !== void 0 && (t.marginTop = e.marginTop), e.marginRight !== void 0 && (t.marginRight = e.marginRight), e.marginLeft !== void 0 && (t.marginLeft = e.marginLeft), e.verticalCenter !== void 0 && (t.verticalCenter = Df(e.verticalCenter)), e.horizontalCenter !== void 0 && (t.horizontalCenter = Nr(e.horizontalCenter)), e.strokeWidth !== void 0 && (t.strokeWidth = e.strokeWidth), e.wrap !== void 0 && (t.wrap = e.wrap), e.truncate !== void 0 && (t.truncate = e.truncate), e.maxWidth !== void 0 && (t.maxWidth = e.maxWidth), e.applyOnClones !== void 0 && (t.applyOnClones = e.applyOnClones, t.background.applyOnClones = e.applyOnClones));
}
function Vt(t, e) {
  const i = e?.createChild(So) ?? new So();
  return Jn(i, t), i;
}
function VC(t) {
  const e = t.push(new ah());
  e.dx = 1, e.dy = 1, e.opacity = 1;
}
function EC(t, e, i) {
  if (i.alpha > 0 && e >= 0) {
    t.length === 0 && VC(t);
    const a = t.getIndex(0);
    a.blur = e, a.color = i;
  } else
    t.clear();
}
function zC(t, e) {
  const i = je(t.uid, "isGuide");
  let a = e.visible === !1;
  return !a && (i === !0 || !(t instanceof lr)) && e.content.text === "" && (a = !0), a;
}
function oc(t) {
  const { label: e, offset: i, offsetProperty: a } = t, o = 99;
  if (e.adapter.remove(a, o), typeof i == "string" && !Number.isFinite(Number(i))) {
    let n = Rn(i);
    n !== void 0 && (n /= 100, e.adapter.add(
      a,
      () => (e.parent?.[a === "dx" ? "measuredWidth" : "measuredHeight"] ?? 0) * n,
      o
    ));
  } else
    e[a] = i;
}
function Tt(t) {
  const { label: e, labelConfig: i, defaults: a, skipSettingText: o } = t;
  if (i !== void 0) {
    const n = Sn(i.content, e.rtl, a);
    e.fill = n.fill, e.fontFamily = n.fontFamily, e.fontWeight = n.fontWeight, e.fontSize = n.fontSize, e.textDecoration = n.textDecoration, e.align = n.align, e.valign = n.valign, e.verticalCenter = n.verticalCenter, e.horizontalCenter = n.horizontalCenter, e.background.fill = n.backgroundFill, e.background.stroke = n.borderFill, e.background.strokeWidth = n.borderWidth, e.rotation = n.angle, oc({ label: e, offset: n.xOffset, offsetProperty: "dx" }), oc({ label: e, offset: n.yOffset, offsetProperty: "dy" }), e.rtl = n.rtl, e.wrap = n.wrap, e instanceof lr || (e.maxWidth = n.maxWidth), o || (e.text = n.text), EC(e.filters, n.haloSize, n.haloColor);
    const s = zC(e, i);
    e.disabled = s, Q(e, i.visible !== !1 && !s);
  } else
    e.disabled = !0;
}
function Er(t, e) {
  e !== void 0 && (t === b.BarSeries || t === b.LineSeries || t === b.HistogramSeries) && e.adapter.add("dy", (i, a) => {
    const o = a.dataItem, { chart: n } = o?.component ?? {};
    return n instanceof ne && (a.visible = !If(a, n)), i ?? 0;
  });
}
function zf(t, e) {
  e !== void 0 && (t === b.BarSeries && e.adapter.add("dx", (i, a) => {
    let o = i ?? 0;
    const n = a.dataItem, { chart: s } = n?.component ?? {};
    return (s !== void 0 ? I(s.uid, "isRotated") : !1) === !0 && (n.valueX ?? n.valueY) < 0 && (o -= a.measuredWidth + L.dataLabelNegative.paddingRight), o;
  }), (t === b.BarSeries || t === b.LineSeries) && e.adapter.add("dy", (i, a) => {
    let o = i ?? 0;
    const n = a.dataItem, { chart: s } = n?.component ?? {};
    return (s !== void 0 ? I(s.uid, "isRotated") : !1) !== !0 && (n.valueX ?? n.valueY) < 0 && (o += a.measuredHeight + L.dataLabelNegative.paddingTop), o;
  }));
}
function Bs(t) {
  t.bulletsContainer.invalidateLabels(), t instanceof Xe && t.columns?.template.invalidateLabels();
}
function Ms(t) {
  const { dataValue: e, series: i, seriesType: a, stackedType: o, axisMin: n } = t;
  let s = e === void 0;
  return e !== void 0 && (n !== void 0 && e < n ? s = !0 : i instanceof Xe && (a === b.BarSeries || a === b.ComboLineAndBarSeries) && (s = e === 0 && o !== void 0 && o !== Ie.Side)), s;
}
function To(t, e) {
  let i;
  const a = (o) => je(o.uid, "isDataLabel") ?? !1;
  return e === "bullets" ? i = t.bullets.values.find(a) : t instanceof Xe && (i = t.columns.template.children.values.find(a)), i;
}
function Ns(t, e) {
  t.adapter.add(
    "htmlOutput",
    (i, a) => {
      let o = i;
      const { dataItem: n } = a;
      if (Fo(t) && (e instanceof Xe && n instanceof Ro || e instanceof ue && n instanceof ta)) {
        const s = _(
          e.uid,
          e instanceof Xe ? "barSeriesDataLabelFormatter" : "lineSeriesDataLabelFormatter"
        );
        if (s !== void 0) {
          const r = I(e.chart.uid, "isRotated"), l = _(e.uid, "stackedType"), c = r === !0 ? n.valueX : n.valueY, u = r === !0 ? n.values?.valueX?.totalPercent : n.values?.valueY?.totalPercent, d = r === !0 ? (n.component?.xAxis).min : (n.component?.yAxis).min;
          o = Ms({
            dataValue: c,
            series: e,
            seriesType: e instanceof Xe ? b.BarSeries : b.LineSeries,
            stackedType: l,
            axisMin: d
          }) ? "" : s(c, u);
        }
      }
      return He(o);
    },
    0
    // 0 = high priority
  );
}
function Wf(t) {
  const { numberFormatter: e, dataLabelsConfigContent: i, stackedType: a } = t;
  return (o, n) => {
    let s = a === Ie.Stacked100 && n !== void 0 ? n : o;
    return e.numberFormat.style === "percent" && (s /= 100), ft({
      textSymbol: {
        ...i,
        text: e.format(s)
      },
      format: "html"
    });
  };
}
function zr(t) {
  t.tabindex = -1;
}
function es(t) {
  const {
    series: e,
    seriesType: i,
    dataLabel: a,
    labelDefaults: o,
    dataLabelsConfig: n,
    yAxisValueFormat: s,
    stackedType: r,
    isRotated: l,
    defaultDataLabelFormatter: c,
    customDataLabelFormatter: u
  } = t;
  if (a !== void 0) {
    let d = u;
    const m = n?.content ?? { type: te.TS };
    if (u === void 0 && c !== void 0 && s?.type === b.NumberAxisFormat) {
      const h = I(e.chart.uid, "formatLocale"), y = Ot({
        type: s.type,
        iLocale: e.chart.language.locale,
        formatLocale: h
      });
      y.numberFormat = s.intlOptions, d = c({
        numberFormatter: y,
        dataLabelsConfigContent: m,
        stackedType: r
      });
    }
    let g;
    switch (i) {
      case b.BarSeries:
        g = "barSeriesDataLabelFormatter";
        break;
      case b.LineSeries:
        g = "lineSeriesDataLabelFormatter";
        break;
      case b.HistogramSeries:
        g = "histogramDataLabelFormatter";
        break;
      case b.ScatterSeries:
        g = "scatterplotDataLabelFormatter";
        break;
    }
    g !== void 0 && We(e.uid, {
      [g]: d
    }), n !== void 0 && (n.content.text = l === !0 ? "{valueX}" : "{valueY}", n.visible = n.visible !== !1), Tt({
      label: a,
      labelConfig: n,
      defaults: o ?? L.dataLabel
    }), Bs(e);
  }
}
function Sa(t, e) {
  let i = e;
  i === void 0 && (i = I(t.uid, "config"));
  const a = I(t.uid, "colorMatchApplied") ?? !1;
  return (i?.colorMatch ?? !1) && a;
}
function Hf(t, e) {
  let i;
  return t instanceof ze ? i = e === !0 ? "dateY" : "dateX" : t instanceof lt ? i = e === !0 ? "categoryY" : "categoryX" : i = e === !0 ? "valueY" : "valueX", i;
}
function Kt(t, e) {
  t.name = e;
}
function Gf(t) {
  const { axes: e, currentSeries: i, tooltipValueFormat: a } = t, o = e[1].valueFormat, n = e[0].valueFormat, s = I(i.chart.uid, "formatLocale");
  if (o?.type === b.NumberAxisFormat) {
    const r = Ot({
      type: o.type,
      iLocale: i.chart.language.locale,
      formatLocale: s
    });
    r.numberFormat = o.intlOptions, We(i.uid, {
      tooltipValueYNumberFormatCallback: (l) => r.format(l, a?.intlOptions)
    });
  }
  if (n?.type === b.NumberAxisFormat) {
    const r = Ot({
      type: n.type,
      iLocale: i.chart.language.locale,
      formatLocale: s
    });
    r.numberFormat = n.intlOptions, We(i.uid, {
      tooltipValueXNumberFormatCallback: (l) => r.format(l, a?.intlOptions)
    });
  }
}
function ts(t) {
  const { chart: e, lineSeries: i, applyPropertiesToClones: a } = t, o = i.bullets.push(new ur());
  return lC(o.uid, { isBulletMarker: !0 }), a !== !1 && (o.applyOnClones = !0), i.bulletsContainer.parent = e.seriesContainer, o;
}
function Wr(t) {
  const { series: e, seriesConfig: i, rotationChanged: a, stackedType: o, isRotated: n } = t;
  switch (o) {
    case Ie.Stacked: {
      e.stacked = !0, e instanceof ue && (e.stackToNegative = i.stackNegativeValuesToBaseline ?? L.lineSeries.stackNegativeValuesToBaseline), a === n ? e.dataFields.valueYShow = void 0 : e.dataFields.valueXShow = void 0, e.updateStacking();
      break;
    }
    case Ie.Stacked100: {
      e.stacked = !0, n ? e.dataFields.valueXShow = "totalPercent" : e.dataFields.valueYShow = "totalPercent", e.updateStacking();
      break;
    }
    case Ie.Side:
    default: {
      e.stacked = !1, a === n ? e.dataFields.valueYShow = void 0 : e.dataFields.valueXShow = void 0;
      break;
    }
  }
}
function WC(t) {
  return () => {
    const { chart: e, marker: i } = t;
    i.clones.each((a) => {
      Q(a, !If(a, e));
    });
  };
}
function Xf(t) {
  const { chart: e, series: i, seriesType: a, marker: o, numberOfChartSeries: n, ignoreSmoothRenderingLimit: s } = t;
  let r = WC({ marker: o, chart: e });
  const l = n ?? 1, c = e.data.length * l + l;
  s !== !0 && c > L.elementLimitForSmoothRendering && (r = Ye(r, L.debounceTime)), e.xAxes.getIndex(0)?.events.on(B.Validated, r), e.yAxes.getIndex(0)?.events.on(B.Validated, r), a === b.LineSeries && (e.xAxes.getIndex(0)?.events.on(B.Validated, () => {
    Bs(i);
  }), e.yAxes.getIndex(0)?.events.on(B.Validated, () => {
    Bs(i);
  }));
}
function Yf(t, e) {
  t.series.each((i) => {
    const a = _(i.uid, e);
    a !== void 0 && !a.isDisposed() && a.dispose();
  });
}
function HC(t) {
  let e;
  return t !== void 0 && t.series.length > 0 && (e = t.series.values.map((i) => i.visible ? i.id : "").filter((i) => i !== "")), e;
}
function Ss(t) {
  const { dataItem: e, y: i, splitBy: a, showOutliers: o } = t, n = be({ key: J.Min, y: i, splitBy: a, showOutliers: o }), s = be({ key: J.Max, y: i, splitBy: a, showOutliers: o }), r = be({ key: J.FirstQuartile, y: i, splitBy: a, showOutliers: o }), l = be({ key: J.ThirdQuartile, y: i, splitBy: a, showOutliers: o });
  return Number.isFinite(e[n]) && Number.isFinite(e[s]) && Number.isFinite(e[r]) && Number.isFinite(e[l]);
}
function GC(t, e) {
  let i = !1;
  if (e !== void 0) {
    const a = be({ key: J.Average, splitBy: e });
    i = Number.isFinite(t[a]);
  }
  return i;
}
function XC(t, e) {
  let i = 0;
  if (t !== void 0 && e !== void 0) {
    const a = wi(e.series), o = U(e.series), n = Oi(e);
    t.data.forEach((s) => {
      switch (o) {
        case P.BoxPlotMonoField:
        case P.BoxPlotMultiFields:
        case P.BoxPlotMonoFieldAndCategory:
          Ss({ dataItem: s, showOutliers: n }) && (i += 1);
          break;
        case P.BoxPlotMultiFieldsAndCategory:
          a.forEach((r) => {
            Ss({ dataItem: s, y: r, showOutliers: n }) && (i += 1);
          });
          break;
        case P.BoxPlotMonoFieldAndSplitBy:
        case P.BoxPlotMultiFieldsAndSplitBy:
        case P.BoxPlotMonoFieldAndCategoryAndSplitBy:
          e.series.forEach((r) => {
            Ss({ dataItem: s, splitBy: r.query?.where, showOutliers: n }) && (i += 1);
          });
          break;
      }
    });
  }
  return i;
}
function nc() {
  return (t) => {
    const e = I(t.chart.uid, "config");
    let i = !1;
    if (e !== void 0 && t instanceof Ci) {
      const a = XC(t.chart, e);
      let o = 0, n = 0, s = 0, r = 0, l = 0;
      t.chart.series.values.forEach((d) => {
        if (d instanceof _e)
          o += d.columns.length;
        else if (d instanceof ue && !(d instanceof vt)) {
          const m = Oe(d);
          if (m !== void 0 && !m.disabled) {
            const g = m.clones.values.filter((h) => !(h.dataItem instanceof ia))?.length ?? 0;
            if (_(d.uid, "isBoxPlotMeanLineSeries") === !0) {
              r += g;
              const h = d.data.filter(
                (y) => Number.isFinite(y[d.dataFields.valueX ?? d.dataFields.valueY ?? ""])
              ).length;
              l += h;
            } else {
              const h = d.data.filter(
                (y) => Number.isFinite(y[d.dataFields.valueX ?? d.dataFields.valueY ?? ""])
              ).length;
              s += h, n += g;
            }
          }
        }
      });
      const c = s === 0 || n >= s, u = l === 0 || r >= l;
      i = o >= a && c && u && t.chart.appeared && t.isReady() && t.chart.isReady();
    }
    return i;
  };
}
function YC(t, e) {
  let i;
  switch (t) {
    case b.BarSeries:
      i = (a, o) => {
        if (a instanceof Xe) {
          const n = Rt({ chart: a.chart });
          let s = 0;
          if (o.type === b.BarSeries) {
            const r = (n ? a.dataFields.valueX : a.dataFields.valueY) ?? o.y;
            s = a.chart?.data?.filter(
              (l) => Number.isFinite(l[r])
            ).length;
          }
          return a.chart.isReady() && a.columns.length === s;
        }
        return !1;
      };
      break;
    case b.LineSeries:
      e === !0 ? i = nc() : i = (a, o) => {
        if (a instanceof ue) {
          const n = Rt({ chart: a.chart }), s = Oe(a);
          let r = 0;
          if (o.type === b.LineSeries) {
            const { y: l } = o, c = (n ? a.dataFields.valueX : a.dataFields.valueY) ?? [l].flat()[0];
            r = a.chart?.data?.filter(
              (u) => Number.isFinite(u[c])
            ).length;
          }
          return a.chart.appeared && a.chart.isReady() && s !== void 0 && s.clones.values.length >= r;
        }
        return !1;
      };
      break;
    case b.PieSeries:
      i = (a) => a instanceof Nt && a.slices.length > 0;
      break;
    case b.ScatterSeries:
      i = (a) => {
        const o = a instanceof ue ? Oe(a) : void 0, n = _(a.uid, "isOverlay") === !0;
        return a.chart.appeared && a.chart.isReady() && (n || o !== void 0 && a.chart.data.length === o.clones.length);
      };
      break;
    case b.HistogramSeries:
      i = (a) => a instanceof Xe && a.columns.length > 0;
      break;
    case b.BoxPlotSeries:
      i = nc();
      break;
  }
  return i;
}
function Uf(t) {
  const { series: e, callbackInfo: i, seriesConfig: a, onReadyEvent: o } = t, { type: n } = i, s = z([a]), r = _(e.uid, "isBoxPlotMeanLineSeries"), l = n === "style" ? "updateStyleCallbackDisposer" : "updateSelectionCallbackDisposer", c = async (g) => {
    const { type: h, callbackProps: y } = g;
    h === "selection" ? $L(y) : g.styleCallback !== void 0 && (Q(e, a.visible), await g.styleCallback(y));
  };
  o === !0 && e.events.once(B.Ready, async () => await c(i));
  let u = _(e.uid, l);
  u !== void 0 && u.dispose();
  const d = YC(s, r);
  u = (s === b.PieSeries ? e.chart : e).events.on(B.Validated, async () => {
    d !== void 0 && d(e, a) && (u !== void 0 && u.dispose(), await c(i));
  }), e.dispatchImmediately(B.Validated), We(e.uid, { [l]: u });
}
function la(t) {
  const { series: e, styleCallback: i, callbackProps: a, onReadyEvent: o, seriesConfig: n } = t;
  Uf({
    callbackInfo: { styleCallback: i, callbackProps: a, type: "style" },
    series: e,
    seriesConfig: n,
    onReadyEvent: o
  });
}
function UC(t) {
  const { series: e, callbackProps: i, seriesConfig: a, onReadyEvent: o } = t;
  Uf({
    callbackInfo: { callbackProps: i, type: "selection" },
    series: e,
    seriesConfig: a,
    onReadyEvent: o
  });
}
function Vi(t) {
  const { defaultChartItemRole: e } = L.aria;
  t instanceof _e || t instanceof Xe ? (t.columns.template.properties.role = e, t.columns.template.focusable = !0, t.columns.template.hoverOnFocus = !0, t.itemReaderText = dn()) : t instanceof vt ? t.segments.template.properties.role = e : t instanceof ue ? t.bullets.values.forEach((i) => {
    i.focusable = !0, i.properties.role = e, i.readerTitle = dn(), i.hoverOnFocus = !0;
  }) : t instanceof Nt && (t.slices.template.properties.role = e, t.slices.template.hoverOnFocus = !0, t.itemReaderText = "{category} {value.formatNumber('#.#')} {value.percent.formatNumber('#.#')}%");
}
function jC(t) {
  const e = I(t.uid, "config");
  t.series.each((i) => {
    const a = e?.series?.find((o) => o.id === i.id);
    a !== void 0 && a.visible !== !1 && !i.visible && Q(i);
  });
}
function is(t, e) {
  const i = z(e?.series);
  return e?.series.find((a) => {
    let o = !1;
    return i !== b.BoxPlotSeries || t instanceof _e ? o = t.id === a.id : t instanceof vt ? o = t.id.replace(`_${me.Top}`, "") === a.id || t.id.replace(`_${me.Median}`, "") === a.id || t.id.replace(`_${me.Bottom}`, "") === a.id : t instanceof ue && (o = t.id.replace(`_${me.Outliers}`, "") === a.id), o;
  });
}
function qC(t, e) {
  let i = !1;
  if (e !== void 0 && Fo(t)) {
    const a = Id.spriteRectToSvg(t.bbox, t), o = e.x, n = e.y, s = e.x + e.width, r = e.y + e.height, l = a.x, c = a.y, u = a.x + a.width, d = a.y + a.height;
    i = !(l > s || u < o || c > r || d < n);
  }
  return i;
}
function Ei(t) {
  const { element: e, customSelectionTheme: i, useNativeState: a } = t, o = a === !0 ? st.Active : st.CustomActive, n = e.states.getKey(o) ?? e.states.create(o), s = e.states.getKey(st.CustomInactive) ?? e.states.create(st.CustomInactive), { selectedElementsTheme: r, nonSelectedElementsTheme: l } = i ?? L.selectionTheme ?? {};
  ac(n, r), ac(s, l);
}
function Et(t) {
  const { element: e, selected: i, multiSelect: a, isDateOrCategoryAxis: o, useNativeState: n, backToDefaultState: s } = t;
  if (e !== void 0) {
    let r = e.isActive;
    a !== !0 ? o === !0 ? r = e.isActive ? !1 : e.isActive !== i : r = i : r = e.isActive !== i, r !== e.isActive && (e.isActive = r);
    const l = n === !0 ? st.Active : st.CustomActive, c = s === !0 ? st.Default : st.CustomInactive;
    e.setState(e.isActive ? l : c, 0);
  }
  return e?.isActive ?? !1;
}
function as(t, e) {
  let i = !1;
  if (e instanceof ne || e instanceof Le) {
    const a = I(e.uid, "actionMode");
    a !== void 0 && (i = a === K.MultiSelection || a === K.MultiSelectionWithCtrlKey && (t?.event?.ctrlKey || t?.event?.metaKey));
  }
  return i;
}
function jf(t) {
  const e = I(t.uid, "config"), i = qe(e), a = t instanceof ne && t.zoomOutButton.isHover, o = t.legend.isHover;
  let n = !1, s = !1, r = !1, l = !1;
  return t instanceof ne && (n = t.xAxes.values.some(
    (c) => c.renderer.labels.template.events.has(B.Hit) && c.renderer.isHover
  ), s = t.yAxes.values.some(
    (c) => c.renderer.labels.template.events.has(B.Hit) && c.renderer.isHover
  ), r = n || s, i && (l = t.series.values.find((u) => u instanceof _e)?.isHover ?? !1)), !a && !o && !r && !l;
}
function Hr(t, e) {
  return t.values.filter((i) => {
    let a = !1;
    const o = !i.isActive;
    if (!(i.dataItem instanceof ia)) {
      i.isActive = !i.isActive;
      const s = I(e.uid, "filterBySelection") !== !0 && o;
      Et({ element: i, selected: s }), a = o;
    }
    return a;
  });
}
function sc(t, e) {
  let i = [];
  const { columns: a, chart: o } = t, n = I(o.uid, "config");
  if (n && a !== void 0 && t.visible) {
    const s = n?.series[0].x, r = t?.dataFields?.customValue ?? "", l = Qn(t, e), c = is(t, n), u = l === b.BoxPlotSeries ? c?.y : aa(t), d = {
      element: {},
      yAxisField: u,
      xAxisField: s,
      splitBy: r,
      seriesIndex: e,
      chartConfig: n
    };
    l === b.HistogramSeries && e === 0 && (d.xAxisField = r), i = Hr(a, o).map(
      (m) => ({
        ...d,
        element: m,
        elementDataContext: m.dataItem?.dataContext,
        elementIndex: m.dataItem?.index
      })
    );
  }
  return i;
}
function rc(t, e) {
  let i = [];
  if (t.visible) {
    const a = Oe(t)?.clones;
    if (a !== void 0) {
      const { chart: o } = t, n = I(o.uid, "config");
      if (n) {
        const s = z(n.series, e), r = n.series[0].x ?? "", l = aa(t), c = t?.dataFields?.customValue ?? "", u = {
          element: {},
          xAxisField: r,
          yAxisField: l,
          splitBy: c,
          uniqueFeature: s === b.ScatterSeries,
          // a line series marker can be aggregated
          seriesIndex: e,
          chartConfig: n
        };
        i = Hr(a, o).map(
          (d) => ({
            ...u,
            element: d,
            elementDataContext: d.dataItem?.dataContext,
            elementIndex: d.dataItem?.index
          })
        );
      }
    }
  }
  return i;
}
function _C(t) {
  let e = [];
  if (t.visible) {
    const { chart: i } = t, a = I(i.uid, "config");
    if (a) {
      const o = Ef(t), n = aa(t), s = {
        element: {},
        xAxisField: o,
        yAxisField: n,
        seriesIndex: 0,
        chartConfig: a
      };
      let r;
      e = Hr(t.slices, i).map(
        (l) => {
          const c = l.dataItem?.dataContext ?? {};
          return Di(c) && (r = Bo({
            groupOfSlicesDataContext: c
          })), {
            ...s,
            element: l,
            elementIndex: l.dataItem?.index,
            elementDataContext: c
          };
        }
      ), r !== void 0 && r.forEach((l, c) => {
        e.push({
          ...s,
          elementIndex: c,
          elementDataContext: l
        });
      });
    }
  }
  return e;
}
function ZC(t) {
  const { chart: e, selectionSource: i, chartConfig: a } = t, o = qe(a);
  let n = [];
  if (z(a?.series) === b.BoxPlotSeries) {
    if (n = e.series.values.filter((s) => !(s instanceof vt)), i === Ne.SelectionByClick) {
      const s = /* @__PURE__ */ new Set(), r = n.find(
        (l) => l instanceof _e && l.isHover
      );
      r === void 0 ? n.forEach((l) => {
        l instanceof ue && (l.id.includes(me.Outliers) && l.tooltip?.visible === !0 || _(l.uid, "isBoxPlotMeanLineSeries")) && s.add(l);
      }) : s.add(r), n = Array.from(s);
    }
  } else
    n = e.series.values;
  return n = n.filter(
    (s) => s.visible && _(s.uid, "isOverlay") !== !0 && (!o || !(s instanceof _e || _(s.uid, "isBoxPlotOutliersSeries")))
  ), n;
}
async function qf(t) {
  const { chart: e, cursorSelectionRectangle: i, multiSelect: a, selectionSource: o, hitElement: n } = t, s = I(e.uid, "config"), r = s?.series[0]?.x ?? "";
  let l = [];
  j(e.uid, { pendingSelectionQueries: !0 });
  let c = [], u = !0;
  ZC({
    chart: e,
    selectionSource: o,
    chartConfig: s
  }).forEach((m, g) => {
    const h = is(m, s);
    if (s && m.visible && _(m.uid, "isOverlay") !== !0 && m instanceof Ci) {
      const y = Qn(m, g), p = y === b.BoxPlotSeries ? h?.y : aa(m), S = m.dataFields?.customValue ?? "", x = {
        element: {},
        yAxisField: p,
        xAxisField: r,
        splitBy: S,
        seriesIndex: g,
        chartConfig: s
      };
      let C;
      m instanceof Xe || m instanceof _e ? (C = m.columns?.values, y === b.HistogramSeries && (x.xAxisField = S)) : m instanceof vt ? C = m.segments.values : m instanceof ue && (C = Oe(m)?.clones?.values, x.uniqueFeature = !0), C !== void 0 && (c = [...c, ...C], C.forEach((v, F) => {
        if (!(v.dataItem instanceof ia)) {
          const T = v.isActive, k = v === n || qC(v, i);
          k && (u = !1);
          let $ = !1;
          T ? k ? $ = o !== Ne.SelectionByClick : $ = a === !0 : $ = k, $ && l.push({
            ...x,
            element: v,
            elementDataContext: v.dataItem?.dataContext,
            elementIndex: F
          }), Et({ element: v, selected: $ });
        }
      }));
    }
  }), u && (l = []), await Wo({
    chart: e,
    listSelectedElements: l,
    selectionSource: o
  });
}
function KC(t) {
  const e = async (i) => {
    const a = i.target.cursor;
    if (a.xRange !== void 0) {
      a.selection.isMeasured = !0, a.validate(), a.selection.validate();
      const o = Id.spriteRectToSvg(
        a.selection.bbox,
        a.selection
      );
      if (a.selection.hide(), o.width > 0 || o.height > 0) {
        const n = as(i, t);
        await qf({
          chart: t,
          cursorSelectionRectangle: o,
          multiSelect: n,
          selectionSource: Ne.SelectionByRange
        });
      }
    }
    a.selection.hide();
  };
  kt(t) && t.events.on(B.Up, async (i) => {
    const a = i.target.cursor, o = aC(t.uid, "selectEndedCallbackDisposer");
    if (o !== void 0 && o.dispose(), a.xRange !== void 0 && i.event instanceof TouchEvent)
      await e(i);
    else {
      const n = a.events.once(B.SelectEnded, async () => {
        await e(i);
      });
      oC(t.uid, {
        selectEndedCallbackDisposer: n
      });
    }
  });
}
async function xn(t, e) {
  const { target: i } = t, a = I(e.uid, "actionMode");
  if (e !== void 0 && jf(e) && a !== K.None && a !== K.Zoom && (i instanceof ne || t.point === void 0)) {
    const o = t.svgPoint ? { x: t.svgPoint.x, y: t.svgPoint.y, width: 0, height: 0 } : void 0, n = as(t, e);
    await qf({
      chart: e,
      cursorSelectionRectangle: o,
      multiSelect: n,
      selectionSource: Ne.SelectionByClick,
      hitElement: i
    });
  }
}
function QC(t) {
  kt(t) && (t.zoomOutButton.hoverable = !0, t.events.on(B.Hit, async (e) => await xn(e, t)), t.events.on(B.DoubleHit, async (e) => await xn(e, t)));
}
function xa(t, e) {
  e.events.on(B.Hit, async (i) => await xn(i, t)), e.events.on(B.DoubleHit, async (i) => await xn(i, t));
}
async function JC(t) {
  const { series: e } = t;
  if (e.length > 0) {
    j(t.uid, { pendingSelectionQueries: !0 });
    const i = I(t.uid, "config"), o = e.values.map(
      (n, s) => {
        let r = [];
        if (n.visible && _(n.uid, "isOverlay") !== !0) {
          const l = z(i?.series, s);
          l === b.BarSeries || l === b.HistogramSeries ? r = sc(n, s) : l === b.LineSeries || l === b.ScatterSeries && _(n.uid, "isOverlay") !== !0 ? r = rc(n, s) : l === b.PieSeries ? r = _C(n) : l === b.BoxPlotSeries && (n instanceof _e ? r = sc(n, s) : n instanceof ue && !(n instanceof vt) && (r = rc(n, s)));
        }
        return r;
      }
    ).flat();
    await Wo({
      chart: t,
      listSelectedElements: o,
      selectionSource: Ne.ProgrammaticSelection
    }), t instanceof Le && t.feedLegend();
  }
}
function xs(t) {
  if (kt(t))
    if (t.events.disableType(B.Hit), t.events.disableType(B.DoubleHit), t instanceof Le) {
      const e = t.series.getIndex(0);
      e !== void 0 && (e.slices.template.clickable = !1, e.slices.template.togglable = !1, e.slices.template.events.disableType(B.Hit), e.slices.template.events.disableType(B.DoubleHit), e.labels.template.clickable = !1, e.labels.template.togglable = !1, e.labels.template.events.disableType(B.Hit), e.labels.template.events.disableType(B.DoubleHit));
    } else t instanceof ne && (t.xAxes.each((e) => Cn(e, !0)), t.yAxes.each((e) => Cn(e, !0)), t.events.disableType(B.Up));
}
function ev(t) {
  if (kt(t))
    if (t.events.enableType(B.Hit), t.events.enableType(B.DoubleHit), t instanceof Le) {
      const e = t.series.getIndex(0);
      e !== void 0 && (e.slices.template.clickable = !0, e.slices.template.togglable = !0, e.slices.template.events.enableType(B.Hit), e.slices.template.events.enableType(B.DoubleHit), e.labels.template.clickable = !0, e.labels.template.togglable = !0, e.labels.template.events.enableType(B.Hit), e.labels.template.events.enableType(B.DoubleHit));
    } else t instanceof ne && (t.xAxes.each((e) => Cn(e, !1)), t.yAxes.each((e) => Cn(e, !1)), t.events.enableType(B.Up));
}
function di(t) {
  const { element: e, stylingInfo: i, stateKey: a = "default" } = t;
  if (e !== void 0 && i !== void 0) {
    const o = e.states.getKey(a)?.properties ?? e.defaultState.properties;
    if (o.fill = i.pattern ?? i.fill, o.fillOpacity = zn(o.fill.toString()).alpha === 0 ? 0 : 1, i.outline !== void 0) {
      const { outline: n } = i;
      o.stroke = n.stroke, o.strokeOpacity = n.stroke.alpha === 0 ? 0 : 1, o.strokeDasharray = n.strokeDasharray, o.strokeLinecap = n.strokeLinecap, o.strokeWidth = n.strokeWidth;
    }
  }
}
function tv(t, e) {
  const i = new fr();
  return i.width = ot(100), i.height = ot(100), i.background.fill = rt(e ?? L.loaderBackground), i.parent = t, i;
}
function iv(t) {
  const e = new So();
  return e.valign = ee.Middle, e.align = se.Center, e.fontSize = L.loaderLabelFontSize, e.dy = 40, e.text = "", e.parent = t, e;
}
function av(t, e) {
  const i = new wd();
  return i.parent = t, i.align = se.Center, i.valign = ee.Middle, i.path = "M2.2 16A13.81 13.81 0 0 1 14 2.362v1.01a12.8 12.8 0 1 0 4 0v-1.01A13.792 13.792 0 1 1 2.2 16z", i.stroke = rt(e ?? L.loaderSpinnerColor), i.strokeWidth = 2, i;
}
function ov(t) {
  return window.setInterval(() => {
    t.animate({ from: 0, to: 360, property: "rotation" }, L.loaderRotationSpeed);
  }, L.loaderIntervalTimeout);
}
function nv(t, e) {
  const i = tv(t, e?.loaderColors?.curtainColor);
  return iv(i), { loaderPolygon: av(i, e?.loaderColors?.spinnerColor), loaderContainer: i };
}
function sv(t, e) {
  t.preloader !== void 0 && (t.preloader.disabled = !0);
  let i, a, o;
  if (t.tooltipContainer !== void 0) {
    const c = nv(t.tooltipContainer, e);
    i = c.loaderContainer, a = c.loaderPolygon;
  }
  function n() {
    o !== void 0 && (window.clearInterval(o), o = void 0), i !== void 0 && (Q(i, !1), t instanceof ne && (t.zoomOutButton.disabled = !1));
  }
  function s(c) {
    c && (o === void 0 && a !== void 0 && (o = ov(a)), i !== void 0 && (Q(i), t instanceof ne && (t.zoomOutButton.disabled = !0)));
  }
  return n(), { loaderElements: {
    loaderContainer: i ?? new fr(),
    loaderPolygon: a ?? new wd()
  }, loaderHandle: {
    hideLoader: n,
    showLoader: s
  } };
}
function rv(t, e) {
  const { loaderContainer: i, loaderPolygon: a } = t;
  i !== void 0 && (i.background.fill = rt(
    e?.loaderColors?.curtainColor ?? L.loaderBackground
  )), a !== void 0 && (a.stroke = rt(e?.loaderColors?.spinnerColor ?? L.loaderSpinnerColor));
}
function Vo(t) {
  return t.values.every((i) => i.isReady());
}
function Qt(t, e) {
  t.events.on(B.Ready, () => {
    const { chart: i } = t;
    i !== void 0 && Vo(t.chart.series) && (jC(i), e(), Ua(t.chart.htmlContainer));
  });
}
function _f(t, e) {
  const { dataTooltipStyle: i, dataTooltipStyleReversed: a } = L;
  if (e === !0) {
    const o = t.background.fill;
    if (o !== void 0) {
      t.background.stroke = o, t.background.strokeWidth = a?.outline?.width ?? Number.NaN, t.background.fill = rt(a?.color);
      const n = t.background.fill.rgb;
      if (n !== void 0) {
        const s = t.label.fill;
        t.label.fill = rh(n) ? s?.darkColor : s?.lightColor;
      }
    }
  } else
    t.getStrokeFromObject = !0, t.getFillFromObject = !0, t.background.strokeWidth = i?.outline?.width ?? Number.NaN, t.background.stroke = rt(i?.outline?.color);
}
function Oa(t) {
  const { series: e, callbackName: i, value: a } = t, o = _(e.uid, i);
  return o !== void 0 ? o(a) : a.toString();
}
function lv(t) {
  const e = t.tooltip ?? new $d();
  e.pointerOrientation = "vertical", t instanceof _e || t instanceof vt ? e.label.maxWidth = L.boxPlot.boxPlotTooltipLabelWidth : e.label.maxWidth = L.tooltipWidth, e.label.wrap = !0, e.events.on(B.Shown, (i) => {
    const a = I(t.chart.uid, "config");
    if (a !== void 0) {
      const o = is(t, a), { dataTooltipReverseColor: n } = o ?? {};
      _f(i.target, n);
    }
  });
}
function cv(t) {
  t instanceof yt || t.series.each((e) => {
    _(e.uid, "isOverlay") !== !0 && lv(e);
  });
}
function Zf(t, e) {
  t.tooltipHTML = L.htmlEmptyContent, t.adapter.add("tooltipHTML", (i, a) => {
    let o = i ?? "";
    const { chart: n } = e;
    if (n !== void 0) {
      const s = I(n.uid, "config"), { dataTooltipVisible: r } = s?.series[0] ?? {};
      if (r === !1)
        o = "";
      else {
        const l = _(
          e.uid,
          "barAndLineTooltipFormatter"
        );
        if (l !== void 0 && e.isReady()) {
          const { dataItem: c } = a;
          if (c instanceof Ro || c instanceof ta) {
            const u = s?.series.find((d) => d.id === e.id);
            if (u !== void 0) {
              const d = Rt({ config: s }), m = d ? c.valueX : c.valueY, g = (d ? c.values.valueX.totalPercent : c.values.valueY.totalPercent) / 100, h = c.dataContext ?? {};
              if (h !== void 0) {
                const y = I(n.uid, "rendererFieldNames"), p = oi({
                  value: h[u.x],
                  dataContext: h,
                  useRendererLabel: yo(s, y)
                });
                let S = si(h);
                S === void 0 && (S = p);
                const x = h[L.dateBinningRange];
                o = l({
                  seriesName: e.name,
                  xValue: p,
                  originalXValue: S,
                  dateBinningRange: x,
                  statValue: m,
                  percentValue: g
                });
              }
            }
          }
        }
      }
    }
    return He(o);
  }), t.tooltipPosition = e instanceof ue ? L.markerTooltipPosition : L.columnTooltipPosition, e.cursorTooltipEnabled = !1;
}
function dv(t) {
  const {
    isStacked100: e,
    series: i,
    statValue: a,
    percentValue: o,
    yAxisValueFormat: n,
    dataTooltipValueFormat: s,
    dataTooltipPercentFormat: r
  } = t;
  let l = s;
  l === void 0 && (Lt(n) && n ? (l = n, e && (l.intlOptions.style = "decimal")) : l = Us());
  const c = I(i.chart.uid, "formatLocale"), u = a !== void 0 ? ra({
    value: a,
    valueFormat: l,
    iLocale: i.chart.language.locale,
    formatLocale: c
  }) : "";
  let d = "";
  if (e && o !== void 0) {
    let m = r;
    m === void 0 && (m = Nc(), m.intlOptions.minimumFractionDigits = 2, m.intlOptions.maximumFractionDigits = 2), d = ra({
      value: o,
      valueFormat: m,
      iLocale: i.chart.language.locale,
      formatLocale: c
    });
  }
  return { formattedStatValue: u, formattedPercentValue: d };
}
function uv(t) {
  const { series: e, dateRange: i, xAxisValueFormat: a } = t;
  let o;
  const n = I(e.chart.uid, "timeIntervalInfo");
  if (i !== void 0 && i.length > 0) {
    let s = {};
    switch (n?.unit) {
      case xe.Second:
        s = {
          month: "numeric",
          day: "numeric",
          year: "numeric",
          hour: "numeric",
          minute: "numeric",
          second: "numeric"
        };
        break;
      case xe.Minute:
        s = {
          month: "numeric",
          day: "numeric",
          year: "numeric",
          hour: "numeric",
          minute: "numeric"
        };
        break;
      case xe.Hour:
        s = {
          month: "numeric",
          day: "numeric",
          year: "numeric",
          hour: "numeric",
          minute: "numeric"
        };
        break;
      case xe.Day:
      case xe.Week:
      case xe.Month:
      case xe.Year:
        s = {
          month: "numeric",
          day: "numeric",
          year: "numeric"
        };
        break;
    }
    s.timeZone = a.intlOptions.timeZone;
    const r = new Date(i[0]), l = new Date(i[1]);
    if (!Number.isNaN(r.valueOf())) {
      const c = I(e.chart.uid, "formatLocale"), u = Ot({
        type: b.DateAxisFormat,
        iLocale: e.chart.language.locale,
        formatLocale: c
      }), d = u.format(r, s);
      if (o = d, !Number.isNaN(l.valueOf())) {
        const m = u.format(l, s);
        m !== d && (o = `${o} - ${m}`);
      }
    }
  }
  return o?.toString() ?? "";
}
function Kf(t) {
  const {
    seriesConfig: e,
    xAxisValueFormat: i,
    setTimeBinningInfoWhenNotProvided: a,
    dataTooltipValueFormat: o,
    dataTooltipDateFormat: n,
    series: s,
    xValue: r,
    dateBinningRange: l
  } = t;
  let c;
  const u = I(s.chart.uid, "formatLocale");
  return /* case 1: time binning chart */ Ha({
    seriesConfig: e,
    xAxisValueFormatType: i?.type,
    setTimeBinningInfoWhenNotProvided: a
  }) && l !== void 0 && i?.type === b.DateAxisFormat ? c = uv({
    series: s,
    dateRange: l,
    xAxisValueFormat: i
  }) : mi(i) && r !== void 0 ? c = ra({
    value: r,
    valueFormat: n ?? i,
    iLocale: s.chart.language.locale,
    formatLocale: u
  }) : typeof r == "number" && Lt(i) ? c = ra({
    value: r,
    valueFormat: o ?? i,
    iLocale: s.chart.language.locale,
    formatLocale: u
  }) : c = r, c?.toString() ?? "";
}
function fv(t) {
  const { series: e, fieldList: i, queryObject: a, setTimeBinningInfoWhenNotProvided: o, seriesIndex: n, seriesConfig: s, utilsStrings: r } = t, { dataTooltipValueFormat: l, dataTooltipPercentFormat: c, dataTooltipDateFormat: u } = s;
  let d = () => "";
  const { chart: m } = e;
  if (m !== void 0) {
    const g = I(m.uid, "config");
    if (g !== void 0) {
      const { dataTooltipVisible: h } = s, y = e instanceof ue ? s.markerVisible : void 0;
      if (h === !1 || y === !1)
        d = () => "";
      else {
        const p = g.axes, S = p[0].valueFormat, x = p[1].valueFormat, C = U(g.series), v = zt(g) === Ie.Stacked100, F = pt(a)?.objectIdField, T = De(i, s.x), k = li(T, p[0].title?.content.text), $ = xu({
          config: g,
          fieldList: i,
          objectIdField: F,
          seriesIndex: n,
          utilsStrings: r,
          isStacked100: v
        }), O = bt(m.rtl);
        d = (D) => {
          const { statValue: R, percentValue: M, xValue: N, dateBinningRange: E } = D, V = Kf({
            seriesConfig: s,
            xAxisValueFormat: S,
            dataTooltipValueFormat: l,
            dataTooltipDateFormat: u,
            setTimeBinningInfoWhenNotProvided: o,
            series: e,
            xValue: N,
            dateBinningRange: E
          }), { formattedStatValue: W, formattedPercentValue: H } = dv({
            isStacked100: v,
            yAxisValueFormat: x,
            dataTooltipValueFormat: l,
            dataTooltipPercentFormat: c,
            series: e,
            statValue: R,
            percentValue: M
          }), Z = [`<b>${k}${O} </b>${V}`];
          switch (C) {
            case P.BarAndLineFromFields: {
              Z.pop();
              const oe = xr({
                config: g,
                fieldName: De(i, V ?? ""),
                utilsStrings: r
              });
              Z.push(`<b>${oe}${O} </b>${W}`);
              break;
            }
            case P.BarAndLineMonoField:
            case P.BarAndLineNoAggregation:
            case P.BarAndLineMultiFields:
              Z.push(`<b>${$}${O} </b>${W}`);
              break;
            case P.BarAndLineSplitByNoAggregation:
            case P.BarAndLineSplitBy:
              {
                const oe = ki(s.query?.where, !1), ie = Mc({
                  value: De(i, oe)
                });
                Z.push(
                  `<b>${ie}${O} </b>${e.name}<br /><b>${$}${O} </b>${W}`
                );
              }
              break;
          }
          return v && Z.push(`<b>${r.statistics.percent}${O} </b>${H}`), Z.join("<br />");
        };
      }
    }
  }
  return d;
}
function Qf(t) {
  const { series: e, tooltipFormatter: i } = t;
  We(e.uid, {
    barAndLineTooltipFormatter: i ?? fv(t)
  });
}
function Gr(t) {
  const { target: e, defaultTooltipHTML: i, candleStickSeries: a, meanLineSeries: o, outliersSeries: n, tooltipCallback: s } = t;
  let r = i;
  const l = a ?? o;
  if (l !== void 0) {
    const { chart: c } = l;
    if (c !== void 0) {
      const u = I(c.uid, "config"), { dataTooltipVisible: d } = u?.series[0] ?? {};
      if (d === !1)
        r = "";
      else {
        const m = _(
          l.uid,
          "boxPlotTooltipFormatter"
        );
        m !== void 0 && l.isReady() && u && (r = s({
          target: e,
          defaultTooltipHTML: i,
          config: u,
          candleStickSeries: a,
          meanLineSeries: o,
          outliersSeries: n,
          boxPlotTooltipFormatter: m
        }));
      }
    }
  }
  return He(r);
}
function mv(t) {
  const { target: e, defaultTooltipHTML: i, config: a, candleStickSeries: o, outliersSeries: n, boxPlotTooltipFormatter: s } = t;
  let r = i;
  if (o !== void 0 && n !== void 0) {
    const l = o.dataItems.values.find(
      (u) => (u.categories.categoryX ?? u.categories.categoryY) === (e.dataItem?.categories.categoryX ?? e.dataItem?.categories.categoryY)
    ), c = a.series.find((u) => u.id === o.id);
    if (c !== void 0) {
      const u = l?.dataContext ?? {};
      if (u !== void 0) {
        const d = oi({
          value: u[c.x],
          dataContext: u,
          useRendererLabel: Ii(a)
        });
        let m = si(u);
        m === void 0 && (m = d), r = s({
          seriesName: n.name,
          xValue: d,
          originalXValue: m,
          dataContext: u
        });
      }
    }
  }
  return r;
}
function gv(t) {
  const { target: e, defaultTooltipHTML: i, config: a, meanLineSeries: o, boxPlotTooltipFormatter: n } = t;
  let s = i;
  if (o !== void 0) {
    const r = o.dataItems.values.find(
      (l) => (l.categories.categoryX ?? l.categories.categoryY) === (e.dataItem?.categories.categoryX ?? e.dataItem?.categories.categoryY)
    );
    if (r instanceof ta) {
      const l = a.series.find((c) => c.id === o.id);
      if (l !== void 0) {
        const c = r.dataContext ?? {};
        if (c !== void 0) {
          const u = oi({
            value: c[l.x],
            dataContext: c,
            useRendererLabel: Ii(a)
          });
          let d = si(c);
          d === void 0 && (d = u), s = n({
            seriesName: o.name,
            xValue: u,
            originalXValue: d,
            dataContext: c
          });
        }
      }
    }
  }
  return s;
}
function hv(t) {
  const { target: e, defaultTooltipHTML: i, config: a, candleStickSeries: o, boxPlotTooltipFormatter: n } = t;
  let s = i;
  if (o !== void 0) {
    const r = e.dataItem;
    if (r instanceof Yg) {
      const l = a.series.find(
        (c) => c.id === o.id
      );
      if (l !== void 0) {
        const c = r.dataContext ?? {};
        if (c !== void 0) {
          const u = oi({
            value: c[l.x],
            dataContext: c,
            useRendererLabel: Ii(a)
          });
          let d = si(c);
          d === void 0 && (d = u), s = n({
            seriesName: o.name,
            xValue: u,
            originalXValue: d,
            dataContext: c
          });
        }
      }
    }
  }
  return s;
}
function pv(t) {
  t.cursorTooltipEnabled = !1, t.tooltipPosition = L.columnTooltipPosition, t.columns.template.tooltipHTML = L.htmlEmptyContent, t.columns.template.adapter.add(
    "tooltipHTML",
    (e, i) => Gr({
      target: i,
      defaultTooltipHTML: e ?? "",
      candleStickSeries: t,
      tooltipCallback: hv
    })
  );
}
function bv(t, e) {
  const i = Oe(t);
  i !== void 0 && (i.tooltipPosition = L.markerTooltipPosition, i.tooltipHTML = L.htmlEmptyContent, t.cursorTooltipEnabled = !1, i.adapter.add(
    "tooltipHTML",
    (a, o) => Gr({
      target: o,
      defaultTooltipHTML: a ?? "",
      candleStickSeries: e,
      outliersSeries: t,
      tooltipCallback: mv
    })
  ));
}
function yv(t) {
  const e = Oe(t);
  e !== void 0 && (t.cursorTooltipEnabled = !1, e.tooltipPosition = L.markerTooltipPosition, e.tooltipHTML = L.htmlEmptyContent, e.adapter.add(
    "tooltipHTML",
    (i, a) => Gr({
      target: a,
      defaultTooltipHTML: i ?? "",
      meanLineSeries: t,
      tooltipCallback: gv
    })
  ));
}
function Wi(t) {
  const { label: e, value: i, strongColon: a, useTable: o } = t, n = `<b>${e}${a}</b> ${i}`;
  return o !== !1 ? `<tr><td>${n}</td></tr>` : n;
}
function Sv(t) {
  const { dataContext: e, series: i, dataTooltipValueFormat: a, y: o, splitBy: n, utilsStrings: s, useTable: r } = t, l = a ?? Us(), c = Object.values(J), u = bt(i.rtl), d = r !== !1 ? ['<tr><td colspan="2"><hr style="border-top: solid black;"></td></tr>'] : [""];
  return c.forEach((m) => {
    const g = be({ key: m, y: o, splitBy: n }), h = e[g];
    if (h != null && typeof h == "number") {
      const y = I(i.chart.uid, "formatLocale"), p = ra({
        value: h,
        valueFormat: l,
        iLocale: i.chart.language.locale,
        formatLocale: y
      });
      let S = "";
      switch (m) {
        case J.Min:
          S = s.statistics.minimum;
          break;
        case J.FirstQuartile:
          S = s.statistics.firstQuartile;
          break;
        case J.Median:
          S = s.statistics.median;
          break;
        case J.ThirdQuartile:
          S = s.statistics.thirdQuartile;
          break;
        case J.Max:
          S = s.statistics.maximum;
          break;
        case J.IQR:
          S = s.statistics.iqr;
          break;
        case J.Average:
          S = s.statistics.mean;
          break;
        case J.StandardDeviation:
      }
      ka(S) || d.push(
        Wi({
          label: S,
          value: p,
          strongColon: u,
          useTable: r
        })
      );
    }
  }), d;
}
function xv(t) {
  const { series: e, fieldList: i, seriesConfig: a, utilsStrings: o } = t, { dataTooltipValueFormat: n } = a;
  let s = () => "";
  const { chart: r } = e;
  if (r !== void 0) {
    const l = I(r.uid, "config");
    if (l !== void 0) {
      const c = l.axes, u = c?.[0].valueFormat, { showMean: d } = l, m = U(l.series), g = ki(a.query?.where), h = De(i, g), y = Ki({
        where: a.query?.where,
        escape: !1
      }), p = De(i, a.x);
      let S;
      a.x !== Ks && (S = li(p, c?.[0].title?.content.text));
      const x = bt(r.rtl);
      s = (C) => {
        const { dataContext: v, xValue: F } = C, T = Kf({
          seriesConfig: a,
          xAxisValueFormat: u,
          series: e,
          xValue: F
        }), k = [], $ = T !== void 0 && !ka(T) ? De(i, T) : "", O = d === !0 ? [l.series[0].y].flat()[0] : [a.y].flat()[0], D = De(i, O);
        switch (m) {
          case P.BoxPlotMonoField:
          case P.BoxPlotMultiFields:
          case P.BoxPlotMonoFieldAndSplitBy:
          case P.BoxPlotMultiFieldsAndSplitBy: {
            if (T !== void 0 && !ka(T)) {
              const W = m === P.BoxPlotMonoField ? a.name ?? $ : $;
              k.push(
                Wi({
                  label: o.field,
                  strongColon: x,
                  value: W
                })
              );
            }
            ye(h) || k.push(
              Wi({
                label: h,
                strongColon: x,
                value: a.name ?? y?.toString()
              })
            );
            break;
          }
          case P.BoxPlotMonoFieldAndCategory:
          case P.BoxPlotMultiFieldsAndCategory: {
            k.push(
              Wi({
                label: o.field,
                strongColon: x,
                value: a.name ?? D
              })
            ), T !== void 0 && !ka(T) && k.push(
              Wi({
                label: S,
                strongColon: x,
                value: $
              })
            );
            break;
          }
          case P.BoxPlotMonoFieldAndCategoryAndSplitBy:
            k.push(
              Wi({
                label: o.field,
                strongColon: x,
                value: D
              })
            ), T !== void 0 && !ka(T) && k.push(
              Wi({
                label: S,
                strongColon: x,
                value: $
              })
            ), ye(h) || k.push(
              Wi({
                label: h,
                strongColon: x,
                value: a.name ?? y?.toString()
              })
            );
            break;
        }
        const R = [P.BoxPlotMultiFieldsAndCategory], M = v[L.boxPlot.boxPlotMeanLineMarkerId] !== void 0, N = k.length > 0 && !M, E = Sv({
          dataContext: v,
          series: e,
          dataTooltipValueFormat: n,
          splitBy: a.query?.where,
          y: R.includes(m) ? [a.y].flat()[0] : void 0,
          utilsStrings: o,
          useTable: N
        });
        return N ? `${k.join("<br>")}<table>${E.join("")}</table>` : `${k.join("<br>")}${E.join("<br>")}`;
      };
    }
  }
  return s;
}
function Cv(t) {
  const { series: e, tooltipFormatter: i } = t;
  We(e.uid, {
    boxPlotTooltipFormatter: i ?? xv(t)
  });
}
function vv(t) {
  const e = Vt(L.dataLabelInitialize);
  return ci(e.uid, { isDataLabel: !0 }), t.bullets.push(e), zr(e), Er(b.LineSeries, e), zf(b.LineSeries, e), Ns(e, t), e.html = "{valueX}", e;
}
function Lv(t) {
  const { series: e } = t, i = To(e, "bullets");
  es({
    ...t,
    dataLabel: i,
    defaultDataLabelFormatter: Wf,
    seriesType: b.LineSeries
  });
}
function Fv(t, e) {
  e !== void 0 && (e.layout !== void 0 && (t.layout = e.layout), e.width !== void 0 && (t.width = ic(e.width)), e.height !== void 0 && (t.height = ic(e.height)), e.paddingTop !== void 0 && (t.paddingTop = e.paddingTop), e.paddingBottom !== void 0 && (t.paddingBottom = e.paddingBottom));
}
function Av(t) {
  let e = !1;
  const i = t.legend?.visible, a = t.legend?.title?.content.text, o = t.legend?.title?.visible;
  return e = i !== !1 && o !== !1 && a !== void 0 && a.length > 0, e;
}
function Jf(t, e) {
  const i = new fr();
  return Fv(i, t), i.parent = e, i;
}
function em(t, e) {
  t.disabled = e;
}
function Tv(t, e) {
  t.toBack();
}
function kv(t) {
  if (t instanceof yt) {
    const { paddingTop: e, paddingRight: i, paddingBottom: a, paddingLeft: o } = L.gauge;
    t.padding(e, i, a, o);
  } else {
    const { paddingMinSize: e, marginMinSize: i, chartPaddingMinSize: a, chartContainer: o } = L;
    t.padding(a, a, a, a), t.chartAndLegendContainer.margin(i, i, i, i), t.chartAndLegendContainer.padding(e, e, e, e), t.chartContainer.margin(i, i, i, i), t.chartContainer.padding(o.paddingTop, e, e, e);
  }
}
function Iv(t, e) {
  const i = (a, o) => {
    const { chartContainer: n, chartAndLegendContainer: s } = L, r = I(a.uid, "config");
    if (r !== void 0) {
      const l = Av(r), c = r.legend?.position;
      if (l)
        switch (c) {
          case Y.Top:
            a.chartAndLegendContainer.paddingTop = o.bbox.height ?? 0, a.chartContainer.paddingBottom = n.paddingBottom ?? 0;
            break;
          case Y.Bottom:
            a.chartContainer.paddingBottom = o.bbox.height ?? 0, a.chartAndLegendContainer.paddingTop = s.paddingTop ?? 0;
            break;
          default:
            a.chartAndLegendContainer.paddingTop = s.paddingTop ?? 0, a.chartContainer.paddingBottom = n.paddingBottom ?? 0;
            break;
        }
      else
        a.chartAndLegendContainer.paddingTop = s.paddingTop ?? 0, a.chartContainer.paddingBottom = n.paddingBottom ?? 0;
    }
  };
  e.events.on(B.PositionChanged, () => {
    i(t, e);
  });
}
function Xr(t) {
  const {
    iLocale: e,
    pieChart: i,
    valueIntlOptions: a,
    percentageIntlOptions: o,
    displayNumericValue: n,
    displayPercentage: s,
    valuePrefix: r,
    valueSuffix: l,
    percentagePrefix: c,
    percentageSuffix: u
  } = t, d = I(i.uid, "formatLocale"), m = Ot({
    type: b.NumberAxisFormat,
    iLocale: e,
    formatLocale: d
  }), g = Ot({
    type: b.NumberAxisFormat,
    iLocale: e,
    formatLocale: d
  });
  m.numberFormat = { ...a }, g.numberFormat = { ...o, style: "percent" };
  const h = bt(i.rtl, " ");
  return (p, S, x) => {
    let C = "";
    if (S !== void 0 && x !== void 0) {
      const v = `${r ?? ""}${m.format(S)}${l ?? ""}`, F = `${c ?? ""}${g.format(Math.abs(x / 100))}${u ?? ""}`;
      Number.isFinite(S) ? n === !0 && s === !0 ? C = `${F}${h}(${v})` : n === !0 ? C = v : s === !0 && (C = F) : C = "";
    }
    return C;
  };
}
function tm(t) {
  let e = !1;
  if (t.position === Y.Right || t.position === Y.Left)
    e = !0;
  else {
    const i = t.labels.getIndex(0)?.parent?.x;
    i !== void 0 && (e = !t.labels.values.some((a) => a.parent?.x !== i));
  }
  return e;
}
function wv(t) {
  let e = !1;
  const i = t.labels.getIndex(0)?.parent?.y;
  return i !== void 0 && (e = !t.labels.values.some((a) => a.parent?.y !== i)), e;
}
function $v(t) {
  t.events.on(B.LayoutValidated, () => {
    const e = tm(t), i = wv(t), a = e || !i ? se.Right : se.Center;
    t.valueLabels.template.horizontalCenter = Nr(a), t.valueLabels.template.align = $f(a);
  });
}
function Dv(t) {
  ci(t.valueLabels.template.uid, { isLegendValueLabel: !0 }), t.valueLabels.template.adapter.add("htmlOutput", (e, i) => {
    let a = e;
    const o = nC(
      t.uid,
      "pieChartLegendValueLabelsFormatter"
    );
    if (o !== void 0 && (a = o(
      i.dataItem?.values?.value?.value ?? 0,
      i.dataItem?.values?.value?.percent ?? 0
    )), ye(a) && (a = L.htmlEmptyContent), t.baseSprite instanceof Ld) {
      const n = I(t.baseSprite.uid, "config");
      n?.legend?.body !== void 0 && (a = ft({
        textSymbol: { ...n.legend.body, text: a },
        format: "html"
      }));
    }
    return He(a);
  }), t.valueLabels.template.html = L.htmlEmptyContent, $v(t);
}
function Ov(t) {
  const {
    legendElements: { legend: e },
    seriesConfig: i,
    webChartLegend: a,
    pieChartLegendValueLabelFormatter: o
  } = t, {
    visible: n,
    body: s,
    displayNumericValue: r,
    displayPercentage: l,
    displayCategory: c
  } = a ?? {};
  if (z(i) === b.PieSeries) {
    const { numericValueFormat: d, percentValueFormat: m, valuePrefix: g, valueSuffix: h, percentagePrefix: y, percentageSuffix: p } = i[0], S = c ?? L.pieChart.displayCategoryOnLegend, x = r ?? L.pieChart.displayNumericValueOnLegend, C = l ?? L.pieChart.displayPercentageOnLegend;
    let v = o;
    if (o === void 0) {
      const k = Xr({
        iLocale: e.language.locale,
        pieChart: e.baseSprite,
        valueIntlOptions: d?.intlOptions,
        percentageIntlOptions: m?.intlOptions,
        displayNumericValue: x,
        displayPercentage: C,
        valuePrefix: g,
        valueSuffix: h,
        percentagePrefix: y,
        percentageSuffix: p
      });
      v = ($, O) => k("", $, O);
    }
    sC(e.uid, {
      pieChartLegendValueLabelsFormatter: v
    });
    const F = tm(e), T = {
      type: b.Text,
      visible: n,
      content: {
        ...s,
        type: te.TS,
        text: ".",
        verticalAlignment: ee.Middle,
        // The horizontalAlignment value needs to be consistent with the one set by `handleValueLabelsRightAlignment()`. It avoids flickering the labels.
        horizontalAlignment: F ? se.Right : se.Center
      }
    };
    Tt({
      label: e.valueLabels.template,
      labelConfig: T,
      defaults: L.legendProperties.valueLabels
    }), e.labels.template.disabled = S === !1, e.valueLabels.template.disabled = x === !1 && C === !1;
  }
}
function Rv(t) {
  const { dataContext: e } = t.target.dataItem ?? {};
  if (e instanceof ri) {
    const { component: i } = e;
    i instanceof Nt && i.showTooltip();
  }
}
function Bv(t) {
  const e = () => {
    const i = t.children.values.find(
      (a) => a.className === "Container"
    );
    if (i?.children.length === 3) {
      const a = i.children.values.findIndex((o) => o.className === "Container");
      if (a !== -1) {
        const n = a !== 0 ? 0 : 2, s = i.children.getIndex(n)?.clonedFrom;
        s !== void 0 && je(s.uid, "isLegendValueLabel") !== !0 && t.children.each((r) => {
          r.className === "Container" && r.children.swap(1, n);
        });
      }
    }
  };
  t.events.on(B.Validated, e), e();
}
function lc(t, e) {
  const { legendLabelReducedOpacity: i } = L.legendProperties;
  t !== void 0 && (t.fillOpacity = e === !1 ? i : 1);
}
function Ta(t) {
  const { labels: e, seriesId: i, sliceCategory: a } = t;
  e.each((o) => {
    a !== void 0 ? a === o.dataItem.category && lc(o, o.dataItem.slice.visible ?? !0) : i === o.dataItem?.component?.id && lc(o, o.dataItem?.component?.visible ?? !0);
  });
}
function Eo(t) {
  t instanceof Nt ? (t.slices.template.events.on(B.Shown, (e) => {
    const i = e.target.dataItem.category;
    Ta({
      labels: t.chart?.legend?.labels,
      sliceCategory: i
    }), Ta({
      labels: t.chart?.legend?.valueLabels,
      sliceCategory: i
    });
  }), t.slices.template.events.on(B.Hidden, (e) => {
    const i = e.target.dataItem.category;
    Ta({
      labels: t.chart?.legend?.labels,
      sliceCategory: i
    }), Ta({
      labels: t.chart?.legend?.valueLabels,
      sliceCategory: i
    });
  })) : t.events.on(B.VisibilityChanged, (e) => {
    const i = e.target.id;
    Ta({ labels: t.chart?.legend?.labels, seriesId: i });
  });
}
function im(t) {
  const { title: e, visible: i } = t;
  return e !== void 0 && i !== !1 && e?.visible !== !1;
}
function Mv(t, e) {
  const { legendProperties: i } = L;
  if (t.position === Y.Bottom)
    t.marginTop = i.marginTop ?? 0, t.marginBottom = 0, t.dy = 0;
  else if (t.position === Y.Top)
    t.marginBottom = i.marginBottom ?? 0, t.marginTop = 0, t.dy = 0;
  else if (t.marginTop = 0, t.marginBottom = 0, !(t.baseSprite instanceof Le)) {
    const a = im(e), o = e.title?.content?.font?.size ?? L.generalFontSize;
    t.dy = -(a ? o : 15);
  }
}
function Nv(t) {
  const e = t.baseSprite;
  let i;
  if (e !== void 0) {
    const a = I(e?.uid, "config");
    i = e?.rtl && (a?.legend?.position === Y.Top || a?.legend?.position === Y.Bottom);
  }
  return i ?? !1;
}
function Pv(t) {
  const e = t.baseSprite;
  let i = "";
  if (e instanceof ne) {
    const a = I(e.uid, "config"), o = jt(a), n = o ? f.Rotated : f.NonRotated, s = zt(a);
    let r = f.SideBySide;
    s === Ie.Stacked ? r = f.Stacked : s === Ie.Stacked100 && (r = f.Stacked100);
    const l = e.rtl ? f.RTL : f.LTR;
    let c;
    switch (a?.legend?.position) {
      case Y.Left:
        c = f.LegendLeft;
        break;
      case Y.Top:
        c = f.LegendTop;
        break;
      case Y.Bottom:
        c = f.LegendBottom;
        break;
      case Y.Right:
      default:
        c = f.LegendRight;
        break;
    }
    const u = o ? e.yAxes.getIndex(0) : e.xAxes.getIndex(0);
    let d;
    u instanceof ze ? d = f.DateAxis : u instanceof ve ? d = f.ValueAxis : d = f.CategoryAxis;
    const g = a?.orderOptions?.data?.orderBy === Ln.Descending ? f.OrderByFieldsDESC : f.OrderByFieldsASC;
    i = `${n}-${l}-${r}-${c}-${d}-${g}`;
  }
  return i;
}
function Vv(t) {
  const e = Pv(t);
  return tu.has(e);
}
function am(t, e) {
  const { legend: i, legendTitle: a } = t ?? {};
  switch (e) {
    case b.HistogramSeries:
    case b.PieSeries:
      i.reverseOrder = Nv(i);
      break;
    case b.BarSeries:
    case b.LineSeries:
    case b.ComboLineAndBarSeries:
      i.reverseOrder = Vv(i);
      break;
  }
  const o = i.reverseOrder === !0 ? i.children.length - 1 : 0;
  i.children.moveValue(a, o);
}
function Ev(t) {
  if (t.visible) {
    const i = I(t.chart.uid, "config")?.series.find(
      (a) => a.id === t.id
    );
    if (i !== void 0 && z([i]) === b.LineSeries) {
      const { markerVisible: o } = i;
      o !== !1 && t.bulletsContainer.show();
    }
  }
}
function zv(t, e) {
  const i = t.target.dataItem, a = t.target.isActive;
  if (i?.dataContext !== void 0) {
    const { dataContext: o } = i, n = { visible: a };
    if (_(o.uid, "isOverlay") === !0)
      n.overlayType = _(o.uid, "type");
    else if (o instanceof ri)
      I(e.uid, "isNonAggregatedChart") === !0 ? n.sliceData = o.dataContext : n.sliceId = o.category;
    else if (o instanceof _e) {
      const r = o.id, l = zo(e, r);
      if (l !== void 0) {
        const m = I(e.uid, "config"), g = Ur(m?.showOutliers, a), h = Oe(l);
        h !== void 0 && (h.disabled = !g), Q(l, g);
      }
      const { topStepLineSeries: c, medianStepLineSeries: u, bottomStepLineSeries: d } = os(
        e,
        r
      );
      c !== void 0 && Q(c, a), u !== void 0 && Q(u, a), d !== void 0 && Q(d, a), n.seriesId = o.id;
    } else
      n.seriesId = o.id;
    const s = o instanceof ri ? o.component : o;
    (s instanceof Ci || s instanceof Nt) && _(s.uid, "isOverlay") !== !0 && s.events.once(B.Validated, () => {
      s instanceof Ci && (ym(s), s.events.dispatchImmediately(B.Validated, {
        type: B.Validated,
        target: s
      }));
      const r = s instanceof Nt, l = I(
        e.uid,
        "currentSelectionDataItems"
      ), c = l !== void 0 && l.length > 0, u = I(e.uid, "actionMode") ?? L.actionMode;
      let d;
      s instanceof Xe ? d = s.columns : r ? d = s.slices : s instanceof ue && (Ev(s), d = Oe(s)?.clones), d?.each((m) => {
        m.dataItem instanceof ia || (Et({
          element: m,
          selected: m.isActive,
          useNativeState: r,
          backToDefaultState: !c
          // back to default state when there's no selection at all
        }), r && u === K.None && (m.clickable = !1));
      });
    }), ed(n, e.htmlContainer);
  }
}
function Wv(t) {
  const { legendProperties: e, legendProperties: i } = L;
  t.adapter.add(
    "paddingRight",
    () => t.scrollbar.visible ? i.legendPaddingRightWithScrollbarVisible : e.paddingRight
  ), t.adapter.add("paddingLeft", () => e.paddingLeft), t.adapter.add("paddingTop", () => e.paddingTop), t.adapter.add("paddingBottom", () => e.paddingBottom);
}
function Hv(t) {
  t.scrollable = !0;
}
function Gv(t) {
  const e = Vt(void 0, t);
  return e.adapter.add("paddingTop", (i) => {
    let a = i;
    const o = e.bbox.height;
    return o > 0 && (a = -o), a;
  }), e.adapter.add("x", (i) => {
    let a = i;
    const { marginLeft: o, marginRight: n } = L.legendProperties.legendTitle;
    switch (I(t.baseSprite.uid, "config")?.legend?.title?.content?.horizontalAlignment) {
      case se.Left:
        a = e.measuredWidth + (o ?? 0);
        break;
      case se.Right:
        a = t.measuredWidth - e.measuredWidth - (n ?? 0);
        break;
      case se.Center:
      case se.Justify:
      default:
        a = t.measuredWidth / 2;
        break;
    }
    return a;
  }), e.adapter.add("disabled", (i) => (i === !1 && e.validate(), i)), e;
}
function Xv(t) {
  const { legendConfig: e, legendTitle: i } = t, { title: a, position: o } = e, { legendTitle: n } = L.legendProperties, s = im(e);
  if (a !== void 0) {
    const r = {
      ...a,
      visible: s
    };
    Tt({ label: i, labelConfig: r, defaults: n }), i.marginLeft = n.marginLeft ?? 0;
  }
  o === Y.Top || o === Y.Bottom ? (i.maxWidth = Number.NaN, i.isMeasured = !1) : (i.maxWidth = n.maxWidth ?? Number.NaN, i.marginTop = s ? i.bbox?.height ?? a?.content?.font?.size ?? L.generalFontSize : 0, i.isMeasured = !0);
}
function Yv(t) {
  const e = L.legendProperties;
  t.labels.template = Vt(e.legendLabels), t.valueLabels.template = Vt(e.legendLabels), t.markers.template.width = e.legendMarkersSize, t.markers.template.height = e.legendMarkersSize, t.labels.template.adapter.add("wrap", () => !0), t.labels.template.adapter.add("maxWidth", (i) => {
    let a = i, o;
    if (t.baseSprite instanceof Le && (o = I(t.baseSprite.uid, "config")?.legend?.labelMaxWidth), t.position === Y.Right || t.position === Y.Left)
      a = o ?? L.legendProperties.legendLabels.maxWidth;
    else if (o !== void 0)
      a = o;
    else {
      let n = 0;
      t.valueLabels.template.disabled || t.valueLabels.each((s) => {
        n = Math.max(n, s.measuredWidth);
      }), a = t.measuredWidth - n - 45;
    }
    return a;
  }), t.labels.template.adapter.add("textOutput", (i, a) => {
    const o = a.dataItem?.label?.currentText;
    let n;
    const s = I(t.baseSprite.uid, "config");
    if (s !== void 0) {
      const { series: l } = s;
      if (z(l) === b.PieSeries) {
        const u = U(l) === P.PieFromFields ? ii : l[0].x, d = a.dataItem?.dataContext?.[u];
        typeof d == "string" ? n = d : d && typeof d != "object" && (n = d.toString());
      } else a.dataItem?.component instanceof jg && (n = a.dataItem.component.name);
    }
    return (n !== void 0 && !ye(n) ? tr(n) : n) ?? o;
  }), t.valueLabels.template.adapter.add("maxWidth", (i) => {
    let a = i, o;
    return t.baseSprite instanceof Le && (o = I(t.baseSprite.uid, "config")?.legend?.valueLabelMaxWidth), t.position === Y.Right || t.position === Y.Left ? a = o ?? L.legendProperties.valueLabels.maxWidth : a = o ?? Number.NaN, a;
  });
}
function Uv(t, e) {
  t.itemContainers.template.events.on(B.Hit, (i) => zv(i, e)), e instanceof Le && t.itemContainers.template.events.on(B.Over, (i) => Rv(i));
}
function jv(t) {
  t.itemContainers.template.reverseOrder = t.rtl;
}
function jo(t, e) {
  t.adapter.keys().includes(e) || t.adapter.add(e, (i) => {
    let a = i;
    const o = t.dataItem?.dataContext;
    if (o !== void 0) {
      const n = o instanceof ri ? o.component?.chart : o.chart;
      if (n !== void 0) {
        const s = I(n.uid, "config"), { rectangleMarkerRadius: r, roundedMarkerRadius: l } = L.legendProperties;
        a = s?.legend?.roundMarkers === !0 ? l : r;
      }
    }
    return a;
  });
}
function cc(t) {
  t.markers.each((e) => {
    const i = e.children.getIndex(0);
    i instanceof oh && (jo(i, "cornerRadiusBottomLeft"), jo(i, "cornerRadiusBottomRight"), jo(i, "cornerRadiusTopLeft"), jo(i, "cornerRadiusTopRight"), i.validate());
  });
}
function qv(t) {
  t.markers.template.events.on(B.Inited, () => {
    cc(t);
  }), t.events.once(B.Validated, () => {
    cc(t);
  });
}
function _v(t) {
  const {
    legendElements: { legend: e },
    seriesConfig: i,
    webChartLegend: a
  } = t, { visible: o, body: n } = a ?? {}, s = z(i), r = {
    type: b.Text,
    visible: o,
    content: {
      ...n,
      type: te.TS,
      text: " "
      // using a non empty string to kick in the adapter on `textOutput`
    }
  };
  Tt({ label: e.labels.template, labelConfig: r, defaults: L.legendProperties.legendLabels }), e.labels.template.valign = ee.Middle, e.valueLabels.template.valign = ee.Middle, s === b.PieSeries && Ov(t), e.valueLabels.template.width = Number.NaN;
}
function Zv(t, e) {
  e.chartContainer.events.on(
    B.SizeChanged,
    Ye(() => {
      let a = I(e.uid, "config")?.legend?.maxHeight ?? Number.NaN;
      Number.isFinite(a) || (t.position === Y.Top || t.position === Y.Bottom ? a = L.legendProperties.maxHeight : a = e instanceof Le ? e.chartContainer.measuredHeight : e.seriesContainer.measuredHeight), t.maxHeight = a, t.invalidateLayout();
    }),
    L.debounceTime
  );
}
function Kv(t, e) {
  const { position: i } = e;
  i === Y.Top || i === Y.Bottom ? t.contentAlign = se.Center : t.contentAlign = "none";
}
function Qv(t, e) {
  const { legend: i } = t;
  i.events.on(B.DataItemsValidated, () => {
    i.dataItems.length > 0 && am(t, e);
  });
}
function Jv(t, e) {
  e === Y.Right || e === Y.Left ? t.width = Number.NaN : t.maxWidth = Number.MAX_SAFE_INTEGER;
}
function om(t, e) {
  let i = Gt.pointer;
  e === !0 ? (t.itemContainers.template.clickable = !1, t.itemContainers.template.focusable = !1, i = Gt.default) : (t.itemContainers.template.clickable = !0, t.itemContainers.template.focusable = !0), t.itemContainers.values.forEach((a) => {
    a.cursorOverStyle = i;
  });
}
function eL(t, e) {
  const i = new Ug();
  t.legend = i, Hv(i);
  const a = Gv(i);
  return Yv(i), Dv(i), Uv(i, t), jv(i), Wv(i), Qv({ legend: i, legendTitle: a }, z(e)), Zv(i, t), Iv(t, a), Bv(i), t.legend.events.on(B.ChildAdded, () => {
    const o = I(t.uid, "options");
    om(i, o?.disableTogglingLegendItems);
  }), { legend: i, legendTitle: a };
}
function Yr(t) {
  const { legendElements: e, seriesConfig: i, webChartLegend: a } = t, { legend: o, legendTitle: n } = e, s = o.baseSprite, l = (s === void 0 ? !0 : Bc(i)) && a?.visible !== !1;
  if (s !== void 0 && a !== void 0 && l) {
    const { position: c = L.legendProperties.position } = a;
    Q(o, !0), Xv({
      legendConfig: a,
      legendTitle: n
    }), qv(o), _v(t), Kv(o, a), am(e, z(i)), o.position = c, Jv(o, c), Mv(o, a);
    const u = I(s.uid, "options");
    om(o, u?.disableTogglingLegendItems), o.events.once(B.Validated, () => {
      o.baseSprite instanceof Le && o.invalidateDataItems();
    });
  } else
    o.position = Y.Right, o.width = 0, Q(o, !1);
}
function tL(t) {
  const {
    chart: e,
    chartConfig: i,
    seriesIndex: a,
    axisList: o = [],
    queryObject: n,
    hideLoaderHandle: s,
    selectionTheme: r,
    ignoreSmoothRenderingLimit: l
  } = t, c = i.series.length, { rotated: u } = i, d = i.series[a], { y: m, name: g, id: h, assignToSecondValueAxis: y } = d, p = new ue();
  p.id = h, Qt(p, s), Kt(p, g);
  let S, x;
  u !== !0 ? (S = o[0], x = y === !0 && o[2] ? o[2] : o[1]) : (S = y === !0 && o[2] ? o[2] : o[0], x = o[1]), S !== void 0 && (p.xAxis = S), x !== void 0 && (p.yAxis = x);
  const C = Rt({ chart: e }), v = U(i.series), F = v === P.BarAndLineSplitByNoAggregation ? `${m.toString()}_${Ki({ where: d.query?.where, keepSurroundingQuotes: !1, escape: !1 })}` : [m].flat()[0];
  C ? p.dataFields.valueX = F : p.dataFields.valueY = F;
  const T = C ? o[1] : o[0];
  if (T !== void 0) {
    const O = Hf(T, C);
    p.dataFields[O] = L.xAxisField;
  }
  p.dataFields.customValue = d?.query?.where;
  const k = pt(n);
  nm({
    series: p,
    seriesConfig: d,
    seriesIndex: a,
    chartSubType: v,
    colorMatch: i.colorMatch === !0,
    rendererType: $o(i.chartRenderer, k?.renderer)
  }), sm(d, p);
  const $ = ts({ chart: e, lineSeries: p, applyPropertiesToClones: !1 });
  return Zf($, p), vv(p), Ei({ element: $, customSelectionTheme: r }), xa(e, $), Xf({
    chart: e,
    numberOfChartSeries: c,
    series: p,
    seriesType: b.LineSeries,
    marker: $,
    ignoreSmoothRenderingLimit: l
  }), Eo(p), Vi(p), p;
}
function iL(t) {
  const { series: e, seriesIndex: i, chartSubType: a, seriesConfig: o, colorMatch: n, lineColor: s, rendererType: r } = t, l = Oe(e);
  let c = !1, u;
  if (l !== void 0) {
    o.markerVisible !== !1 && o.visible !== !1 ? e.bulletsContainer.show() : e.bulletsContainer.hide();
    let { markerSymbol: d } = o;
    const m = Hc();
    d === void 0 && (d = m, d.color = s), n ? d.color = s : d.color ??= s;
    const g = /* @__PURE__ */ new Set();
    let h;
    Vr({ element: l, markerSymbol: d }), l.clones.each((y) => {
      if (y.dataItem instanceof ia)
        y.states.getKey(st.CustomActive)?.reset(), y.states.getKey(st.CustomInactive)?.reset();
      else {
        const p = y.dataItem?.dataContext, S = Ft({
          seriesConfig: o,
          dataItem: p,
          chartSubType: a,
          colorMatch: n,
          rendererType: r
        }), x = Ai({
          seriesConfig: o,
          seriesIndex: i,
          seriesSymbol: d,
          element: y,
          colorMatch: n,
          rendererSymbol: S
        });
        u = x.symbolWithColorInfo, h = x.stylingInfo, di({ element: y, stylingInfo: h }), g.add(JSON.stringify(h));
      }
    }), c = g.size > 1, c || di({ element: l, stylingInfo: h });
  }
  return c ? void 0 : u;
}
function aL(t) {
  const { series: e, seriesConfig: i, chartSubType: a, colorMatch: o, rendererType: n } = t;
  let s;
  return e.dataItems?.values.every((r) => {
    let l = !0;
    const c = r.dataContext;
    return s = Ft({
      seriesConfig: i,
      dataItem: c,
      chartSubType: a,
      colorMatch: o,
      rendererType: n
    }), s !== void 0 && (l = !1), l;
  }), s;
}
function nm(t) {
  const { series: e, seriesIndex: i, seriesConfig: a, chartSubType: o, colorMatch: n, rendererType: s } = t, r = e, l = aL({
    series: r,
    seriesConfig: a,
    chartSubType: o,
    colorMatch: n,
    rendererType: s
  }), c = Ai({
    seriesConfig: a,
    seriesIndex: i,
    seriesSymbol: a.lineSymbol ?? Wc(i),
    element: r,
    colorMatch: n,
    rendererSymbol: l
  });
  return Q(r, a.visible), c.symbolWithColorInfo;
}
function sm(t, e) {
  t.showArea === !0 ? t.areaColor !== void 0 ? (e.fill = rt(t.areaColor), e.fillOpacity = e.fill.alpha === 0 ? 0 : 1) : (e.fill = zn(e.stroke.hex, 1), e.fillOpacity = L.lineSeries.areaOpacity) : e.fillOpacity = 0;
}
function rm(t) {
  const { series: e, seriesIndexMapper: i, seriesSymbolMapForEvent: a, seriesIndex: o, colorMatch: n, rendererType: s } = t, r = t.seriesConfig, l = I(e.chart.uid, "config"), c = l?.series.length ?? 0, u = U(l?.series);
  Q(e, r.visible);
  const d = nm({
    series: e,
    seriesConfig: r,
    seriesIndex: o,
    chartSubType: u,
    colorMatch: n,
    rendererType: s
  }), m = iL({
    series: e,
    seriesIndex: o,
    seriesConfig: r,
    chartSubType: u,
    colorMatch: n,
    lineColor: d.color,
    rendererType: s
  });
  a.set(i.get(r.id) ?? o, {
    lineSymbol: d,
    markerSymbol: m
  }), sm(r, e), a.size === c && (Bt({
    data: a,
    htmlContainer: e.chart.htmlContainer,
    chartId: e.chart.id,
    colorMatchApplied: Sa(e.chart)
  }), e.chart.feedLegend());
}
function oL(t) {
  const { seriesConfig: e, lineSeries: i, isRotated: a } = t;
  e.lineSmoothed === !0 ? i.smoothing = a ? fl.MonotoneY : fl.MonotoneX : i.smoothing = L.lineSeries.lineSmoothedKind;
}
function dc(t, e) {
  const { connectLines: i, temporalBinning: a } = e, o = a?.nullPolicy;
  t.connect = i !== !1 && o !== Ic.Null;
}
function nL(t) {
  const {
    seriesConfig: e,
    series: i,
    axes: a,
    rotationChanged: o,
    seriesIndex: n,
    subtypeInfo: s,
    fieldList: r,
    stackedType: l,
    queryObject: c,
    options: u,
    utilsStrings: d
  } = t, { visible: m, name: g } = e, h = a[1].valueFormat, y = I(i.chart.uid, "config"), p = Rt({ config: y }), S = U(y?.series);
  i.id = e.id, Q(i, m);
  let x = g;
  const C = i.dataFields?.customValue ?? "";
  (S === P.BarAndLineSplitBy || S === P.BarAndLineSplitByNoAggregation) && (x = Zs({
    subtypeInfo: s,
    fieldList: r,
    fieldName: ki(C),
    fieldValueToMatch: x
  }) ?? x), Kt(i, x), dc(i, e), Wr({ series: i, seriesConfig: e, rotationChanged: o, stackedType: l, isRotated: p }), dc(i, e), la({
    // TODO: Remove the type assertion and correct the typings
    styleCallback: rm,
    callbackProps: t,
    series: i,
    seriesConfig: e,
    onReadyEvent: !0
  }), oL({ seriesConfig: e, lineSeries: i, isRotated: p }), Qf({
    series: i,
    seriesConfig: e,
    fieldList: r,
    queryObject: c,
    seriesIndex: n,
    setTimeBinningInfoWhenNotProvided: u?.setTimeBinningInfoWhenNotProvided,
    utilsStrings: d,
    tooltipFormatter: u?.tooltipFormatter
  }), Lv({
    series: i,
    seriesType: b.LineSeries,
    stackedType: l,
    dataLabelsConfig: e.dataLabels,
    yAxisValueFormat: h,
    customDataLabelFormatter: u?.dataLabelFormatter
  });
}
function os(t, e) {
  const i = t.series.values.find(
    (n) => n.id === `${e}_${me.Top}`
  ), a = t.series.values.find(
    (n) => n.id === `${e}_${me.Median}`
  ), o = t.series.values.find(
    (n) => n.id === `${e}_${me.Bottom}`
  );
  return { topStepLineSeries: i, medianStepLineSeries: a, bottomStepLineSeries: o };
}
function zo(t, e) {
  return t.series.values.find((i) => i.id === `${e}_${me.Outliers}`);
}
function Ur(t, e) {
  return (t ?? L.boxPlot.boxPlotOutliersVisibility) && e !== !1;
}
function sL(t) {
  const { chart: e, axisList: i = [], chartConfig: a, seriesIndex: o, hideLoaderHandle: n, selectionTheme: s } = t, r = qe(a), l = a.series[o], [c, u] = i, d = new _e();
  return d.hoverable = !0, Qt(d, n), r || (Ei({
    element: d.columns.template,
    customSelectionTheme: s
  }), xa(e, d.columns.template)), d.id = l.id, c !== void 0 && (d.xAxis = c), u !== void 0 && (d.yAxis = u), d.simplifiedProcessing = !0, d.columns.template.applyOnClones = !0, d.riseFromOpenState.reset(), d.riseFromPreviousState.reset(), d.dropFromOpenState.reset(), d.dropFromPreviousState.reset(), Kt(d, l.name), Vi(d), d;
}
function Cs(t) {
  const { axisList: e = [], chartConfig: i, seriesIndex: a, type: o, hideLoaderHandle: n, selectionTheme: s } = t, r = i.series[a], [l, c] = e, u = new vt();
  return u.hoverable = !0, Qt(u, n), u.id = `${r.id}_${o}`, l !== void 0 && (u.xAxis = l), c !== void 0 && (u.yAxis = c), u.noRisers = !0, u.simplifiedProcessing = !0, Ei({
    element: u.segments.template,
    customSelectionTheme: s
  }), u.hiddenInLegend = !0, Vi(u), u;
}
function rL(t) {
  const { chart: e, axisList: i = [], chartConfig: a, hideLoaderHandle: o, seriesIndex: n, selectionTheme: s } = t, r = a.series[n], l = qe(a), [c, u] = i, d = new ue();
  We(d.uid, { isBoxPlotOutliersSeries: !0 }), Qt(d, o), d.id = `${r.id}_${me.Outliers}`, c !== void 0 && (d.xAxis = c), u !== void 0 && (d.yAxis = u), d.simplifiedProcessing = !0, d.hiddenInLegend = !0, d.strokeOpacity = 0;
  const m = ts({ chart: e, lineSeries: d });
  return l || (Ei({
    element: m,
    customSelectionTheme: s
  }), xa(e, m)), Vi(d), d;
}
function io(t) {
  const {
    chartConfig: e,
    seriesConfig: i,
    meanLineSeries: a,
    candleStickSeries: o,
    topStepLineSeries: n,
    medianStepLineSeries: s,
    bottomStepLineSeries: r,
    outliersSeries: l,
    creation: c = !1,
    rotationChanged: u,
    outliersVisibilityChanged: d,
    standardizeValuesVisibilityChanged: m
  } = t, { x: g, y: h } = i, y = c || u === !0 || m === !0, p = y || d === !0, S = y, x = y;
  if (e !== void 0) {
    const { showOutliers: C, standardizeValues: v, showMean: F } = e, T = Rt({ config: e });
    if (a instanceof ue && x) {
      const M = U(e.series), N = i?.query?.where, E = be({
        y: M === P.BoxPlotMultiFieldsAndCategory ? h : void 0,
        chartSubType: M,
        splitBy: N,
        showOutliers: C,
        standardizeValues: po(M) ? v : !1,
        key: J.Average
      });
      T ? (a.dataFields.valueX = E, a.dataFields.categoryY = g) : (a.dataFields.valueY = E, a.dataFields.categoryX = g), a.dataFields.customValue = N;
    }
    const k = ar(e), $ = U(k.series), O = F === !0 ? void 0 : i?.query?.where, D = {
      y: $ === P.BoxPlotMultiFieldsAndCategory ? h : void 0,
      chartSubType: $,
      splitBy: O,
      showOutliers: C,
      standardizeValues: po($) ? v : !1
    };
    if (p) {
      if (o instanceof _e) {
        const M = be({
          ...D,
          key: J.Min
        }), N = be({
          ...D,
          key: J.FirstQuartile
        }), E = be({
          ...D,
          key: J.Max
        }), V = be({
          ...D,
          key: J.ThirdQuartile
        });
        T ? (o.dataFields.lowValueX = M, o.dataFields.openValueX = N, o.dataFields.highValueX = E, o.dataFields.valueX = V, o.dataFields.categoryY = g) : (o.dataFields.lowValueY = M, o.dataFields.openValueY = N, o.dataFields.highValueY = E, o.dataFields.valueY = V, o.dataFields.categoryX = g), o.dataFields.customValue = O;
      }
      if (n instanceof vt && s instanceof vt && r instanceof vt) {
        const M = be({
          key: J.Max,
          ...D
        }), N = be({
          key: J.Median,
          ...D
        }), E = be({
          key: J.Min,
          ...D
        });
        T ? (n.dataFields.valueX = M, s.dataFields.valueX = N, r.dataFields.valueX = E, n.dataFields.categoryY = g, s.dataFields.categoryY = g, r.dataFields.categoryY = g) : (n.dataFields.valueY = M, s.dataFields.valueY = N, r.dataFields.valueY = E, n.dataFields.categoryX = g, s.dataFields.categoryX = g, r.dataFields.categoryX = g), n.dataFields.customValue = O, r.dataFields.customValue = O, s.dataFields.customValue = O;
      }
    }
    if (l instanceof ue && S) {
      const M = be({
        ...D,
        key: J.Outlier
      });
      T ? (l.dataFields.valueX = M, l.dataFields.categoryY = g) : (l.dataFields.valueY = M, l.dataFields.categoryX = g), l.dataFields.customValue = O, l.invalidateRawData();
    }
    const R = a?.chart ?? o?.chart;
    R !== void 0 && (p || x) && R.invalidateRawData();
  }
}
function lL(t) {
  const { chart: e, axisList: i = [], chartConfig: a, hideLoaderHandle: o, seriesIndex: n, selectionTheme: s } = t, r = a.series[n], [l, c] = i, u = new ue();
  We(u.uid, { isBoxPlotMeanLineSeries: !0 }), Qt(u, o), u.id = r.id, l !== void 0 && (u.xAxis = l), c !== void 0 && (u.yAxis = c), u.simplifiedProcessing = !0;
  const d = ts({ chart: e, lineSeries: u });
  return Ei({ element: d, customSelectionTheme: s }), xa(e, d), Vi(u), yv(u), io({
    chartConfig: a,
    seriesConfig: r,
    meanLineSeries: u,
    creation: !0
  }), u;
}
function cL(t) {
  const { chartConfig: e, seriesIndex: i } = t, a = e.series[i], o = z([a]), n = [];
  if (o === b.BoxPlotSeries) {
    const s = sL(t), r = Cs({
      ...t,
      type: me.Top
    }), l = Cs({
      ...t,
      type: me.Median
    }), c = Cs({
      ...t,
      type: me.Bottom
    }), u = rL(t);
    pv(s), bv(u, s), io({
      chartConfig: e,
      seriesConfig: a,
      candleStickSeries: s,
      topStepLineSeries: r,
      medianStepLineSeries: l,
      bottomStepLineSeries: c,
      outliersSeries: u,
      creation: !0
    }), n.push(
      s,
      r,
      l,
      c,
      u
    );
  } else if (o === b.LineSeries) {
    const s = lL(t);
    n.push(s);
  }
  return n;
}
function lm(t) {
  const { chart: e, chartData: i, chartConfig: a } = t;
  if (e && i?.length > 1 && a?.showMean === !0) {
    const o = a.series[0].x ?? L.originalCategoryValue, n = I(e.uid, "boxPlotMeanLinesData");
    if (n !== void 0 && n.length > 1) {
      const s = [];
      for (const r of i) {
        const l = n.find(
          (c) => o in c && c[o] === r[o]
        );
        l !== void 0 && s.push(l);
      }
      j(e.uid, { boxPlotMeanLinesData: s });
    }
  }
}
function dL(t) {
  const { candleStickSeries: e, seriesConfig: i, stylingInfo: a, chartSubType: o, colorMatch: n, rendererType: s } = t;
  if (a !== void 0) {
    const r = { ...a }, l = gf({
      data: e.chart.data,
      colorMatch: n,
      chartSubType: o,
      rendererType: s
    });
    a?.outline !== void 0 && l && (r.outline.stroke = sa(L.boxPlot.boxPlotWhiskersColor));
    const { topStepLineSeries: c, medianStepLineSeries: u, bottomStepLineSeries: d } = os(
      e.chart,
      e.id
    );
    if (c !== void 0 && u !== void 0 && d !== void 0 && r.outline !== void 0) {
      r.outline.strokeWidth = L.boxPlot.boxPlotLineWidth, Da(c, r.outline), Da(u, r.outline), Da(d, r.outline);
      const m = i.visible !== !1;
      Q(c, m), Q(u, m), Q(d, m);
    }
  }
}
function uL(t) {
  const { candleStickSeries: e, seriesConfig: i, showOutliers: a, seriesSymbol: o } = t;
  if (o !== void 0) {
    const n = zo(e.chart, e.id);
    if (n !== void 0) {
      const s = Oe(n);
      if (s !== void 0) {
        const r = Ur(a, i.visible), l = {
          type: te.SMS,
          style: xt.Circle,
          color: o.color,
          size: L.boxPlot.boxPlotOutliersSize
        };
        s.clones.each((c) => {
          const u = e.dataItems.values.find(
            (d) => (d.categories.categoryX ?? d.categories.categoryY) === (c.dataItem?.categories.categoryX ?? c.dataItem?.categories.categoryY)
          )?.column.fill;
          Vr({
            element: c,
            markerSymbol: {
              ...l,
              color: kf(u) ?? l.color
            },
            visible: r
          });
        });
      }
    }
  }
}
function fL(t) {
  const { series: e, seriesConfig: i, seriesIndex: a, numberOfSeries: o, chartSubType: n, colorMatch: s, showMean: r, rendererType: l } = t;
  let c, u, d;
  const m = /* @__PURE__ */ new Set();
  let g = !1;
  const h = i.fillSymbol ?? Js(a);
  if (e.columns.length === 0 ? (d = Ai({
    seriesConfig: i,
    seriesIndex: a,
    seriesSymbol: h,
    element: new ur(),
    colorMatch: s,
    isChartFillSymbol: !0
  }), c = d.symbolWithColorInfo, u = d.stylingInfo) : e.columns.each((y) => {
    d = Ai({
      seriesConfig: i,
      seriesIndex: a,
      seriesSymbol: h,
      element: y,
      colorMatch: s,
      isChartFillSymbol: !0,
      rendererSymbol: r ? void 0 : Ft({
        dataItem: y.dataItem?.dataContext,
        seriesConfig: i,
        chartSubType: n,
        colorMatch: s,
        rendererType: l
      })
    }), c = d.symbolWithColorInfo, u = d.stylingInfo, m.add(JSON.stringify(c));
  }), g = m.size > 1, o > 1) {
    const y = e.legendDataItem?.marker.children.getIndex(0);
    y !== void 0 ? di({ element: y, stylingInfo: u }) : e.chart.legend.events.once(B.Validated, () => {
      di({
        element: e.legendDataItem?.marker.children.getIndex(0),
        stylingInfo: u
      }), e.chart.legend.invalidate();
    });
  }
  return {
    multipleSymbolsForOneSeries: g,
    seriesSymbol: c,
    stylingInfo: u
  };
}
function mL(t) {
  const {
    series: e,
    showOutliers: i,
    colorMatch: a,
    seriesIndex: o,
    seriesIndexMapper: n,
    seriesSymbolMapForEvent: s,
    seriesConfig: r,
    rendererType: l
  } = t, c = I(e.chart.uid, "config"), u = qe(c), d = c?.series.length ?? 0, m = U(c?.series);
  let g = !1, h;
  if (e instanceof _e && r.type === b.BoxPlotSeries) {
    const y = fL({
      series: e,
      seriesConfig: r,
      seriesIndex: o,
      numberOfSeries: d,
      chartSubType: m,
      colorMatch: a,
      showMean: u,
      rendererType: l
    }), { stylingInfo: p } = y;
    ({ multipleSymbolsForOneSeries: g, seriesSymbol: h } = y), s.set(
      n.get(r.id) ?? o,
      g ? void 0 : { fillSymbol: h ?? r.fillSymbol }
    ), dL({
      candleStickSeries: e,
      seriesConfig: r,
      colorMatch: a,
      stylingInfo: p,
      chartSubType: m,
      rendererType: l
    }), uL({
      candleStickSeries: e,
      seriesConfig: r,
      showOutliers: i,
      seriesSymbol: h
    });
  } else e instanceof ue && r.type === b.LineSeries && rm({
    series: e,
    seriesConfig: r,
    seriesIndexMapper: n,
    seriesSymbolMapForEvent: s,
    seriesIndex: o,
    colorMatch: a,
    rendererType: l
  });
  s.size === d && Bt({
    data: s,
    htmlContainer: e.chart.htmlContainer,
    chartId: e.chart.id,
    colorMatchApplied: Sa(e.chart)
  });
}
function gL(t) {
  const { numberOfSeries: e, chart: i, showMean: a } = t, o = Rt({ chart: i }), n = o ? i.yAxes.getIndex(0)?.renderer : i.xAxes.getIndex(0)?.renderer;
  if (n !== void 0) {
    const { cellStartLocation: s, cellEndLocation: r } = n, l = s / (a === !0 ? 1 : e), c = i.series.values.filter((u) => u instanceof _e);
    c.forEach((u, d) => {
      const m = s + d / c.length * (r - s) + l, g = s + (d + 1) / c.length * (r - s) - l, { topStepLineSeries: h, medianStepLineSeries: y, bottomStepLineSeries: p } = os(
        i,
        u.id
      );
      h !== void 0 && (h.startLocation = m, h.endLocation = g), y !== void 0 && (y.startLocation = m, y.endLocation = g), p !== void 0 && (p.startLocation = m, p.endLocation = g);
      const S = zo(i, u.id);
      if (S !== void 0) {
        const x = (m + g) / 2;
        o ? S.dataItems.template.locations.categoryY = x : S.dataItems.template.locations.categoryX = x;
      }
    });
  }
}
function hL(t) {
  const { outliersSeries: e, chartData: i, dataWasUpdated: a, rotationChanged: o, seriesReordered: n } = t;
  (o === !0 || a === !0 || n === !0) && (e.data = i?.outliers ?? []);
}
function pL(t) {
  const { meanLineSeries: e, chartData: i, rotationChanged: a, sortChanged: o, dataWasUpdated: n, seriesReordered: s } = t;
  (a === !0 || n === !0 || o === !0 || s === !0) && (e.data = i?.meanLines ?? [], e.invalidateData());
}
function bL(t) {
  const {
    chart: e,
    chartConfig: i,
    seriesConfig: a,
    chartData: o,
    candleStickSeriesId: n,
    showOutliers: s,
    dataWasUpdated: r,
    rotationChanged: l,
    seriesReordered: c,
    outliersVisibilityChanged: u,
    standardizeValuesVisibilityChanged: d
  } = t, m = zo(e, n);
  if (m !== void 0) {
    const g = Oe(m);
    if (g !== void 0) {
      const h = Ur(s, a.visible);
      g.disabled = !h, hL({
        outliersSeries: m,
        chartData: o,
        dataWasUpdated: r,
        rotationChanged: l,
        seriesReordered: c
      });
    }
    io({
      chartConfig: i,
      seriesConfig: a,
      outliersVisibilityChanged: u,
      standardizeValuesVisibilityChanged: d,
      rotationChanged: l,
      outliersSeries: m
    });
  }
}
function yL(t) {
  const {
    meanLineSeries: e,
    seriesConfig: i,
    chartData: a,
    dataWasUpdated: o,
    seriesReordered: n,
    sortChanged: s,
    rotationChanged: r,
    chartConfig: l,
    outliersVisibilityChanged: c,
    standardizeValuesVisibilityChanged: u
  } = t;
  Kt(e, i?.name), io({
    chartConfig: l,
    seriesConfig: i,
    meanLineSeries: e,
    outliersVisibilityChanged: c,
    standardizeValuesVisibilityChanged: u,
    rotationChanged: r
  }), pL({
    meanLineSeries: e,
    chartData: a,
    dataWasUpdated: o,
    seriesReordered: n,
    sortChanged: s,
    rotationChanged: r
  });
}
function SL(t) {
  const {
    series: e,
    chartConfig: i,
    seriesConfig: a,
    rotationChanged: o,
    outliersVisibilityChanged: n,
    standardizeValuesVisibilityChanged: s
  } = t;
  Kt(e, a?.name), e.hiddenInLegend = qe(i), io({
    chartConfig: i,
    seriesConfig: a,
    candleStickSeries: e,
    outliersVisibilityChanged: n,
    standardizeValuesVisibilityChanged: s,
    rotationChanged: o
  });
}
function xL(t) {
  const {
    chart: e,
    chartConfig: i,
    seriesConfig: a,
    candleStickSeriesId: o,
    outliersVisibilityChanged: n,
    standardizeValuesVisibilityChanged: s,
    rotationChanged: r
  } = t, l = a.visible !== !1, { topStepLineSeries: c, medianStepLineSeries: u, bottomStepLineSeries: d } = os(
    e,
    o
  );
  c !== void 0 && Q(c, l), u !== void 0 && Q(u, l), d !== void 0 && Q(d, l), io({
    chartConfig: i,
    seriesConfig: a,
    outliersVisibilityChanged: n,
    standardizeValuesVisibilityChanged: s,
    rotationChanged: r,
    topStepLineSeries: c,
    medianStepLineSeries: u,
    bottomStepLineSeries: d
  });
}
function CL(t) {
  const {
    chart: e,
    series: i,
    chartData: a,
    utilsStrings: o,
    dataWasUpdated: n,
    sortChanged: s,
    seriesReordered: r,
    fieldList: l,
    outliersVisibilityChanged: c,
    showMean: u,
    seriesConfig: d,
    showOutliers: m,
    standardizeValuesVisibilityChanged: g,
    rotationChanged: h,
    options: y
  } = t, { tooltipFormatter: p } = y ?? {};
  gL({
    numberOfSeries: t.numberOfSeries,
    chart: e,
    showMean: u
  });
  const S = I(e.uid, "config");
  if (S !== void 0) {
    if (i instanceof _e && d.type === b.BoxPlotSeries) {
      const { id: x } = i;
      SL({
        series: i,
        chartConfig: S,
        seriesConfig: d,
        rotationChanged: h,
        outliersVisibilityChanged: c,
        standardizeValuesVisibilityChanged: g
      }), xL({
        chart: e,
        chartConfig: S,
        seriesConfig: d,
        candleStickSeriesId: x,
        outliersVisibilityChanged: c,
        standardizeValuesVisibilityChanged: g,
        rotationChanged: h
      }), bL({
        chart: e,
        chartConfig: S,
        seriesConfig: d,
        chartData: a,
        showOutliers: m,
        candleStickSeriesId: x,
        dataWasUpdated: n,
        rotationChanged: h,
        seriesReordered: r,
        outliersVisibilityChanged: c,
        standardizeValuesVisibilityChanged: g
      });
    } else i instanceof ue && d.type === b.LineSeries && yL({
      chartConfig: S,
      chartData: a,
      meanLineSeries: i,
      seriesConfig: d,
      dataWasUpdated: n,
      seriesReordered: r,
      sortChanged: s,
      rotationChanged: h,
      outliersVisibilityChanged: c,
      standardizeValuesVisibilityChanged: g
    });
    la({
      // TODO: Remove the type assertion and correct the typings
      styleCallback: mL,
      callbackProps: t,
      series: i,
      seriesConfig: d,
      onReadyEvent: !0
    }), Cv({
      series: i,
      seriesConfig: d,
      fieldList: l,
      tooltipFormatter: p,
      utilsStrings: o
    });
  }
}
function vL(t) {
  const e = t.series.getIndex(0);
  e !== void 0 && (e.slices.each((i) => {
    Et({
      element: i,
      selected: !1,
      backToDefaultState: !0
    });
  }), t.feedLegend());
}
function LL(t, e = !0) {
  let i;
  t.series.each((a, o) => {
    if ((!e || a.visible) && (i === void 0 || i !== b.HistogramSeries && i !== b.ScatterSeries)) {
      i = Qn(a, o);
      let n = [];
      if (i === b.HistogramSeries || i === b.BarSeries)
        n = a.columns?.values;
      else if (i === b.ScatterSeries || i === b.LineSeries)
        n = Oe(a)?.clones?.values;
      else if (i === b.BoxPlotSeries) {
        if (a instanceof _e)
          n.push(...a.columns.values);
        else if (a instanceof vt)
          n.push(...a.segments.values);
        else if (a instanceof ue) {
          const s = Oe(a)?.clones?.values;
          s !== void 0 && n.push(...s);
        }
      }
      n !== void 0 && n.forEach((s) => {
        Et({
          element: s,
          selected: !1,
          backToDefaultState: !0
        });
      });
    }
  });
}
function ao(t) {
  const { chart: e, selectionSource: i, clearOnlyVisibleSeries: a, disposeStyleAndSelection: o } = t, n = I(
    e.uid,
    "currentSelectionDataItems"
  );
  o !== !1 && Yf(e, "updateSelectionCallbackDisposer"), j(e.uid, {
    currentSelectionDataItems: void 0,
    currentSelectionOIDs: void 0,
    currentSelectionIndexes: void 0,
    computedSelectionDataItems: void 0,
    computedSelectionIndexes: void 0,
    pendingSelectionQueries: !1
  }), kt(e) && (e instanceof ne ? LL(e, a ?? !0) : e instanceof Le && vL(e)), n && Xa({
    data: {
      selectionSource: i ?? Ne.ClearSelection
    },
    htmlContainer: e.htmlContainer
  });
}
function FL(t) {
  Ec(), ad(t.htmlContainer), ao({ chart: t });
}
function AL(t) {
  const { chart: e, chartType: i, showMean: a } = t;
  return e.series.values.filter(
    (n) => _(n.uid, "isOverlay") !== !0 && (i !== b.BoxPlotSeries || !a && n instanceof _e || a && _(n.uid, "isBoxPlotMeanLineSeries"))
  ).every((n) => _(n.uid, "isSelectionApplied") === !0);
}
function TL(t) {
  t.series.each((e) => We(e.uid, { isSelectionApplied: void 0 }));
}
function cm(t, e) {
  const i = I(t.uid, "actionMode");
  if ((i === K.MonoSelection || i === K.None) && e.length > 1)
    ao({ chart: t });
  else {
    const o = t instanceof Le;
    e.forEach((n) => {
      Et({
        element: n,
        useNativeState: o,
        selected: !0
      });
    });
  }
}
function kL(t) {
  const {
    chart: e,
    chartConfig: i,
    series: a,
    options: o,
    elementsToApplySelectionTo: n,
    selectionDataItems: s,
    layerOidField: r,
    xAxisField: l,
    yAxisField: c
  } = t, u = z(i.series), d = U(i.series), m = Oi(i), g = I(e.uid, "queryObject"), h = [], y = [], p = [], S = wi(i.series), x = a instanceof Ci ? a.dataFields?.customValue ?? "" : "";
  return n.forEach((C) => {
    if (!(C instanceof ia)) {
      let v = C.dataItem?.dataContext;
      if (v !== void 0 && (u === b.BoxPlotSeries && v[L.boxPlot.boxPlotOutlierId] !== !0 || d === P.BarAndLineMultiFields) && (v = Li({
        dataContext: v,
        yAxisField: c,
        yList: S,
        xAxisField: l,
        splitBy: x,
        chartType: u,
        chartSubType: d,
        showOutliers: m,
        isFeatureCollectionLayer: Si(g)
      })), Hn({
        elementDataContext: v,
        options: o,
        selectionDataItems: s,
        layerOidField: r,
        xAxisField: l,
        yAxisField: c,
        chartType: u,
        splitBy: x,
        chartSubType: d,
        showOutliers: m
      }))
        if (h.push(C), C.dataItem !== void 0 && y.push(C.dataItem.index), C?.dataItem instanceof ta && v !== void 0)
          p.push(v);
        else {
          const T = /* @__PURE__ */ new Set();
          u === b.PieSeries && Di(v) ? (Bo({
            groupOfSlicesDataContext: v
          }) ?? []).forEach(($) => {
            s.forEach((O) => {
              br({
                layerOidField: r,
                sliceDataContext: $,
                selectionDataContext: O,
                xAxisField: l
              }) && T.add($);
            });
          }) : T.add(v), Array.from(T)?.forEach((k) => {
            const $ = Li({
              dataContext: k,
              yAxisField: c,
              yList: S,
              xAxisField: l,
              splitBy: x,
              chartType: u,
              chartSubType: d,
              showOutliers: m,
              isFeatureCollectionLayer: Si(g)
            });
            $ !== void 0 && p.push($);
          });
        }
      else
        Et({
          element: C,
          useNativeState: e instanceof Le,
          selected: !1
        });
    }
  }), cm(e, h), { selectedIndexes: y, newSelectionDataItems: p };
}
function IL(t, e) {
  const i = [], a = [], o = I(t.uid, "config"), n = I(t.uid, "queryObject"), s = Oi(o), r = wi(o?.series ?? []), l = U(o?.series);
  return t.series.each((c, u) => {
    if (o && c.visible && _(c.uid, "isOverlay") !== !0) {
      const d = o.series[0].x, m = aa(c), g = c instanceof Ci ? c.dataFields?.customValue ?? "" : "", h = Qn(c, u), y = e.get(u);
      if (y !== void 0) {
        let p;
        if (c instanceof Xe ? p = c.columns : c instanceof Nt ? p = c.slices : p = Oe(c)?.clones, p !== void 0) {
          const { indexesToSelect: S } = y;
          p.each((x, C) => {
            if (x && (S === void 0 || S.includes(C))) {
              let v;
              h === b.BoxPlotSeries && x.dataItem instanceof ta ? v = x.dataItem.dataContext : x.dataItem instanceof ia || (v = Li({
                dataContext: x.dataItem?.dataContext,
                yList: r,
                yAxisField: m,
                xAxisField: d,
                splitBy: g,
                chartType: h,
                chartSubType: l,
                showOutliers: s,
                isFeatureCollectionLayer: Si(n)
              })), v !== void 0 && i.push(v), a.push(x);
            } else
              Et({
                element: x,
                useNativeState: t instanceof Le,
                selected: !1
              });
          });
        }
      }
    }
  }), cm(t, a), i;
}
function wL(t) {
  const { series: e, chartType: i, showMean: a } = t;
  let o;
  switch (i) {
    case b.ComboLineAndBarSeries:
      if (e instanceof Xe)
        o = e.columns.values;
      else if (e instanceof ue) {
        const n = Oe(e);
        n !== void 0 && (o = n.clones.values);
      }
      break;
    case b.BarSeries:
    case b.HistogramSeries:
      e instanceof Xe && (o = e.columns.values);
      break;
    case b.LineSeries:
    case b.ScatterSeries:
      if (e instanceof ue) {
        const n = Oe(e);
        n !== void 0 && (o = n.clones.values);
      }
      break;
    case b.PieSeries:
      o = e.slices.values;
      break;
    case b.BoxPlotSeries:
      if (e.chart instanceof ne) {
        if (e instanceof _e && a !== !0) {
          o = [...e.columns.values];
          const n = zo(e.chart, e.id);
          if (n !== void 0 && n.visible) {
            const s = Oe(n);
            s !== void 0 && o.push(...s.clones.values);
          }
        } else if (a === !0 && e instanceof ue && _(e.uid, "isBoxPlotMeanLineSeries")) {
          const n = Oe(e);
          n !== void 0 && (o = n.clones.values);
        }
      }
      break;
  }
  return o;
}
function $L(t) {
  const {
    series: e,
    seriesIndex: i,
    queryObject: a,
    options: o,
    dataWasUpdated: n,
    sortChanged: s,
    groupOfSlicesWasUpdated: r,
    xAxisField: l,
    yAxisField: c,
    rotationChanged: u
  } = t, { filterBySelection: d, selectionData: m, returnSelectionIndexes: g, returnSelectionOIDs: h } = o ?? {}, { selectionIndexes: y } = m ?? {}, { chart: p } = e, S = I(p.uid, "config"), x = S && "showOutliers" in S && typeof S.showOutliers == "boolean" ? S.showOutliers : !1, C = qe(S), v = z(S?.series);
  if (d !== !0 && S !== void 0) {
    const F = wL({
      series: e,
      chartType: v,
      showMean: C
    }), T = U(S?.series);
    let k;
    a !== void 0 && (k = pt(a).objectIdField);
    const $ = I(
      p.uid,
      "currentSelectionDataItems"
    );
    let O = !1, D = !1, R, M = !1;
    if (F?.[0] !== void 0) {
      if (o?.viewExtentUpdated !== !0) {
        R = o?.selectionData?.selectionItems ?? $;
        const N = I(
          p.uid,
          "currentSelectionIndexes"
        );
        M = rd({
          itemsA: R,
          itemsB: $,
          isPieFromFields: T === P.PieFromFields
        });
        const E = y?.keys.length !== N?.keys.length || !fo(y, N);
        O = s === !0 || n === !0 || r === !0 || u === !0 || R !== void 0 && M;
        let V = !0;
        if (y !== void 0 && y.size > 0) {
          const { indexesToSelect: W } = y.get(i ?? 0) ?? {};
          V = W !== void 0 && W[0] === void 0;
        }
        D = n === !0 || r === !0 || u === !0 || !V && E;
      }
      if (O && R !== void 0 && R.length > 0) {
        const { selectedIndexes: N, newSelectionDataItems: E } = kL({
          chart: p,
          chartConfig: S,
          options: o,
          series: e,
          elementsToApplySelectionTo: F,
          selectionDataItems: R,
          layerOidField: k,
          xAxisField: l,
          yAxisField: c
        });
        let V = I(p.uid, "computedSelectionDataItems") ?? [];
        if (V.push(...E), S.series.length > 1 && T !== P.BarAndLineNoAggregation && T !== P.BarAndLineSplitByNoAggregation && (V = ld({
          data: V,
          x: S.series[0].x,
          splitByField: ki(S.series[0].query?.where)
        })), j(p.uid, { computedSelectionDataItems: V }), g === !0) {
          const W = Array.from(new Set(N));
          let H = I(
            p.uid,
            "computedSelectionIndexes"
          );
          H === void 0 && (H = /* @__PURE__ */ new Map()), W.length === F.length ? H.set(i ?? 0, {}) : H.set(i ?? 0, {
            indexesToSelect: W
          }), j(p.uid, { computedSelectionIndexes: H });
        }
      } else if (y !== void 0 && D)
        R = IL(p, y);
      else {
        const N = R === void 0 || R.length === 0, E = e instanceof Ci ? e.dataFields?.customValue ?? "" : "", V = (W) => {
          let H = W.dataItem?.dataContext;
          return H !== void 0 && v === b.BoxPlotSeries && H[L.boxPlot.boxPlotOutlierId] !== !0 && (H = Li({
            dataContext: H,
            yAxisField: c,
            yList: wi(S.series),
            xAxisField: l,
            splitBy: E,
            chartType: v,
            chartSubType: T,
            showOutliers: x,
            isFeatureCollectionLayer: Si(a)
          })), Hn({
            elementDataContext: H,
            options: o,
            selectionDataItems: R ?? $ ?? [],
            layerOidField: k,
            xAxisField: l,
            yAxisField: c,
            chartType: v,
            splitBy: E,
            chartSubType: T,
            showOutliers: x
          });
        };
        F.forEach((W) => {
          const H = W.isActive || V(W);
          Et({
            element: W,
            selected: H,
            useNativeState: p instanceof Le,
            backToDefaultState: N
          });
        });
      }
    }
    if (We(e.uid, { isSelectionApplied: !0 }), AL({ chart: p, chartType: v, showMean: C }) && (TL(p), M || D)) {
      let N = I(p.uid, "computedSelectionDataItems") ?? R;
      N = Array.from(
        new Set(N?.map((V) => JSON.stringify(V)))
      ).map((V) => JSON.parse(V)), R !== void 0 && j(p.uid, {
        currentSelectionDataItems: N
      }), m?.selectionOIDs !== void 0 && j(p.uid, {
        currentSelectionOIDs: m.selectionOIDs
      });
      let E;
      if (g === !0 && (E = I(p.uid, "computedSelectionIndexes") ?? y, E !== void 0 && j(p.uid, {
        currentSelectionIndexes: E
      })), N === void 0 || N.length === 0)
        ao({
          chart: p,
          selectionSource: Ne.ProgrammaticSelection
        });
      else {
        const V = {
          selectionItems: N,
          selectionSource: Ne.ProgrammaticSelection
        };
        g === !0 && (V.selectionIndexes = E), h !== !1 && (V.selectionOIDs = m?.selectionOIDs ?? I(p.uid, "currentSelectionOIDs")), Xa({
          data: V,
          seriesConfig: S.series,
          htmlContainer: p.htmlContainer
        });
      }
      j(p.uid, {
        computedSelectionIndexes: void 0,
        computedSelectionDataItems: void 0
      });
    }
  }
}
async function DL(t) {
  const { chart: e, options: i, dataWasUpdated: a, chartData: o, chartConfig: n, queryObject: s, rotationChanged: r, errorStrings: l } = t, c = I(e.uid, "currentSelectionOIDs"), u = I(e.uid, "queryConfig"), d = await sd({
    chartConfig: n,
    queryConfig: u,
    chartData: o,
    currentSelectionOIDs: c,
    dataWasUpdated: a,
    queryObject: s,
    options: i,
    errorStrings: l
  });
  d !== void 0 && i !== void 0 && (i.selectionData = {
    ...i?.selectionData,
    selectionItems: d
  });
  for (let m = 0; m < e.series.length; m += 1) {
    let g = e.series.getIndex(m);
    if (g) {
      const h = is(g, n);
      if (h) {
        const y = z([h]);
        if (y === b.ScatterSeries ? g = e.series.values.find((p) => _(p.uid, "isOverlay") !== !0) : y === b.BoxPlotSeries && (g = e.series.values.find((p) => p.id === h.id)), g !== void 0) {
          const p = h.x, S = y === b.BoxPlotSeries ? h.y.toString() : aa(g);
          UC({
            callbackProps: {
              ...t,
              series: g,
              seriesIndex: m,
              xAxisField: p,
              yAxisField: S
            },
            series: g,
            seriesConfig: h,
            onReadyEvent: r === !0
          });
        }
      }
    }
  }
}
async function Wo(t) {
  const { chart: e, listSelectedElements: i, selectionSource: a } = t, o = I(e.uid, "options"), n = I(e.uid, "config"), s = I(e.uid, "queryObject");
  if (n)
    if (i.length === 0)
      ao({
        chart: e,
        selectionSource: a,
        clearOnlyVisibleSeries: !1,
        disposeStyleAndSelection: !1
      });
    else
      try {
        Yf(e, "updateSelectionCallbackDisposer");
        const r = Oi(n), l = [], c = [];
        let u = [];
        const d = /* @__PURE__ */ new Map(), { xAxisField: m } = i[0] ?? {}, g = z(n?.series), h = U(n?.series), y = wi(n?.series ?? []);
        let p;
        if (s !== void 0 && (p = (await qt(s)).find((C) => C.name === m)?.type), i.forEach((x) => {
          const { elementDataContext: C, yAxisField: v, splitBy: F } = x, T = Li({
            dataContext: C,
            yAxisField: v,
            yList: y,
            xAxisField: m,
            splitBy: F,
            chartType: g,
            chartSubType: h,
            showOutliers: r,
            isFeatureCollectionLayer: Si(s)
          });
          T !== void 0 && c.push(T);
          const { seriesIndex: k, elementIndex: $ } = x;
          if ($ !== void 0) {
            const O = d.get(k)?.indexesToSelect ?? [];
            O.push($), d.set(k, {
              indexesToSelect: Array.from(new Set(O))
            });
          }
          if (C !== void 0) {
            const O = C[Na.uniqueIdsName] !== void 0 ? [C[Na.uniqueIdsName]].flat() : [];
            if (O.length > 0)
              u.push(...O);
            else if (o?.returnSelectionOIDs !== !1) {
              const D = od({
                dataContext: C,
                options: o,
                xAxisField: m,
                yAxisField: v ?? "",
                splitBy: F,
                xAxisFieldType: p,
                chartConfig: n
              });
              l.push(D);
            }
          }
        }), o?.returnSelectionOIDs !== !1 && s !== void 0 && l.length > 0) {
          const C = { ...I(e.uid, "queryConfig") };
          delete C.groupByFieldsForStatistics, delete C.orderByFields, delete C.outStatistics;
          const v = await nd({
            whereList: l,
            queryObject: s,
            queryConfig: C
          });
          if (l.length === i.length)
            u = v;
          else
            for (let F = 0; F < v.length; F += 1)
              u.push(v[F]);
        }
        j(e.uid, {
          currentSelectionDataItems: c,
          currentSelectionOIDs: u,
          currentSelectionIndexes: d
        });
        const S = {
          selectionItems: c,
          selectionSource: a
        };
        o?.returnSelectionIndexes === !0 && (S.selectionIndexes = d), o?.returnSelectionOIDs !== !1 && (S.selectionOIDs = u), Xa({
          data: S,
          seriesConfig: n?.series,
          htmlContainer: e.htmlContainer
        });
      } catch (r) {
        j(e.uid, { pendingSelectionQueries: !1 });
        const { httpStatus: l } = r instanceof wn ? r.details.details : r.details ?? {};
        if (l === 429)
          FL(e);
        else
          throw r;
      }
  j(e.uid, { pendingSelectionQueries: !1 });
}
function OL(t) {
  const { axis: e } = t, i = e.chart;
  return { axis: e, chart: i };
}
async function RL(t) {
  const e = t.target, { axis: i, chart: a } = OL(e), o = [], { seriesDataItems: n } = t.target.dataItem;
  Object.keys(n).forEach((u) => {
    if (Object.hasOwn(n, u)) {
      const d = n[u];
      for (const m of d)
        if (m instanceof Ro)
          o.push(m.column);
        else {
          const g = m.sprites.find((h) => !(h instanceof So));
          g !== void 0 && o.push(g);
        }
    }
  });
  const s = as(t, a), r = i instanceof ze || i instanceof lt, l = [], c = I(a.uid, "config");
  if (c) {
    const u = c.series[0].x ?? "";
    a.series.each((d, m) => {
      let g;
      if (d instanceof Xe ? g = d.columns : g = Oe(d)?.clones, d.visible) {
        const h = aa(d), y = d.dataFields?.customValue ?? "";
        g?.each((p, S) => {
          const x = o.includes(p);
          Et({
            element: p,
            selected: x,
            multiSelect: s,
            isDateOrCategoryAxis: r
          }) && l.push({
            element: p,
            elementDataContext: p.dataItem?.dataContext,
            yAxisField: h,
            xAxisField: u,
            splitBy: y,
            seriesIndex: m,
            elementIndex: S,
            chartConfig: c
          });
        });
      }
    }), await Wo({
      chart: a,
      listSelectedElements: l,
      selectionSource: Ne.SelectionByClick
    });
  }
}
function BL(t) {
  if (kt(t.renderer.labels.template)) {
    t.renderer.labels.template.events.on(B.Hit, async (a) => {
      t.renderer.labels.template.events.isEnabled(B.Hit) && await RL(a);
    });
    const i = I(t.chart.uid, "filterBySelection") === !0 ? Gt.default : Gt.pointer;
    Rs(t, i);
  }
}
function Cn(t, e) {
  if (kt(t?.renderer?.labels?.template) && (t instanceof lt || t instanceof ze))
    if (e)
      t.renderer.labels.template.events.disableType(B.Hit), Rs(t, Gt.default);
    else {
      t.renderer.labels.template.events.enableType(B.Hit);
      const a = I(t.chart.uid, "filterBySelection") === !0 ? Gt.default : Gt.pointer;
      Rs(t, a);
    }
}
function ca(t) {
  const { chart: e, label: i, labelType: a } = t;
  let o = Number.NaN;
  switch (a) {
    case ae.GuideLabel:
      !(e instanceof yt) && e instanceof ne && (i.rotation === 90 || i.rotation === 270 ? o = e.seriesContainer.measuredHeight : o = e.seriesContainer.measuredWidth);
      break;
    case ae.XAxisTitle:
      e instanceof ne && (o = e.seriesContainer.measuredWidth);
      break;
    case ae.YAxisTitle:
      e instanceof ne && (o = e.seriesContainer.measuredHeight);
      break;
    case ae.ChartTitle:
    case ae.ChartSubTitle:
    case ae.ChartFooter:
      o = e.measuredWidth - 20;
      break;
  }
  o > 0 && (i.maxWidth = o, e.invalidateLabels(), e instanceof ne && (e.xAxes.getIndex(0)?.invalidateLabels(), e.xAxes.getIndex(1)?.invalidateLabels(), e.yAxes.getIndex(0)?.invalidateLabels(), e.yAxes.getIndex(1)?.invalidateLabels()));
}
function ko(t) {
  const { chart: e, labelType: i } = t;
  ca(t);
  const a = i === ae.YAxisTitle ? 1 : 0;
  e.events.on(
    B.Validated,
    Ye(() => ca(t), L.debounceTime),
    a
  );
}
function ML(t, e) {
  t.chart instanceof yt || (e.adapter.add("dx", (i) => {
    let a = i;
    return (e.rotation === 90 || e.rotation === 270) && (a = e.bbox.height, e.dataItem.value !== e.dataItem.endValue && (a /= 2)), a;
  }), e.padding(0, 10, 0, 10));
}
function NL(t, e) {
  const i = t.renderer instanceof En ? new cr() : new lr();
  return i.disabled = !0, i.axis = t, Jn(i), ci(i.uid, { isGuide: e }), ko({ chart: t.chart, label: i, labelType: ae.GuideLabel }), e && ML(t, i), i;
}
function PL(t) {
  const { label: e, labelConfig: i, guideType: a } = t, o = e.axis.renderer instanceof wt;
  let n;
  e instanceof cr || (o ? a === te.SFS ? n = L.verticalSurfaceGuideLabels : n = L.verticalLineGuideLabels : a === te.SFS ? n = L.horizontalSurfaceGuideLabels : n = L.horizontalLineGuideLabels);
  const s = { ...i };
  s.content.rightToLeft = e.axis.rtl, Tt({ label: e, labelConfig: s, defaults: n }), e.axis.invalidateLabels();
}
function VL(t, e, i) {
  const a = i.chart;
  t.axisFill.tooltip = new $d(), t.axisFill.interactionsEnabled = !0, t.axisFill.tooltipPosition = L.columnTooltipPosition, t.axisFill.tooltip.label.wrap = !0, t.axisFill.tooltip.adapter.add(
    "maxWidth",
    () => Math.min(L.tooltipWidth, a.seriesContainer.maxWidth)
  ), t.axisFill.tooltip.boundingContainer = a.chartAndLegendContainer, t.axisFill.adapter.add("tooltipHTML", (o, n) => {
    let s = o;
    const { dataItem: r, axis: l } = n;
    if (!(l.renderer instanceof En)) {
      const c = nt(
        l.uid,
        "guideTooltipFormatter"
      );
      if (c !== void 0) {
        let u = "", d;
        r instanceof dr ? (u = r.value, d = r.endValue) : r instanceof Pa ? (u = r.category, d = r.endCategory) : r instanceof Vn && (u = r.date, d = r.endDate), s = c({
          guideName: r.id ?? "",
          start: u,
          end: d,
          guideIndex: e
        });
      }
    }
    return s;
  }), t.axisFill.tooltip.events.on(B.Shown, (o) => {
    const n = I(t.axisFill.axis.chart.uid, "config");
    if (n !== void 0) {
      const s = I(t.axisFill.axis.chart.uid, "isRotated"), l = !Ca(t.axisFill.axis.renderer, s) ? 1 : 0, u = n.axes?.[l]?.guides, { tooltipReverseColor: d } = u?.[e] ?? {};
      _f(o.target, d);
    }
  });
}
function EL(t, e) {
  return (i) => {
    const { guideName: a, start: o, end: n, guideIndex: s } = i, { chart: r } = t;
    let l = "";
    if (r !== void 0) {
      const c = I(r.uid, "config"), u = I(r.uid, "isRotated"), m = !Ca(t.renderer, u) ? 1 : 0, h = c?.axes?.[m]?.guides;
      let y = o, p = n;
      if (t instanceof ze) {
        let v = new Fd(), F;
        if (r !== void 0) {
          const T = I(t.chart.uid, "formatLocale");
          v = Ot({
            type: b.DateAxisFormat,
            iLocale: r.language.locale,
            formatLocale: T
          }), F = c?.axes?.[0]?.valueFormat?.intlOptions;
        }
        y = v.format(o, F), n !== void 0 && (p = v.format(n, F));
      } else if (t instanceof ve && !(o instanceof Date) && !(n instanceof Date)) {
        const { start: v, end: F } = jr(t, h?.[s]);
        Number.isFinite(v) && (y = v), Number.isFinite(F) && (p = F);
        const T = nt(t.uid, "numberFormatter") ?? ((k) => new Ad().format(k));
        y = T(y), p !== void 0 && (p = T(p));
      } else t instanceof lt && (y = o, p = n);
      const S = y.toString(), x = p?.toString() ?? "";
      !ye(x) && S !== x ? l = Ra(e.guideTooltipLabel, {
        guideStart: S,
        guideEnd: x
      }) : l = S;
      const C = bt(r.rtl);
      l = `${a}${C} ${l}`;
    }
    return l;
  };
}
function zL(t) {
  const { axis: e, guideTooltipFormatter: i, utilsStrings: a } = t;
  et(e.uid, {
    guideTooltipFormatter: i ?? EL(e, a)
  });
}
function WL(t) {
  let e = Ia.Value;
  return t instanceof ze ? e = Ia.Date : t instanceof lt && (e = Ia.Category), e;
}
function uc(t) {
  const { inputValue: e, axisType: i, axisMin: a, axisMax: o } = t;
  let n = e;
  if (e != null)
    switch (i) {
      case Ia.Date:
        n = e instanceof Date ? e : new Date(e);
        break;
      case Ia.Category:
        n = e.toString();
        break;
      case Ia.Value:
        if (typeof e != "number") {
          const s = e.toString().trim(), r = Rn(s);
          r !== void 0 ? a !== void 0 && o !== void 0 ? n = r / 100 * (o - a) + a : n = null : n = Number.parseFloat(s);
        }
        break;
    }
  return n;
}
function jr(t, e) {
  const { start: i, end: a } = e ?? {};
  let o;
  if (e !== void 0 && i !== void 0 && i !== null) {
    const n = WL(t), s = t instanceof ve ? t.min : void 0, r = t instanceof ve ? t.max : void 0, l = uc({
      inputValue: i,
      axisType: n,
      axisMin: s,
      axisMax: r
    }), c = e.style?.type === te.SFS && a !== null && a !== void 0 ? uc({
      inputValue: a,
      axisType: n,
      axisMin: s,
      axisMax: r
    }) : l;
    o = {
      isValidGuide: l != null && c != null,
      start: l,
      end: c
    };
  } else
    o = { isValidGuide: !1, start: void 0, end: void 0 };
  return o;
}
function dm(t) {
  const { axis: e, tickOrGuide: i, numberOfElementsToBeDeleted: a } = t, o = [];
  let n = e.axisRanges.length - 1, s = a;
  for (; s > 0 && n >= 0; ) {
    const r = e.axisRanges.getIndex(n);
    if (r !== void 0) {
      const l = je(r.label?.uid, "isGuide") ?? !1;
      (l !== !0 && i === ce.Ticks || l === !0 && i === ce.Guides) && (o.push(r), s -= 1);
    }
    n -= 1;
  }
  for (let r = 0; r < o.length; r += 1)
    e.axisRanges.removeValue(o[r]);
}
function Ze(t, e) {
  return t.axisRanges?.values?.filter((a) => {
    const o = je(a.label?.uid, "isGuide") ?? !1, n = je(a.label?.uid, "isGaugeAxisLabel") ?? !1;
    let s = !1;
    switch (e) {
      case ce.Ticks:
        s = o === !1;
        break;
      case ce.Guides:
        s = o === !0;
        break;
      case ce.GaugeTicksWithLabels:
        s = n === !0 && a.value !== void 0;
        break;
      case ce.GaugeFirstAndLastGuides:
        s = o === !0 && (a.id === L.gaugeFirstLabelId || a.id === L.gaugeLastLabelId);
        break;
    }
    return s;
  }) ?? [];
}
function um(t, e) {
  let i = t.axisRanges.length;
  if (e) {
    const o = t.axisRanges.values.findIndex(
      (n) => n.id === L.gaugeFirstLabelId
    );
    o !== -1 && (i = o);
  }
  let a;
  return t instanceof lt ? a = new Pa() : t instanceof ze ? a = new Vn() : a = new dr(), t.axisRanges.insertIndex(i, a), a.label = NL(t, e), a.axisFill.fillOpacity = 1, a.axisFill.disabled = !0, a.grid.strokeOpacity = 1, a;
}
function HL(t, e) {
  const i = um(t, !0);
  VL(i, e, t), i.tick !== void 0 && (i.tick.disabled = !0), i.label !== void 0 && (i.label.inside = !0), i.grid !== void 0 && (i.grid.disabled = !0);
}
function GL(t, e) {
  const { start: i, end: a } = e, o = I(t.uid, "config"), n = ir(o);
  let s = i !== null ? i : void 0;
  s = t.data.find((c) => c[L.originalCategoryValue] === i)?.[n] ?? s;
  let l = a !== null ? a : void 0;
  if (l !== void 0)
    for (let c = t.data.length - 1; c >= 0; c -= 1) {
      const u = t.data[c];
      if (u[L.originalCategoryValue] === a) {
        l = u[n];
        break;
      }
    }
  return { modifiedStart: s, modifiedEnd: l };
}
function XL(t, e) {
  const { start: i, end: a } = e;
  if (i !== void 0) {
    const { chart: o } = t?.component ?? {};
    let n;
    if (t instanceof Pa && o instanceof ne && I(o.uid, "isNonAggregatedChart") === !0) {
      const { modifiedStart: s, modifiedEnd: r } = GL(o, e);
      n = {
        isValidGuide: !0,
        start: s ?? i,
        end: r ?? a
      };
    } else
      n = jr(t.axisFill.axis, e);
    n.isValidGuide && (t instanceof Pa ? (t.category = `${n.start?.toString()}`, t.endCategory = `${n.end?.toString()}`) : t instanceof Vn ? (t.date = n.start, t.endDate = n.end) : (t.value = n.start, t.endValue = n.end));
  }
}
function YL(t, e) {
  t.axisFill.above = e ?? L.guideAbove, t.grid.above = e ?? L.guideAbove;
}
function UL(t, e) {
  const { axisFill: i, label: a } = t;
  if (e !== void 0) {
    if (t.id = e.name, t.visible = e.visible !== void 0 ? e.visible : t.visible, XL(t, e), e.style.type === te.SLS ? Ao({
      element: i,
      fillSymbol: {
        type: te.SFS,
        color: e.style?.color,
        outline: e.style
      },
      visible: e.visible
    }) : e.style.type === te.SFS && Ao({
      element: i,
      fillSymbol: e.style,
      visible: e.visible
    }), YL(t, e.above), e.label !== void 0) {
      const n = {
        type: b.Text,
        visible: e.visible,
        content: e.label
      };
      PL({
        label: a,
        labelConfig: n,
        guideType: e.style.type
      });
    }
    const o = t.component?.chart;
    o !== void 0 && ca({
      chart: o,
      label: a,
      labelType: ae.GuideLabel
    });
  } else
    i.disabled = !0, a.disabled = !0;
}
function jL(t, e) {
  const a = Ze(t, ce.Guides).length, o = e?.length ?? a;
  for (let n = a; n < o; n += 1)
    HL(t, n);
}
function qL(t) {
  const { axis: e, guides: i, guideTooltipFormatter: a, utilsStrings: o } = t;
  if (i !== void 0) {
    for (let n = 0; n < i.length; n += 1) {
      const r = Ze(e, ce.Guides)[n];
      r !== void 0 && UL(r, i[n]);
    }
    zL({ axis: e, guideTooltipFormatter: a, utilsStrings: o });
  }
}
function _L(t, e) {
  const a = Ze(t, ce.Guides).length, o = e?.length ?? 0, n = a - o;
  dm({
    axis: t,
    numberOfElementsToBeDeleted: n,
    tickOrGuide: ce.Guides
  });
}
function ZL(t) {
  const { axis: e, guides: i } = t;
  jL(e, i), qL(t), _L(e, i);
}
function KL(t) {
  const e = um(t, !1);
  e.label.inside = !1, e.grid.disabled = !0, e.label.html = L.htmlEmptyContent, e.label.adapter.add(
    "htmlOutput",
    (i, a) => Mr(t, a?.dataItem?.value ?? i)
  );
}
function QL(t) {
  const { axisTick: e, value: i, axisConfig: a, numberFormatter: o } = t;
  e.value = i, a.labels.content.text = o.format(i), Ut({
    element: e.tick,
    lineSymbol: a.lineSymbol,
    visible: a.visible
  });
}
function JL(t, e) {
  const a = Ze(t, ce.Ticks).length, n = (e?.length ?? a) - a;
  for (let s = 0; s < n; s += 1)
    KL(t);
}
function e0(t) {
  const { valueAxis: e, axisConfig: i, ticks: a } = t, o = I(e.chart.uid, "formatLocale"), n = Ot({
    type: i.valueFormat.type,
    iLocale: e.chart.language.locale,
    formatLocale: o
  });
  if (n.numberFormat = ni(i.valueFormat), a !== void 0) {
    const s = Ze(e, ce.Ticks);
    for (let r = 0; r < a.length; r += 1) {
      const l = s[r];
      if (l !== void 0) {
        const c = a[r];
        QL({ axisTick: l, value: c, axisConfig: i, numberFormatter: n });
      }
    }
  }
}
function t0(t, e) {
  const a = Ze(t, ce.Ticks).length, o = e?.length ?? 0, n = a - o;
  dm({
    axis: t,
    numberOfElementsToBeDeleted: n,
    tickOrGuide: ce.Ticks
  });
}
function i0(t) {
  const { valueAxis: e, axisConfig: i, ticks: a } = t;
  JL(e, a), e0({ valueAxis: e, axisConfig: i, ticks: a }), t0(e, a);
}
function fm(t) {
  const { axis: e, labels: i, restoreLabelsVisibility: a = !0 } = t;
  let o, n = 0;
  if ((i ?? e.renderer.labels.values).forEach((s) => {
    const r = s.x instanceof mn ? s.x.value : s.x;
    r > n && (n = r, o = s), a && Q(s, !0);
  }), o?.visible === !0) {
    const s = Math.max(1, o.measuredWidth) / 2, r = e.chart.leftAxesContainer.measuredWidth;
    if (Number.isFinite(n) && Number.isFinite(s) && Number.isFinite(r)) {
      const c = n + s + r > e.chart.measuredWidth && o.rotation === 0;
      Q(o, !c);
    }
  }
}
function mm(t) {
  const e = t.renderer.labels.values.filter(
    (i) => je(i.uid, "isGuide") !== !0 && i.measuredWidth > 0
  ).length;
  return t.pixelWidth / e;
}
function a0(t) {
  const { target: e } = t;
  if ((I(e.chart.uid, "config")?.horizontalAxisLabelsBehavior ?? ke.Rotate) === ke.Wrap) {
    let o = Number.MAX_SAFE_INTEGER;
    e.renderer.labels.each((s) => {
      je(s.uid, "isGuide") !== !0 && s.measuredWidth > 0 && (o = Math.min(
        o,
        s.bbox.width
      ));
    });
    const n = e instanceof ze ? e.pixelWidth / L.maxNumberOfXAxisLabelsInWrapModeForDateAxis : e.pixelWidth / L.maxNumberOfXAxisLabelsInWrapMode;
    e.renderer.minGridDistance = Math.max(o + 1, n);
  }
}
function o0(t) {
  const { axis: e, labelsConfig: i, horizontalAxisLabelsBehavior: a, isSecondValueAxis: o, tickSpacing: n } = t;
  let s = e.renderer.minGridDistance;
  if (typeof n == "number" && Number.isFinite(n))
    s = n;
  else if (e.renderer instanceof En)
    s = L.gauge.gaugeMinGridDistance;
  else if (e instanceof ve)
    s = e.renderer instanceof wt ? L.xAxisMinGridDistance : L.yAxisMinGridDistance;
  else if (e.renderer instanceof wt)
    if (o === !0)
      s = L.secondRotatedValueAxisMinGridDistance;
    else if (a === void 0 || a === ke.Rotate) {
      const r = i.content.font?.size ?? L.generalFontSize, l = e instanceof lt ? L.categoryAxisLabelPadding : L.axisLabelPadding;
      s = r * l;
    } else if (a === ke.Wrap) {
      const r = Ye(
        a0,
        L.debounceTime
      );
      et(e.uid, {
        debouncedUpdateMinGridDistanceForWrapBehavior: r
      }), e.events.on(B.SizeChanged, r), e.dispatchImmediately(B.SizeChanged);
    } else a === ke.Stagger ? s = L.staggerMinGridDistance : s = e instanceof lt ? L.xCategoryAxisMinGridDistance : L.xAxisMinGridDistance;
  else
    s = e instanceof lt ? L.yCategoryAxisMinGridDistance : L.yAxisMinGridDistance;
  e.renderer.minGridDistance = s;
}
function n0(t) {
  const e = t.renderer.labels.template;
  kt(e) && (e.adapter.add(
    "rotation",
    (i, a) => je(a.uid, "isGuide") !== !0 ? nt(t.uid, "labelsSymbol")?.angle ?? i : i
  ), e.adapter.add(
    "verticalCenter",
    (i, a) => je(a.uid, "isGuide") !== !0 ? nt(t.uid, "labelsSymbol")?.verticalCenter ?? i : i
  ), e.adapter.add(
    "horizontalCenter",
    (i, a) => je(a.uid, "isGuide") !== !0 ? nt(t.uid, "labelsSymbol")?.horizontalCenter ?? i : i
  ), e.adapter.add("dy", (i, a) => {
    let o = L.axisLabel.dy ?? i ?? 0;
    return a.dataItem?.tick?.length > L.axisTickLength ? o = i ?? 0 : o = Number(
      je(a.uid, "isGuide") !== !0 ? nt(t.uid, "labelsSymbol")?.yOffset ?? o : o
    ), o;
  }));
}
function s0(t) {
  const { target: e } = t;
  if (e.chart !== void 0) {
    const a = I(e.chart.uid, "config")?.axes?.[0].labels;
    if ((a?.visible ?? !0) && a !== void 0 && e.renderer.labels.length > 1) {
      let n = 0;
      e.renderer.labels.each((c) => {
        if (je(c.uid, "isGuide") !== !0 && c.measuredWidth > 0) {
          const u = c.bbox.width;
          u > n && (n = u);
        }
      });
      const s = nt(e.uid, "labelsSymbol")?.angle ?? 0, l = mm(e) >= n + 5;
      if (!l && s === 0 || l && s === L.rotatedAxisLabel.rotation) {
        const c = l ? Sn(a.content, e.rtl, L.axisLabel) : Sn({ type: te.TS }, e.rtl, L.rotatedAxisLabel);
        et(e.uid, { labelsSymbol: c }), e.renderer.invalidateLabels();
      }
    }
  }
}
function r0(t, e = 1) {
  const { target: i } = t, a = mm(i);
  Number.isFinite(a) && (i.renderer.labels.template.maxWidth = Math.min(a * e, i.renderer.minGridDistance));
}
function l0(t) {
  const { target: e } = t;
  if (I(e.chart.uid, "config")?.axes?.[0].labels?.visible !== !1) {
    let o = 0;
    e.dataItems.each((n) => {
      const { label: s, itemIndex: r } = n;
      je(s.uid, "isGuide") !== !0 && s.currentText !== void 0 && s.measuredWidth > 0 && r % 2 === 0 && s.bbox.height > o && (o = s.bbox.height);
    }), e.dataItems.each((n) => {
      const { tick: s, label: r, itemIndex: l } = n;
      if (je(r.uid, "isGuide") !== !0 && r.currentText !== void 0 && r.measuredWidth > 0) {
        const c = l % 2 === 1;
        s.length = c ? o + 5 : L.axisTickLength, s.dataItem.label.dy = L.axisLabel.dy + (c ? o : 0);
      }
    }), o !== void 0 && (e.renderer.labels.template.paddingBottom = o + 5), e.validate();
  }
}
function c0(t) {
  const { chart: e } = t;
  t.renderer.labels.template.paddingLeft = Number.NaN, t.renderer.labels.template.paddingRight = Number.NaN;
  const i = nt(t.uid, "debouncedAxisLabelRotationCallback");
  if (i !== void 0 && (t.events.off(B.Validated, i), et(t.uid, {
    debouncedAxisLabelRotationCallback: void 0
  })), e !== void 0) {
    const o = I(e.uid, "config")?.axes?.[0].labels;
    if (o !== void 0) {
      const n = Sn(o.content, e.rtl, L.axisLabel), s = t.renderer.labels.template;
      s.rotation = n.angle, s.verticalCenter = n.verticalCenter, s.horizontalCenter = n.horizontalCenter, Number.isFinite(n.yOffset) && (s.dy = n.yOffset);
    }
    et(t.uid, { labelsSymbol: void 0 });
  }
}
function gm(t) {
  t.renderer.labels.template.wrap = !1, t.renderer.labels.template.textAlign = "start";
}
function d0(t) {
  gm(t), t.renderer.labels.template.paddingLeft = Number.NaN, t.renderer.labels.template.paddingRight = Number.NaN;
  const e = nt(
    t.uid,
    "debouncedAxisLabelWrapCallback"
  );
  e !== void 0 && (t.events.off(B.DataRangeChanged, e), et(t.uid, { debouncedAxisLabelWrapCallback: void 0 }));
}
function u0(t) {
  gm(t);
  const e = nt(t.uid, "debouncedUpdateMinGridDistanceForWrapBehavior");
  e !== void 0 && (t.events.off(B.SizeChanged, e), et(t.uid, {
    debouncedUpdateMinGridDistanceForWrapBehavior: void 0
  }));
}
function f0(t) {
  const e = nt(t.uid, "debouncedAxisLabelStaggerCallback");
  e !== void 0 && (t.events.off(B.DataRangeChanged, e), et(t.uid, {
    debouncedAxisLabelStaggerCallback: void 0
  })), t.renderer.ticks.each((i) => {
    i.length = L.axisTickLength, i.dataItem?.label && (i.dataItem.label.dy = L.axisLabel.dy ?? 0);
  });
}
function m0(t) {
  c0(t), d0(t), f0(t);
}
function fc(t) {
  n0(t), t.renderer.labels.template.paddingLeft = 0, t.renderer.labels.template.paddingRight = 0, t.renderer.labels.template.maxWidth = Number.NaN;
  const e = Ye(s0, L.debounceTime, {
    leading: !0
  });
  et(t.uid, { debouncedAxisLabelRotationCallback: e }), t.events.on(B.Validated, e), t.dispatchImmediately(B.Validated);
}
function mc(t, e = 1) {
  t.renderer.labels.template.wrap = !0, t.renderer.labels.template.paddingLeft = 0.5, t.renderer.labels.template.paddingRight = 0.5, t.renderer.labels.template.textAlign = "middle";
  const i = Ye((a) => r0(a, e), L.debounceTime);
  et(t.uid, { debouncedAxisLabelWrapCallback: i }), t.events.on(B.DataRangeChanged, i);
}
function g0(t) {
  t.renderer.labels.template.maxWidth = L.yAxisLabelMaxWidth, t.renderer.labels.template.wrap = !0, t.renderer.labels.template.textAlign = "end";
}
function h0(t) {
  const e = Ye(l0, L.debounceTime);
  et(t.uid, { debouncedAxisLabelStaggerCallback: e }), t.events.on(B.DataRangeChanged, e);
}
function p0(t) {
  const {
    axis: e,
    horizontalAxisLabelsBehavior: i,
    verticalAxisLabelsBehavior: a,
    labelsConfig: o,
    axisLabelsBehaviorChanged: n,
    isSecondValueAxis: s
  } = t;
  if (e.renderer instanceof wt && n?.[0] !== !1) {
    if (m0(e), s !== !0)
      switch (i) {
        case ke.Hide:
          break;
        case ke.Stagger:
          h0(e), mc(e, 1.5);
          break;
        case ke.Wrap:
          mc(e);
          break;
        case ke.Rotate:
          fc(e);
          break;
        default:
          o.content.angle !== null && o.content.angle === void 0 && fc(e);
          break;
      }
  } else e.renderer instanceof Va && (a !== ke.Hide ? g0(e) : u0(e));
}
function b0(t) {
  const {
    axis: e,
    axisConfig: i,
    chartType: a,
    horizontalAxisLabelsBehavior: o,
    verticalAxisLabelsBehavior: n,
    axisLabelsBehaviorChanged: s,
    isSecondValueAxis: r
  } = t;
  if (e.renderer instanceof Va || a !== b.HistogramSeries) {
    const l = e.renderer.labels.template;
    l.axis = e;
    const { labels: c } = i, u = e.renderer instanceof wt && l.rotation === L.rotatedAxisLabel.rotation, d = c;
    let m;
    u ? (d.content.angle = void 0, d.content.horizontalAlignment = void 0, d.content.verticalAlignment = void 0, d.content.yoffset = void 0, m = L.rotatedAxisLabel) : e.renderer instanceof wt && (o === ke.Stagger || o === ke.Wrap) && (m = { wrap: !0, dy: L.axisLabel.dy }), e.renderer instanceof Va && n !== ke.Hide && (m = { wrap: !0 }), Tt({ label: l, labelConfig: d, defaults: m }), e.renderer.labels.template.paddingTop = e.renderer instanceof wt ? 0 : L.axisLabel.dy, l.align = "none", l.valign = "none", p0({
      axis: e,
      horizontalAxisLabelsBehavior: o,
      verticalAxisLabelsBehavior: n,
      labelsConfig: c,
      axisLabelsBehaviorChanged: s,
      isSecondValueAxis: r
    }), l.axis.invalidateLabels();
  }
}
function qr(t) {
  return (t ?? jc()) === Ie.Side;
}
function hm(t, e) {
  let i, a;
  const o = To(t, "bullets"), n = To(t, "columns"), s = qr(e);
  return s && o !== void 0 ? (i = o, a = n) : s || (i = n, a = o), { labelToRender: i, labelToHide: a };
}
function y0(t, e = !0) {
  t.hideOversized = e;
}
function S0(t, e) {
  let i, a;
  const o = Vt(L.dataLabelInitialize);
  ci(o.uid, { isDataLabel: !0 }), t.bullets.push(o);
  const n = Vt(L.dataLabelInitialize, t.columns.template);
  return ci(n.uid, { isDataLabel: !0 }), Ns(n, t), Ns(o, t), t.events.on(
    B.Validated,
    Ye(() => {
      Fo(n) && n.clones.each((s) => {
        Fo(s) && s.validate();
      });
    }, L.debounceTime)
  ), n.html = "{valueX}", o.html = "{valueX}", zr(o), qr(e) ? (i = o, a = n) : (i = n, a = o), Er(b.BarSeries, o), zf(b.BarSeries, i), { newLabelToRender: i, newLabelToHide: a };
}
function x0(t) {
  const { series: e, stackedType: i, isRotated: a, hideOversizedStackedLabels: o, hideOversizedSideBySideLabels: n } = t;
  let { labelToRender: s, labelToHide: r } = hm(e, i);
  if (s === void 0) {
    const { newLabelToRender: u, newLabelToHide: d } = S0(e, i);
    s = u, r = d;
  }
  let l = L.dataLabel, c = !0;
  qr(i) ? (l = a === !0 ? L.dataLabelRotated : L.dataLabel, c = n === !0) : (l = a === !0 ? L.dataLabelStackedRotated : L.dataLabelStackedNonRotated, c = o !== !1), y0(s, c), r !== void 0 && (r.visible = !1, r.disabled = !0), s.html = "{valueX}", es({
    ...t,
    dataLabel: s,
    labelDefaults: l,
    defaultDataLabelFormatter: Wf,
    seriesType: b.BarSeries
  });
}
function C0(t) {
  const e = t.tooltip;
  e !== void 0 && !(t instanceof ze) && (e.label.adapter.add("html", (i, a) => {
    let o = i ?? "";
    return t instanceof ve ? o = Mr(t, a.properties?.text ?? i ?? "") : t instanceof lt && (o = Tf({
      axis: t,
      defaultOutput: i ?? "",
      dataItem: e.dataItem
    })), He(o);
  }), e.label.html = L.htmlEmptyContent);
}
function Ps(t) {
  const { axis: e, start: i, end: a } = t;
  e.zoom({ start: i ?? 0, end: a ?? 1 });
}
function gc(t) {
  t !== void 0 && (t.start = 0, t.end = 1);
}
function _r(t) {
  t !== void 0 && (t.xAxes !== void 0 && t.xAxes.each((e) => Ps({ axis: e })), t.yAxes !== void 0 && t.yAxes.each((e) => Ps({ axis: e })), gc(t.scrollbarX), gc(t.scrollbarY), Q(t.zoomOutButton, !1));
}
function Ca(t, e) {
  return t instanceof wt && e !== !0 || t instanceof Va && e === !0;
}
function v0(t) {
  kt(t.labels.template) && (t.labels.template.events.on(B.Over, (e) => {
    const { axisLabelOveredOpacity: i } = L;
    e.target.fillOpacity = (e.target.fillOpacity ?? 1) * i;
  }), t.labels.template.events.on(B.Out, (e) => {
    const { axisLabelOveredOpacity: i } = L;
    e.target.fillOpacity = (e.target.fillOpacity ?? 0.5) / i;
  }));
}
function L0(t) {
  const { axis: e, valueFormat: i, axisRenderer: a, chartType: o } = t;
  a.grid.template.applyOnClones = !0, a.ticks.template.applyOnClones = !0, a.labels.template.applyOnClones = !0, a.hoverable = !0, a.line.strokeOpacity = 1, a.grid.template.strokeOpacity = 1, a.ticks.template.strokeOpacity = 1, Jn(a.labels.template, L.axisLabel), a.ticks.template.disabled = !1, a.labels.template.disabled = !0, C0(e), Oo(i) && (v0(a), BL(e)), ko({
    chart: e.chart,
    label: e.title,
    labelType: e.renderer instanceof wt ? ae.XAxisTitle : ae.YAxisTitle
  }), e.renderer instanceof wt && o !== b.HistogramSeries && e.events.on(
    B.Validated,
    Ye(() => {
      fm({ axis: e, restoreLabelsVisibility: !0 });
    }, L.debounceTime)
  );
}
function F0(t) {
  const e = t.target, i = I(e.chart.uid, "isRotated");
  let a = [];
  if (e instanceof ve) {
    if (e.renderer instanceof En)
      a.push({
        isXAxis: !0,
        minimum: e.min,
        maximum: e.max
      });
    else if (e.renderer instanceof (i !== !0 ? Va : wt)) {
      e.maxZoomFactor = 1;
      const o = t.target, n = o.chart, s = i !== !0 ? n.xAxes.getIndex(0) : n.yAxes.getIndex(0), r = n.yAxes.getIndex(1) ?? n.xAxes.getIndex(1);
      a = [
        {
          isXAxis: !1,
          minimum: o.min,
          maximum: o.max
        },
        {
          isXAxis: !0,
          minimum: s instanceof ve ? s.min : void 0,
          maximum: s instanceof ve ? s.max : void 0
        }
      ], r instanceof ve && a.push({
        isXAxis: !1,
        isSecondValueAxis: !0,
        minimum: r.min,
        maximum: r.max
      });
    }
    a.length > 0 && a.every((o) => Number.isFinite(o.minimum) && Number.isFinite(o.maximum)) && dd(a, e.chart.htmlContainer);
  }
}
function A0(t) {
  t.events.on(B.Validated, Ye(F0, L.debounceTime));
}
function T0(t) {
  const { axis: e, isNonAggregatedChart: i } = t;
  let a, o, n;
  const s = e.dataItems.values, r = e.axisRanges.values;
  if (e instanceof lt)
    for (let l = 0; l < r.length; l += 1) {
      a = !1, o = !1, n = !1;
      const c = r[l], { category: u, endCategory: d, axisFill: m, grid: g, label: h } = c;
      if (c instanceof Pa && c.visible)
        for (let y = 0; y < s.length; y += 1) {
          let p;
          i === !0 ? p = oi({
            value: s[y].category,
            dataContext: s[y].dataContext
          }) : p = s[y].category.toString(), u === p && (o = !0), d === p && (n = !0);
        }
      o && n && (a = !0), Q(m, a), Q(g, a), Q(h, a);
    }
}
function hc(t) {
  const { axis: e, axisMinimum: i, axisMaximum: a } = t;
  let o;
  if (e instanceof ve && a !== void 0 && i !== void 0) {
    const n = e.axisRanges.values, s = I(e.chart.uid, "config"), r = I(e.chart.uid, "isRotated"), c = !Ca(e.renderer, r) ? 1 : 0, d = s?.axes?.[c]?.guides;
    for (let m = 0; m < n.length; m += 1) {
      const g = n[m], { value: h, endValue: y, axisFill: p, grid: S, label: x } = g;
      if (je(x?.uid, "isGuide") === !0) {
        if (o = g.visible, o && g instanceof dr) {
          const { start: v, end: F } = jr(e, d?.[m]), T = Math.min(h, y, v ?? h, F ?? y), k = Math.max(h, y, v ?? h, F ?? y);
          T < i && k < i || T > a && k > a ? o = !1 : (g.value = T < i ? i : T, g.endValue = k > a ? a : k);
        }
        Q(p, o), Q(S, o), Q(x, o);
      }
    }
  }
}
function k0(t) {
  t instanceof ve ? (t.adapter.add("min", (e) => (hc({
    axis: t,
    axisMinimum: e,
    axisMaximum: t.max
  }), e)), t.adapter.add("max", (e) => (hc({
    axis: t,
    axisMinimum: t.min,
    axisMaximum: e
  }), e))) : t instanceof lt && t.events.on(B.Validated, () => {
    const e = I(t.chart.uid, "isNonAggregatedChart");
    T0({ axis: t, isNonAggregatedChart: e });
  });
}
function uo(t) {
  const { axes: e, isSecondValueAxis: i = !1, isXAxis: a, valueFormat: o, chartType: n } = t;
  let s;
  if (rr({ isXAxis: a, chartType: n, valueFormat: o }) && !i)
    s = e.push(new lt());
  else if (mi(o))
    s = e.push(new ze());
  else if (Lt(o)) {
    s = e.push(new ve());
    const r = I(s.chart.uid, "formatLocale");
    s.numberFormatter = Ot({
      type: b.NumberAxisFormat,
      iLocale: s.chart.language.locale,
      formatLocale: r
    }), s.numberFormatter.numberFormat = "#", i ? (s.renderer.opposite = !0, s.renderer.grid.template.disabled = !0) : A0(s);
  }
  s !== void 0 && (hC(s), L0({
    axis: s,
    valueFormat: o,
    axisRenderer: s.renderer,
    chartType: n
  }), k0(s));
}
function ns(t) {
  const { chart: e, axesConfig: i, isRotated: a, chartType: o } = t;
  j(e.uid, { isRotated: a === !0 });
  const n = a === !0 ? i?.[1] : i?.[0], s = a === !0 ? i?.[0] : i?.[1], r = n?.valueFormat, l = s?.valueFormat;
  r !== void 0 && l !== void 0 && (e.xAxes.clear(), e.yAxes.clear(), uo({
    chartType: o,
    isXAxis: a !== !0,
    axes: e.xAxes,
    valueFormat: r
  }), uo({
    chartType: o,
    isXAxis: a === !0,
    axes: e.yAxes,
    valueFormat: l
  }), i?.[2] !== void 0 && uo({
    chartType: o,
    isXAxis: a === !0,
    axes: a === !0 ? e.xAxes : e.yAxes,
    valueFormat: i[2].valueFormat,
    isSecondValueAxis: !0
  }));
}
function pm(t, e) {
  const { chart: i } = t;
  let a = !0;
  if (i !== void 0) {
    const o = I(i.uid, "config"), n = I(i.uid, "isRotated");
    if (o !== void 0) {
      const s = Ca(t.renderer, n);
      let r = 0;
      s || (r = e === !0 ? 2 : 1);
      const { isLogarithmic: l } = o.axes?.[r] ?? {};
      if (l === !0) {
        const c = Do({
          chartConfig: o,
          isSecondValueAxis: e
        }), { minY: u, maxY: d, minX: m, maxX: g } = $n({
          chartConfig: o,
          chartData: i.data,
          filteredSeriesIds: c
        }), h = s ? m : u, y = s ? g : d;
        Number.isFinite(h) && h !== Number.MAX_SAFE_INTEGER && Number.isFinite(y) && y !== Number.MIN_SAFE_INTEGER && (a = h > 0 && y > 0);
      }
    }
  }
  return a;
}
function I0(t) {
  const { axis: e, isLogarithmic: i, isSecondValueAxis: a } = t;
  (e instanceof ze || e instanceof ve) && (e.logarithmic = i === !0 && pm(e, a));
}
function w0(t, e) {
  const { minimum: i, maximum: a, isLogarithmic: o } = e ?? {};
  let { buffer: n } = e ?? {};
  return n ??= L.buffer, t instanceof ve && !(t instanceof ze) && !n && (o !== !0 || a != null || i != null);
}
function $0(t, e) {
  let i = !1;
  return t instanceof ve && !(t instanceof ze) && (i = w0(t, e), t.strictMinMax = i), i;
}
function D0(t) {
  let e;
  return t >= 1 ? e = 10 ** (t.toFixed(0).length - 1) : t < 1 && t > 0 && (e = 10 ** -Math.abs(Math.floor(Math.log10(t)))), e;
}
function O0(t) {
  const { axis: e, axisConfig: i, chartType: a, isSecondValueAxis: o } = t, n = i?.minimum, s = i?.maximum, r = i?.isLogarithmic ?? !1;
  let l = n, c = s;
  const { chart: u } = e, d = I(u.uid, "isRotated"), m = I(u.uid, "config");
  let g = 0;
  if (u instanceof ne && m !== void 0) {
    const h = zt(m), y = Ca(e.renderer, d), p = HC(u), S = Do({
      chartConfig: m,
      isSecondValueAxis: o,
      seriesIds: p
    }), x = $n({
      chartConfig: m,
      chartData: u.data,
      filteredSeriesIds: S
    }), { minX: C, maxX: v, minY: F, maxY: T } = x, [k, $] = y ? [C ?? Number.NaN, v ?? Number.NaN] : [F, T];
    g = k, a === b.BarSeries || a === b.HistogramSeries || a === b.ComboLineAndBarSeries || a === b.LineSeries && h === Ie.Stacked && !y ? (l = Math.min(k, 0), c = Math.max($, 0)) : (l = k, c = $);
  }
  return l = n ?? l, c = s ?? c, r && l !== void 0 && l !== null && l <= 0 && (l = D0(g)), { min: l, max: c };
}
function bm(t) {
  const { axis: e, axisConfig: i, chartType: a, isSecondValueAxis: o } = t, { minimum: n, maximum: s, isLogarithmic: r } = i ?? {};
  if (e instanceof ve || e instanceof ze)
    if ($0(e, i)) {
      let c = n, u = s;
      if (
        // If both the min and max from the config are valid, we directly assign them.
        // Otherwise, if strictMinMax is true, or if logarithmic is on and minimum is set to 0, we add some logic to consider the chart's data
        a !== b.HistogramSeries && (n != null && n <= 0 && r === !0 || e.strictMinMax && (!Number.isFinite(n) || !Number.isFinite(s)))
      ) {
        const d = O0({
          axis: e,
          axisConfig: i,
          chartType: a,
          isSecondValueAxis: o
        });
        c = d.min, u = d.max;
      }
      c = c ?? Number.NaN, u = u ?? Number.NaN, Number.isNaN(c) || Number.isNaN(u) || c < u ? (e.min = c, e.max = u) : (e.min = Number.NaN, e.max = Number.NaN), a === b.GaugeSeries && e.validate();
    } else
      e.min = Number.NaN, e.max = Number.NaN;
}
function R0(t) {
  const { axis: e, timeIntervalInfo: i, dateBaseInterval: a } = t;
  if (e instanceof ze) {
    let { size: o, unit: n } = i ?? {};
    if (n || ({ size: o, unit: n } = a ?? {}), o !== void 0 && n !== void 0) {
      let s;
      switch (n) {
        case xe.Second:
          s = "second";
          break;
        case xe.Minute:
          s = "minute";
          break;
        case xe.Hour:
          s = "hour";
          break;
        case xe.Day:
          s = "day";
          break;
        case xe.Week:
          s = "week";
          break;
        case xe.Month:
          s = "month";
          break;
        case xe.Year:
          s = "year";
          break;
      }
      s !== void 0 && (e.baseInterval = {
        timeUnit: s,
        count: o
      });
    }
  }
}
function B0(t, e) {
  t instanceof ve && (t.renderer.baseGrid.disabled = e !== !0);
}
function M0(t, e) {
  t.cursorTooltipEnabled = e === !0;
}
function N0(t, e) {
  const i = t.renderer instanceof wt;
  t.events.once(B.Validated, () => {
    let a = t.renderer instanceof Va ? L.yAxisTitleLabel : L.xAxisTitleLabel;
    i && (a = { ...a, dy: a.dy ?? 0 }), Tt({ label: t.title, labelConfig: e, defaults: a }), ca({
      chart: t.chart,
      label: t.title,
      labelType: t.renderer instanceof wt ? ae.XAxisTitle : ae.YAxisTitle
    });
  });
}
function P0(t, e) {
  let i = !0;
  switch (e) {
    case b.ScatterSeries:
    case b.HistogramSeries:
      i = _(t.uid, "isOverlay") !== !0;
      break;
    case b.BoxPlotSeries:
      i = t instanceof _e;
      break;
  }
  return i;
}
function ym(t) {
  const e = Ye(() => {
    const { chart: i } = t, a = I(i.uid, "config");
    if (i !== void 0 && a !== void 0) {
      const o = z(a?.series);
      if (P0(t, o)) {
        const n = I(i.uid, "isRotated"), s = _(t.uid, "stackedType");
        s === Ie.Stacked100 && !t.visible && Q(t, !1);
        const l = i.xAxes.getIndex(0), c = i.yAxes.getIndex(0), u = i.yAxes.getIndex(1), d = n === !0 ? 1 : 0, m = a.axes?.[d], g = n === !0 ? 0 : 1, h = a.axes?.[g], y = a.axes?.[2];
        [
          { axis: l, axisConfig: m, updateLabels: !1 },
          { axis: c, axisConfig: h, updateLabels: !0 },
          {
            axis: u,
            axisConfig: y,
            updateLabels: !0,
            isSecondValueAxis: !0
          }
        ].forEach((p) => {
          const { axis: S, axisConfig: x, updateLabels: C, isSecondValueAxis: v } = p;
          S !== void 0 && (bm({
            axis: S,
            chartType: o,
            axisConfig: x,
            isSecondValueAxis: v
          }), C !== void 0 && S.events.once(B.Validated, () => {
            const { labelToRender: F } = hm(t, s);
            F && (F.html = n === !0 ? "{valueX}" : "{valueY}");
          }));
        });
      }
    }
  }, L.debounceTime);
  t.events.once(B.Validated, e);
}
function V0(t, e) {
  if (t instanceof ve) {
    const { integerOnlyValues: i, valueFormat: a } = e, o = Qc(a) ? a.intlOptions.maximumFractionDigits : void 0;
    t.maxPrecision = i === !0 || o === 0 ? 0 : Number.NaN;
  }
}
async function tn(t) {
  const {
    axis: e,
    axisConfig: i,
    timeIntervalInfo: a,
    chartType: o,
    horizontalAxisLabelsBehavior: n,
    verticalAxisLabelsBehavior: s,
    axisLabelsBehaviorChanged: r,
    guideTooltipFormatter: l,
    stackedType: c,
    axisValueFormatter: u,
    isSecondValueAxis: d,
    isRotated: m,
    utilsStrings: g,
    errorStrings: h
  } = t, {
    visible: y,
    isLogarithmic: p,
    title: S,
    grid: x,
    lineSymbol: C,
    labels: v,
    guides: F,
    valueFormat: T,
    displayZeroLine: k,
    displayCursorTooltip: $,
    tickSpacing: O,
    dateBaseInterval: D
  } = i;
  R0({ axis: e, timeIntervalInfo: a, dateBaseInterval: D }), Ut({
    element: e.renderer.grid.template,
    lineSymbol: x,
    visible: y
  }), Ut({
    element: e.renderer.line,
    lineSymbol: {
      color: [...L.color],
      ...C ?? wo()
    },
    visible: y
  }), Ut({
    element: e.renderer.ticks.template,
    lineSymbol: C,
    visible: y
  }), b0({
    axis: e,
    axisConfig: i,
    chartType: o,
    horizontalAxisLabelsBehavior: n,
    verticalAxisLabelsBehavior: s,
    axisLabelsBehaviorChanged: r,
    isSecondValueAxis: d
  }), V0(e, i), o0({
    axis: e,
    labelsConfig: v,
    horizontalAxisLabelsBehavior: n,
    isSecondValueAxis: d,
    tickSpacing: O
  }), await xC({
    axis: e,
    isXAxis: Ca(e.renderer, m),
    chartType: o,
    labelsTextSymbol: i.labels.content,
    formatOptions: T,
    overridePercentMultiplication: c === Ie.Stacked100,
    axisValueFormatter: u,
    errorStrings: h
  }), bm({
    axis: e,
    axisConfig: i,
    chartType: o,
    isSecondValueAxis: d
  }), I0({ axis: e, isLogarithmic: p, isSecondValueAxis: d }), N0(e, S), M0(e, $), d !== !0 && (ZL({ axis: e, guides: F, guideTooltipFormatter: l, utilsStrings: g }), B0(e, k));
}
async function Zr(t) {
  const {
    chart: e,
    axesConfig: i,
    rotationChanged: a,
    isRotated: o,
    dualAxisChanged: n,
    timeIntervalInfoWasReset: s,
    timeIntervalInfo: r,
    guideTooltipFormatter: l,
    xAxisLabelFormatter: c,
    yAxisLabelFormatter: u,
    secondaryYAxisLabelFormatter: d,
    utilsStrings: m,
    errorStrings: g
  } = t;
  let { axisLabelsBehaviorChanged: h } = t;
  const y = I(e.uid, "config"), { horizontalAxisLabelsBehavior: p, verticalAxisLabelsBehavior: S } = y, x = z(y.series), C = zt(y), v = o === !0 ? 1 : 0, F = o === !0 ? 0 : 1, T = i?.[v], k = i?.[F];
  let $ = e.xAxes.getIndex(0);
  Sm({
    chart: e,
    dualAxisChanged: n,
    rotationChanged: a,
    timeIntervalInfoWasReset: s,
    axisLabelsBehaviorChanged: h
  }) && (ns({
    chart: e,
    axesConfig: i,
    isRotated: o,
    chartType: x
  }), h = [!0, !0]), $ = e.xAxes.getIndex(0);
  const O = e.yAxes.getIndex(0), D = e.xAxes.getIndex(1) ?? e.yAxes.getIndex(1), R = $?.start, M = $?.end, N = O?.start, E = O?.end, V = D?.start, W = D?.end, H = {
    timeIntervalInfo: r,
    chartType: x,
    horizontalAxisLabelsBehavior: p,
    verticalAxisLabelsBehavior: S,
    axisLabelsBehaviorChanged: h,
    guideTooltipFormatter: l,
    stackedType: C,
    isRotated: o,
    utilsStrings: m,
    errorStrings: g
  };
  $ !== void 0 && T !== void 0 && await tn({
    ...H,
    axis: $,
    axisConfig: T,
    axisValueFormatter: v === 0 ? c : u
  }), O !== void 0 && k !== void 0 && await tn({
    ...H,
    axis: O,
    axisConfig: k,
    axisValueFormatter: F === 1 ? u : c
  }), D !== void 0 && i?.[2] !== void 0 && await tn({
    ...H,
    axis: D,
    axisConfig: i[2],
    axisValueFormatter: d,
    isSecondValueAxis: !0
  }), a === !0 && [
    { axis: $, start: R, end: M },
    { axis: O, start: N, end: E },
    { axis: D, start: V, end: W }
  ].forEach((Z) => {
    const { axis: oe, start: ie, end: X } = Z;
    oe !== void 0 && oe.events.once(B.Validated, () => {
      Ps({ axis: oe, start: ie, end: X });
    });
  }), $ !== void 0 && $.ghostLabel.setPropertyValue("disabled", !0), O !== void 0 && O.ghostLabel.setPropertyValue("disabled", !0), D !== void 0 && D.ghostLabel.setPropertyValue("disabled", !0);
}
function Sm(t) {
  const { chart: e, dualAxisChanged: i, rotationChanged: a, timeIntervalInfoWasReset: o, axisLabelsBehaviorChanged: n } = t, s = I(e.uid, "config"), { rotated: r, series: l } = s, c = s.axes, u = z(l), d = r === !0 ? 1 : 0, m = r === !0 ? 0 : 1, g = c?.[d]?.valueFormat, h = c?.[m]?.valueFormat, y = e.xAxes.getIndex(0), p = e.yAxes.getIndex(0), S = y === void 0 || a || g !== void 0 && Os({
    axis: y,
    valueFormat: g,
    chartType: u
  }), x = p === void 0 || a || h !== void 0 && Os({
    axis: p,
    valueFormat: h,
    chartType: u
  });
  return i === !0 || a === !0 || o === !0 || n?.[0] || n?.[1] || S || x;
}
function E0(t) {
  ns(t);
}
async function z0(t) {
  const {
    chart: e,
    chartConfig: i,
    rotationChanged: a,
    axisLabelsBehaviorChanged: o,
    isRotated: n,
    dualAxisChanged: s,
    timeIntervalInfoWasReset: r,
    timeIntervalInfo: l,
    guideTooltipFormatter: c,
    xAxisLabelFormatter: u,
    yAxisLabelFormatter: d,
    secondaryYAxisLabelFormatter: m,
    utilsStrings: g,
    errorStrings: h
  } = t, y = i.axes, p = zt(i);
  await Zr({
    chart: e,
    axesConfig: y,
    rotationChanged: a,
    axisLabelsBehaviorChanged: o,
    isRotated: n,
    dualAxisChanged: s,
    timeIntervalInfoWasReset: r,
    timeIntervalInfo: l,
    guideTooltipFormatter: c,
    xAxisLabelFormatter: u,
    yAxisLabelFormatter: d,
    secondaryYAxisLabelFormatter: m,
    utilsStrings: g,
    errorStrings: h
  });
  const S = n === !0 ? e.yAxes.getIndex(0) : e.xAxes.getIndex(0);
  if (S !== void 0) {
    S instanceof lt && (S.dataFields.category = ir(i));
    const v = S.renderer, F = v.grid.template;
    F.location = 0, v.cellStartLocation = 0.1, v.cellEndLocation = 0.9;
    const T = i.orderOptions?.data?.orderBy === Ln.Descending;
    let k = n === !0;
    T && S instanceof ze && (k = !k), v.inversed = k;
  }
  const x = n === !0 ? e.xAxes.getIndex(0) : e.yAxes.getIndex(0), C = n === !0 ? e.xAxes.getIndex(1) : e.yAxes.getIndex(1);
  p === Ie.Stacked100 ? (x instanceof ve && (x.calculateTotals = !0), C instanceof ve && (C.calculateTotals = !0)) : (x instanceof ve && (x.calculateTotals = !1), C instanceof ve && (C.calculateTotals = !1));
}
const Je = {
  InnerLabel: 0,
  InnerLabelSecondary: 1,
  AxisLabels: 2,
  FirstAndLastLabels: 3
};
function Yi(t, e) {
  let i;
  switch (e) {
    case Je.InnerLabel:
      i = "gaugeAutoResizeInnerLabelFirstDisposer";
      break;
    case Je.InnerLabelSecondary:
      i = "gaugeAutoResizeInnerLabelSecondDisposer";
      break;
    case Je.AxisLabels:
      i = "gaugeAutoResizeAxisLabelsDisposer";
      break;
    case Je.FirstAndLastLabels:
      i = "gaugeAutoResizeFirstAndLastLabelsDisposer";
      break;
  }
  if (i !== void 0) {
    let a = I(t.uid, i);
    a !== void 0 && (a.dispose(), a = void 0, j(t.uid, { [i]: void 0 }));
  }
}
function W0(t) {
  const { chart: e, labelList: i, scaleToAdjust: a, fontSize: o, type: n, axisConfig: s } = t;
  let r = Number.NaN, l = Number.NaN, c = a;
  if (n === Je.InnerLabel) {
    const d = i[0], m = s?.innerLabel?.content?.verticalAlignment ?? ee.Middle, g = d.dy ?? 0, h = Math.round(e.chartContainer.measuredHeight - e.radarContainer.pixelY - g), y = d.bbox.height * a;
    let p = 0;
    switch (m) {
      case ee.Bottom:
        p = y;
        break;
      case ee.Top:
        p = -y;
        break;
      case ee.Middle:
      case ee.Baseline:
        p = y * 0.5;
        break;
    }
    p > h && (c = a * (h / p)), r = L.gauge.innerLabelAutoMinFontSize, l = L.gauge.innerLabelAutoMaxFontSize;
  } else
    r = L.gauge.axisLabelAutoMinFontSize, l = L.gauge.axisLabelAutoMaxFontSize;
  const u = o * c;
  return u < r ? c *= r / u : u > l && (c *= l / u), c;
}
function Kr(t) {
  const { chart: e, type: i, labelList: a, currentScale: o, currentFontSize: n, axisConfig: s } = t;
  let r = Number.NaN, l = Number.NaN;
  if (i === Je.InnerLabel) {
    const c = typeof e.innerRadius == "number" ? e.innerRadius : e.innerRadius.value;
    l = (e.xAxes.getIndex(0)?.measuredWidth !== 0 ? e.xAxes.getIndex(0)?.measuredWidth ?? 1 : 1) * c;
  } else
    l = e.xAxes.getIndex(0)?.measuredHeight ?? 1;
  if (l > 1) {
    const c = i === Je.InnerLabel ? a[0]?.measuredWidth ?? 0 : a.find((u) => u.measuredWidth > 0 && u.measuredHeight > 0)?.measuredHeight ?? 0;
    if (c > 0) {
      const u = c / l;
      if (u > 0) {
        const { axisLabelToInnerChartRatio: d, innerLabelToInnerChartRatio: m } = L.gauge, g = i === Je.InnerLabel ? m : d;
        r = o * (g / u), r = W0({
          chart: e,
          labelList: a,
          axisConfig: s,
          scaleToAdjust: r,
          fontSize: n,
          type: i
        }), r = Number(r.toFixed(2));
      }
    }
  }
  return Number.isFinite(r) || (r = o), r;
}
function ss(t) {
  return t.some((i) => On(i) && i.value !== void 0);
}
function H0(t) {
  const { chart: e, axisConfig: i, axis: a } = t;
  if (i.labels.content.font?.size === void 0 && i.onlyShowFirstAndLastLabels !== !0) {
    Yi(e, Je.AxisLabels), Yi(e, Je.FirstAndLastLabels);
    const o = () => {
      a.events.once(B.Validated, () => {
        const s = Ze(a, ce.GaugeTicksWithLabels);
        if (ss(s)) {
          const r = s.map((m) => m.label), l = r[0].scale, c = r[0].fontSize, u = Kr({
            chart: e,
            type: Je.AxisLabels,
            labelList: r,
            currentScale: l,
            currentFontSize: c,
            axisConfig: i
          }), d = u / l;
          Number.isFinite(u) && u > 0 && (d <= 0.98 || d > 1.02) && r.forEach((m) => {
            m.scale = u;
          });
        }
      }), a.validate();
    };
    e.events.once(B.Validated, o);
    const n = e.events.on(B.SizeChanged, o);
    j(e.uid, { gaugeAutoResizeAxisLabelsDisposer: n }), o();
  } else {
    Yi(e, Je.AxisLabels);
    const o = Ze(a, ce.GaugeTicksWithLabels);
    o.length > 0 && o.map((s) => s.label).forEach((s) => {
      s.scale = 1;
    });
  }
}
function G0(t, e) {
  Yi(t, Je.InnerLabel), Yi(t, Je.InnerLabelSecondary);
  const i = () => {
    const s = I(t.uid, "config")?.axes?.[0];
    if (s?.innerLabel?.visible !== !1 && s?.innerLabel?.content?.font?.size === void 0) {
      const r = t.xAxes.getIndex(0)?.measuredWidth;
      if (r !== void 0 && r > 0) {
        const l = Kr({
          chart: t,
          type: Je.InnerLabel,
          labelList: [e],
          currentScale: e.scale,
          currentFontSize: e.fontSize,
          axisConfig: s
        });
        Number.isFinite(l) && Math.abs(e.scale - l) > 0.25 && (e.scale = l, e.validate());
      }
    } else
      e.scale = 1;
  }, a = t.events.on(B.Validated, i), o = t.events.on(B.SizeChanged, i);
  j(t.uid, {
    gaugeAutoResizeInnerLabelFirstDisposer: o,
    gaugeAutoResizeInnerLabelSecondDisposer: a
  }), i();
}
function X0(t) {
  const { chart: e, axisConfig: i, axis: a } = t;
  if (i.labels.content.font?.size === void 0 && i.onlyShowFirstAndLastLabels === !0) {
    Yi(e, Je.AxisLabels), Yi(e, Je.FirstAndLastLabels);
    const o = () => {
      const s = Ze(a, ce.GaugeFirstAndLastGuides);
      if (ss(s)) {
        const r = s.map((m) => m.label), l = r[0].scale, c = r[0].fontSize, u = Kr({
          chart: e,
          type: Je.FirstAndLastLabels,
          labelList: r,
          currentScale: l,
          currentFontSize: c,
          axisConfig: i
        }), d = u / l;
        Number.isFinite(u) && u > 0 && (d <= 0.98 || d > 1.02) && r.forEach((m) => {
          ci(m.uid, {
            originalWidth: m.measuredWidth / m.scale,
            originalHeight: m.measuredHeight / m.scale
          }), m.scale = u;
        });
      }
    };
    e.events.once(B.Validated, o);
    const n = e.events.on(
      B.SizeChanged,
      o
    );
    j(e.uid, { gaugeAutoResizeFirstAndLastLabelsDisposer: n }), o();
  } else
    Yi(e, Je.FirstAndLastLabels), Ze(a, ce.GaugeFirstAndLastGuides).map(
      (n) => n.label
    ).forEach((n) => {
      n.scale = 1;
    });
}
function Vs(t, e) {
  const i = t.xAxes.getIndex(0);
  if (i !== void 0) {
    const a = e ?? I(t.uid, "config"), { onlyShowFirstAndLastLabels: o } = a?.axes?.[0] ?? {};
    if (!i.renderer.labels.template.visible || o === !0)
      t.radius = new mn(L.gauge.radius);
    else {
      const n = Ze(i, ce.GaugeTicksWithLabels), { furthestLabelX: s, furthestLabelY: r } = n.reduce(
        ({ furthestLabelX: l, furthestLabelY: c, furthestPixelX: u, furthestPixelY: d }, { label: m }) => {
          if (m?.visible && m.bbox.width > 0 && m.bbox.height > 0) {
            const g = m.pixelX, h = m.bbox.width * m.scale;
            let y = 0;
            g < 0 ? y = Math.abs(g) : y = g + h, y > u && (u = y, l = m);
            const p = m.pixelY, S = m.bbox.height * m.scale;
            let x = 0;
            p < 0 ? x = Math.abs(p) : x = p + S, x > d && (d = x, c = m);
          }
          return {
            furthestLabelX: l,
            furthestLabelY: c,
            furthestPixelX: u,
            furthestPixelY: d
          };
        },
        {
          furthestLabelX: void 0,
          // the furthest X label from the center
          furthestPixelX: 0,
          // the furthest pixelX from the center
          furthestLabelY: void 0,
          // the furthest Y label from the center
          furthestPixelY: 0
          // the furthest pixelY from the center
        }
      );
      if (s !== void 0 && r !== void 0) {
        const c = (s.bbox.width + 5) * s.scale, u = (r.bbox.height + 5) * r.scale, d = typeof i.renderer.labels.template.radius == "number" ? i.renderer.labels.template.radius : i.renderer.labels.template.radius.value, m = (c + d) * 2 + t.radarContainer.measuredWidth + Uo(t.paddingLeft) + Uo(t.paddingRight), g = 80, h = 170, y = t.htmlContainer?.clientHeight ?? 0, p = Math.max(
          0,
          Math.min(1, (y - g) / (h - g))
        ), S = t.radarContainer.measuredHeight + (u + d * p) * 2 + Uo(t.paddingTop) + Uo(t.paddingBottom), x = t.measuredWidth, C = t.measuredHeight, v = x / m, F = C / S, T = (typeof t.radius == "number" ? t.radius : t.radius.value) * 100, k = Number((T * v).toFixed(2)), $ = Number((T * F).toFixed(2)), O = k / T, D = $ / T, R = t.radarContainer.measuredWidth * O, M = t.radarContainer.measuredWidth * D, [N, E] = R < M ? [k, O] : [$, D];
        Number.isFinite(N) && N >= 10 && N <= L.gauge.radius && (E < 0.98 || E > 1.02) && (t.radius = new mn(N));
      }
    }
  }
}
function Y0(t) {
  const e = t.xAxes.getIndex(0);
  e !== void 0 && (e.events.on(B.SizeChanged, () => Vs(t)), e.events.on(
    B.Validated,
    Ye(() => Vs(t), L.debounceTime)
  ));
}
function xm(t) {
  const e = t.hands.push(new qg()), i = L.gaugeNeedle, { startWidth: a, endWidth: o, innerRadius: n } = i;
  e.pin.disabled = !0, e.startWidth = a ?? Number.NaN, e.endWidth = o ?? Number.NaN, e.innerRadius = ot(n ?? Number.NaN);
  const s = t.xAxes.getIndex(0);
  return s !== void 0 && (e.axis = s), e;
}
function U0(t) {
  const { x: e, data: i, chart: a, valueFormat: o, minimum: n, maximum: s } = t;
  let r = Number.NaN;
  if (i !== void 0 && e !== void 0) {
    const l = i.find((u) => e in u), c = Number.parseFloat(l[e]);
    Number.isFinite(c) && (r = c, j(a.uid, { gaugeData: r }));
  } else {
    const l = I(a.uid, "gaugeData");
    Number.isFinite(l) && (r = l);
  }
  return Ya(o) && n !== void 0 && s !== void 0 && n !== null && s !== null && r !== null && s - n !== 0 && (r = Lo({
    value: r,
    axisMin: n,
    axisMax: s
  })), r;
}
function j0(t, e) {
  let i = e ?? null;
  if (e != null) {
    const a = t.xAxes.getIndex(0), o = I(t.uid, "config"), n = a.min ?? o?.axes?.[0].minimum ?? L.gauge.axisMinimum, s = a.max ?? o?.axes?.[0].maximum ?? L.gauge.axisMaximum;
    e < n ? i = n : e > s && (i = s);
  }
  return i;
}
function q0(t) {
  const { chart: e, needle: i, gaugeValue: a } = t, o = e.hands.getIndex(0) ?? xm(e);
  if (o !== void 0) {
    Ao({ element: o, fillSymbol: i?.symbol });
    const { startWidth: n, endWidth: s, innerRadius: r } = L.gaugeNeedle;
    o.value = j0(e, a), o.pin.disabled = i?.displayPin !== !0, o.visible = i?.visible ?? !0, o.startWidth = i?.startWidth ?? n, o.endWidth = i?.endWidth ?? s, o.innerRadius = ot(i?.innerRadius ?? r);
  }
}
function _0(t) {
  const e = Vt(void 0, t.radarContainer);
  e.isMeasured = !1, ci(e.uid, { isGaugeAxisInnerLabel: !0 }), G0(t, e);
}
function Z0(t) {
  const { chart: e, innerLabelConfig: i, valueFormat: a, gaugeValue: o, gaugeInnerLabelFormatter: n } = t, s = e.radarContainer.children.values.find(
    (r) => je(r.uid, "isGaugeAxisInnerLabel") === !0
  );
  if (s !== void 0) {
    Tt({ label: s, labelConfig: i, defaults: L.gaugeInnerLabel });
    const r = I(e.uid, "formatLocale");
    s.html = rF({
      valueFormat: a,
      iLocale: e.language.locale,
      formatLocale: r,
      gaugeValue: o,
      innerLabelConfigContent: i?.content,
      gaugeInnerLabelFormatter: n
    }), e.radarContainer.invalidateLabels();
  }
}
function K0(t) {
  const e = t.axisRanges.create();
  return e.axisFill.fillOpacity = 1, e.axisFill.disabled = !0, e.grid.strokeOpacity = 1, e.grid.disabled = !1, e.tick.length = L.gaugeTicksLength, e;
}
function Q0(t) {
  const e = new cr();
  return e.disabled = !0, e.axis = t, Jn(e), e.padding(10, 10, 10, 10), ci(e.uid, { isGaugeAxisLabel: !0 }), e;
}
function J0(t) {
  const { axis: e, min: i, max: a, labelsIncrement: o, numberOfIntervals: n, valueFormat: s } = t, r = Ya(s);
  let l = 1;
  const c = Ze(e, ce.Ticks);
  c.length > 0 && (l = c[0].label?.scale, c.forEach((m) => {
    if (On(m)) {
      const g = e.axisRanges.values.indexOf(m);
      g >= 0 && e.axisRanges.removeIndex(g);
    }
  }));
  const u = L.gauge.numberOfTicksBetweenTwoLabels + 1, d = n * u + 1;
  for (let m = 0; m < d; m += 1) {
    const g = m === d - 1, h = K0(e), y = g ? a : i + m / u * o;
    h.value = r ? Lo({ value: y, axisMin: i, axisMax: a }) : y, m % u === 0 && (h.label = Q0(e), h.label.text = String(y), h.grid.disabled = !0, Number.isFinite(l) && (h.label.scale = l));
  }
}
function eF(t) {
  const { chart: e, axis: i, onlyShowFirstAndLastLabels: a, valueFormat: o, axisLabelConfigContent: n, axisValueFormatter: s } = t;
  if (!a) {
    const r = Ze(i, ce.GaugeTicksWithLabels);
    if (ss(r)) {
      const l = I(e.uid, "formatLocale");
      r.forEach((c) => {
        Tt({ label: c.label, labelConfig: n }), On(c) && (c.label.html = Cm({
          valueFormat: o,
          iLocale: e.language.locale,
          formatLocale: l,
          gaugeLabelConfigContent: n?.content,
          itemLabelValue: c.value,
          axisValueFormatter: s
        }));
      });
    }
  }
}
function tF(t, e) {
  const i = e?.ticks?.visible ?? !0, a = Ze(t, ce.Ticks);
  for (let o = 0; o < a.length; o += 1) {
    const n = a[o];
    Q(n.tick, i);
  }
}
function iF(t, e) {
  if (t instanceof ve && t.chart instanceof yt) {
    const i = Ze(t, ce.GaugeTicksWithLabels);
    if (ss(i)) {
      const { onlyShowFirstAndLastLabels: a, labels: o } = e, n = (o?.visible ?? !0) && a !== !0;
      i.forEach((s) => {
        Q(s.label, n);
      });
    }
  }
}
function aF(t) {
  const { labels: e, guides: i, onlyShowFirstAndLastLabels: a } = t, o = i ?? [];
  if (a === !0) {
    const n = {
      type: b.Guide,
      start: Number.NaN,
      style: {
        type: "esriSLS"
      },
      name: ""
    };
    o.push(
      {
        ...n,
        start: t.minimum ?? Number.NaN,
        name: L.gaugeFirstLabelId,
        label: { ...e.content, text: `${t.minimum}` }
      },
      {
        ...n,
        start: t.maximum ?? Number.NaN,
        name: L.gaugeLastLabelId,
        label: { ...e.content, text: `${t.maximum}` }
      }
    );
  }
  t.guides = o;
}
function oF(t) {
  Ze(t, ce.GaugeFirstAndLastGuides).forEach((i) => {
    i.label.adapter.keys().includes("dx") || i.label.adapter.add("dx", (a) => {
      let o = a;
      return i.label.measuredWidth > 0 && (o = (je(i.label.uid, "originalWidth") ?? 1) / 2, o *= i.label.scale, i.id === L.gaugeLastLabelId && (o *= -1)), o;
    }), i.label.adapter.keys().includes("dy") || i.label.adapter.add("dy", (a) => {
      let o = a;
      return i.label.measuredHeight > 0 && (o = (je(i.label.uid, "originalHeight") ?? 1) / 2, o *= i.label.scale), o;
    });
  });
}
function nF(t) {
  const { chart: e, axis: i, onlyShowFirstAndLastLabels: a, valueFormat: o, gaugeLabelConfigContent: n, axisValueFormatter: s } = t;
  if (a) {
    const r = Ze(i, ce.GaugeFirstAndLastGuides), l = I(e.uid, "formatLocale");
    r.forEach((c) => {
      c?.label !== void 0 && On(c) && (c.label.html = Cm({
        valueFormat: o,
        iLocale: e.language.locale,
        formatLocale: l,
        gaugeLabelConfigContent: n?.content,
        itemLabelValue: c.value,
        axisValueFormatter: s
      }));
    }), oF(i);
  }
}
function sF(t, e) {
  t.xAxes.clear(), uo({ isXAxis: !0, axes: t.xAxes, valueFormat: e });
  const i = t.xAxes.getIndex(0);
  i instanceof ve && (i.renderer.labels.template.disabled = !0, i.renderer.ticks.template.disabled = !0, xm(t), _0(t), Y0(t), i.maxZoomFactor = 1);
}
function rF(t) {
  const { valueFormat: e, iLocale: i, formatLocale: a, innerLabelConfigContent: o, gaugeValue: n, gaugeInnerLabelFormatter: s } = t;
  let r = "";
  if (Number.isFinite(n))
    if (s !== void 0)
      r = s(n);
    else {
      const l = ni(e), c = Ot({
        type: b.NumberAxisFormat,
        iLocale: i,
        formatLocale: a
      });
      c.numberFormat = l, r = c.format(`${n}`), r = ft({
        textSymbol: {
          type: te.TS,
          ...o,
          text: r
        },
        format: "html"
      }), r = He(r);
    }
  return r;
}
function Cm(t) {
  const { valueFormat: e, iLocale: i, formatLocale: a, gaugeLabelConfigContent: o, itemLabelValue: n, axisValueFormatter: s } = t;
  let r = "";
  if (Number.isFinite(n))
    if (s !== void 0)
      r = s(n);
    else {
      const l = ni(e), c = Ot({
        type: b.NumberAxisFormat,
        iLocale: i,
        formatLocale: a
      });
      c.numberFormat = l, r = c.format(`${n}`), r = ft({
        textSymbol: {
          type: te.TS,
          ...o,
          text: r
        },
        format: "html"
      }), r = He(r);
    }
  return r;
}
async function lF(t) {
  const {
    chart: e,
    chartConfig: i,
    data: a,
    queryObject: o,
    axisValueFormatter: n,
    gaugeInnerLabelFormatter: s,
    utilsStrings: r,
    errorStrings: l
  } = t, { axes: c, series: u } = i, d = Qs(i), m = z(i.series), { featureIndex: g, x: h } = u[0], y = c?.[0], p = e.xAxes.getIndex(0), S = { ...y };
  if (p !== void 0 && S !== void 0) {
    const { valueFormat: x, needle: C, innerLabel: v, onlyShowFirstAndLastLabels: F } = S;
    Os({ axis: p, valueFormat: x, chartType: m }) && uo({ isXAxis: !0, axes: e.xAxes, valueFormat: x });
    const T = await Qu({
      featureIndex: g,
      chartData: e.data,
      chartConfig: i,
      queryObject: o,
      queryConfig: I(e.uid, "queryConfig")
    });
    S.minimum = T.minimum, S.maximum = T.maximum;
    const { min: k, max: $, labelsIncrement: O, numberOfIntervals: D } = Zu(S);
    Vy({
      oldConfig: I(p.chart.uid, "config"),
      axisMax: p.max,
      min: k,
      max: $,
      labelsIncrement: O,
      numberOfIntervals: D,
      valueFormat: x
    }) && J0({
      axis: p,
      min: k,
      max: $,
      labelsIncrement: O,
      numberOfIntervals: D,
      valueFormat: x
    });
    const M = { ...S };
    Ya(x) ? (M.minimum = 0, M.maximum = 1, Ku({
      axisConfig: M,
      axisMin: S.minimum,
      axisMax: S.maximum
    })) : (M.minimum = k, M.maximum = $), aF(M), await tn({
      axis: p,
      axisConfig: M,
      chartType: b.GaugeSeries,
      axisValueFormatter: n,
      utilsStrings: r,
      errorStrings: l
    }), p.renderer.labels.template.disabled || (p.renderer.labels.template.disabled = !0), p.renderer.ticks.template.disabled || (p.renderer.ticks.template.disabled = !0), H0({
      chart: p.chart,
      axis: p,
      axisConfig: S
    }), X0({
      chart: e,
      axis: p,
      axisConfig: S
    }), tF(p, S), eF({
      chart: e,
      axis: p,
      onlyShowFirstAndLastLabels: F ?? !1,
      valueFormat: x,
      axisLabelConfigContent: S.labels,
      axisValueFormatter: n
    }), nF({
      chart: e,
      axis: p,
      onlyShowFirstAndLastLabels: F ?? !1,
      valueFormat: x,
      gaugeLabelConfigContent: S.labels,
      axisValueFormatter: n
    });
    const N = d ? T?.dataValue : U0({
      x: h,
      data: a,
      chart: e,
      minimum: S.minimum,
      maximum: S.maximum,
      valueFormat: x
    });
    q0({
      chart: e,
      needle: C,
      gaugeValue: N
    }), Z0({
      chart: e,
      innerLabelConfig: v,
      valueFormat: x,
      gaugeValue: N,
      gaugeInnerLabelFormatter: s
    }), iF(p, S), Vs(e, i), e.validateData();
  }
}
function cF(t) {
  let e = [];
  if (t.length > 0) {
    e = t.map((a) => a.minValue);
    const i = t[t.length - 1].maxValue;
    e.push(i);
  }
  return e;
}
function dF(t) {
  let e = 0;
  return t.forEach((i) => {
    const { label: a } = i;
    e = Math.max(e, a?.bbox.width, a.measuredWidth);
  }), e;
}
function uF(t) {
  let e = t.axisRanges.length - 1;
  if (t.isReady()) {
    const i = Ze(t, ce.Ticks), a = i[0]?.point?.x ?? 0, n = (i[1]?.point?.x ?? 0) - a, s = dF(i);
    if (s !== 0) {
      const r = L.histogramAxisLabel.paddingRight ?? 0;
      for (let l = 0; l < i.length; l += 1)
        if (l * n - s - r > 0) {
          e = l;
          break;
        }
    }
  }
  return e;
}
function Es(t) {
  const e = I(t.chart.uid, "config"), { axes: i } = e, a = i?.[0];
  if (a !== void 0) {
    const { visible: o, labels: n, guides: s } = a, { visible: r } = n, l = uF(t), c = Ze(t, ce.Ticks);
    for (let d = 0; d < c.length; d += 1) {
      const { tick: m, label: g } = c[d], h = d % l === 0 && o === !0, y = d % l === 0 && r === !0, p = { ...a.labels };
      p.content.angle = void 0, p.content.yoffset = void 0, p.content.horizontalAlignment = void 0, p.content.verticalAlignment = void 0, Tt({ label: g, labelConfig: p, defaults: L.histogramAxisLabel }), Q(m, h), Q(g, y);
    }
    fm({
      axis: t,
      labels: c.map((d) => d.label),
      restoreLabelsVisibility: !1
    });
    const u = Ze(t, ce.Guides);
    for (let d = 0; d < u.length; d += 1) {
      const m = s?.[d]?.visible ?? !0;
      Q(u[d].label, m), u[d].label.disabled = !m;
    }
    t.invalidateLabels();
  }
}
function fF(t) {
  const { chart: e, axesConfig: i } = t;
  ns({ chart: e, axesConfig: i });
  const a = e.xAxes.getIndex(0);
  if (a !== void 0) {
    a.renderer.ticks.template.disabled = !0;
    const o = () => Es(a);
    a.events.once(B.DataItemsValidated, o), e.chartContainer.events.on(B.SizeChanged, Ye(o, L.debounceTime));
  }
}
function mF(t, e) {
  if (t.renderer.labels.template.disabled = !0, e.length !== 0) {
    t.strictMinMax = !0;
    const { 0: i, [e.length - 1]: a } = e;
    t.min = i, t.max = a;
  } else
    t.min = Number.NaN, t.max = Number.NaN, t.strictMinMax = !1;
}
async function gF(t) {
  const {
    chart: e,
    axesConfig: i,
    histogramBins: a,
    guideTooltipFormatter: o,
    xAxisLabelFormatter: n,
    yAxisLabelFormatter: s,
    utilsStrings: r,
    errorStrings: l
  } = t, c = cF(a), u = i?.[0];
  await Zr({
    chart: e,
    axesConfig: i,
    guideTooltipFormatter: o,
    xAxisLabelFormatter: n,
    yAxisLabelFormatter: s,
    utilsStrings: r,
    errorStrings: l
  });
  const d = e.xAxes.getIndex(0);
  d instanceof ve && (mF(d, c), u !== void 0 && i0({
    valueAxis: d,
    axisConfig: u,
    ticks: c
  }), Es(d), d.events.once(
    B.DataItemsValidated,
    () => Es(d)
  ));
}
function hF(t, e) {
  ns({ chart: t, axesConfig: e });
}
async function pF(t) {
  await Zr(t);
}
function bF(t) {
  t.background.fill = rt(L.backgroundColor);
}
function rs(t, e) {
  t.background.fill = rt(e ?? L.backgroundColor);
}
function yF(t) {
  const e = Jf(L.headerContainer, t), i = Vt(L.title, e), a = Vt(L.subtitle, e);
  return ko({ chart: t, label: i, labelType: ae.ChartTitle }), ko({ chart: t, label: a, labelType: ae.ChartSubTitle }), Tv(e), { headerContainer: e, title: i, subtitle: a };
}
function ls(t, e) {
  const { title: i, subtitle: a, headerContainer: o } = t;
  Tt({ label: i, labelConfig: e?.title, defaults: L.titleLabel }), Tt({ label: a, labelConfig: e?.subtitle, defaults: L.titleLabel }), em(o, i.disabled && a.disabled), ca({
    chart: i.parent,
    label: i,
    labelType: ae.ChartTitle
  }), ca({
    chart: a.parent,
    label: a,
    labelType: ae.ChartSubTitle
  });
}
function SF(t) {
  const e = Jf(L.footerContainer, t), i = Vt(L.footer, e);
  return ko({ chart: t, label: i, labelType: ae.ChartFooter }), { footerContainer: e, footer: i };
}
function cs(t, e) {
  const { footer: i, footerContainer: a } = t;
  Tt({ label: i, labelConfig: e, defaults: L.footer }), em(a, i.disabled || e?.content.text === ""), ca({
    chart: i.parent,
    label: i,
    labelType: ae.ChartFooter
  });
}
function vm(t) {
  if (t instanceof ne) {
    const e = new xl(), i = new xl();
    e.disabled = !0, i.disabled = !0, e.marginTop = -10, i.marginRight = 0, t.scrollbarX = e, t.scrollbarY = i;
  }
}
function xF(t, e) {
  const i = e ? 0 : -1;
  t.thumb.tabindex = i, t.startGrip.tabindex = i, t.endGrip.tabindex = i;
}
function CF(t, e) {
  if (e !== void 0) {
    const i = sa(e);
    [
      // applying color to grips and bar
      t.background,
      t.startGrip.background,
      t.endGrip.background,
      t.thumb.background,
      // applying color to hover and down states
      t.background.states.getKey("default")?.properties,
      t.startGrip.background.states.getKey("default")?.properties,
      t.endGrip.background.states.getKey("default")?.properties,
      t.thumb.background.states.getKey("default")?.properties,
      t.startGrip.background.states.getKey("hover")?.properties,
      t.endGrip.background.states.getKey("hover")?.properties,
      t.thumb.background.states.getKey("hover")?.properties,
      t.startGrip.background.states.getKey("down")?.properties,
      t.endGrip.background.states.getKey("down")?.properties,
      t.thumb.background.states.getKey("down")?.properties
    ].forEach((a) => {
      a !== void 0 && (a.fill = i);
    });
  }
}
function vF(t, e) {
  typeof e == "number" && Number.isFinite(e) && (t.orientation === "horizontal" ? (t.height = e, t.minHeight = e) : (t.width = e, t.minWidth = e));
}
function LF(t, e) {
  if (typeof e == "number" && Number.isFinite(e)) {
    const a = e / 30;
    t.startGrip.scale = a, t.endGrip.scale = a;
  }
}
function FF(t, e) {
  typeof e == "number" && Number.isFinite(e) && (t.orientation === "horizontal" ? t.marginBottom = e : t.marginLeft = e, t.parent?.invalidateLayout());
}
function Lm(t) {
  const { chart: e, scrollbarXConfig: i, scrollbarYConfig: a } = t;
  if (e instanceof ne) {
    const o = I(e.uid, "isRotated");
    (e.scrollbarX === void 0 || e.scrollbarY === void 0) && vm(e);
    const { scrollbarX: n, scrollbarY: s } = e;
    [n, s].forEach((r) => {
      const l = r.orientation === "horizontal" && o !== !0 || r.orientation === "vertical" && o === !0 ? i : a, c = l?.visible !== !0;
      if (r.disabled = c, xF(r, !c), l !== void 0 && !c) {
        const { width: u, color: d, gripSize: m, margin: g } = l;
        FF(r, g), CF(r, d), LF(r, m), vF(r, u);
      }
    });
  }
}
function AF(t, e) {
  t.columns.each((i) => {
    (i.dataItem?.dataContext)[e] === 0 && (i.strokeOpacity = 0);
  });
}
function TF(t, e) {
  t.chart.legend.events.once(B.Validated, () => {
    di({
      element: t.legendDataItem?.marker.children.getIndex(0),
      stylingInfo: e
    }), t.chart.legend.invalidate();
  });
}
function kF(t) {
  const { series: e, seriesConfig: i, seriesIndex: a, numberOfSeries: o, chartSubType: n, colorMatch: s, rendererType: r } = t, l = e.dataFields.valueY ?? e.dataFields.valueX ?? i.y;
  let c = !1;
  const u = /* @__PURE__ */ new Set();
  let d;
  const m = i.fillSymbol, g = {
    seriesConfig: i,
    seriesIndex: a,
    seriesSymbol: m,
    colorMatch: s,
    isChartFillSymbol: !0
  };
  let h = {};
  const y = zc(a);
  if (e.columns.length === 0 ? h = Ai({
    seriesConfig: i,
    seriesIndex: a,
    seriesSymbol: m ?? y,
    element: new ur(),
    colorMatch: s,
    isChartFillSymbol: !0
  }) : e.columns.each((p) => {
    const S = p.dataItem?.dataContext;
    if (Number.isFinite(S?.[l])) {
      const x = Ft({
        dataItem: S,
        seriesConfig: i,
        chartSubType: n,
        colorMatch: s,
        rendererType: r
      }), v = (S[L.xAxisField] === L.nullValue && i.nullCategory?.symbol !== void 0 ? i.nullCategory.symbol : m) ?? y;
      h = Ai({
        ...g,
        seriesSymbol: v,
        element: p,
        rendererSymbol: x
      }), di({ element: p, stylingInfo: h.stylingInfo }), u.add(JSON.stringify(h.symbolWithColorInfo));
    }
  }), o > 1) {
    const p = e.chart.legend.markers.values;
    p.length !== 0 ? p.forEach((S) => {
      if (S.dataItem instanceof ia) {
        const x = S.dataItem.marker.children.getIndex(0);
        x !== void 0 && x.baseSprite?.parent instanceof Xe ? di({
          element: x,
          stylingInfo: h.stylingInfo
        }) : c = !0;
      }
    }) : c = !0;
  }
  return c && TF(e, h.stylingInfo), u.size <= 1 && (d = h.symbolWithColorInfo ?? m), AF(e, l), d;
}
function IF(t) {
  const { series: e, seriesSymbolMapForEvent: i, seriesIndexMapper: a, seriesIndex: o, colorMatch: n, rendererType: s } = t, r = t.seriesConfig, l = I(e.chart.uid, "config"), c = l?.series.length ?? 0, u = U(l?.series), d = kF({
    series: e,
    seriesConfig: r,
    seriesIndex: o,
    numberOfSeries: c,
    chartSubType: u,
    colorMatch: n,
    rendererType: s
  });
  i.set(a.get(r.id) ?? o, d), i.size === c && Bt({
    data: i,
    htmlContainer: e.chart.htmlContainer,
    chartId: e.chart.id,
    colorMatchApplied: Sa(e.chart)
  });
}
function Fm(t) {
  const {
    seriesConfig: e,
    series: i,
    seriesIndexMapper: a,
    rotationChanged: o,
    subtypeInfo: n,
    colorMatch: s,
    stackedType: r,
    rendererType: l,
    fieldList: c,
    seriesIndex: u,
    seriesSymbolMapForEvent: d
  } = t, { name: m } = e, g = I(i.chart.uid, "config"), h = Rt({ config: g }), y = U(g?.series);
  Q(i, e.visible);
  let p = m;
  const S = i.dataFields?.customValue ?? "";
  (y === P.BarAndLineSplitBy || y === P.BarAndLineSplitByNoAggregation) && (p = Zs({
    subtypeInfo: n,
    fieldList: c,
    fieldName: ki(S),
    fieldValueToMatch: p
  }) ?? p), Kt(i, p), Wr({
    series: i,
    seriesConfig: e,
    rotationChanged: o,
    stackedType: r,
    isRotated: h
  }), IF({
    series: i,
    seriesConfig: e,
    seriesIndex: u,
    seriesIndexMapper: a,
    colorMatch: s,
    rendererType: l,
    seriesSymbolMapForEvent: d
  }), We(i.uid, {
    barSeriesLastUpdate: {
      numberOfColumnsUpdated: i.columns.length,
      updateProps: t
    }
  });
}
function wF(t) {
  t.events.on(B.Validated, () => {
    const e = _(
      t.uid,
      "barSeriesLastUpdate"
    );
    if (e !== void 0) {
      const { numberOfColumnsUpdated: i, updateProps: a } = e;
      t.columns.length > i && Fm(a);
    }
  });
}
function $F(t) {
  const { chart: e, chartConfig: i, seriesIndex: a, axisList: o = [], hideLoaderHandle: n, selectionTheme: s } = t, { rotated: r } = i, l = i.series[a], { y: c, assignToSecondValueAxis: u } = l, d = new Xe();
  Qt(d, n), d.id = l.id;
  let m, g;
  r !== !0 ? (m = o[0], g = u === !0 && o[2] ? o[2] : o[1]) : (m = u === !0 && o[2] ? o[2] : o[0], g = o[1]), m !== void 0 && (d.xAxis = m), g !== void 0 && (d.yAxis = g);
  const h = e instanceof ne ? Rt({ chart: e }) : !1, p = U(i.series) !== P.BarAndLineSplitByNoAggregation ? c : `${c}_${Ki({ where: l.query?.where, keepSurroundingQuotes: !1, escape: !1 })}`;
  h ? d.dataFields.valueX = p : d.dataFields.valueY = p;
  const S = h ? o[1] : o[0];
  if (S !== void 0) {
    const x = Hf(S, h);
    d.dataFields[x] = L.xAxisField, d.baseAxis = S;
  }
  return Wr({
    series: d,
    seriesConfig: l,
    rotationChanged: !1,
    stackedType: i.stackedType,
    isRotated: h
  }), d.dataFields.customValue = l?.query?.where, Zf(d.columns.template, d), d.columns.template.width = ot(100), Ei({
    element: d.columns.template,
    customSelectionTheme: s
  }), xa(e, d.columns.template), Eo(d), wF(d), Vi(d), d;
}
function DF(t) {
  const { seriesConfig: e, series: i, seriesIndex: a, axes: o, utilsStrings: n, fieldList: s, queryObject: r, stackedType: l, options: c } = t;
  i.id = e.id;
  const u = Rt({ chart: i.chart });
  x0({
    series: i,
    seriesType: b.BarSeries,
    isRotated: u,
    stackedType: l,
    hideOversizedSideBySideLabels: e.hideOversizedSideBySideLabels,
    hideOversizedStackedLabels: e.hideOversizedStackedLabels,
    dataLabelsConfig: e.dataLabels,
    yAxisValueFormat: o[1].valueFormat,
    customDataLabelFormatter: c?.dataLabelFormatter
  }), la({
    // TODO: Remove the type assertion and correct the typings
    styleCallback: Fm,
    callbackProps: t,
    series: i,
    seriesConfig: e,
    onReadyEvent: !0
  }), Qf({
    series: i,
    seriesConfig: e,
    fieldList: s,
    queryObject: r,
    utilsStrings: n,
    seriesIndex: a,
    tooltipFormatter: c?.tooltipFormatter
  });
}
function OF(t, e) {
  t.adapter.add(
    "htmlOutput",
    (i, a) => {
      let o = i;
      const n = _(
        e.uid,
        "histogramDataLabelFormatter"
      ), { dataItem: s } = a;
      if (n !== void 0 && s instanceof Ro) {
        const { valueY: r, openValueX: l, valueX: c } = s;
        o = n(r, l, c);
      }
      return He(o);
    },
    0
    // 0 = high priority
  );
}
function RF(t) {
  const e = Vt(L.dataLabelInitialize);
  return ci(e.uid, { isDataLabel: !0 }), t.bullets.push(e), zr(e), Er(b.HistogramSeries, e), OF(e, t), e.html = "{valueX}", e;
}
function BF(t) {
  const { numberFormatter: e, dataLabelsConfigContent: i } = t;
  return (a, o, n) => ft({
    textSymbol: {
      ...i,
      text: e.format(a)
    },
    format: "html"
  });
}
function MF(t) {
  const { series: e } = t, i = To(e, "bullets");
  es({
    ...t,
    dataLabel: i,
    defaultDataLabelFormatter: BF,
    seriesType: b.HistogramSeries
  });
}
function NF(t) {
  const { axes: e, seriesConfig: i, series: a, fieldList: o, utilsStrings: n } = t, { dataTooltipVisible: s } = i;
  let r;
  const l = bt(a.rtl);
  return s === !1 ? r = (c, u, d) => "" : r = (c, u, d) => {
    const m = De(o, i.x), g = li(m, e?.[0].title?.content?.text), h = li(n.statistics.count, e?.[1].title?.content?.text), y = Oa({
      series: a,
      callbackName: "tooltipValueYNumberFormatCallback",
      value: c
    }), p = Oa({
      series: a,
      callbackName: "tooltipValueXNumberFormatCallback",
      value: u
    }), S = Oa({
      series: a,
      callbackName: "tooltipValueXNumberFormatCallback",
      value: d
    });
    return `<b>${g}${l} </b>${p} - ${S}<br /><b>${h}${l} </b>${y}`;
  }, r;
}
function PF(t) {
  const e = t.columns.template;
  e.tooltipPosition = L.columnTooltipPosition, e.tooltipHTML = L.htmlEmptyContent, e.adapter.add("tooltipHTML", (i, a) => {
    let o = i ?? "";
    const { chart: n } = t;
    if (n !== void 0) {
      const s = I(n.uid, "config"), { dataTooltipVisible: r } = s?.series[0] ?? {};
      if (r === !1)
        o = "";
      else {
        const l = _(
          t.uid,
          "histogramTooltipFormatter"
        );
        if (l !== void 0) {
          const { dataItem: c } = a;
          if (c instanceof Ro) {
            const { valueY: u, openValueX: d, valueX: m } = c;
            o = l(u, d, m);
          }
        }
      }
    }
    return He(o);
  });
}
function VF(t) {
  const { series: e, tooltipFormatter: i } = t;
  We(e.uid, {
    histogramTooltipFormatter: i ?? NF(t)
  });
}
const vs = {
  Count: "count",
  Start: "minValue",
  End: "maxValue"
}, Qe = {
  Mean: "Mean",
  Median: "Median",
  StdDev: "Standard Deviation",
  Normal: "Normal Distribution",
  Trendline: "Trendline"
};
async function qo(t) {
  const { xAxis: e, yAxis: i, type: a, hideLoaderHandle: o } = t, n = new ue();
  return n.id = a, Qt(n, o), We(n.uid, { isOverlay: !0, type: a }), n.dataFields.valueX = "x", n.dataFields.valueY = "y", e !== void 0 && (n.xAxis = e), i !== void 0 && (n.yAxis = i), n.hidden = !0, n;
}
function EF(t) {
  const { lineSeries: e, valueFormat: i, overlay: a, chartData: o, utilsStrings: n } = t;
  if (!a)
    Q(e, !1), e.hiddenInLegend = !0;
  else {
    const { symbol: s, created: r, visible: l } = a, c = r === !0 && l !== !1, u = _(e.uid, "type"), d = _(e.uid, "upper");
    if (Ut({
      element: e,
      lineSymbol: s,
      visible: c
    }), e.hiddenInLegend = r !== !0 || d === !0, o && "bins" in o) {
      const g = o.bins.map((k) => k.count), h = Math.max(...g), { mean: y, stddev: p, median: S } = o, x = y - p, C = y + p;
      let v = { x: Number.NaN, y: Number.NaN }, F = { x: Number.NaN, y: Number.NaN };
      switch (u) {
        case Qe.Mean:
          v = { x: y, y: 0 }, F = { x: y, y: h };
          break;
        case Qe.Median:
          v = { x: S, y: 0 }, F = { x: S, y: h };
          break;
        case Qe.StdDev:
          d === !0 ? (v = { x: C, y: 0 }, F = { x: C, y: h }) : (v = { x, y: 0 }, F = { x, y: h });
          break;
      }
      const T = {
        data: [v, F]
      };
      e.data = T.data;
    }
    let m = e.data[0]?.x;
    if (u === Qe.StdDev && (m = o?.stddev ?? _(e.uid, "stddev"), We(e.uid, { stddev: m })), m !== void 0) {
      let g = u;
      switch (u) {
        case Qe.Mean:
          g = n.overlays.mean;
          break;
        case Qe.Median:
          g = n.overlays.median;
          break;
        case Qe.StdDev:
          g = n.overlays.stdDev;
          break;
        case Qe.Trendline:
          g = n.overlays.trendline;
          break;
      }
      const h = I(e.chart.uid, "formatLocale");
      Kt(
        e,
        `${g}: ${ra({
          value: m,
          valueFormat: i,
          iLocale: e.chart.language.locale,
          formatLocale: h
        })}`
      );
    }
  }
}
async function zF(t, e, i) {
  const a = new ue();
  return We(a.uid, {
    isOverlay: !0,
    type: Qe.Normal
  }), a.xAxis = t, a.yAxis = e, a.dataFields.valueX = "x", a.dataFields.valueY = "y", Kt(a, i.overlays.normal), a.hidden = !0, a.id = Qe.Normal, a;
}
function WF(t) {
  const { lineSeries: e, overlay: i, seriesData: a, numberOfPoints: o } = t;
  if (!i)
    Q(e, !1), e.hiddenInLegend = !0;
  else {
    const { symbol: n, created: s, visible: r } = i;
    if (Ut({
      element: e,
      lineSymbol: n,
      visible: s === !0 && r !== !1
    }), e.hiddenInLegend = s !== !0, a && "bins" in a) {
      const { mean: c, stddev: u, min: d, max: m } = a, g = _d(a.bins), h = jd(d, m, o ?? L.histogramSeries.normalDistribNumberOfPoints).map(
        (y) => ({
          x: y,
          y: qd({
            x: y,
            mean: c,
            stddev: u,
            scalingFactor: g
          })
        })
      );
      e.data = h;
    }
  }
}
async function HF(t) {
  const { chart: e, seriesConfig: i, axisList: a = [], hideLoaderHandle: o, utilsStrings: n, selectionTheme: s } = t, r = [], l = new Xe();
  Qt(l, o), l.id = i.id, l.hiddenInLegend = !0;
  const [c, u] = a;
  if (c !== void 0 && (l.xAxis = c), u !== void 0 && (l.yAxis = u), PF(l), RF(l), l.dataItems.template.locations.valueX = 1, l.dataItems.template.locations.openValueX = 0, l.dataFields.openValueX = vs.Start, l.dataFields.valueX = vs.End, l.dataFields.valueY = vs.Count, l.dataFields.customValue = i.x, Vi(l), Ei({
    element: l.columns.template,
    customSelectionTheme: s
  }), xa(e, l.columns.template), r.push(l), c !== void 0 && u !== void 0) {
    r.push(
      await qo({
        xAxis: c,
        yAxis: u,
        type: Qe.Mean,
        hideLoaderHandle: o
      })
    ), r.push(
      await qo({
        xAxis: c,
        yAxis: u,
        type: Qe.Median,
        hideLoaderHandle: o
      })
    );
    const d = await qo({
      xAxis: c,
      yAxis: u,
      type: Qe.StdDev,
      hideLoaderHandle: o
    });
    We(d.uid, { upper: !1 });
    const m = await qo({
      xAxis: c,
      yAxis: u,
      type: Qe.StdDev,
      hideLoaderHandle: o
    });
    We(m.uid, { upper: !0 }), d.events.on(B.Hidden, () => {
      Q(m, !1);
    }), d.events.on(B.Shown, () => {
      Q(m);
    }), r.push(d), r.push(m), r.push(await zF(c, u, n));
  }
  return r.forEach((d) => {
    const m = _(d.uid, "isOverlay"), g = _(d.uid, "upper");
    m === !0 && g !== !0 && Eo(d);
  }), r;
}
function GF(t) {
  const { series: e, seriesConfig: i, colorMatch: a, rendererSymbol: o } = t;
  let n;
  const s = i.fillSymbol ?? Vc();
  if (e.columns.each((r) => {
    const l = Ai({
      element: r,
      seriesConfig: i,
      seriesSymbol: s,
      rendererSymbol: o,
      colorMatch: a,
      isChartFillSymbol: !0
    });
    n = l.symbolWithColorInfo;
    const c = l.stylingInfo;
    di({ element: r, stylingInfo: c });
  }), n !== void 0) {
    const r = /* @__PURE__ */ new Map();
    r.set(0, n), Bt({
      data: r,
      htmlContainer: e.chart.htmlContainer,
      chartId: e.chart.id,
      colorMatchApplied: Sa(e.chart)
    });
  }
}
async function XF(t) {
  const {
    chartConfig: e,
    seriesConfig: i,
    chartSeries: a,
    axes: o,
    chartData: n,
    fieldList: s,
    options: r,
    queryObject: l,
    chartRenderer: c,
    utilsStrings: u
  } = t, { tooltipFormatter: d, dataLabelFormatter: m } = r ?? {}, g = 6, h = i.overlays;
  for (let y = 0; y < g; y += 1) {
    const p = a[y];
    if (_(p?.uid, "isOverlay") === !0 && p instanceof ue) {
      const S = _(p.uid, "type");
      if (S === Qe.Normal) {
        if (h?.comparisonDistribution && h?.comparisonDistribution.symbol?.color === void 0) {
          const x = nn(S), C = h?.comparisonDistribution?.symbol ?? {
            type: te.SLS
          };
          h.comparisonDistribution.symbol = {
            ...C,
            color: ai({
              colorIndex: x,
              histogramOverlays: !0
            })
          };
        }
        WF({
          lineSeries: p,
          overlay: h?.comparisonDistribution,
          seriesData: n
        });
      } else {
        let x;
        switch (S) {
          case Qe.Mean:
            x = h?.mean;
            break;
          case Qe.Median:
            x = h?.median;
            break;
          case Qe.StdDev:
            x = h?.standardDeviation;
            break;
        }
        if (x && x.symbol?.color === void 0) {
          x.symbol = { ...x.symbol, type: te.SLS };
          const C = nn(S);
          x.symbol.color = ai({
            colorIndex: C,
            histogramOverlays: !0
          });
        }
        EF({
          lineSeries: p,
          valueFormat: In(),
          overlay: x,
          chartData: n,
          utilsStrings: u
        });
      }
      p.events.once(B.Validated, () => {
        _(p.uid, "upper") !== !0 && Ta({
          labels: p.chart?.legend?.labels,
          seriesId: p.id
        });
      });
    } else if (p instanceof Xe) {
      p.id = i.id, Q(p, i.visible), Kt(p, i.name);
      const S = pt(l), x = td({
        chartRenderer: c,
        queryObject: l
      }), C = c ?? S?.renderer, v = $o(c, S?.renderer);
      let F;
      if (Qi({
        chartConfig: e,
        queryObject: l
      })) {
        const T = await id({
          seriesConfig: [i],
          dataItem: {},
          renderer: C,
          rendererOrigin: c !== void 0 ? cn.ChartRenderer : cn.LayerRenderer,
          rendererType: v,
          chartSubType: P.NonSpecific,
          graphicTemplate: x
        });
        F = T.rendererSymbol, j(p.chart.uid, { colorMatchApplied: T.colorMatchApplied });
      }
      la({
        // TODO: Remove the type assertion and correct the typings
        styleCallback: GF,
        callbackProps: { ...t, rendererSymbol: F },
        series: p,
        seriesConfig: i
      }), MF({
        series: p,
        seriesType: b.HistogramSeries,
        dataLabelsConfig: i.dataLabels,
        yAxisValueFormat: o[1].valueFormat,
        customDataLabelFormatter: m
      }), VF({
        axes: o,
        series: p,
        seriesConfig: i,
        fieldList: s,
        tooltipFormatter: d,
        utilsStrings: u
      }), Gf({
        axes: o,
        currentSeries: p,
        tooltipValueFormat: i.dataTooltipValueFormat
      });
    }
  }
}
function YF(t) {
  t.labels.template.adapter.add("html", (e, i) => {
    const a = _(
      t.uid,
      "pieChartDataLabelFormatter"
    );
    let o = e ?? "";
    const { dataItem: n } = i;
    if (n instanceof ri) {
      const { slice: s } = n;
      if (s !== void 0 && !Fo(s))
        o = "";
      else if (a !== void 0) {
        const { value: r, percent: l } = n.values?.value ?? {};
        if (r !== void 0 && r !== 0) {
          const c = `${n.properties?.category ?? e}`;
          o = a(c, r, l);
        }
      }
    }
    return ye(o) && (o = L.htmlEmptyContent), He(o);
  });
}
function UF(t) {
  const e = t.labels.template;
  e.maxWidth = L.pieChart.dataLabels.maxWidth ?? Number.NaN, e.wrap = L.pieChart.dataLabels.wrap ?? !0, e.events.on(B.Over, (i) => {
    const { dataItem: a } = i.target ?? {};
    a instanceof ri && a.slice.showTooltip();
  }), YF(t);
}
function jF(t, e) {
  const {
    numericValueFormat: i,
    percentValueFormat: a,
    displayCategoryOnDataLabel: o,
    displayNumericValueOnDataLabel: n,
    displayPercentageOnDataLabel: s,
    valuePrefix: r,
    valueSuffix: l,
    percentagePrefix: c,
    percentageSuffix: u,
    dataLabelsCharacterLimit: d
  } = e, m = Xr({
    iLocale: t.chart.language.locale,
    pieChart: t.chart,
    valueIntlOptions: i?.intlOptions,
    percentageIntlOptions: a?.intlOptions,
    displayNumericValue: n ?? L.pieChart.displayNumericValueOnDataLabel,
    displayPercentage: s ?? L.pieChart.displayPercentageOnDataLabel,
    valuePrefix: r,
    valueSuffix: l,
    percentagePrefix: c,
    percentageSuffix: u
  }), g = or(d), h = bt(t.rtl, " ");
  return (y, p, S) => {
    const x = m(y, p, S), v = o ?? L.pieChart.displayCategoryOnDataLabel ? g(y) : "";
    let F = ye(v) ? "" : `${v}${h}`;
    return F = `${F}${x}`, e.dataLabels?.content !== void 0 && (F = ft({
      textSymbol: { ...e.dataLabels.content, text: F },
      format: "html",
      defaults: {
        ...L.pieChart.dataLabels,
        wrap: e.optimizeDataLabelsOverlapping ?? L.pieChart.dataLabels.wrap
      }
    })), F;
  };
}
function qF(t) {
  const { pieSeries: e, seriesConfig: i, dataLabelFormatter: a } = t, { dataLabels: o } = i, n = i.dataLabelsOffset ?? L.pieChart.dataLabelsOffset, s = i.dataLabelsInside ?? L.pieChart.dataLabelsInside;
  We(e.uid, {
    pieChartDataLabelFormatter: a ?? jF(e, i)
  }), Tt({
    label: e.labels.template,
    labelConfig: o,
    defaults: {
      ...L.pieChart.dataLabels,
      wrap: i.optimizeDataLabelsOverlapping ?? L.pieChart.alignDataLabels
    },
    skipSettingText: !0
  }), e.alignLabels = !s && (i.alignDataLabels ?? L.pieChart.alignDataLabels);
  const r = e.labels.template.radius;
  e.chart.invalidateData(), (s && r !== ot(-40) || !s && r === ot(-40) || n !== void 0 && Number.isFinite(n) && r !== n) && (e.labels.template.radius = s ? ot(-40) : n, e.invalidate());
}
function _F(t, e) {
  let i = (h, y, p) => L.htmlEmptyContent;
  const {
    numericValueFormat: a,
    percentValueFormat: o,
    dataTooltipValueFormat: n,
    dataTooltipPercentFormat: s,
    displayCategoryOnTooltip: r,
    displayNumericValueOnTooltip: l,
    displayPercentageOnTooltip: c,
    valuePrefix: u,
    valueSuffix: d,
    percentagePrefix: m,
    percentageSuffix: g
  } = e;
  return i = (h, y, p) => {
    let S = L.htmlEmptyContent;
    const C = Xr({
      iLocale: t.chart.language.locale,
      pieChart: t.chart,
      valueIntlOptions: (n ?? a)?.intlOptions,
      percentageIntlOptions: (s ?? o)?.intlOptions,
      displayNumericValue: l ?? L.pieChart.displayNumericValueOnTooltip,
      displayPercentage: c ?? L.pieChart.displayPercentageOnTooltip,
      valuePrefix: u,
      valueSuffix: d,
      percentagePrefix: m,
      percentageSuffix: g
    })("", y, p), v = !ye(h) && (r ?? L.pieChart.displayCategoryOnTooltip);
    if (v && (S = `<b>${h}</b>`), !ye(C)) {
      const F = tr(C);
      S = v ? `${S}<br />${F}` : F;
    }
    return S;
  }, i;
}
function ZF(t) {
  if (t.tooltip !== void 0) {
    let e = t.fill;
    e instanceof Td ? e = e.stroke : e instanceof kd && (e = e.backgroundFill), t.tooltip.background.fill = e;
  }
}
function KF(t) {
  const e = t.slices.template;
  e.tooltipHTML = L.htmlEmptyContent, e.adapter.add("tooltipHTML", (i, a) => {
    let o = i ?? "";
    const { chart: n } = t;
    if (n !== void 0 && a.tooltip !== void 0) {
      const s = I(n.uid, "config"), { dataTooltipVisible: r } = s?.series[0] ?? {};
      if (r === !1)
        a.tooltip.disabled = !0;
      else {
        const l = _(
          t.uid,
          "pieChartTooltipFormatter"
        );
        if (l !== void 0) {
          const { dataItem: c } = a;
          if (c instanceof ri) {
            const u = c.properties.category ?? "", d = c.dataContext;
            let m = si(d);
            m === void 0 && (m = u);
            const g = c.values?.value?.value, h = c.values?.value?.percent;
            typeof g == "number" && g !== 0 && s?.series?.[0]?.dataTooltipVisible !== !1 ? (a.tooltip.disabled = !1, ZF(a), o = l(`${u}`, g, h, m)) : a.tooltip.disabled = !0;
          }
        }
      }
    }
    return He(o);
  });
}
function QF(t) {
  const { series: e, seriesConfig: i, tooltipFormatter: a } = t;
  We(e.uid, {
    pieChartTooltipFormatter: a ?? _F(e, i)
  });
}
function JF(t) {
  t.ticks.template.adapter.add("disabled", (e, i) => i.dataItem?.values?.value?.value === 0 || !Number.isFinite(i.dataItem?.values?.value?.value) || e === !0);
}
function eA(t) {
  const { chartData: e, pieSeries: i, pieSlicesSymbols: a, seriesConfig: o } = t;
  if (i.slices.length === 0) {
    const n = [];
    e?.forEach((s) => {
      const r = gr({
        dataContext: s,
        pieSlicesSymbols: a,
        seriesConfig: o
      });
      n.push(sa(r.color));
    }), n.length > 0 && (i.colors.list = n);
  }
}
function tA(t) {
  const { seriesConfig: e, hideLoaderHandle: i, selectionTheme: a } = t, { x: o, y: n, id: s, visible: r } = e, l = new Nt();
  l.id = s, Qt(l, i), l.dataFields.value = n, l.dataFields.category = o;
  const c = L.pieChart;
  l.startAngle = c.min, l.endAngle = 360 + l.startAngle, JF(l), KF(l), UF(l);
  const u = a !== void 0 && a.selectedElementsTheme?.transformation?.opacity === void 0 ? {
    ...a,
    selectedElementsTheme: {
      ...a?.selectedElementsTheme,
      transformation: {
        ...a?.selectedElementsTheme?.transformation,
        opacity: 1
      }
    }
  } : a;
  return Ei({
    element: l.slices.template,
    useNativeState: !0,
    customSelectionTheme: u
  }), l.slices.template.states.removeKey("hover"), Vi(l), l.hidden = r === !1, Eo(l), l;
}
function iA(t) {
  const { series: e, pieSlicesSymbols: i, seriesConfig: a, selectionTheme: o } = t;
  e.defaultState.reset(), e.slices.each((n, s) => {
    const r = n.dataItem?.dataContext, l = gr({
      dataContext: r,
      pieSlicesSymbols: i,
      seriesConfig: a
    }), c = Ao({
      element: n,
      fillSymbol: l,
      defaultToColorFromRamp: !0,
      colorRampIndex: s,
      isChartFillSymbol: !0
    });
    o !== void 0 && o.selectedElementsTheme === void 0 && di({
      element: n,
      stylingInfo: c,
      stateKey: st.Active
    });
  });
}
async function aA(t) {
  const { chartConfig: e, queryObject: i, usePopupTemplateFieldsInfo: a, labelUpdateNeeded: o, utilsStrings: n } = t, { series: s } = e, r = s[0], { x: l } = r, c = !ud({ chartConfig: e }), u = U([r]), d = u === P.PieFromFields, g = pt(i).objectIdField, h = await qt(i, a);
  return {
    x: l,
    isNonAggregatedChart: c,
    objectIdField: g,
    isPieFromFields: d,
    seriesConfig: r,
    fieldList: h,
    labelUpdateNeeded: o,
    chartSubType: u,
    colorMatch: Ii(e),
    utilsStrings: n
  };
}
function pc(t) {
  return `${t[0]},${t[1]},${t[2]}`;
}
function oA(t, e, i) {
  const a = new Set(Array.from(e).map(pc)), o = t.findIndex((n) => !a.has(pc(n)));
  return o !== -1 ? o : i;
}
function nA(t) {
  const {
    dataContext: e,
    seriesConfig: i,
    existingSlicesColors: a,
    isGroupOfSlices: o,
    sliceFromConfig: n,
    dataIndex: s,
    colorMatch: r,
    chartSubType: l
  } = t, c = o ? {
    ...L.pieChart.sliceGrouping.fillSymbol,
    ...i.sliceGrouping?.fillSymbol
  } : Ge(n?.fillSymbol ?? i.fillSymbol), u = Ft({
    dataItem: e,
    seriesConfig: i,
    chartSubType: l,
    colorMatch: r
  });
  let d = s;
  c?.color || (d = oA(og, a, s));
  const m = new Dd();
  m.dataItem = {
    dataContext: e
  };
  const { symbolWithColorInfo: g } = Ai({
    element: m,
    seriesConfig: i,
    y: i.y,
    seriesSymbol: c ?? on(),
    seriesIndex: d,
    rendererSymbol: u,
    colorMatch: r,
    isChartFillSymbol: !0
  });
  return g;
}
function bc(t, e) {
  const {
    x: i,
    isNonAggregatedChart: a,
    objectIdField: o,
    isPieFromFields: n,
    seriesConfig: s,
    fieldList: r,
    labelUpdateNeeded: l,
    colorMatch: c,
    chartSubType: u,
    utilsStrings: d
  } = e, m = [];
  let g, h;
  const y = /* @__PURE__ */ new Set();
  return t.forEach((p, S) => {
    const x = Od({
      dataContext: p,
      x: i,
      isNonAggregatedChart: a,
      dataIndex: S,
      objectIdField: o,
      isPieFromFields: n
    });
    p[L.pieChart.technicalFieldSliceId] = x;
    const C = gn(s.slices, x);
    C?.fillSymbol?.color !== void 0 && y.add(C.fillSymbol.color);
  }), t.forEach((p, S) => {
    const x = p[L.pieChart.technicalFieldSliceId], C = gn(s.slices, x), v = Di(p), F = nA({
      dataContext: p,
      seriesConfig: s,
      existingSlicesColors: y,
      isGroupOfSlices: v,
      sliceFromConfig: C,
      dataIndex: S,
      colorMatch: c,
      chartSubType: u
    });
    F.color && y.add(F.color);
    const T = Rd({
      dataContext: p,
      sliceFromConfig: C,
      isGroupOfSlices: v,
      seriesConfig: s,
      fieldList: r,
      isPieFromFields: n,
      labelUpdateNeeded: l,
      colorMatch: c,
      utilsStrings: d
    }), k = {
      sliceId: x,
      label: T,
      fillSymbol: F
    };
    k.originalLabel = C?.originalLabel ?? (p?.[L.originalCategoryValue] !== void 0 ? p?.[L.originalCategoryValue] : k.label), v ? (h = p[L.pieChart.technicalFieldGroupedSlices], s.sliceGrouping !== void 0 && (g = {
      sliceId: s.sliceGrouping.sliceId,
      percentageThreshold: s.sliceGrouping.percentageThreshold,
      label: T,
      originalLabel: s.sliceGrouping.originalLabel ?? T,
      fillSymbol: F
    })) : m.push(k);
  }), { slices: m, groupOfSlicesSymbols: g, groupOfSlices: h };
}
async function Qr(t) {
  const { chart: e } = t, i = await aA(t), { slices: a, groupOfSlicesSymbols: o, groupOfSlices: n } = bc(
    e.data,
    i
  ), { slices: s } = bc(n ?? [], i);
  return {
    slices: a,
    groupedSlices: s,
    groupOfSlices: o
  };
}
function sA(t, e) {
  const { ticks: i } = e, a = i?.visible === !1 || e.dataLabelsInside === !0 || e.dataLabels === void 0 || e.dataLabels?.visible === !1 || e.dataLabelsOffset !== void 0 && e.dataLabelsOffset <= 0;
  t.ticks.template.disabled = a, t.ticks.template.strokeOpacity = L.pieChart.ticksOpacity;
  const o = i?.lineSymbol ?? wo({ color: Gc });
  a && (o.width = 0), Ut({
    element: t.ticks.template,
    lineSymbol: o,
    visible: !a
  });
}
function rA(t) {
  const { chart: e, seriesConfig: i, series: a, pieSlicesSymbols: o, options: n, utilsStrings: s } = t, { tooltipFormatter: r, dataLabelFormatter: l } = n ?? {}, { x: c, y: u, id: d, innerRadius: m, startAngle: g, endAngle: h } = i;
  a.id = d;
  const y = U([i]), p = L.pieChart;
  a.dataFields.value = y !== P.PieFromFields ? u : wa, a.dataFields.category = y !== P.PieFromFields ? c : ii;
  const S = e.radius instanceof mn ? e.radius.value : e.radius;
  e.innerRadius = ot((m ?? p.innerRadius) * S), a.startAngle = g ?? p.min, a.endAngle = h ?? 360 + a.startAngle, qF({
    pieSeries: a,
    seriesConfig: i,
    dataLabelFormatter: l
  }), eA({
    chartData: e.data,
    pieSeries: a,
    pieSlicesSymbols: o,
    seriesConfig: i
  }), la({
    // TODO: Remove the type assertion and correct the typings
    styleCallback: iA,
    callbackProps: t,
    series: a,
    seriesConfig: i
  }), sA(a, i), QF({
    series: a,
    seriesConfig: i,
    tooltipFormatter: r
  });
}
function Am(t) {
  const { chart: e, seriesConfig: i, utilsStrings: a } = t, o = e.data, n = Rr({ data: o, seriesConfig: i, utilsStrings: a });
  e.data = n;
}
function lA(t, e) {
  t.adapter.add(
    "htmlOutput",
    (i, a) => {
      let o = i;
      const n = _(
        e.uid,
        "scatterplotDataLabelFormatter"
      ), { dataItem: s } = a;
      if (s instanceof ta && n !== void 0) {
        const { valueX: r, valueY: l, customValue: c } = s, u = (s.component?.xAxis).min, d = (s.component?.yAxis).min;
        o = Ms({
          dataValue: r,
          series: e,
          seriesType: b.ScatterSeries,
          axisMin: u
        }) || Ms({
          dataValue: l,
          series: e,
          seriesType: b.ScatterSeries,
          axisMin: d
        }) ? "" : n(r, l, c);
      }
      return He(o);
    },
    0
    // 0 = high priority
  );
}
function cA(t) {
  const e = Vt(L.dataLabelInitialize);
  return ci(e.uid, { isDataLabel: !0 }), t.bullets.push(e), lA(e, t), e.html = "{valueX} - {valueY}", e;
}
function dA(t) {
  const { numberFormatter: e, dataLabelsConfigContent: i } = t;
  return (a, o) => ft({
    textSymbol: {
      ...i,
      text: `${e.format(a)} - ${e.format(o)}`
    },
    format: "html"
  });
}
function uA(t) {
  const { series: e } = t, i = To(e, "bullets");
  es({
    ...t,
    dataLabel: i,
    defaultDataLabelFormatter: dA,
    seriesType: b.ScatterSeries
  });
}
function fA(t) {
  const { axes: e, seriesConfig: i, series: a, fieldList: o } = t, { dataTooltipVisible: n } = i;
  let s;
  const r = bt(a.rtl);
  return n === !1 ? s = (l, c, u) => "" : s = (l, c, u) => {
    const d = De(o, i.x), m = li(d, e?.[0].title?.content?.text), g = De(o, i.y), h = li(g, e?.[1].title?.content?.text), y = Oa({
      series: a,
      callbackName: "tooltipValueXNumberFormatCallback",
      value: l
    }), p = Oa({
      series: a,
      callbackName: "tooltipValueYNumberFormatCallback",
      value: c
    });
    let S = `<b>${m}${r} </b>${y}<br /><b>${h}${r} </b>${p}`;
    if (u !== void 0 && i.sizePolicy?.field !== void 0) {
      const x = De(o, i.sizePolicy?.field), C = Oa({
        series: a,
        callbackName: "tooltipValueYNumberFormatCallback",
        value: u
      });
      S += `<br /><b>${x}${r} </b>${C}<br /><b>`;
    }
    return S;
  }, s;
}
function mA(t, e) {
  t.tooltipHTML = L.htmlEmptyContent, t.adapter.add("tooltipHTML", (i, a) => {
    let o = i ?? "";
    const { chart: n } = e;
    if (n !== void 0) {
      const s = I(n.uid, "config"), { dataTooltipVisible: r } = s?.series[0] ?? {};
      if (r === !1)
        o = "";
      else {
        const l = _(
          e.uid,
          "scatterplotTooltipFormatter"
        );
        if (!a.isHidden && l !== void 0) {
          const { dataItem: c } = a;
          if (c instanceof ta) {
            const { valueX: u, valueY: d, customValue: m } = c;
            o = l(u, d, m);
          }
        }
      }
    }
    return He(o);
  });
}
function gA(t) {
  const { series: e, tooltipFormatter: i } = t;
  We(e.uid, {
    scatterplotTooltipFormatter: i ?? fA(t)
  });
}
function hA(t) {
  const { series: e, seriesConfig: i, newMin: a, newMax: o } = t, n = e.heatRules.getIndex(0);
  let s = n === void 0 && i.sizePolicy !== void 0 || n !== void 0 && i.sizePolicy === void 0;
  if (!s && n !== void 0) {
    const r = n.min === a && n.max === o, l = e.dataFields.customValue === i.sizePolicy?.field, c = i.sizePolicy?.scaleType === Ui.Linear && n.logarithmic !== !0 || i.sizePolicy?.scaleType === Ui.Logarithmic && n.logarithmic === !0;
    s = !(r && l && c);
  }
  return s;
}
function pA(t, e) {
  const { sizePolicy: i } = t, a = e.heatRules.getIndex(0);
  let o = !1;
  if (i !== void 0) {
    const { scaleType: n, field: s, minSize: r, maxSize: l } = i, c = Oe(e);
    if (c !== void 0) {
      const u = Pc(), d = r ?? u.minSize, m = l ?? u.maxSize;
      a !== void 0 ? hA({ series: e, seriesConfig: t, newMin: d, newMax: m }) && (o = !0, a.min = d, a.max = m, a.logarithmic = n === Ui.Logarithmic) : (o = !0, e.heatRules.push({
        target: c,
        property: "minWidth",
        min: d,
        max: m,
        dataField: "customValue",
        // this is a static value, to be kept in sync with the code below `series.dataFields.customValue = field`
        logarithmic: n === Ui.Logarithmic
      })), e.dataFields.customValue = s;
    }
  } else a !== void 0 && (e.heatRules.pop(), e.dataFields.customValue = void 0, o = !0);
  return o;
}
function bA(t) {
  t !== void 0 && t.validateData();
  const e = t?.series?.values?.find((i) => _(i.uid, "isOverlay") === !0);
  e !== void 0 && e.validateData();
}
async function yA(t) {
  const { xAxis: e, yAxis: i, x: a, y: o, name: n, hideLoaderHandle: s } = t, r = new ue();
  return Kt(r, n), Qt(r, s), r.ignoreMinMax = !0, We(r.uid, {
    isOverlay: !0,
    type: Qe.Trendline
  }), r.dataFields.valueX = a, r.dataFields.valueY = o, r.xAxis = e, r.yAxis = i, r.hidden = !0, r;
}
function SA(t) {
  const { trendLine: e, seriesConfig: i, valueFormat: a, chartData: o, defaultR2Value: n } = t, s = L.scatterplotSeries;
  if (o?.trendLinePoints) {
    e.data = o.trendLinePoints;
    const c = I(e.chart.uid, "formatLocale"), u = Number.isFinite(o.r2) ? ra({
      value: o.r2 ?? s.r2,
      valueFormat: a,
      iLocale: e.chart.language.locale,
      formatLocale: c
    }) : void 0, d = u !== void 0 ? `R = ${u}` : n;
    Kt(e, d);
  }
  e.hiddenInLegend = i.overlays?.trendLine?.created !== !0;
  const r = i.overlays?.trendLine?.created === !0 && i.overlays.trendLine.visible !== !1, l = i.overlays?.trendLine?.symbol ?? {
    type: te.SLS
  };
  l.color === void 0 && (l.color = ai({ colorIndex: 1 })), Ut({
    element: e,
    lineSymbol: l ?? wo(),
    visible: r
  });
}
async function xA(t) {
  const { chart: e, seriesConfig: i, axisList: a = [], hideLoaderHandle: o, selectionTheme: n, ignoreSmoothRenderingLimit: s } = t, r = L.scatterplotSeries, [l, c] = a, { x: u, y: d, overlays: m, name: g, id: h } = i, y = [], p = new ue();
  We(p.uid, { type: b.ScatterSeries }), p.id = h, Qt(p, o), p.hiddenInLegend = !0, p.dataFields.valueX = u, p.dataFields.valueY = d, l !== void 0 && (p.xAxis = l), c !== void 0 && (p.yAxis = c);
  const S = ts({ chart: e, lineSeries: p });
  mA(S, p), cA(p), p.strokeOpacity = r.strokeOpacity, p.minDistance *= Math.ceil(p.data.length / 1e4), p.hidden = !0, Ei({ element: S, customSelectionTheme: n }), xa(e, S), Xf({
    chart: e,
    series: p,
    seriesType: b.ScatterSeries,
    marker: S,
    ignoreSmoothRenderingLimit: s
  }), y.push(p);
  const x = m?.trendLine, C = await yA({
    xAxis: l,
    yAxis: c,
    x: u,
    y: d,
    hideLoaderHandle: o,
    name: g,
    visible: x?.visible
  });
  return Eo(C), y.push(C), Vi(p), y;
}
function CA(t) {
  const { seriesConfig: e, series: i, colorMatch: a } = t, { chart: o } = i, n = Oe(i), s = pA(e, i), r = () => {
    if (n !== void 0) {
      let l, c;
      const u = e.markerSymbol ?? js(), d = /* @__PURE__ */ new Set();
      n.clones.each((g) => {
        const h = Ft({
          dataItem: g.dataItem?.dataContext,
          seriesConfig: e,
          chartSubType: P.NonSpecific,
          colorMatch: a
        }), y = Ai({
          element: g,
          seriesSymbol: u,
          seriesConfig: e,
          colorMatch: a,
          rendererSymbol: h
        });
        l = y.symbolWithColorInfo, c = y.stylingInfo, di({ element: g, stylingInfo: c }), d.add(JSON.stringify(c));
      }), l = d.size > 1 ? void 0 : l;
      const m = /* @__PURE__ */ new Map();
      m.set(0, l), Bt({
        data: m,
        htmlContainer: o.htmlContainer,
        chartId: o.id,
        colorMatchApplied: Sa(o)
      });
    }
  };
  s ? (i.events.disableType(B.Validated), bA(o), o.events.once(B.Validated, () => {
    r(), i.events.enableType(B.Validated), i.dispatchImmediately(B.Validated);
  })) : r();
}
function vA(t) {
  const { seriesConfig: e, chartSeries: i, axes: a, fieldList: o, chartData: n, options: s, utilsStrings: r } = t, { tooltipFormatter: l, dataLabelFormatter: c } = s ?? {}, u = i.find((g) => _(g.uid, "isOverlay") === !0), d = r.notAvailable;
  if (u !== void 0) {
    const g = {
      trendLine: u,
      seriesConfig: e,
      valueFormat: In(),
      chartData: n,
      defaultR2Value: d
    };
    la({
      // TODO: Remove the type assertion and correct the typings
      styleCallback: SA,
      callbackProps: g,
      series: u,
      seriesConfig: e
    });
  }
  const m = i.find((g) => _(g.uid, "isOverlay") !== !0);
  m !== void 0 && (Oe(m) !== void 0 && (m.id = e.id, la({
    // TODO: Remove the type assertion and correct the typings
    styleCallback: CA,
    callbackProps: t,
    series: m,
    seriesConfig: e
  }), Gf({
    axes: a,
    currentSeries: m,
    tooltipValueFormat: e.dataTooltipValueFormat
  }), gA({
    axes: a,
    seriesConfig: e,
    series: m,
    fieldList: o,
    tooltipFormatter: l
  })), uA({
    series: m,
    seriesType: b.ScatterSeries,
    dataLabelsConfig: e.dataLabels,
    yAxisValueFormat: a[1].valueFormat,
    customDataLabelFormatter: c
  }));
}
function LA(t) {
  const e = t.isHover, i = t.dataItem instanceof ri ? t.dataItem?.label?.isHover : !1;
  return e || i;
}
async function FA(t) {
  t.series.getIndex(0)?.slices.values.some((i) => LA(i)) || await Wo({ chart: t, listSelectedElements: [], selectionSource: Ne.SelectionByClick });
}
async function yc(t) {
  const { chart: e, hitSlice: i, multiSelect: a = !1 } = t, o = [], n = I(e.uid, "config"), s = e.series.getIndex(0);
  if (n && s !== void 0) {
    if (!s.slices.values.every((l) => (l.isHover || l.isFocused) !== l.isActive)) {
      const l = Ef(s), c = aa(s), u = {
        element: {},
        xAxisField: l,
        yAxisField: c,
        seriesIndex: 0,
        chartConfig: n
      };
      s.slices.each((d, m) => {
        d.isActive && (d === i || a || d.dataItem instanceof ri && d.dataItem.label.isHover) ? Di(d.dataItem?.dataContext) ? (Bo({
          groupOfSlicesDataContext: d.dataItem?.dataContext
        }) ?? []).forEach((p) => {
          o.push({
            ...u,
            element: void 0,
            elementDataContext: p,
            elementIndex: m
          });
        }) : o.push({
          ...u,
          element: d,
          elementDataContext: d.dataItem?.dataContext,
          elementIndex: m
        }) : Et({
          element: d,
          selected: !1,
          useNativeState: !0
        });
      }), o.forEach((d) => {
        Et({
          element: d.element,
          selected: !0,
          useNativeState: !0
        });
      });
    }
    await Wo({ chart: e, listSelectedElements: o, selectionSource: Ne.SelectionByClick });
  }
  e.feedLegend();
}
function AA(t) {
  const e = async (o) => {
    const { target: n } = o;
    if (jf(t) && t.series.getIndex(0)?.slices.template.togglable) {
      const s = as(o, t);
      if (n instanceof Dd)
        await yc({ chart: t, multiSelect: s, hitSlice: n });
      else if (n instanceof So) {
        const r = n.dataItem;
        if (r instanceof ri) {
          const { slice: l } = r;
          l.isActive = !l.isActive, await yc({ chart: t, multiSelect: s, hitSlice: l });
        }
      } else
        await FA(t);
    }
  }, i = t.series.getIndex(0)?.slices.template;
  i !== void 0 && (i.events.on(B.Hit, e), i.events.on(B.DoubleHit, e));
  const a = t.series.getIndex(0)?.labels.template;
  a !== void 0 && a.events.on(B.Hit, e), t.events.on(B.Hit, e), t.events.on(B.DoubleHit, e);
}
function Sc(t) {
  return t?.offsetParent !== null;
}
function TA(t, e) {
  t !== void 0 && e !== void 0 && window.IntersectionObserver !== void 0 && new IntersectionObserver(
    (a) => {
      a[0].intersectionRatio > 0 && (I(t.uid, "chartWasCreatedWhileHidden") === !0 ? (t.reinit(), t.events.once(B.Validated, () => {
        t.reinit();
      }), j(t.uid, {
        chartWasCreatedWhileHidden: !1
      })) : I(t.uid, "chartWasUpdatedWhileHidden") === !0 && (t.reinit(), j(t.uid, {
        chartWasUpdatedWhileHidden: !1
      })));
    },
    {
      root: null
    }
  ).observe(e);
}
function kA(t, e) {
  let i = L.pieChart.dataLabels.maxWidth ?? 100;
  if (t != null) {
    const {
      alignDataLabels: a,
      dataLabelsOffset: o = L.pieChart.dataLabelsOffset,
      optimizeDataLabelsOverlapping: n,
      dataLabels: s,
      dataLabelsInside: r
    } = t;
    if (s?.visible === !0 && a === !0 && r !== !0 && n === !0) {
      const l = typeof e.radius == "number" ? e.radius / 100 : e.radius.value, c = e.chartContainer.measuredWidth, u = e.chartContainer.measuredHeight, d = l * Math.min(c, u), m = 5, g = Math.floor((c - d) / 2) - m - o;
      i = Math.min(g, i - m);
      const h = 30;
      i < h && (i = h);
    }
  }
  return i;
}
function Tm(t) {
  if (kt(t)) {
    const e = typeof t.radius == "number" ? t.radius : t.radius.percent;
    j(t.uid, { pieChartRadius: e });
    const i = () => {
      const a = ot(
        I(t.uid, "pieChartRadius") ?? L.pieChart.chartOptimizedRadius
      );
      let o = a;
      const n = I(t.uid, "config");
      if (n !== void 0) {
        const { series: s } = n, {
          innerRadius: r,
          optimizeDataLabelsOverlapping: l,
          alignDataLabels: c,
          dataLabelsOffset: u = L.pieChart.dataLabelsOffset,
          dataLabels: d,
          dataLabelsInside: m
        } = s[0];
        if (d?.visible === !0 && c === !0 && l === !0 && m !== !0) {
          const p = L.pieChart.chartOptimizedRadius / 100, S = 500, x = 150, C = 0.6, v = 0.5, F = 1, T = t.chartContainer.measuredWidth - u * 2, k = Math.max(T - x, 0) / (S - x), $ = k < 1 ? (
            // case 1: the container width is less than the radiusContainerWidthBreakpoint - we want to scale the radius down.
            Math.max(k ** F * C, 0.4)
          ) : (
            // case 2: the container width is at or more than the radiusContainerWidthBreakpoint - ramp up radius to the max radius
            Math.min(k ** v * C, p)
          );
          o = ot($ * 100);
        } else
          o = ot(L.pieChart.chartRadius);
        a.value.toFixed(1) !== o.value.toFixed(1) && (j(t.uid, { pieChartRadius: o.percent }), t.radius = o, t.innerRadius = ot((r ?? L.pieChart.innerRadius) * o.value));
        const h = t.series?.values?.[0];
        h instanceof Nt && (h.labels.template.maxWidth = kA(
          n?.series[0],
          t
        ));
      }
      return o;
    };
    t.events.on(B.SizeChanged, Ye(i, L.debounceTime)), i(), t.validate();
  }
}
function km(t) {
  if (t instanceof Le)
    Tm(t);
  else if (!(t instanceof yt)) {
    const e = () => {
      const a = I(t.uid, "config"), {
        chartPaddingMinSize: o,
        chartPaddingRightWhenLegendNotOnRight: n,
        chartContainerPaddingTopWhenRotated: s,
        chartContainer: r
      } = L, l = a?.series, c = z(l), u = Rt({ config: a }), d = l?.[0]?.dataLabels?.visible ?? !0;
      let m = L.chartDefaultPaddingRight;
      if (u && d && (c === b.LineSeries || c === b.ComboLineAndBarSeries || c === b.BarSeries && (a?.stackedType ?? jc()) === Ie.Side)) {
        let h = 0;
        const y = (p) => je(p.uid, "isDataLabel") ?? !1;
        t.series.each((p) => {
          const S = p.bullets.values.find(y);
          S !== void 0 && S.clones.each((x) => {
            let C = x.measuredWidth;
            switch (x.horizontalCenter) {
              case ee.Middle:
                C /= 2;
                break;
              case se.Right:
                C *= -1;
                break;
              case se.Left:
            }
            const v = x.pixelX + C;
            v > h && (h = v, m = C);
          });
        });
      }
      m >= 0 && (t.chartContainer.paddingRight = m), t.chartContainer.paddingTop = u ? s : r.paddingTop;
      const g = a?.legend?.visible !== !1 && a?.legend?.position === Y.Right;
      t.paddingRight = g ? o : n;
    };
    let i = 0;
    t.series.each((a) => {
      a.events.once(B.Validated, () => {
        i += 1, i === t.series.length && e();
      });
    });
  }
}
function IA(t, e) {
  t.adapter.add("criticalError", (i) => (i.message = e.errors.simpleError, i));
}
function Ls(t, e) {
  const i = t.svgContainer?.SVGContainer;
  i !== void 0 && (i.style.position = e ?? "relative");
}
function wA(t) {
  const e = t.svgContainer?.SVGContainer;
  e !== void 0 && (e.style.display = "flex");
}
function $A(t) {
  const e = I(t?.uid, "options")?.loaderColors, { backgroundCSSColor: i, textCSSColor: a } = uf(e);
  t.modal?.elements.wrapper && (t.modal.elements.wrapper.style.backgroundColor = i, t.modal.elements.wrapper.style.color = a), t.modal?.elements.curtain && (t.modal.elements.curtain.style.backgroundColor = i);
}
function DA(t) {
  t.modal !== void 0 && (t.modal.classPrefix = "modal", Ls(t, "static"), t.modal.events.on(B.Opened, () => {
    Ls(t, "relative"), wA(t), $A(t);
  }), t.modal.events.on(B.Closed, () => {
    Ls(t, "static");
  }));
}
function Jr(t) {
  DA(t);
}
function xc(t) {
  let e = "";
  for (let i = 0; i < t.length; i += 1) {
    const a = t[i];
    e += `<li>${a.message}</li>`;
  }
  return `<ol>${e}</ol>`;
}
function vn(t) {
  t.modal !== void 0 && (t.modal.closable = !0, t.modal.content = "", t.closeModal());
}
async function va(t) {
  const { chart: e, chartConfig: i, queryObject: a, createMessage: o, allowUsingObjectIdStat: n, errorStrings: s } = t, r = I(e.uid, "options"), l = await er({
    input: i,
    queryObject: a,
    allowUsingObjectIdStat: n
  }), { schemaErrors: c, customErrors: u, warnings: d } = l;
  if (e.modal !== void 0) {
    let m, g;
    if (e.modal.closable = !1, i === void 0)
      g = o === void 0 ? s.modalHeaders.newChart : void 0, m = o ?? s.errors.newChartRequest, e.modal.events.once(B.Opened, () => {
        if (o !== void 0) {
          const h = e.modal?.elements?.title?.parentElement ?? null;
          h !== null && (h.style.visibility = "hidden");
        }
      });
    else if (c.length > 0)
      m = s.errors.simpleError, g = s.modalHeaders.error;
    else if (u.length > 0)
      m = xc(u), g = s.modalHeaders.error;
    else if (d.length > 0) {
      const h = xc(d);
      m = `<p>${s.errors.warningRequest}</p>${h}`, g = s.modalHeaders.warning;
    }
    m !== void 0 && r?.showUIMessages !== !1 && kt(e) && e.openModal(m, g);
  }
  return l;
}
async function da(t) {
  const { chart: e, chartConfig: i, invalidType: a, elementCount: o, seriesCount: n, errorStrings: s } = t, r = I(e.uid, "queryObject"), l = I(e.uid, "options"), c = I(e.uid, "formatLocale"), u = i !== void 0 && Ha({
    seriesConfig: i.series[0],
    xAxisValueFormatType: Bn(i)
  }), d = await fd({
    invalidType: a,
    elementCount: o,
    seriesCount: n,
    chartLimits: l?.chartLimits,
    filterBySelection: l?.filterBySelection,
    queryObject: r,
    errorStrings: s,
    formatLocale: c,
    isTemporalLineChart: u
  });
  md(d, e.htmlContainer), e.modal !== void 0 && l?.showUIMessages !== !1 && kt(e) && (e.modal.closable = !1, e.openModal(d.message, d.header));
}
async function Cc(t) {
  const { chart: e, chartConfig: i, errorStrings: a } = t, o = I(e.uid, "options");
  (e.modal?.content === void 0 || e.modal?.content === "") && Yc({
    chartConfig: i,
    nullAsValid: o?.nullAsValid,
    dataSet: e.data
  }) && await da({
    chart: e,
    invalidType: bi.EmptyDataSet,
    chartConfig: i,
    errorStrings: a
  });
}
async function vc(t, e) {
  if (t instanceof ne) {
    const i = I(t.uid, "isRotated"), a = [];
    [
      { axis: t.xAxes.getIndex(0) },
      { axis: t.yAxes.getIndex(0) },
      { axis: t.xAxes.getIndex(1), isSecondValueAxis: !0 },
      { axis: t.yAxes.getIndex(1), isSecondValueAxis: !0 }
    ].forEach((o) => {
      const { axis: n, isSecondValueAxis: s } = o;
      if (n !== void 0) {
        const r = Ca(n.renderer, i);
        pm(n, s) || a.push(
          da({
            chart: t,
            invalidType: r ? bi.NegativeValueInXAxisLogScale : bi.NegativeValueInYAxisLogScale,
            errorStrings: e
          })
        );
      }
    }), await Promise.all(a);
  }
}
async function el(t) {
  const {
    chart: e,
    data: i,
    chartConfig: a,
    pieSlicesSymbols: o,
    queryObject: n,
    options: s,
    currentValidationStatus: r,
    utilsStrings: l,
    errorStrings: c
  } = t, { slices: u } = o ?? {}, { chartWillRender: d, createMessage: m } = s ?? {};
  let g = r, h = a, y = Ge(o);
  if (d !== void 0 && (e instanceof yt || e instanceof Le)) {
    h = Ge(a);
    const p = Ag({
      data: i,
      seriesConfig: a.series
    });
    if (h = await d({
      chartConfig: h,
      data: p,
      slices: u
    }), g = await va({
      chart: e,
      chartConfig: h,
      queryObject: n,
      createMessage: m,
      allowUsingObjectIdStat: s?.allowUsingObjectIdStat,
      errorStrings: c
    }), e instanceof Le) {
      if (i && "dataItems" in i) {
        const { colorMatchApplied: S, rendererFieldNames: x } = await qa({
          data: i.dataItems,
          queryObject: n,
          chartConfig: h,
          allowColorMatch: Qi({ chartConfig: h, queryObject: n })
        });
        j(e.uid, { colorMatchApplied: S, rendererFieldNames: x });
      }
      y = await Qr({
        chart: e,
        chartConfig: h,
        queryObject: n,
        labelUpdateNeeded: !0,
        usePopupTemplateFieldsInfo: s?.usePopupTemplateFieldsInfo,
        utilsStrings: l
      });
    }
  }
  return { alteredConfig: h, newValidationStatus: g, alteredPieSlicesSymbols: y };
}
function Im(t) {
  const { chart: e, data: i, config: a, hideEmptySeries: o } = t, n = a.series.length, s = Ge(a);
  let r = !1;
  if (o && e instanceof ne && n > 1) {
    const l = z(a?.series), c = U(a?.series), u = /* @__PURE__ */ new Set();
    switch (l) {
      case b.ComboLineAndBarSeries:
      case b.BarSeries:
      case b.LineSeries: {
        s.series.forEach((m) => {
          let g = "";
          "y" in m && (g = Array.isArray(m.y) ? m.y[0] : m.y, c === P.BarAndLineSplitByNoAggregation && (g = `${g}_${Ki({
            where: m.query?.where,
            keepSurroundingQuotes: !1,
            escape: !1
          })}`), (i ?? e.data)?.some(
            (y) => Ys({
              dataItem: y,
              x: m.x,
              y: g
            })
          ) && u.add(m));
        });
        break;
      }
      case b.BoxPlotSeries: {
        const m = Oi(a);
        s.series.forEach((g) => {
          let h, y;
          g.type === b.BoxPlotSeries ? (h = (i ?? e.data).dataItems, y = h?.some(
            (p) => ng({
              dataItem: p,
              splitBy: g.query?.where,
              showOutliers: m
            })
          )) : g.type === b.LineSeries && (h = (i ?? e.data).meanLines, y = h?.some((p) => GC(p, g.query?.where))), y && u.add(g);
        });
        break;
      }
    }
    const d = Array.from(u.values());
    r = d.length > 0 && d.length < n, r ? (j(e.uid, { unfilteredConfig: Ge(a) }), s.series = d, j(e.uid, { config: Ge(s) })) : j(e.uid, { unfilteredConfig: void 0 });
  }
  return j(e.uid, { seriesFilteredOut: r }), { seriesFilteredOut: r, updatedConfig: s };
}
lo.classNamePrefix = "arcgis-charts-";
async function tl(t, e) {
  const i = await cC(e.locale);
  lo.defaultLocale = i, t.language.locale = i, j(t.uid, { formatLocale: e.formatLocale }), t.rtl = e.rtl;
}
function ds(t) {
  const { chart: e, actionMode: i, cursorRange: a } = t;
  if (kt(e)) {
    const o = i ?? I(e.uid, "actionMode") ?? L.actionMode;
    j(e.uid, { actionMode: o });
    const n = I(e.uid, "filterBySelection");
    switch (o) {
      case K.MonoSelection:
      case K.MultiSelection:
      case K.MultiSelectionWithCtrlKey:
        n !== !0 ? ev(e) : xs(e);
        break;
      case K.Zoom:
        xs(e);
        break;
      case K.None:
        ao({
          chart: e,
          selectionSource: Ne.ClearSelection,
          clearOnlyVisibleSeries: !1,
          disposeStyleAndSelection: !1
        }), xs(e);
        break;
    }
    MC({ chart: e, actionMode: o, cursorRange: a });
  }
}
function OA(t, e) {
  e === !0 && (t.tapToActivate = !0, t.tapTimeout = 3e3, t.responsive.enabled = !0);
}
async function RA(t) {
  const { chart: e, axesConfig: i, chartType: a, isRotated: o, errorStrings: n } = t;
  switch (await Ji({ chartType: a, axesConfig: i, errorStrings: n }), a) {
    case b.ScatterSeries: {
      hF(e, i);
      break;
    }
    case b.HistogramSeries: {
      fF({ chart: e, axesConfig: i });
      break;
    }
    case b.GaugeSeries: {
      e instanceof yt && i?.[0]?.valueFormat !== void 0 && sF(e, i[0].valueFormat);
      break;
    }
    case b.BarSeries:
    case b.LineSeries:
    case b.ComboLineAndBarSeries:
    case b.BoxPlotSeries: {
      E0({ chart: e, chartType: a, isRotated: o, axesConfig: i });
      break;
    }
  }
}
async function il(t) {
  const {
    chart: e,
    chartConfig: i,
    chartConfig: { axes: a },
    rotationChanged: o,
    axisLabelsBehaviorChanged: n,
    chartType: s,
    isRotated: r,
    dualAxisChanged: l,
    timeIntervalInfoWasReset: c,
    data: u,
    queryObject: d,
    guideTooltipFormatter: m,
    xAxisLabelFormatter: g,
    yAxisLabelFormatter: h,
    secondaryYAxisLabelFormatter: y,
    gaugeInnerLabelFormatter: p,
    utilsStrings: S,
    errorStrings: x
  } = t;
  switch (await Ji({ chartType: s, axesConfig: a, errorStrings: x }), s) {
    case b.ScatterSeries: {
      e instanceof ne && await pF({
        chart: e,
        axesConfig: a,
        axisLabelsBehaviorChanged: n,
        guideTooltipFormatter: m,
        xAxisLabelFormatter: g,
        yAxisLabelFormatter: h,
        utilsStrings: S,
        errorStrings: x
      });
      break;
    }
    case b.HistogramSeries: {
      e.data !== void 0 && e instanceof ne && await gF({
        chart: e,
        axesConfig: a,
        histogramBins: e.data,
        guideTooltipFormatter: m,
        xAxisLabelFormatter: g,
        yAxisLabelFormatter: h,
        utilsStrings: S,
        errorStrings: x
      });
      break;
    }
    case b.BarSeries:
    case b.LineSeries:
    case b.ComboLineAndBarSeries:
    case b.BoxPlotSeries: {
      e instanceof ne && await z0({
        chart: e,
        chartConfig: i,
        rotationChanged: o,
        axisLabelsBehaviorChanged: n,
        isRotated: r,
        dualAxisChanged: l,
        timeIntervalInfoWasReset: c,
        timeIntervalInfo: u?.timeIntervalInfo ?? I(e.uid, "timeIntervalInfo"),
        guideTooltipFormatter: m,
        xAxisLabelFormatter: g,
        yAxisLabelFormatter: h,
        secondaryYAxisLabelFormatter: y,
        utilsStrings: S,
        errorStrings: x
      });
      break;
    }
    case b.GaugeSeries: {
      e instanceof yt && await lF({
        chart: e,
        chartConfig: i,
        data: (u ?? e.data).dataItems,
        queryObject: d,
        axisValueFormatter: g,
        gaugeInnerLabelFormatter: p,
        utilsStrings: S,
        errorStrings: x
      });
      break;
    }
  }
}
async function wm(t) {
  const { chart: e, chartConfig: i, hideLoaderHandle: a, options: o, utilsStrings: n, queryObject: s } = t, { selectionTheme: r, ignoreSmoothRenderingLimit: l } = o ?? {}, c = z(i.series);
  e.series.clear();
  let u, d;
  const m = [], g = [], h = e instanceof ne ? [e.xAxes.getIndex(0), e.yAxes.getIndex(0), e.xAxes.getIndex(1) ?? e.yAxes.getIndex(1)] : void 0, y = { hideLoaderHandle: a, selectionTheme: r, utilsStrings: n }, p = { ...y, axisList: h };
  for (let x = 0; x < i.series.length; x += 1) {
    const C = i.series[x];
    if (d = z([C]), e instanceof ne && (d === b.BoxPlotSeries || d === b.LineSeries && c === b.BoxPlotSeries))
      u = cL({
        ...p,
        chart: e,
        axisList: h,
        chartConfig: i,
        seriesIndex: x
      }), g.push(...u.flat());
    else
      switch (d) {
        case b.BarSeries: {
          e instanceof ne && (u = $F({
            ...p,
            chart: e,
            chartConfig: i,
            seriesIndex: x
          }), g.push(u));
          break;
        }
        case b.LineSeries: {
          e instanceof ne && (u = tL({
            ...p,
            chart: e,
            chartConfig: i,
            seriesIndex: x,
            ignoreSmoothRenderingLimit: l,
            queryObject: s
          }), g.push(u));
          break;
        }
        case b.ScatterSeries: {
          e instanceof ne && C.type === b.ScatterSeries && (m.push(
            xA({
              ...p,
              chart: e,
              seriesConfig: C,
              ignoreSmoothRenderingLimit: l
            })
          ), e.bulletsContainer.zIndex = 1, e.seriesContainer.zIndex = 2);
          break;
        }
        case b.HistogramSeries: {
          e instanceof ne && C.type === b.HistogramSeries && m.push(
            HF({ ...p, chart: e, seriesConfig: C })
          );
          break;
        }
        case b.PieSeries: {
          e instanceof Le && C.type === b.PieSeries && (u = tA({ ...y, seriesConfig: C }), g.push(u));
          break;
        }
      }
  }
  const S = Bg({ chartConfig: i, queryObject: s, chartData: e.data });
  if (S.length > 0 && (e.colors.list = S.map((x) => {
    const [C, v, F, T] = x;
    return new fn({ r: C, g: v, b: F, a: T });
  })), m.length > 0) {
    const x = await Promise.all(m);
    e.series.pushAll(x.flat());
  } else g.length > 0 && e.series.pushAll(g);
  cv(e);
}
async function al(t) {
  const {
    chart: e,
    chartConfig: i,
    chartConfig: { series: a, axes: o, chartRenderer: n },
    seriesIndexMapper: s,
    rotationChanged: r,
    seriesReordered: l,
    outliersVisibilityChanged: c,
    standardizeValuesVisibilityChanged: u,
    chartData: d,
    queryObject: m,
    options: g,
    dataWasUpdated: h,
    sortChanged: y,
    groupOfSlicesWasUpdated: p,
    pieSlicesSymbols: S,
    utilsStrings: x,
    errorStrings: C
  } = t, v = e.series.values, F = /* @__PURE__ */ new Map(), T = i.series.length, k = z(a), $ = Ii(i), O = zt(i), D = Xc(m), R = await qt(m, g?.usePopupTemplateFieldsInfo), M = pt(m), N = $o(n, M.renderer);
  for (const [E, V] of a.entries()) {
    const W = z([V]), H = v[E], Z = {
      numberOfSeries: T,
      series: H,
      seriesConfig: V,
      seriesIndex: E,
      colorMatch: $,
      queryObject: m,
      rendererType: N,
      options: g,
      dataWasUpdated: h,
      fieldList: R,
      subtypeInfo: D,
      sortChanged: y,
      utilsStrings: x
    }, oe = {
      ...Z,
      axes: o,
      seriesIndexMapper: s
    };
    let ie = H;
    if (e instanceof ne && (W === b.BoxPlotSeries || W === b.LineSeries && k === b.BoxPlotSeries)) {
      if (ie = v.find((X) => X.id === V.id), H !== void 0 && (ie instanceof _e || ie instanceof ue)) {
        const X = qe(i);
        CL({
          ...Z,
          chart: e,
          series: ie,
          seriesIndexMapper: s,
          seriesSymbolMapForEvent: F,
          chartData: d,
          showOutliers: i.showOutliers,
          showMean: X,
          outliersVisibilityChanged: c,
          seriesReordered: l,
          standardizeValuesVisibilityChanged: u,
          rotationChanged: r,
          options: g
        });
      }
    } else
      switch (W) {
        case b.BarSeries:
          DF({
            ...oe,
            stackedType: O,
            seriesSymbolMapForEvent: F,
            rotationChanged: r
          });
          break;
        case b.LineSeries:
          nL({
            ...oe,
            stackedType: O,
            seriesSymbolMapForEvent: F,
            rotationChanged: r
          });
          break;
        case b.ScatterSeries:
          vA({
            ...oe,
            chartSeries: v,
            chartData: d
          });
          break;
        case b.HistogramSeries:
          await XF({
            ...oe,
            chartSeries: v,
            chartConfig: i,
            chartData: d && "bins" in d ? d : void 0,
            chartRenderer: n
          });
          break;
        case b.PieSeries:
          rA({
            ...Z,
            chart: e,
            groupOfSlicesWasUpdated: p,
            pieSlicesSymbols: S,
            selectionTheme: g?.selectionTheme
          });
          break;
      }
  }
  await DL({
    chart: e,
    options: g,
    dataWasUpdated: h,
    chartData: d,
    chartConfig: i,
    queryObject: m,
    rotationChanged: r,
    sortChanged: y,
    groupOfSlicesWasUpdated: p,
    errorStrings: C
  });
}
async function ol(t) {
  let { chartConfig: e } = t;
  const { chart: i, options: a, globalOptions: o, queryObject: n, utilsStrings: s, errorStrings: r } = t, {
    hideLoaderAnimation: l,
    disableTogglingLegendItems: c,
    cursorRange: u,
    actionMode: d,
    pieChartLegendValueLabelFormatter: m,
    guideTooltipFormatter: g,
    xAxisLabelFormatter: h,
    yAxisLabelFormatter: y,
    secondaryYAxisLabelFormatter: p,
    gaugeInnerLabelFormatter: S,
    usePopupTemplateFieldsInfo: x
  } = a ?? {};
  let C, v, F, T;
  const { loaderElements: k, loaderHandle: $ } = sv(i, a);
  $.showLoader(l !== !0);
  const O = z(e.series), D = await qt(n, x);
  j(i.uid, { fieldList: D });
  const {
    valid: R,
    invalidType: M,
    data: N,
    count: E,
    binnedServerData: V,
    queryConfig: W
  } = await ja({
    chartConfig: e,
    queryObject: n,
    abortKey: Po(i),
    options: a,
    errorStrings: r,
    fieldList: D
  });
  j(i.uid, {
    options: a,
    elementCount: E,
    initialized: R,
    binnedServerData: V,
    queryConfig: W,
    boxPlotMeanLinesData: N?.meanLines,
    timeIntervalInfo: N?.timeIntervalInfo,
    serverLimitReached: N?.serverLimitReached,
    trendLineData: {
      r2: N?.r2,
      trendLinePoints: N?.trendLinePoints
    }
  });
  const H = /* @__PURE__ */ new Map();
  e.series.forEach((q, Fe) => {
    H.set(q.id, Fe);
  });
  const Z = $i(N), oe = qe(e);
  e = Im({
    chart: i,
    hideEmptySeries: a?.hideEmptySeries ?? L.options.hideEmptySeries,
    data: oe ? N : Z,
    config: e
  }).updatedConfig;
  const ie = N && oe && "meanLines" in N ? N.meanLines : Z;
  if (ie !== void 0 && O !== b.HistogramSeries) {
    const { colorMatchApplied: q, rendererFieldNames: Fe } = await qa({
      data: ie,
      queryObject: n,
      chartConfig: e,
      allowColorMatch: Qi({ chartConfig: e, queryObject: n })
    });
    j(i.uid, { colorMatchApplied: q, rendererFieldNames: Fe });
  }
  if (!R)
    await da({
      chart: i,
      invalidType: M,
      elementCount: E,
      seriesCount: e.series.length,
      chartConfig: e,
      errorStrings: r
    }), $.hideLoader();
  else {
    Z !== void 0 && (i.data = Z);
    const q = U(e.series);
    O === b.BoxPlotSeries && q !== P.BoxPlotMonoField && q !== P.BoxPlotMonoFieldAndSplitBy && (Ga({ arrayToSort: i.data, chartConfig: e }), lm({ chart: i, chartData: i.data, chartConfig: e }));
    let Fe;
    i instanceof Le && (Am({
      chart: i,
      seriesConfig: e.series,
      utilsStrings: s
    }), Fe = await Qr({
      chart: i,
      chartConfig: e,
      queryObject: n,
      labelUpdateNeeded: !0,
      usePopupTemplateFieldsInfo: a?.usePopupTemplateFieldsInfo,
      utilsStrings: s
    }));
    const Jt = {
      dataItems: i.data,
      timeIntervalInfo: I(i.uid, "timeIntervalInfo"),
      serverLimitReached: I(i.uid, "serverLimitReached"),
      meanLines: I(i.uid, "boxPlotMeanLinesData"),
      outliers: N?.outliers
    };
    xi({
      data: i instanceof Le ? { dataItems: i.data } : N,
      seriesConfig: e.series,
      htmlContainer: i.htmlContainer
    });
    const gi = await el({
      chart: i,
      data: N,
      chartConfig: e,
      pieSlicesSymbols: Fe,
      queryObject: n,
      options: a,
      utilsStrings: s,
      errorStrings: r
    });
    T = gi.newValidationStatus;
    const { alteredConfig: Ue, alteredPieSlicesSymbols: La } = gi;
    if (Fe = La, i instanceof Le && (Wn({
      data: i.data,
      newChartConfig: Ue,
      pieSlicesSymbols: Fe,
      fieldList: I(i.uid, "fieldList")
    }), Bt({
      data: Fe,
      htmlContainer: i.htmlContainer,
      chartId: i.id,
      colorMatchApplied: Sa(i, Ue)
    }), Cd({ data: i.data, chartConfig: Ue, htmlContainer: i.htmlContainer })), T?.valid !== !1) {
      const { title: Fa, subtitle: Be, footer: Ve, series: pe, background: it } = Ue;
      C = yF(i), ls(C, { title: Fa, subtitle: Be }), v = SF(i), cs(v, Ve), F = eL(i, pe), kv(i);
      const It = Rt({ config: Ue }), oa = U(pe);
      j(i.uid, {
        config: Ue,
        isRotated: It,
        isNonAggregatedChart: !Pn(oa)
      }), Ue.axes !== void 0 && (await RA({ chart: i, axesConfig: Ue.axes, chartType: O, isRotated: It, errorStrings: r }), await il({
        chart: i,
        chartConfig: Ue,
        chartType: O,
        isRotated: It,
        data: N,
        queryObject: n,
        guideTooltipFormatter: g,
        xAxisLabelFormatter: h,
        yAxisLabelFormatter: y,
        secondaryYAxisLabelFormatter: p,
        gaugeInnerLabelFormatter: S,
        utilsStrings: s,
        errorStrings: r
      })), await wm({
        chart: i,
        chartConfig: Ue,
        hideLoaderHandle: $.hideLoader,
        utilsStrings: s,
        options: a,
        queryObject: n
      }), await al({
        chart: i,
        chartConfig: Ue,
        seriesIndexMapper: H,
        rotationChanged: !1,
        queryObject: n,
        chartData: O === b.BoxPlotSeries ? Jt : N,
        groupOfSlicesWasUpdated: !0,
        pieSlicesSymbols: Fe,
        dataWasUpdated: !0,
        options: a,
        utilsStrings: s,
        errorStrings: r
      }), Yr({
        legendElements: F,
        seriesConfig: pe,
        webChartLegend: Ue.legend,
        pieChartLegendValueLabelFormatter: m
      }), vm(i), bF(i), rs(i, it), Lm({
        chart: i,
        scrollbarXConfig: Ue.axes?.[0]?.scrollbar,
        scrollbarYConfig: Ue.axes?.[1]?.scrollbar
      }), Mf(i), Nf(i, Ue?.cursorCrosshair), ds({ chart: i, actionMode: d, cursorRange: u });
      const Aa = Dn(i.htmlContainer ?? document.documentElement);
      i.dateFormatter.intlLocales = Aa, OA(i, o?.enableResponsiveFeatures), (i instanceof yt || Vo(i.series)) && ($.hideLoader(), Ua(i.htmlContainer)), km(i);
    }
  }
  return { chartElements: C !== void 0 && v !== void 0 && F !== void 0 && k !== void 0 ? { headerElements: C, footerElements: v, legendElements: F, loaderHandle: $, loaderElements: k } : void 0, validationStatus: T };
}
function $m(t) {
  t.series.each((e) => {
    e.events.on(B.Ready, () => {
      Vo(t.series) && _r(t);
    });
  });
}
async function BA(t) {
  const { chartContainer: e, chartConfig: i, queryObject: a, t9nStrings: o, options: n, globalOptions: s } = t, { errorStrings: r, utilsStrings: l } = o, { createMessage: c } = n ?? {};
  e == null && await fa("divNode", o.errorStrings);
  const u = mr(e, ne);
  u.id = i?.id ?? u.uid, j(u.uid, { queryObject: a });
  const { t9nLocale: d } = Tn(u.htmlContainer ?? document.documentElement), m = Dn(u.htmlContainer ?? document.documentElement), g = Xs(u.htmlContainer ?? document.documentElement) === "rtl";
  await tl(u, { locale: d, formatLocale: m, rtl: g }), Jr(u), u.events.on(B.Inited, () => u.zoomOutButton.deepInvalidate());
  const y = await va({
    chart: u,
    chartConfig: i,
    queryObject: a,
    createMessage: c,
    allowUsingObjectIdStat: n?.allowUsingObjectIdStat,
    errorStrings: r
  }), p = Mn(i, u.htmlContainer), S = z(p?.series);
  let x;
  return y.valid && (u instanceof ne && S !== b.BoxPlotSeries && (u.maskBullets = !1), x = (await ol({
    chartConfig: p,
    chart: u,
    queryObject: a,
    options: n,
    globalOptions: s,
    utilsStrings: l,
    errorStrings: r
  })).chartElements, j(u.uid, { config: Ge(p) }), $m(u), KC(u), QC(u)), ea(y, u.htmlContainer), { chart: u, chartElements: x };
}
async function MA(t) {
  const { chartContainer: e, chartConfig: i, queryObject: a, errorStrings: o, utilsStrings: n, options: s, globalOptions: r } = t;
  e == null && await fa("divNode", o);
  const l = mr(e, Le);
  l.id = i?.id ?? l.uid;
  const c = Zc(l.htmlContainer);
  await tl(l, c), l.radius = ot(L.pieChart.chartRadius), Jr(l);
  const u = await va({
    chart: l,
    chartConfig: i,
    queryObject: a,
    createMessage: s?.createMessage,
    allowUsingObjectIdStat: s?.allowUsingObjectIdStat,
    errorStrings: o
  });
  let d;
  return u.valid && (d = (await ol({
    chartConfig: i,
    chart: l,
    queryObject: a,
    options: s,
    globalOptions: r,
    utilsStrings: n,
    errorStrings: o
  })).chartElements, j(l.uid, { config: Ge(i), filterBySelection: s?.filterBySelection }), AA(l)), ea(u, e), { chart: l, chartElements: d };
}
async function NA(t) {
  const { chartContainer: e, chartConfig: i, queryObject: a, errorStrings: o, utilsStrings: n, options: s, globalOptions: r } = t;
  e == null && await fa("divNode", o);
  const l = mr(e, yt);
  l.id = i?.id ?? l.uid;
  const c = Zc(l.htmlContainer);
  await tl(l, c), Jr(l), l.maskBullets = !1;
  let u = await va({
    chart: l,
    chartConfig: i,
    queryObject: a,
    createMessage: s?.createMessage,
    allowUsingObjectIdStat: s?.allowUsingObjectIdStat,
    errorStrings: o
  }), d;
  if (u.valid) {
    const m = L.gauge, g = Number.isFinite(i?.innerRadius) ? i?.innerRadius : m.innerRadius, h = Number.isFinite(i?.startAngle) ? i?.startAngle : m.startAngle, y = Number.isFinite(i?.endAngle) ? i?.endAngle : m.endAngle;
    l.radius = ot(m.radius), typeof g == "number" && (l.innerRadius = ot(g)), typeof h == "number" && (l.startAngle = h), typeof y == "number" && (l.endAngle = y);
    const p = await ol({
      chartConfig: i,
      chart: l,
      queryObject: a,
      options: s,
      globalOptions: r,
      utilsStrings: n,
      errorStrings: o
    });
    d = p.chartElements, u = p.validationStatus ?? u, j(l.uid, { config: Ge(i) });
  }
  return $m(l), ea(u, l.htmlContainer), { chart: l, chartElements: d };
}
async function PA(t) {
  let { newConfig: e } = t;
  const { chart: i, chartElements: a, options: o, queryObject: n, forceDataUpdate: s, utilsStrings: r, errorStrings: l } = t, { createMessage: c, chartLimits: u, guideTooltipFormatter: d } = o ?? {};
  vn(i);
  const m = await va({
    chart: i,
    chartConfig: e,
    queryObject: n,
    createMessage: c,
    allowUsingObjectIdStat: o?.allowUsingObjectIdStat,
    errorStrings: l
  });
  if (rv(a.loaderElements, o), m.valid && e !== void 0) {
    a.loaderHandle.showLoader(o?.hideLoaderAnimation !== !0);
    const h = I(i.uid, "seriesFilteredOut"), y = I(i.uid, "unfilteredConfig"), p = I(i.uid, "config"), S = p?.series, x = e.series, C = z(x), v = Rt({ config: e });
    j(i.uid, { config: Ge(e), isRotated: v });
    const { dataUpdateNeeded: F, updateNeededDetails: T } = Nn({
      options: o,
      forceDataUpdate: s,
      oldConfig: h ? y : p,
      newConfig: e,
      formerFilterBySelection: I(i.uid, "filterBySelection"),
      timeIntervalInfo: I(i.uid, "timeIntervalInfo"),
      currentSelectionDataItems: I(i.uid, "currentSelectionDataItems"),
      currentSelectionOIDs: I(i.uid, "currentSelectionOIDs"),
      currentSelectionIndexes: I(i.uid, "computedSelectionIndexes"),
      fieldList: I(i.uid, "fieldList")
    });
    j(i.uid, { filterBySelection: o?.filterBySelection }), ds({ chart: i, actionMode: o?.actionMode, cursorRange: o?.cursorRange });
    const { xOrYChanged: k } = T.common;
    let { numberOfSeriesChanged: $ } = T.common;
    const O = yd(p, e), D = pd(p, e), R = kg(p, e), M = Ig(p, e), N = JSON.stringify(gl(S)) !== JSON.stringify(gl(x)), E = wg(p, e), V = $g(p, e), W = nr(p, e), H = sr({
      oldConfig: h ? y : p,
      newConfig: e,
      dataUpdateNeeded: F
    }), Z = Sd({
      oldConfig: p,
      newConfig: e,
      rotationChanged: D
    }), oe = Sm({
      chart: i,
      dualAxisChanged: R,
      rotationChanged: D,
      timeIntervalInfoWasReset: O,
      axisLabelsBehaviorChanged: Z
    });
    let ie = !1, X, q, Fe = C !== b.BarSeries && C !== b.LineSeries && C !== b.ComboLineAndBarSeries && C !== b.HistogramSeries;
    const Jt = U(x);
    if (j(i.uid, { isNonAggregatedChart: !Pn(Jt) }), F) {
      (s === !0 || Dg(T)) && j(i.uid, { binnedServerData: void 0 });
      const {
        count: Be,
        valid: Ve,
        invalidType: pe,
        data: it,
        binnedServerData: It,
        queryConfig: oa
      } = await ja({
        chartConfig: e,
        queryObject: n,
        abortKey: Po(i),
        currentSelectionOIDs: I(i.uid, "currentSelectionOIDs"),
        currentSelectionDataItems: I(i.uid, "currentSelectionDataItems"),
        binnedServerData: I(i.uid, "binnedServerData"),
        options: o,
        errorStrings: l
      });
      j(i.uid, {
        elementCount: Be,
        initialized: Ve,
        binnedServerData: It,
        queryConfig: oa,
        boxPlotMeanLinesData: it?.meanLines,
        timeIntervalInfo: it?.timeIntervalInfo,
        serverLimitReached: it?.serverLimitReached,
        trendLineData: {
          r2: it?.r2,
          trendLinePoints: it?.trendLinePoints
        }
      }), Fe = Ve, Fe ? (vn(i), X = it, q = $i(X)) : (await da({
        chart: i,
        invalidType: pe,
        elementCount: Be,
        seriesCount: x.length,
        chartConfig: e,
        errorStrings: l
      }), a.loaderHandle.hideLoader());
    } else if (C === b.BarSeries || C === b.LineSeries || C === b.RadarSeries || C === b.ComboLineAndBarSeries || C === b.BoxPlotSeries) {
      const Be = I(i.uid, "elementCount");
      if (Be !== void 0 && (Fe = rg({
        count: Be,
        seriesCount: x.length,
        chartType: C,
        chartLimits: u
      })), Fe) {
        const Ve = xd(S, x);
        if (Ve.length > 0 && (CC(i.series, Ve), i.feedLegend(), ie = !0), lg(x[0])) {
          const { binTemporalData: pe } = x[0], { unit: it, size: It } = x[0].temporalBinning ?? {};
          pe === !1 && it !== void 0 && It !== void 0 && j(i.uid, { timeIntervalInfo: { unit: it, size: It } });
        }
      } else {
        let Ve;
        switch (C) {
          case b.BarSeries:
          case b.ComboLineAndBarSeries:
            Ve = bi.BarElementExceedsLimit;
            break;
          case b.LineSeries:
            Ve = bi.LineChartExceedsLimit;
            break;
          case b.BoxPlotSeries:
            Ve = bi.BoxPlotExceedsLimit;
            break;
        }
        await da({
          chart: i,
          invalidType: Ve,
          elementCount: Be,
          seriesCount: x.length,
          chartConfig: e,
          errorStrings: l
        }), a.loaderHandle.hideLoader();
      }
    }
    H && (Ga({
      arrayToSort: F ? q ?? i.data : i.data,
      chartConfig: e,
      fieldList: I(i.uid, "fieldList"),
      isTimeBinningSeries: Ha({
        seriesConfig: Uc(e),
        xAxisValueFormatType: Bn(e),
        setTimeBinningInfoWhenNotProvided: o?.setTimeBinningInfoWhenNotProvided
      })
    }), C === b.BoxPlotSeries && lm({
      chart: i,
      chartData: F ? q ?? i.data : i.data,
      chartConfig: e
    }), F || (i.validateData(), C === b.BoxPlotSeries && i.series.each((Be) => {
      Be instanceof ue && !(Be instanceof vt) && Be.id.includes(me.Outliers) && Be.validateData();
    })));
    const gi = F && X && "bins" in X ? X : void 0, Ue = X && "trendLinePoints" in X ? X : I(i.uid, "trendLineData");
    X = {
      dataItems: F ? q ?? i.data : i.data,
      timeIntervalInfo: I(i.uid, "timeIntervalInfo"),
      serverLimitReached: I(i.uid, "serverLimitReached"),
      meanLines: I(i.uid, "boxPlotMeanLinesData"),
      outliers: F ? X?.outliers : i.series.values.find((Be) => !(Be instanceof vt) && Be instanceof ue)?.data,
      trendLinePoints: Ue?.trendLinePoints,
      r2: Ue?.r2,
      ...gi
    }, (F || H) && xi({ data: X, seriesConfig: e.series, htmlContainer: i.htmlContainer });
    const La = /* @__PURE__ */ new Map();
    e.series.forEach((Be, Ve) => {
      La.set(Be.id, Ve);
    });
    const Fa = Qi({ chartConfig: e, queryObject: n });
    if (!F || Fe) {
      const Be = qe(e), Ve = Im({
        chart: i,
        data: Be ? X : q,
        config: e,
        hideEmptySeries: o?.hideEmptySeries ?? L.options.hideEmptySeries
      });
      if (e = Ve.updatedConfig, $ = Ve.seriesFilteredOut, (F || W) && C !== b.HistogramSeries) {
        const it = qe(e), It = X && it && "meanLines" in X ? X.meanLines : q ?? i.data, { colorMatchApplied: oa, rendererFieldNames: Aa } = await qa({
          data: It,
          queryObject: n,
          chartConfig: e,
          allowColorMatch: Fa
        });
        j(i.uid, { colorMatchApplied: oa, rendererFieldNames: Aa });
      }
      q !== void 0 && (i.data = q), e.axes !== void 0 && await il({
        chart: i,
        chartConfig: e,
        rotationChanged: D,
        timeIntervalInfoWasReset: O,
        axisLabelsBehaviorChanged: Z,
        chartType: C,
        isRotated: v,
        dualAxisChanged: R,
        guideTooltipFormatter: d,
        xAxisLabelFormatter: o?.xAxisLabelFormatter,
        yAxisLabelFormatter: o?.yAxisLabelFormatter,
        secondaryYAxisLabelFormatter: o?.secondaryYAxisLabelFormatter,
        utilsStrings: r,
        errorStrings: l
      });
      const pe = C === b.BoxPlotSeries && (Og(x, S) || Rg(x, S));
      (i.series === void 0 || i.series.length === 0 || k || $ || Ve.seriesFilteredOut || N || (C === b.BarSeries || C === b.LineSeries || C === b.RadarSeries || C === b.ComboLineAndBarSeries) && i.series.length !== e.series.length || C !== b.HistogramSeries && oe || M || // NOTE: This fix is here to resolve the issue: https://devtopia.esri.com/webgis/arcgis-charts/issues/6537
      // TODO: find a better way to order legends for box plot with split by field rather than re-initializing the series in the future.
      pe || T.boxPlot.showMeanChanged) && (!F && (D || pe || oe) && i.invalidateData(), await wm({
        chart: i,
        chartConfig: e,
        hideLoaderHandle: a.loaderHandle.hideLoader,
        utilsStrings: r,
        queryObject: n,
        options: o
      })), await al({
        chart: i,
        chartConfig: e,
        seriesIndexMapper: La,
        rotationChanged: D,
        seriesReordered: ie,
        outliersVisibilityChanged: E,
        standardizeValuesVisibilityChanged: V,
        queryObject: n,
        chartData: X,
        options: o,
        dataWasUpdated: F,
        sortChanged: H,
        utilsStrings: r,
        errorStrings: l
      }), ls(a.headerElements, { title: e.title, subtitle: e.subtitle }), cs(a.footerElements, e.footer), Yr({
        legendElements: a.legendElements,
        seriesConfig: e.series,
        webChartLegend: e.legend,
        disableTogglingLegendItems: o?.disableTogglingLegendItems
      }), rs(i, e.background), Lm({
        chart: i,
        scrollbarXConfig: e.axes?.[0]?.scrollbar,
        scrollbarYConfig: e.axes?.[1]?.scrollbar
      });
    }
    Vo(i.series) && (a.loaderHandle.hideLoader(), Ua(i.htmlContainer));
  }
  ea(m, i.htmlContainer), Nf(i, e?.cursorCrosshair);
  const g = RC(i);
  (g.behavior === fe.SelectX || g.behavior === fe.SelectXY || g.behavior === fe.SelectY || g.behavior === fe.None) && i.scrollbarX.start === 0 && i.scrollbarX.end === 1 && i.scrollbarY.start === 0 && i.scrollbarY.end === 1 && _r(i), km(i), ym(i.series.values[0]);
}
async function VA(t) {
  const { chart: e, chartElements: i, newConfig: a, queryObject: o, forceDataUpdate: n, options: s, utilsStrings: r, errorStrings: l } = t;
  vn(e);
  let c = await va({
    chart: e,
    chartConfig: a,
    queryObject: o,
    createMessage: s?.createMessage,
    allowUsingObjectIdStat: s?.allowUsingObjectIdStat,
    errorStrings: l
  });
  if (c.valid && a !== void 0) {
    i.loaderHandle.showLoader(s?.hideLoaderAnimation !== !0);
    const u = I(e.uid, "config"), d = u?.series, m = a?.series, { dataUpdateNeeded: g } = Nn({
      forceDataUpdate: n,
      oldConfig: u,
      newConfig: a,
      options: s,
      formerFilterBySelection: I(e.uid, "filterBySelection"),
      currentSelectionDataItems: I(e.uid, "currentSelectionDataItems"),
      currentSelectionOIDs: I(e.uid, "currentSelectionOIDs"),
      currentSelectionIndexes: I(e.uid, "currentSelectionIndexes")
    }), h = nr(u, a), y = sr({ oldConfig: u, newConfig: a, dataUpdateNeeded: g });
    j(e.uid, { filterBySelection: s?.filterBySelection, config: Ge(a) });
    let p = !0, S, x, C = !1;
    if (g) {
      const {
        count: v,
        valid: F,
        invalidType: T,
        data: k,
        queryConfig: $
      } = await ja({
        chartConfig: a,
        currentSelectionDataItems: I(e.uid, "currentSelectionDataItems"),
        currentSelectionOIDs: I(e.uid, "currentSelectionOIDs"),
        options: s,
        queryObject: o,
        abortKey: Po(e),
        errorStrings: l
      });
      S = k, j(e.uid, { elementCount: v, queryConfig: $, initialized: F }), p = F, x = $i(S), p ? x !== void 0 && Tg(e.data, x) && (e.data = x, C = !0) : (await da({
        chart: e,
        invalidType: T,
        elementCount: v,
        seriesCount: m.length,
        errorStrings: l
      }), i.loaderHandle.hideLoader());
    }
    if (!C || p) {
      if (g || h) {
        const M = await qa({
          data: x ?? e.data,
          queryObject: o,
          chartConfig: a,
          allowColorMatch: Qi({ chartConfig: a, queryObject: o })
        });
        e.data = M.dataItems, j(e.uid, {
          colorMatchApplied: M.colorMatchApplied,
          rendererFieldNames: M.rendererFieldNames
        });
      }
      const v = Bd(d, m);
      (C || v) && Am({ chart: e, seriesConfig: m, utilsStrings: r }), (y || v) && (Ga({
        arrayToSort: x ?? e.data,
        chartConfig: a,
        fieldList: I(e.uid, "fieldList")
      }), e.validateData());
      const F = Ts({ oldConfig: u, newConfig: a }), T = bd(u, a);
      let k = await Qr({
        chart: e,
        chartConfig: a,
        queryObject: o,
        labelUpdateNeeded: C || F || h || T,
        usePopupTemplateFieldsInfo: s?.usePopupTemplateFieldsInfo,
        utilsStrings: r
      });
      (C || y) && (xi({
        data: { dataItems: e.data },
        seriesConfig: a.series,
        htmlContainer: e.htmlContainer
      }), Cd({ data: e.data, chartConfig: a, htmlContainer: e.htmlContainer }));
      const $ = await el({
        chart: e,
        data: { dataItems: e.data },
        chartConfig: a,
        pieSlicesSymbols: k,
        queryObject: o,
        options: s,
        currentValidationStatus: c,
        utilsStrings: r,
        errorStrings: l
      });
      c = $.newValidationStatus ?? c;
      const { alteredPieSlicesSymbols: O, alteredConfig: D } = $;
      k = O;
      const R = Ts({
        oldConfig: a,
        newConfig: D
      });
      (g || F || R || h || T) && Wn({
        data: e.data,
        newChartConfig: D,
        pieSlicesSymbols: k,
        fieldList: I(e.uid, "fieldList")
      }), Bt({
        data: k,
        htmlContainer: e.htmlContainer,
        chartId: e.id,
        colorMatchApplied: Sa(e, D)
      }), await al({
        chart: e,
        queryObject: o,
        chartConfig: D,
        seriesIndexMapper: /* @__PURE__ */ new Map(),
        // pie chart won't use this
        options: s,
        dataWasUpdated: C,
        sortChanged: y,
        chartData: S,
        groupOfSlicesWasUpdated: v,
        pieSlicesSymbols: k,
        utilsStrings: r,
        errorStrings: l
      }), ls(i.headerElements, {
        title: D.title,
        subtitle: D.subtitle
      }), cs(i.footerElements, D.footer), Yr({
        legendElements: i.legendElements,
        seriesConfig: D.series,
        webChartLegend: D.legend,
        disableTogglingLegendItems: s?.disableTogglingLegendItems,
        pieChartLegendValueLabelFormatter: s?.pieChartLegendValueLabelFormatter
      }), rs(e, D.background), ds({ chart: e, actionMode: s?.actionMode, cursorRange: s?.cursorRange }), Tm(e);
    }
    Vo(e.series) && (i.loaderHandle.hideLoader(), Ua(e.htmlContainer));
  }
  ea(c, e.htmlContainer);
}
async function EA(t) {
  const { chart: e, chartElements: i, newConfig: a, queryObject: o, forceDataUpdate: n, options: s, utilsStrings: r, errorStrings: l } = t, { createMessage: c, hideLoaderAnimation: u, xAxisLabelFormatter: d, gaugeInnerLabelFormatter: m, guideTooltipFormatter: g } = s ?? {};
  vn(e);
  let h = await va({
    chart: e,
    chartConfig: a,
    queryObject: o,
    createMessage: c,
    allowUsingObjectIdStat: s?.allowUsingObjectIdStat,
    errorStrings: l
  });
  if (h.valid && a !== void 0) {
    i.loaderHandle.showLoader(u !== !0);
    const y = I(e.uid, "config"), p = a.series, S = z(p), { dataUpdateNeeded: x } = Nn({ forceDataUpdate: n, oldConfig: y, newConfig: a });
    let C;
    if (x) {
      const {
        count: T,
        valid: k,
        invalidType: $,
        data: O,
        queryConfig: D
      } = await ja({
        chartConfig: a,
        queryObject: o,
        options: s,
        abortKey: Po(e),
        errorStrings: l
      });
      C = O, C?.dataItems !== void 0 && (e.data = C.dataItems), xi({
        data: { dataItems: e.data },
        seriesConfig: a.series,
        htmlContainer: e.htmlContainer
      }), j(e.uid, { elementCount: T, queryConfig: D, initialized: k }), k || (await da({
        chart: e,
        invalidType: $,
        elementCount: T,
        seriesCount: 1,
        errorStrings: l
      }), i.loaderHandle.hideLoader());
    }
    const v = await el({
      chart: e,
      data: { dataItems: e.data },
      chartConfig: a,
      queryObject: o,
      options: s,
      currentValidationStatus: h,
      utilsStrings: r,
      errorStrings: l
    });
    h = v.newValidationStatus ?? h;
    const F = v.alteredConfig;
    if (h.valid) {
      F.axes !== void 0 && await il({
        chart: e,
        chartConfig: F,
        chartType: S,
        data: C,
        queryObject: o,
        xAxisLabelFormatter: d,
        gaugeInnerLabelFormatter: m,
        guideTooltipFormatter: g,
        utilsStrings: r,
        errorStrings: l
      });
      const T = L.gauge, k = Number.isFinite(F?.innerRadius) ? F.innerRadius : T.innerRadius, $ = Number.isFinite(F?.startAngle) ? F.startAngle : T.startAngle, O = Number.isFinite(F?.endAngle) ? F.endAngle : T.endAngle;
      e.innerRadius = ot(k), e.startAngle = $, e.endAngle = O, ls(i.headerElements, {
        title: F.title,
        subtitle: F.subtitle
      }), cs(i.footerElements, F.footer), rs(e, F.background), j(e.uid, { config: Ge(F) }), i.loaderHandle.hideLoader(), Ua(e.htmlContainer);
    }
  }
  ea(h, e.htmlContainer);
}
async function zA(t) {
  const { chartContainer: e, chartConfig: i, queryObject: a, t9nStrings: o, options: n, globalOptions: s } = t, { errorStrings: r, utilsStrings: l } = o;
  lo.commercialLicense = s?.hideLicenseWatermark !== !1, lo.queue = s?.queueChartCreation !== !1, lo.autoDispose = s?.autoDisposeChart === !0, s?.useAnimatedCharts === !0 ? nh(Sl) : sh(Sl);
  let c;
  switch (z(i?.series)) {
    case b.PieSeries:
      c = await MA({
        chartContainer: e,
        chartConfig: i,
        queryObject: a,
        options: n,
        globalOptions: s,
        utilsStrings: l,
        errorStrings: r
      });
      break;
    case b.GaugeSeries:
      c = await NA({
        chartContainer: e,
        chartConfig: i,
        queryObject: a,
        options: n,
        globalOptions: s,
        utilsStrings: l,
        errorStrings: r
      });
      break;
    default:
      c = await BA({
        chartContainer: e,
        chartConfig: i,
        queryObject: a,
        options: n,
        globalOptions: s,
        t9nStrings: o
      });
      break;
  }
  return c;
}
async function WA(t) {
  const { chartContainer: e, chartConfig: i, t9nStrings: a, options: o, globalOptions: n } = t, { errorStrings: s } = a, { layer: r, view: l } = o ?? {}, c = !Sc(e);
  let u;
  i !== void 0 && (hi(i) ? u = i : u = sn({ chartConfig: i, queryObject: r })), u = await an(u, r);
  let d;
  u && (hi(u) || r !== void 0) && (d = await bo({ chartConfig: u, layer: r, view: l }));
  const m = await zA({
    chartContainer: e,
    chartConfig: u,
    queryObject: d,
    t9nStrings: a,
    options: o,
    globalOptions: n
  }), { chart: g, chartElements: h } = m;
  IA(g, s), j(g.uid, {
    chartWasCreatedWhileHidden: c,
    queryObject: d,
    filterBySelection: o?.filterBySelection,
    options: o
  }), TA(g, e), await Cc({ chart: g, chartConfig: u, errorStrings: s }), await vc(g, s);
  function y() {
    sg.delete(Po(g)), g.isDisposed() || (NC(g), h !== void 0 && (h.loaderHandle.hideLoader(), m.chartElements = void 0), g.dispose());
  }
  async function p(T) {
    const { newConfig: k, forceDataUpdate: $, updateOptions: O } = T, { utilsStrings: D } = T, R = I(g.uid, "initialized"), M = I(g.uid, "config"), N = k?.series, E = N !== void 0 ? z(N) : void 0;
    if (g.isDisposed() || h === void 0 || R === !1 || !gd(M, k))
      throw new wn(ro.ChartDisposed);
    switch (E) {
      case b.BoxPlotSeries:
      case b.BarSeries:
      case b.LineSeries:
      case b.ComboLineAndBarSeries:
      case b.ScatterSeries:
      case b.HistogramSeries:
        await PA({
          chart: g,
          chartElements: h,
          queryObject: d,
          newConfig: k,
          forceDataUpdate: $,
          options: O,
          utilsStrings: D,
          errorStrings: s
        });
        break;
      case b.PieSeries:
        await VA({
          chart: g,
          chartElements: h,
          queryObject: d,
          forceDataUpdate: $,
          newConfig: k,
          options: O,
          utilsStrings: D,
          errorStrings: s
        });
        break;
      case b.GaugeSeries:
        await EA({
          chart: g,
          chartElements: h,
          newConfig: k,
          queryObject: d,
          forceDataUpdate: $,
          options: O,
          utilsStrings: D,
          errorStrings: s
        });
        break;
    }
  }
  async function S(T) {
    const { layerUpdate: k, newConfig: $, viewUpdate: O } = T;
    $ && (k !== void 0 || hi($)) && (d = await bo({ layer: k, view: O, chartConfig: $ }), j(g.uid, { queryObject: d }));
  }
  async function x(T) {
    const { newChartConfig: k, updateOptions: $, updateGlobalOptions: O, t9nStrings: D } = T, { errorStrings: R, utilsStrings: M } = D;
    e == null && await fa("divNode", R);
    const { layer: N, view: E, dataUpdated: V } = $ ?? {}, W = !Sc(e), H = await qt(d, o?.usePopupTemplateFieldsInfo);
    j(g.uid, { chartWasUpdatedWhileHidden: W, options: $, fieldList: H });
    let Z;
    hi(k) ? Z = k : k !== void 0 && (Z = sn({ chartConfig: k, queryObject: N })), Z = await an(Z, N);
    const oe = rn(d);
    await S({ layerUpdate: N, newConfig: Z, viewUpdate: E });
    const ie = I(g.uid, "config");
    ie !== void 0 && hd(ie, Z) && (Z = Mn(Z, g.htmlContainer));
    const X = rn(d);
    await p({
      newConfig: Z,
      updateOptions: $,
      forceDataUpdate: V === !0 || oe !== X,
      utilsStrings: M
    }), await Cc({ chart: g, chartConfig: Z, errorStrings: R }), await vc(g, R);
  }
  async function C() {
    if (kt(g) && (g instanceof ne || g instanceof Le)) {
      const T = I(g.uid, "actionMode");
      T !== K.MonoSelection && T !== K.None && await JC(g);
    }
  }
  function v(T, k, $) {
    g.modal !== void 0 && !g.isDisposed() && (g.modal.closable = $?.closable ?? !1, T !== void 0 ? (g.modal.events.once(B.Opened, () => {
      const O = g.modal?.elements?.title?.parentElement;
      O instanceof HTMLElement && g.modal?.elements?.title?.innerText.length === 0 && (O.style.visibility = "hidden");
    }), g.openModal(T, k)) : g.closeModal());
  }
  function F() {
    _r(g);
  }
  return {
    update: x,
    dispose: y,
    notify: v,
    resetZoom: F,
    clearSelection: () => ao({ chart: g }),
    switchSelection: C,
    exportImage: async (T) => await PC({ chart: g, exportOptions: T }),
    setActionMode: (T, k) => ds({ chart: g, actionMode: T, cursorRange: k })
  };
}
function HA(t, e) {
  let i;
  switch (t) {
    case b.PieSeries:
      i = e?.placeholders.pieChartCreateMsg;
      break;
    case b.BarSeries:
      i = e?.placeholders.barChartCreateMsg;
      break;
    case b.BoxPlotSeries:
      i = e?.placeholders.boxPlotCreateMsg;
      break;
    case b.LineSeries:
      i = e?.placeholders.lineChartCreateMsg;
      break;
    case b.HistogramSeries:
      i = e?.placeholders.histogramCreateMsg;
      break;
    case b.ScatterSeries:
      i = e?.placeholders.scatterplotCreateMsg;
      break;
  }
  return i;
}
function GA() {
  return !0;
}
async function Lc(t) {
  const { layer: e } = t;
  let i;
  if (e !== void 0 && t.layerFilterChangePolicy === Zo.Refresh) {
    const a = pt(e), o = qs(a);
    i = pi.watch(
      () => o.definitionExpression,
      async () => {
        await t.refresh({ updateData: !0, resetAxesBounds: !0 });
      }
    );
  }
  return i;
}
async function Fc(t) {
  const { layer: e, model: i } = t, a = xo(i) ? i.config : i;
  let o;
  if (e !== void 0 && t.layerRendererChangePolicy === Ko.Refresh) {
    const n = pt(e);
    o = pi.watch(
      () => n.renderer,
      async () => {
        if (Ii(a)) {
          const s = GA();
          await t.refresh({ updateData: s });
        }
      }
    );
  }
  return o;
}
async function XA(t) {
  const { view: e, layer: i, model: a } = t, o = xo(a) ? a.config : a;
  let n;
  if (e !== void 0 && o !== void 0) {
    const s = await bo({ chartConfig: o, view: e, layer: i });
    if (_s(s)) {
      await pi.whenOnce(() => !s.updating);
      const r = async () => {
        e.stationary && (s.updating && await pi.whenOnce(() => !s.updating), await t.refresh({ updateData: !0, resetAxesBounds: !0 }));
      };
      n = [], n.push(pi.when(() => e.stationary, r)), n.push(pi.when(() => !s.dataUpdating, r)), await r();
    }
  }
  return n;
}
async function YA(t) {
  const { view: e, model: i } = t, a = xo(i) ? i.config : i, o = z(a?.series);
  let n;
  return e !== void 0 && t.viewTimeExtentChangePolicy === no.Refresh && o !== b.HistogramSeries && (n = pi.watch(
    () => e.timeExtent,
    async () => {
      await t.refresh({ updateData: !0 });
    }
  )), n;
}
async function Ac(t) {
  const { layer: e } = t;
  let i;
  if (e !== void 0 && t.layerFieldsChangePolicy === Qo.Refresh) {
    const a = pt(e), o = qs(a);
    i = pi.watch(
      /**
       * array objects need to be passed in as an array to watch. it's a requirement from the watch function's design.
       *       https://developers.arcgis.com/javascript/latest/api-reference/esri-core-reactiveUtils.html#watch
       */
      () => [o.fields],
      async () => {
        await t.refresh({ updateData: !0 });
      }
    );
  }
  return i;
}
async function Tc(t) {
  const { view: e } = t;
  let i;
  return e !== void 0 && "selectionManager" in e && "selections" in e.selectionManager && (i = pi.watch(
    // TODO: remove the as any ->  @arcgis/core issue - https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/62859#issuecomment-5394936
    () => e.selectionManager.selections,
    (a) => {
      t.syncSelectionsBetweenChartAndLayerViewPolicy === Jo.Enabled && (Array.isArray(a) && a?.length === 0 ? t.clearSelection() : t.applySelectionFromView());
    }
  )), i;
}
const UA = ({ message: t, heading: e, options: i }) => _o`<calcite-alert .icon=${i?.icon ?? "exclamationMarkTriangle"} .open=${i?.active === !0} .autoClose=${i?.autoClose ?? !1} .autoCloseDuration=${i?.duration ?? "medium"} scale=m .kind=${i?.kind ?? "danger"} .ariaHidden=${i?.active !== !0} dir=ltr role=alertdialog label="arcgis charts notify panel">${e !== void 0 ? _o`<div slot=title>${e}</div>` : null}${t !== void 0 ? _o`<div slot=message>${t}</div>` : null}</calcite-alert>`, jA = Vm`.hide{display:none}.am5-modal{width:100%;height:100%;position:absolute;z-index:100000;top:0;left:0}.am5-modal-curtain{top:0;left:0;width:100%;height:100%;position:absolute;background:#fff!important;z-index:100}.am5-modal-wrapper{top:0;left:0;width:100%;height:100%;position:absolute;display:flex;align-items:center;justify-content:center;white-space:nowrap;background:#ffffff80;z-index:101}.am5-modal-content{display:inline-block;padding:1.2em;vertical-align:middle;text-align:start;white-space:normal;background:#fff;border-radius:4px;box-shadow:#00000073 0 0 36px;color:#000}.am5-layer-1000{z-index:1000!important}.am5-layer-30{z-index:100!important}.arcgis-charts-modal{box-shadow:none!important}.arcgis-charts-modal-header{background-color:#0000000d;font-weight:700;padding:4px;align-content:center}.show{display:block}.notifyPanel{flex:0 1 auto}.disable-interactions{pointer-events:none}.dim-text{color:var(--arcgis-charts-dim-text)}.chart{flex-grow:1;overflow-y:hidden}.chart>div{justify-content:center;align-items:center}.chart .arcgis-charts-modal-inside{padding:1em 1em 1em 0}.chart .arcgis-charts-modal-inside ol{padding-left:2em}.chart .arcgis-charts-modal-curtain{width:100%;height:100%;position:absolute;top:0;left:0;z-index:2001;background-color:#fff;opacity:.5;opacity:1}.chart .arcgis-charts-modal-content{background:#fffc;color:#000;display:inline-block;top:0;left:0;overflow:visible;z-index:2002;position:absolute;max-width:90%;max-height:90%;width:auto!important;height:auto!important;margin:auto!important;inset:auto!important}.chart .arcgis-charts-modal-header{display:block;width:100%;min-height:1.8em;background:#0000000d}.chart .arcgis-charts-modal-close{display:block;position:absolute;top:.3em;right:.3em;background:url(data:image/svg+xml;charset=utf-8;base64,PHN2ZyBoZWlnaHQ9IjUxMiIgdmVyc2lvbj0iMSIgdmlld0JveD0iMCAwIDUxMiA1MTIiIHdpZHRoPSI1MTIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTQ0NS4yIDEwOS4ybC00Mi40LTQyLjRMMjU2IDIxMy42IDEwOS4yIDY2LjhsLTQyLjQgNDIuNEwyMTMuNiAyNTYgNjYuOCA0MDIuOGw0Mi40IDQyLjRMMjU2IDI5OC40bDE0Ni44IDE0Ni44IDQyLjQtNDIuNEwyOTguNCAyNTYiLz48L3N2Zz4=) center center/80% no-repeat #6464641a;width:1.2em;height:1.2em;cursor:pointer}.chart .arcgis-charts-modal-title{font-weight:700;font-size:110%;padding:.5em 1.2em .5em 1em}:host{width:var(--chart-width, var(--arcgis-charts-default-width));height:var(--chart-height, var(--arcgis-charts-default-height));display:flex;flex-direction:row}`;
class qA extends Mm {
  constructor() {
    super(), this._messages = Cl(), this.chartRef = Em(), this.commonStrings = Cl({ name: "common", blocking: !0 }), this.dataUpdateNeededProps = [
      "forceDataUpdate",
      "runtimeDataFilters",
      "returnFeaturesExtent",
      "chartLimits"
    ], this.updatedProps = /* @__PURE__ */ new Set(), this._showNotifyPanel = !1, this.handleExternalSelection = (e) => {
      const i = e, { selectionData: a, model: o } = i.detail, n = this.layer && o?.layer?.id === Ho(this.layer).id;
      this.syncSelection && n && e.target !== this.el && !fo(a.selectionOIDs, this.selectionData?.selectionOIDs) && (a.selectionOIDs ? (this.selectionData = {
        selectionOIDs: a.selectionOIDs,
        selectionSource: Ne.ProgrammaticSelection
      }, this.arcgisSelectionComplete.emit({ selectionData: this.selectionData, model: this._model })) : this.clearSelection());
    }, this.configPanelNumberChange = (e) => {
      const i = e, { panelNumber: a, modelList: o } = i.detail;
      this.actionBarElement && this.enableConfiguration && this.ourModelExistsIn(o) && (this.actionBarElement.editChartToggle = a === 1 ? vl.Active : vl.Inactive);
    }, this.configDataChangeError = (e) => {
      const i = e, { error: a, model: o } = i.detail;
      this.enableConfiguration && o?.isSameChartAs(this._model) && this.errorAlert(a.message);
    }, this.configPopoverOpenChange = (e) => {
      const i = e;
      this.useBetaChart() || (this.disableInteractions = i.detail.open);
    }, this.modelConfigChange = async (e) => {
      const i = e;
      this.lastModelSetterCalled = i.detail.setterName;
      const a = this._model?.config;
      this.enableConfiguration && oo(a) && (await this.applyPlaceholderForPartialConfig(a), this.arcgisConfigChange.emit({
        newConfig: a,
        oldConfig: this.config,
        functionCalled: i.detail.setterName
      })), this.config = Ge(a);
    }, this.actionBarSlotRef = (e) => {
      this.actionBarElement = e && "assignedElements" in e ? e.assignedElements().find((i) => i.tagName.toLowerCase() === "arcgis-charts-action-bar") : void 0;
    }, this.isWarningDisplayed = !1, this.enableBetaFeatures = !1, this.enableConfiguration = !1, this.syncSelection = !1, this.allowUsingObjectIdStat = !1, this.nullAsValid = !1, this.errorPolicy = Go.Throw, this.layerFilterChangePolicy = Zo.Refresh, this.viewTimeExtentChangePolicy = no.Ignore, this.layerRendererChangePolicy = Ko.Refresh, this.layerFieldsChangePolicy = Qo.Refresh, this.syncSelectionsBetweenChartAndLayerViewPolicy = Jo.Disabled, this.arcgisAxesMinMaxChange = St(), this.arcgisBadDataWarningRaise = St(), this.arcgisChartNotFoundWarning = St(), this.arcgisConfigChange = St(), this.arcgisDataFetchComplete = St(), this.arcgisDataProcessComplete = St(), this.arcgisDataProcessError = St(), this.arcgisLegendItemVisibilityChange = St(), this.arcgisNoRenderPropChange = St(), this.arcgisRuntimeError = St(), this.arcgisSelectionComplete = St(), this.arcgisSeriesColorChange = St(), this.arcgisSeriesOrder = St(), this.arcgisUpdateComplete = St(), this.listen("arcgisChartsJSDataProcessComplete", this.handleDataProcessComplete), this.listen("arcgisChartsJSDataFetchComplete", this.handleDataFetchComplete), this.listen("arcgisChartsJSLegendItemVisibilityChange", this.handleLegendItemVisibilityChanged), this.listen("arcgisChartsJSUpdateComplete", this.handleUpdateCompleted), this.listen("arcgisChartsJSBadDataWarningRaise", this.handleBadDataWarningRaise), this.listen("arcgisChartsJSSeriesColorChange", this.handleSeriesColorsChange), this.listen("arcgisChartsJSSelectionComplete", this.handleSelection), this.listen("arcgisChartsJSTooManySelectedElements", this.handleTooManySelectedElements), this.listen("calciteAlertClose", this.handleAlertClosed), this.listen("arcgisChartsJSAxesMinMaxChange", this.handleAxesMinMaxChange), this.listen("arcgisChartsJSSeriesOrder", this.handleSeriesOrder);
  }
  static {
    this.properties = { isWarningDisplayed: 16, showNotifyPanel: [16, { hasChanged: (e) => e }], config: 16, enableBetaFeatures: 5, model: 0, enableConfiguration: 7, syncSelection: 7, rotation: [7, { hasChanged: () => !1 }], actionMode: 3, cursorRange: 3, legendPosition: [3, { hasChanged: () => !1 }], legendVisibility: [7, { hasChanged: () => !1 }], allowUsingObjectIdStat: 7, nullAsValid: 7, showUIMessages: 7, hideEmptySeries: 7, autoInverseDataLabelTextColor: 5, replaceNoValueCategoryWithZero: 7, ignoreSmoothRenderingLimit: 7, chartWillRender: 0, legendValueLabelFormatter: 0, timeZone: 3, view: [0, { hasChanged: () => !1 }], layer: 0, layerItemId: 3, chartIndex: 11, selectionData: 0, returnSelectionOIDs: 7, returnSelectionIndexes: 7, returnFeaturesExtent: 7, filterBySelection: 7, filterByExtent: [7, { hasChanged: () => !1 }], disableInteractions: [7, { hasChanged: () => !1 }], queueChartCreation: 7, useAnimatedCharts: 7, hideLicenseWatermark: 7, enableResponsiveFeatures: 7, autoDisposeChart: 7, featureIndex: [11, { hasChanged: () => !1 }], placeholder: 3, selectionTheme: 0, setTimeBinningInfoWhenNotProvided: 7, chartLimits: 0, tooltipFormatter: 0, dataLabelFormatter: 0, guideTooltipFormatter: 0, xAxisLabelFormatter: 0, yAxisLabelFormatter: 0, secondaryYAxisLabelFormatter: 0, gaugeInnerLabelFormatter: 0, errorPolicy: 3, disableTogglingLegendItems: 7, hideLoaderAnimation: 7, loaderColors: 0, runtimeDataFilters: 0, usePopupTemplateFieldsInfo: 7, layerFilterChangePolicy: 3, viewTimeExtentChangePolicy: 3, layerRendererChangePolicy: 3, layerFieldsChangePolicy: 3, syncSelectionsBetweenChartAndLayerViewPolicy: 3, ignoreViewExtent: 7, updateSplitBySeries: 0 };
  }
  static {
    this.styles = jA;
  }
  get showNotifyPanel() {
    return this._showNotifyPanel;
  }
  set showNotifyPanel(e) {
    this._showNotifyPanel = e, this.updatedProps.add("showNotifyPanel");
  }
  get config() {
    return this._config;
  }
  set config(e) {
    const i = this._config;
    this._config = e, this.updatedProps.add("config"), i && e && cg(i, e) && this.updatedProps.add("forceDataUpdate"), this.arcgisConfigChange.emit({ newConfig: e, oldConfig: i, functionCalled: this.lastModelSetterCalled }), this.lastModelSetterCalled = void 0, this.actionBarElement && !oo(e) && (this.actionBarElement.forceDisableActions = !1), this.isWarningDisplayed = !1;
  }
  get rotation() {
    return this._rotation;
  }
  set rotation(e) {
    this._rotation = e, this.rotationChange(this.rotation), this.handleNoRenderPropChange("rotation", this.rotation);
  }
  get legendPosition() {
    return this._legendPosition;
  }
  set legendPosition(e) {
    this._legendPosition = e, this.legendPositionChange(this.legendPosition), this.handleNoRenderPropChange("legendPosition", this.legendPosition);
  }
  get legendVisibility() {
    return this._legendVisibility;
  }
  set legendVisibility(e) {
    this._legendVisibility = e, this.legendVisibilityChange(this.legendVisibility), this.handleNoRenderPropChange("legendVisibility", this.legendVisibility);
  }
  get view() {
    return this._view;
  }
  set view(e) {
    const i = this.view;
    this._view = e, this.viewChange(this.view, i), this.handleNoRenderPropChange("view", this.view);
  }
  get filterByExtent() {
    return this._filterByExtent;
  }
  set filterByExtent(e) {
    this._filterByExtent = e, this.filterByExtentChanged(this.filterByExtent), this.handleNoRenderPropChange("filterByExtent", this.filterByExtent);
  }
  get disableInteractions() {
    return this._disableInteractions ?? !1;
  }
  set disableInteractions(e) {
    this._disableInteractions = e, this.disableInteractionsChange(this.disableInteractions), this.handleNoRenderPropChange("disableInteractions", this.disableInteractions);
  }
  get featureIndex() {
    return this._featureIndex;
  }
  set featureIndex(e) {
    const i = this.featureIndex;
    this._featureIndex = e, this.featureIndexChange(this.featureIndex, i), this.handleNoRenderPropChange("featureIndex", this.featureIndex);
  }
  async loadModel() {
    return this._model ? await this._model.setupFinished : await new Promise((e) => {
      this.resolveModelSetup = e;
    });
  }
  async clearSelection() {
    this.chart !== void 0 && (this.chart.clearSelection(), this.filterBySelection === !0 && await this.refresh());
  }
  async errorAlert(e) {
    this.errorPolicy === Go.Throw && (this.notifyHeading = this.commonStrings?.errorStrings.errorHeading, this.notifyMessage = e, this.notifyOptions = {
      kind: "danger",
      autoClose: !0,
      active: !0
    }, this.actionBarElement && (this.actionBarElement.forceDisableActions = !0), this.showNotifyPanel = !0);
  }
  async exportAsCSV(e) {
    let i, a;
    if (this.chartData) {
      const o = this.layer ?? (hi(this.config) && this.config?.iLayer !== void 0 ? await dg(this.config.iLayer) : void 0), n = await qt(o, this.usePopupTemplateFieldsInfo), s = xo(this.model) ? this.model.titleText : "chart";
      if (Object.values(this.chartData).filter((l) => Array.isArray(l) && l.length > 0).length > 1) {
        const l = new Pm();
        Object.entries(this.chartData).forEach(([u, d]) => {
          if (Array.isArray(d) && d.length > 0) {
            const m = Fl({
              rawData: d,
              config: this._model?.config ?? this.config,
              layer: o,
              fieldList: n
            }), g = Al(m, e), h = `${s}-${u}.csv`;
            l.file(h, g);
          }
        });
        const c = await l.generateAsync({ type: "blob" });
        i = URL.createObjectURL(c), a = `${s}.zip`;
      } else {
        let l;
        if ("bins" in this.chartData ? l = this.chartData.bins : "dataItems" in this.chartData && (l = this.chartData.dataItems), l) {
          const c = Fl({
            rawData: l,
            config: this._model?.config ?? this.config,
            layer: o,
            fieldList: n
          }), u = Al(c, e);
          i = URL.createObjectURL(new Blob([u], { type: "text/csv;charset=utf-8;" })), a = `${s}.csv`;
        }
      }
      i !== void 0 && a !== void 0 && Ll(i, a);
    }
  }
  async exportAsImage(e = hh.PNG) {
    const i = this.chartRef.value;
    i ? (await Nm(i, {
      useCORS: !0,
      backgroundColor: null
    })).toBlob((o) => {
      if (o) {
        const n = URL.createObjectURL(o), s = `${this.model.titleText ?? "chart"}.${e}`;
        Ll(n, s);
      }
    }, e) : this.errorAlert(this.commonStrings?.errorStrings.errors.exportImageChartNotReady);
  }
  async notify(e, i, a) {
    this.chart !== void 0 && this.chart.notify(e, i, a);
  }
  async refresh(e) {
    const { updateData: i = !0, resetAxesBounds: a = !1 } = e ?? {};
    this.updatedProps.add(i ? "forceDataUpdate" : "forceSimpleUpdate"), a && (delete this.config?.axes?.[0]?.minimum, delete this.config?.axes?.[0]?.maximum, delete this.config?.axes?.[1]?.minimum, delete this.config?.axes?.[1]?.maximum), this.requestUpdate();
  }
  async resetZoom() {
    this.chart !== void 0 && this.chart.resetZoom();
  }
  async switchSelection() {
    this.chart !== void 0 && this.filterBySelection !== !0 && await this.chart.switchSelection();
  }
  connectedCallback() {
    super.connectedCallback(), this.addConfigListeners(), document.addEventListener("arcgisSelectionComplete", this.handleExternalSelection);
  }
  async load() {
    if (this.syncSelectionsBetweenChartAndLayerViewPolicy === Jo.Enabled) {
      const e = this.getSelectionFromLayerView();
      e && (this.selectionData = {
        selectionOIDs: e,
        selectionSource: Ne.ProgrammaticSelection
      });
    }
    this.debouncedChartUpdate = Sh.promise(async () => {
      if (this.chart !== void 0) {
        const e = Array.from(this.updatedProps);
        if (e.length > 0) {
          const i = e.some((o) => this.dataUpdateNeededProps.includes(o));
          this.updatedProps.clear();
          const a = this.gatherComponentOptions(i);
          this.updateSplitBySeries?.addMissingSeries === !0 && (i || e.includes("model") || e.includes("layer") || e.includes("filterByExtent")) && await bl(this, this.config, a), this.chart && await this.chart.update({
            newChartConfig: this.config,
            updateOptions: a,
            updateGlobalOptions: {
              queueChartCreation: this.queueChartCreation,
              useAnimatedCharts: this.useAnimatedCharts,
              hideLicenseWatermark: this.hideLicenseWatermark,
              enableResponsiveFeatures: this.enableResponsiveFeatures,
              autoDisposeChart: this.autoDisposeChart
            },
            t9nStrings: {
              errorStrings: this.commonStrings?.errorStrings,
              utilsStrings: this.commonStrings?.utilsStrings
            }
          });
        }
      }
    }, ph);
  }
  willUpdate(e) {
    e.has("model") && this.modelChange(), e.has("selectionData") && this.selectionDataChange(), e.has("layer") && this.layerChange(), e.has("layerItemId") && this.layerItemIdChange(), (e.has("chartIndex") || e.has("layerItemId")) && this.createModelFromLayer(), e.has("runtimeDataFilters") && this.runtimeDataFiltersChange(), e.has("returnFeaturesExtent") && this.returnFeaturesExtentChange(), e.has("timeZone") && this.timeZoneChange(), e.has("filterBySelection") && this.filterBySelectionChanged(), e.has("layerFilterChangePolicy") && (this.hasUpdated || this.layerFilterChangePolicy !== Zo.Refresh) && this.layerFilterChangePolicyCallBack(this.layerFilterChangePolicy), e.has("viewTimeExtentChangePolicy") && (this.hasUpdated || this.viewTimeExtentChangePolicy !== no.Ignore) && this.viewTimeExtentChangePolicyCallback(this.viewTimeExtentChangePolicy), e.has("layerRendererChangePolicy") && (this.hasUpdated || this.layerRendererChangePolicy !== Ko.Refresh) && this.layerRendererChangePolicyCallBack(this.layerRendererChangePolicy), e.has("layerFieldsChangePolicy") && (this.hasUpdated || this.layerFieldsChangePolicy !== Qo.Refresh) && this.layerFieldsChangePolicyCallBack(this.layerFieldsChangePolicy), e.keys().forEach((i) => {
      const a = i.toString();
      this.updatedProps.add(a);
    });
  }
  async updated() {
    if (this.chart === void 0 && this.chartCreationProcessing !== void 0 && (await this.chartCreationProcessing, this.chartCreationProcessing = void 0), this.config !== void 0 && this.chart !== void 0 && !this.showNotifyPanel)
      try {
        (!this.config && !this.layer || yl(this.config, this.layer) && !oo(this.config)) && await this.debouncedChartUpdate?.push();
      } catch (e) {
        this.chartRef.value !== void 0 && (e.name === ro.ChartDisposed ? (this.chart?.dispose(), this.chart = void 0, this.chartRef.value.innerHTML = "", await this.createChartInstance(!1)) : (e.name === ro.QueryFeaturesError ? this.arcgisDataProcessError.emit(e.details) : this.arcgisRuntimeError.emit(e.details ?? e), this.errorAlert(e?.message)));
      }
    else this.chart === void 0 && this.chartCreationProcessing === void 0 && !this.showNotifyPanel && await this.createChartInstance();
    this.placeholder !== void 0 ? await this.notify(this.placeholder) : this.enableConfiguration && oo(this.config) && this.applyPlaceholderForPartialConfig(this.config), this.actionBarElement !== void 0 && mh({
      actionBar: this.actionBarElement,
      chartComponent: this.el,
      config: this.config,
      isWarningDisplayed: this.isWarningDisplayed
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.removeConfigListeners(), this.removeLayerListeners(), this.removeModelListeners(), this.removeExtentChangeListeners(), this.removeViewTimeExtentChangeListener(), document.removeEventListener(fh.SelectionComplete, this.handleExternalSelection), this.chart !== void 0 && this.chart.dispose();
  }
  useBetaChart() {
    const e = z(this.config?.series);
    return this.enableBetaFeatures || e === b.ScatterSeries || e === b.HistogramSeries || e === b.RadarSeries || e === b.HeatSeries;
  }
  handleNoRenderPropChange(e, i) {
    this.updatedProps.add(e), this.arcgisNoRenderPropChange.emit({
      propName: e,
      value: i,
      model: this._model
    });
  }
  applySelectionFromView() {
    const e = this.getSelectionFromLayerView();
    e && (this.selectionData = {
      selectionOIDs: e,
      selectionSource: Ne.ProgrammaticSelection
    }, this.arcgisSelectionComplete.emit({ selectionData: this.selectionData, model: this._model }));
  }
  handleDataProcessComplete(e) {
    this.chartData = e.detail, this.arcgisDataProcessComplete.emit({ chartData: e.detail, model: this._model });
  }
  handleDataFetchComplete(e) {
    this.arcgisDataFetchComplete.emit(e.detail);
  }
  handleLegendItemVisibilityChanged(e) {
    ug(e, this.config), this.arcgisLegendItemVisibilityChange.emit({ legendItemVisibility: e.detail, model: this._model });
  }
  handleUpdateCompleted(e) {
    if (this.enableConfiguration) {
      const i = e.detail, a = this.commonStrings?.errorStrings.notifications;
      if (this.placeholder === void 0 && (i.schemaErrors.length > 0 ? this.notify(a?.invalidConfig, void 0, {
        closable: !1
      }) : i.warnings.length > 0 && i.warnings.some((n) => n.keyword === fg.NonNumericAggregation) && this.notify(a?.validateAggregationTypeMsg, a?.missingNumericFields, {
        closable: !1
      })), (ch(this._model) || dh(this._model)) && this._model.aggregationType === Wt.NoAggregation && this._model.numericFields.length === 1 && this.layer) {
        const o = Ho(this.layer).objectIdField;
        this._model.numericFields.includes(o) && this.notify(a?.noAggregationRequiresNumericFields, a?.missingNumericFields, {
          closable: !1
        });
      }
    }
    this.arcgisUpdateComplete.emit(e.detail);
  }
  handleBadDataWarningRaise(e) {
    this.arcgisBadDataWarningRaise.emit(e.detail), this.isWarningDisplayed = !0;
  }
  handleSeriesColorsChange(e) {
    this.arcgisSeriesColorChange.emit({
      data: e.detail.data,
      colorMatchApplied: e.detail.colorMatchApplied,
      model: this._model
    });
  }
  handleSelection(e) {
    this.selectionData = { ...e.detail }, this.arcgisSelectionComplete.emit({ selectionData: e.detail, model: this._model });
  }
  handleTooManySelectedElements() {
    this.errorPolicy === Go.Throw && (this.notifyHeading = this.commonStrings?.errorStrings.tooManySelectedElements?.title, this.notifyMessage = this.commonStrings?.errorStrings.tooManySelectedElements?.message, this.notifyOptions = {
      kind: "warning",
      autoClose: !0,
      duration: "fast",
      active: !0
    }, this.showNotifyPanel = !0);
  }
  handleAlertClosed(e) {
    e.target === this.el && (this.showNotifyPanel = !1);
  }
  handleAxesMinMaxChange(e) {
    this.arcgisAxesMinMaxChange.emit({ bounds: e.detail, model: this._model });
  }
  handleSeriesOrder(e) {
    this.arcgisSeriesOrder.emit(e.detail);
  }
  modelChange() {
    if (xo(this.model)) {
      this._model = this.model, this.config = Ge(this._model?.config);
      const e = this._model?.layer;
      !this.layerItemId && e && (this.layer = e), this.addModelListeners(), this._model.setupFinished.then(() => {
        typeof this.resolveModelSetup == "function" && this.resolveModelSetup();
      });
    } else
      this.config = this.model;
    if (this.enableBetaFeatures === void 0) {
      const e = z(this.config?.series);
      this.enableBetaFeatures = e === b.ScatterSeries || e === b.HistogramSeries;
    }
  }
  async selectionDataChange() {
    this.layer !== void 0 && this.syncSelectionsBetweenChartAndLayerViewPolicy === Jo.Enabled && this.view !== void 0 && this.setSelectionInLayerView();
  }
  async viewChange(e, i) {
    this.layerItemId && this.layerItemId?.trim() !== "" && (this.layer = hl({
      view: this.view,
      portalItemId: this.layerItemId
    }) ?? new ml({
      portalItem: {
        id: this.layerItemId
      }
    })), await this.setExtentChangeListener(), await this.setViewTimeExtentChangeListener(), i !== void 0 && e === void 0 && await this.refresh(), this.view ? this.setViewSelectionsChangeListener() : this.removeViewSelectionsChangeListener();
  }
  async layerChange() {
    await this.addLayerListeners(), this.layer && (await Ho(this.layer).load(), await this.setExtentChangeListener(), await this.setViewTimeExtentChangeListener());
  }
  layerItemIdChange() {
    this.layerItemId && this.layerItemId?.trim() !== "" ? this.layer = hl({
      view: this.view,
      portalItemId: this.layerItemId
    }) ?? new ml({
      portalItem: {
        id: this.layerItemId
      }
    }) : this.layer = void 0;
  }
  runtimeDataFiltersChange() {
    this.updatedProps.add("runtimeDataFilters");
  }
  returnFeaturesExtentChange() {
    this.updatedProps.add("returnFeaturesExtent");
  }
  featureIndexChange(e, i) {
    i === void 0 && typeof e == "number" && this.updatedProps.add("forceDataUpdate");
  }
  async disableInteractionsChange(e) {
    navigator.userAgent.search("Firefox") !== -1 && (e ? this.chartRef.value?.classList.add(zi.DisableInteractions) : this.chartRef.value?.classList.remove(zi.DisableInteractions));
  }
  rotationChange(e) {
    e !== void 0 && (this.config = mg(e, this.config));
  }
  legendPositionChange(e) {
    e !== void 0 && (this.config = Mg(e, this.config));
  }
  legendVisibilityChange(e) {
    e !== void 0 && (this.config = Ng(e, this.config));
  }
  timeZoneChange() {
    this.updateConfigTimeZone();
  }
  filterBySelectionChanged() {
    this.config = Pg(this.config);
  }
  layerFilterChangePolicyCallBack(e) {
    e !== Zo.Ignore ? this.setLayerFilterListener() : this.removeLayerFilterListener();
  }
  viewTimeExtentChangePolicyCallback(e) {
    e !== no.Refresh ? this.removeViewTimeExtentChangeListener() : this.setViewTimeExtentChangeListener();
  }
  layerRendererChangePolicyCallBack(e) {
    e !== Ko.Ignore ? this.setLayerRendererListener() : this.removeLayerRendererListener();
  }
  async filterByExtentChanged(e) {
    e || await this.refresh({
      updateData: !0,
      resetAxesBounds: !0
    }), this.filterByExtent ? this.setExtentChangeListener() : this.removeExtentChangeListeners();
  }
  layerFieldsChangePolicyCallBack(e) {
    e !== Qo.Ignore ? this.setLayerFieldsListener() : this.removeLayerFieldsListener();
  }
  addConfigListeners() {
    document.addEventListener("arcgisChartsConfigPanelNumberChange", this.configPanelNumberChange), document.addEventListener("arcgisChartsConfigDataChangeError", this.configDataChangeError), document.addEventListener("arcgisChartsConfigPopoverOpenChange", this.configPopoverOpenChange);
  }
  removeConfigListeners() {
    document.removeEventListener("arcgisChartsConfigPanelNumberChange", this.configPanelNumberChange), document.removeEventListener("arcgisChartsConfigDataChangeError", this.configDataChangeError), document.removeEventListener("arcgisChartsConfigPopoverOpenChange", this.configPopoverOpenChange);
  }
  getSelectionFromLayerView() {
    let e = [];
    const i = this.view;
    return i !== void 0 && "selectionManager" in i && "getSelection" in i.selectionManager && (e = i?.selectionManager?.getSelection(this.layer)), e;
  }
  setSelectionInLayerView() {
    let e;
    const i = this.selectionData?.selectionOIDs?.length === 0 || this.selectionData?.selectionOIDs === void 0 || this.selectionData?.selectionSource === Ne.ClearSelection, a = (this.selectionData?.selectionOIDs?.length ?? 0) > 0;
    i ? e = [] : a && this.selectionData && (e = this.selectionData.selectionOIDs);
    const o = this.view;
    e && o !== void 0 && "selectionManager" in o && "setSelection" in o.selectionManager && o.selectionManager.setSelection(this.layer, e);
  }
  addModelListeners() {
    this._model?.addEventListener("arcgisChartsModelConfigChange", this.modelConfigChange);
  }
  removeModelListeners() {
    this._model?.removeEventListener("arcgisChartsModelConfigChange", this.modelConfigChange);
  }
  async addLayerListeners() {
    this.removeLayerListeners(), this.layerFilterListener = await Lc(this), this.layerRendererListener = await Fc(this), this.layerFieldsListener = await Ac(this), this.viewSelectionsChangeListener = await Tc(this);
  }
  async setLayerFilterListener() {
    this.removeLayerFilterListener(), this.layerFilterListener = await Lc(this);
  }
  async setLayerRendererListener() {
    this.removeLayerRendererListener(), this.layerRendererListener = await Fc(this);
  }
  async setLayerFieldsListener() {
    this.removeLayerFieldsListener(), this.layerFieldsListener = await Ac(this);
  }
  async setExtentChangeListener() {
    this.filterByExtent && (this.removeExtentChangeListeners(), this.extentChangeListeners = await XA(this));
  }
  async setViewTimeExtentChangeListener() {
    this.removeViewTimeExtentChangeListener(), this.viewTimeExtentChangeListener = await YA(this);
  }
  async setViewSelectionsChangeListener() {
    this.removeViewSelectionsChangeListener(), this.viewSelectionsChangeListener = await Tc(this);
  }
  removeLayerListeners() {
    this.removeLayerFilterListener(), this.removeLayerRendererListener(), this.removeLayerFieldsListener();
  }
  removeLayerFilterListener() {
    this.layerFilterListener?.remove();
  }
  removeLayerRendererListener() {
    this.layerRendererListener?.remove();
  }
  removeLayerFieldsListener() {
    this.layerFieldsListener?.remove();
  }
  removeExtentChangeListeners() {
    this.extentChangeListeners !== void 0 && (this.extentChangeListeners.forEach((e) => e.remove()), this.extentChangeListeners = []);
  }
  removeViewSelectionsChangeListener() {
    this.viewSelectionsChangeListener !== void 0 && this.viewSelectionsChangeListener.remove();
  }
  removeViewTimeExtentChangeListener() {
    this.viewTimeExtentChangeListener?.remove(), this.runtimeDataFilters?.timeExtent && delete this.runtimeDataFilters.timeExtent;
  }
  async createModelFromLayer() {
    if (this.layer) {
      const e = Ho(this.layer);
      await e.load();
      const i = this.chartIndex ?? 0, a = e?.charts?.[i];
      if (a)
        this.model = await uh({
          layer: e,
          config: a
        });
      else {
        const o = Ra(this._messages?.chartNotFoundWarning ?? "", {
          chartIndex: i.toString(),
          layerTitle: e.title
        });
        this.arcgisChartNotFoundWarning.emit(o), console.warn(o);
      }
    }
  }
  async applyPlaceholderForPartialConfig(e) {
    const i = z(e?.series), a = HA(i, this.commonStrings?.errorStrings);
    await this.notify(a);
  }
  checkForIncompatibleChartVersion() {
    const e = this.config?.version;
    this.errorPolicy === Go.Throw && gg(e).versionStatus === Hm.Newer && (this.notifyHeading = this.commonStrings?.errorStrings.incompatibleChartVersion?.title, this.notifyMessage = this.commonStrings?.errorStrings.incompatibleChartVersion?.message ? Ra(this.commonStrings?.errorStrings.incompatibleChartVersion?.message, {
      chartVersion: e ?? ""
    }) : "", this.notifyOptions = {
      kind: "warning",
      autoClose: !0,
      active: !0
    }, this.showNotifyPanel = !0);
  }
  ourModelExistsIn(e) {
    return e.some((i) => this._model?.isSameChartAs(i));
  }
  updateConfigTimeZone() {
    this.config?.axes?.[0]?.valueFormat.type === b.DateAxisFormat && (this.config.axes[0].valueFormat.intlOptions.timeZone = hg(this.timeZone));
  }
  gatherComponentOptions(e) {
    let i = this.runtimeDataFilters;
    return this.view && this.viewTimeExtentChangePolicy === no.Refresh && this.view.timeExtent?.start != null && this.view.timeExtent?.end != null && (i = {
      ...i,
      timeExtent: [this.view.timeExtent.start.valueOf(), this.view.timeExtent.end.valueOf()]
    }), {
      dataUpdated: e,
      layer: this.layer,
      view: this.filterByExtent ? this.view : void 0,
      viewExtentUpdated: e && this.filterByExtent === !0 && (this.view !== void 0 || _s(this.layer)),
      allowUsingObjectIdStat: this.allowUsingObjectIdStat,
      nullAsValid: this.nullAsValid,
      showUIMessages: this.showUIMessages,
      createMessage: this.placeholder,
      hideLoaderAnimation: this.hideLoaderAnimation,
      loaderColors: this.loaderColors,
      runtimeDataFilters: i,
      usePopupTemplateFieldsInfo: this.usePopupTemplateFieldsInfo,
      ignoreViewExtent: this.ignoreViewExtent,
      chartLimits: this.chartLimits,
      guideTooltipFormatter: this.guideTooltipFormatter,
      xAxisLabelFormatter: this.xAxisLabelFormatter,
      yAxisLabelFormatter: this.yAxisLabelFormatter,
      secondaryYAxisLabelFormatter: this.secondaryYAxisLabelFormatter,
      tooltipFormatter: this.tooltipFormatter,
      dataLabelFormatter: this.dataLabelFormatter,
      selectionData: this.selectionData,
      filterBySelection: this.filterBySelection,
      actionMode: this.actionMode,
      cursorRange: this.cursorRange,
      selectionTheme: this.selectionTheme,
      setTimeBinningInfoWhenNotProvided: this.setTimeBinningInfoWhenNotProvided,
      returnSelectionOIDs: this.returnSelectionOIDs,
      returnSelectionIndexes: this.returnSelectionIndexes,
      returnFeaturesExtent: this.returnFeaturesExtent,
      disableTogglingLegendItems: this.disableTogglingLegendItems,
      hideEmptySeries: this.hideEmptySeries,
      autoInverseDataLabelTextColor: this.autoInverseDataLabelTextColor,
      replaceNoValueCategoryWithZero: this.replaceNoValueCategoryWithZero,
      gaugeInnerLabelFormatter: this.gaugeInnerLabelFormatter,
      ignoreSmoothRenderingLimit: this.ignoreSmoothRenderingLimit,
      chartWillRender: this.chartWillRender,
      pieChartLegendValueLabelFormatter: this.legendValueLabelFormatter
    };
  }
  async createChartInstance(e = !0) {
    this.chartCreationProcessing !== void 0 && (await this.chartCreationProcessing, this.chartCreationProcessing = void 0), this.updateConfigTimeZone(), this.checkForIncompatibleChartVersion(), this.updatedProps.clear();
    try {
      if (!this.config && !this.layer || yl(this.config, this.layer)) {
        const i = this.gatherComponentOptions();
        await bl(this, this.config, i);
        const a = this.useBetaChart() ? iC : WA;
        this.chartCreationProcessing = a({
          chartContainer: this.chartRef.value,
          chartConfig: oo(this.config) ? void 0 : this.config,
          options: i,
          globalOptions: {
            queueChartCreation: this.queueChartCreation,
            useAnimatedCharts: this.useAnimatedCharts,
            hideLicenseWatermark: this.hideLicenseWatermark,
            enableResponsiveFeatures: this.enableResponsiveFeatures,
            autoDisposeChart: this.autoDisposeChart
          },
          t9nStrings: {
            errorStrings: this.commonStrings?.errorStrings,
            utilsStrings: this.commonStrings?.utilsStrings
          }
        }), this.chart = await this.chartCreationProcessing, this.chartCreationProcessing = void 0, e && (await this.addLayerListeners(), await this.setExtentChangeListener(), await this.setViewTimeExtentChangeListener());
      }
    } catch (i) {
      i.name === ro.QueryFeaturesError ? this.arcgisDataProcessError.emit(i.details) : this.arcgisRuntimeError.emit(i.details ?? i), this.errorAlert(i?.message), this.chart?.dispose(), this.chartCreationProcessing = void 0, this.chart = void 0;
    }
  }
  render() {
    const e = this.showNotifyPanel ? UA({ heading: this.notifyHeading, message: this.notifyMessage, options: this.notifyOptions }) : null, i = this.showNotifyPanel && this.notifyOptions?.kind === "danger" ? zi.Hide : `${zi.Chart} ${zi.Show}`, a = this.showNotifyPanel ? `${zi.Show} ${zi.NotifyPanel}` : zi.Hide;
    return _o`<slot name=${lh.actionBar} @slotchange=${(o) => {
      this.actionBarElement = gh(o, this.el, this.config);
    }} ${dl(this.actionBarSlotRef)}></slot><div class=${cl(i)} ${dl(this.chartRef)}></div><div class=${cl(a)}>${e}</div>`;
  }
}
Bm("arcgis-chart", qA);
export {
  qA as ArcgisChart
};
