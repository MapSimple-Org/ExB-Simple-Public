import { c as A } from "../../chunks/runtime.js";
import { ref as $ } from "lit/directives/ref.js";
import { C as B, F as i, L as m } from "../../chunks/common.js";
import { d as T, j as h, h as n, l as E, p, m as L, f as M } from "../../chunks/type-guards.js";
import { W as d } from "../../chunks/series-types.js";
import { c as V, R as f, h as w, g as N, i as D } from "../../chunks/rest-js-object-literals.js";
import "@arcgis/toolkit/intl";
import { isEmpty as u, cloneDeep as r, isArray as v, isObject as k, mergeWith as W } from "lodash-es";
import "d3-array";
import "../../chunks/interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import { c as x, e as l } from "../../chunks/index4.js";
import "@arcgis/toolkit/dom";
import { r as F } from "../../chunks/popover-ui-utils.js";
import { l as G } from "../../chunks/chart-ui-utils2.js";
import { u as R } from "../../chunks/useT9n.js";
import { css as j, html as S } from "lit";
import { LitElement as I, renderElement as O, safeClassMap as g } from "@arcgis/lumina";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
const P = {
  type: f.TS,
  color: [1, 1, 1, 255],
  font: {
    family: "Tahoma",
    size: 12,
    decoration: D.None,
    style: N.Normal,
    weight: w.Normal
  }
}, C = {
  type: f.SLS,
  color: [1, 1, 1, 255],
  style: V.Solid,
  width: 2
}, b = {
  element: "chart-element",
  elementList: "element-list",
  sectionLabel: "section-label"
}, X = j`:host{width:var(--arcgis-charts-config-calcite-block-default-width);margin:var(--arcgis-charts-config-calcite-block-default-margin)}.section-label{display:flex;margin:var(--arcgis-charts-config-margin-major) var(--arcgis-charts-config-margin-minor);justify-content:space-between;align-items:center;font-weight:var(--calcite-font-weight-medium);font-size:var(--calcite-font-size-0)}.element-list{margin:var(--arcgis-charts-config-margin-minor)}.element{user-select:none}`;
class _ extends I {
  constructor() {
    super(...arguments), this._messages = R(), this.formatPopover = null, this.selectableElements = [], this.textProperties = [], this.symbolProperties = [], this.symbolPropertyChange = (t) => {
      const e = t;
      e.stopImmediatePropagation();
      let s;
      if (e.target?.localName === "calcite-list-item" ? s = e.target?.value : s = e.target?.parentNode?.value, this.selectedTexts = [], this.selectedBackground = [], this.selectedSymbols.includes(s))
        this.selectedSymbols = [], this.updateSelectedElement(this.selectedSymbols);
      else {
        const o = this.getFormatValue(s);
        this.selectedSymbols = [s], this.initSelectedSymbols(x(o) ? o : C);
      }
      this.setupFormatPopover();
    }, this.textPropertyChange = (t) => {
      const e = t;
      e.stopImmediatePropagation();
      let s;
      if (e.target?.localName === "calcite-list-item" ? s = e.target?.value : s = e.target?.parentNode?.value, this.selectedSymbols = [], this.selectedBackground = [], e.shiftKey) {
        this.selectedTexts = [];
        const o = this.textProperties.indexOf(this.lastSelectedText ?? s), a = this.textProperties.indexOf(s);
        this.textProperties.forEach((c, y) => {
          y >= Math.min(o, a) && y <= Math.max(o, a) && this.selectedTexts.push(c);
        }), this.updateSelectedElement(this.selectedTexts), this.setupFormatPopover();
      } else if (e.ctrlKey)
        this.selectedTexts.includes(s) ? (this.selectedTexts = this.selectedTexts.filter((o) => o !== s), this.updateSelectedElement(this.selectedTexts)) : (this.selectedTexts = [...this.selectedTexts, s], this.updateSelectedElement(this.selectedTexts)), this.setupFormatPopover();
      else if (this.selectedTexts.includes(s))
        this.selectedTexts = [], this.updateSelectedElement(this.selectedTexts), this.setupFormatPopover();
      else {
        const o = this.getFormatValue(s);
        this.selectedTexts = [s], this.initSelectedTexts(l(o) ? o : P), this.setupFormatPopover();
      }
      this.lastSelectedText = s;
    }, this.backgroundChange = (t) => {
      const e = t;
      e.stopImmediatePropagation();
      let s;
      e.target?.localName === "calcite-list-item" ? s = e.target?.value : s = e.target?.parentNode?.value, this.selectedSymbols = [], this.selectedTexts = [], this.selectedBackground.includes(s) ? (this.selectedBackground = [], this.selectedElement = {}) : (this.selectedBackground = [s], this.selectedElement = u(this.getFormatValue(s)) ? void 0 : this.getFormatValue(s)), this.setupFormatPopover();
    }, this.updateSymbolProps = (t) => {
      const e = t.detail;
      this.selectedSymbols.forEach((s) => {
        this.setFormatValue(s, e);
      }), this.selectedElement = r(t.target.selectedElement);
    }, this.updateBackground = (t) => {
      this.setFormatValue(B.Background, t.detail), this.selectedElement = t.detail;
    }, this.updateTextProps = (t) => {
      const { font: e, color: s } = t.detail;
      this.selectedTexts.forEach((o) => {
        const a = this.getFormatValue(o), c = l(a) ? a : void 0;
        this.setFormatValue(o, {
          ...c,
          type: f.TS,
          font: { ...c?.font, ...e },
          color: s ?? c?.color
        });
      }), this.selectedElement = r(t.target.selectedElement);
    }, this.onModelConfigChange = () => {
      this.requestUpdate();
    }, this.formatPopoverClose = (t) => {
      this.formatPopover === t?.target && (this.selectedTexts = [], this.selectedSymbols = [], this.selectedBackground = [], this.selectedElement = {}, this.removeFormatPopover());
    }, this.mergeFormatValues = (t, e) => {
      let s = !1;
      v(t) && v(e) || k(t) && k(e) ? s = !0 : s = t === e;
      const o = typeof t == "number" || typeof e == "number" ? Number.NaN : "";
      return s ? void 0 : o;
    }, this.updateSelectableElements = (t) => {
      t && !this.selectableElements.includes(t) && this.selectableElements.push(t);
    }, this.selectedSymbols = [], this.selectedTexts = [], this.selectedBackground = [];
  }
  static {
    this.properties = { selectedSymbols: 16, selectedTexts: 16, selectedBackground: 16, selectedElement: 16, messageOverrides: 0, model: 0 };
  }
  static {
    this.styles = X;
  }
  load() {
    this.modelChange(this.model);
  }
  willUpdate(t) {
    t.has("model") && this.modelChange(this.model, t.get("model"));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.removeFormatPopover(), this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
  }
  modelChange(t, e) {
    e?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange), t?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
  }
  correctTextElementSelection() {
    for (const t of this.selectableElements) {
      const e = this.selectedTexts.includes(t.value) || this.selectedSymbols.includes(t.value) || this.selectedBackground.includes(t.value);
      t.selected = e;
    }
  }
  updateSelectedElement(t, e) {
    if (this.selectedElement = void 0, e === void 0) {
      const s = r(this.getFormatValue(t[0]));
      this.selectedElement = t?.reduce((o, a) => {
        const c = this.getFormatValue(a);
        return W(o, c, this.mergeFormatValues);
      }, s);
    } else {
      let s = r(e);
      u(e) && (this.selectedSymbols?.length > 0 && (s = r(C)), this.selectedTexts?.length > 0 && (s = r(P))), this.selectedElement = s;
    }
  }
  initSelectedTexts(t) {
    let e = r(t);
    u(t) && (e = r(P)), this.selectedElement = e;
  }
  initSelectedSymbols(t) {
    let e = r(t);
    u(t) && (e = r(C)), this.selectedElement = e;
  }
  setupFormatPopover() {
    this.formatPopover = F(this.formatPopover);
    const t = this.selectedElement;
    t?.type === f.TS || t?.type === f.SLS || // To check if the selected element is background.
    Array.isArray(this.selectedElement) ? (this.formatPopover = O(S`<arcgis-charts-config-format-popover .selectedElement=${this.selectedElement} .referenceElement=${this.el} @arcgisChartsConfigFormatPopoverSymbolChange=${this.updateSymbolProps} @arcgisChartsConfigFormatPopoverTextChange=${this.updateTextProps} @arcgisChartsConfigFormatPopoverColorChange=${this.updateBackground} placement=auto @arcgisChartsConfigPopoverClose=${this.formatPopoverClose} open></arcgis-charts-config-format-popover>`), this.formatPopover !== null && !document.body.contains(this.formatPopover) && document.body.appendChild(this.formatPopover)) : this.removeFormatPopover();
  }
  removeFormatPopover() {
    this.formatPopover !== null && (this.formatPopover.open = !1, this.formatPopover = F(this.formatPopover));
  }
  getFormatValue(t) {
    switch (t) {
      case i.Title:
        return this.model.titleSymbol;
      case i.Description:
        return this.model.descriptionSymbol;
      case i.XAxisTitle:
        return n(this.model) ? this.model.xAxisTitleSymbol : void 0;
      case i.YAxisTitle:
        return h(this.model) ? this.model.getAxisTitleSymbol(1) : void 0;
      case i.AxisLabels:
        return n(this.model) ? this.model.axisLabelsSymbol : void 0;
      case i.GuideLabels:
        return L(this.model) ? this.model.guideLabelsSymbol : void 0;
      case i.LegendText:
        return p(this.model) ? this.model.legendTextSymbol : void 0;
      case i.LegendTitle:
        return p(this.model) ? this.model.legendTitleSymbol : void 0;
      case i.DataLabels:
        return E(this.model) ? this.model.dataLabelsSymbol : void 0;
      case m.AxisLines:
        return n(this.model) ? this.model.axisLinesSymbol : void 0;
      case m.GridLines:
        return h(this.model) ? this.model.getGridLinesSymbol() : void 0;
      case m.LeaderLines:
        return T(this.model) ? this.model.ticksSymbol : void 0;
      case i.Background:
        return this.model.backgroundColor;
      default:
        return;
    }
  }
  setFormatValue(t, e) {
    switch (t) {
      case i.Title:
        l(e) && (this.model.titleSymbol = e);
        break;
      case i.Description:
        l(e) && (this.model.descriptionSymbol = e);
        break;
      case i.XAxisTitle:
        n(this.model) && l(e) && (this.model.xAxisTitleSymbol = e);
        break;
      case i.YAxisTitle:
        h(this.model) && l(e) && this.model.setAxisTitleSymbol(e, 1);
        break;
      case i.AxisLabels:
        n(this.model) && l(e) && (this.model.axisLabelsSymbol = e);
        break;
      case i.GuideLabels:
        L(this.model) && l(e) && (this.model.guideLabelsSymbol = e);
        break;
      case i.LegendText:
        p(this.model) && l(e) && (this.model.legendTextSymbol = e);
        break;
      case i.LegendTitle:
        p(this.model) && l(e) && (this.model.legendTitleSymbol = e);
        break;
      case i.DataLabels:
        E(this.model) && l(e) && (this.model.dataLabelsSymbol = e);
        break;
      case m.AxisLines:
        n(this.model) && x(e) && (this.model.axisLinesSymbol = e);
        break;
      case m.GridLines:
        if (h(this.model) && x(e)) {
          const s = this.model.chartType;
          let o = [];
          switch (s) {
            // set y-axis grid line for charts -Bar chart/Line chart, Histogram and Box plot
            case d.BarSeries:
            case d.LineSeries:
            case d.ComboLineAndBarSeries:
            case d.HistogramSeries:
            case d.BoxPlotSeries:
            case d.RadarSeries: {
              o = [1];
              break;
            }
            // set both x and y-axis grid lines for charts - Scatter chart
            case d.ScatterSeries: {
              o = [0, 1];
              break;
            }
          }
          this.model.setGridLinesSymbol(e, o);
        }
        break;
      case m.LeaderLines:
        T(this.model) && x(e) && (this.model.ticksSymbol = e);
        break;
      case i.Background:
        Array.isArray(e) && (this.model.backgroundColor = e);
        break;
    }
  }
  renderFormatElements() {
    this.textProperties = [
      i.Title,
      ...n(this.model) ? [i.XAxisTitle] : [],
      ...h(this.model) ? [i.YAxisTitle] : [],
      ...p(this.model) ? [i.LegendTitle] : [],
      i.Description,
      ...p(this.model) ? [i.LegendText] : [],
      ...n(this.model) ? [i.AxisLabels] : [],
      ...L(this.model) ? [i.GuideLabels] : [],
      ...E(this.model) ? [i.DataLabels] : []
    ], M(this.model) && (this.textProperties = this.textProperties.filter((s) => s !== i.DataLabels)), this.symbolProperties = [
      i.Background,
      ...n(this.model) ? [m.AxisLines] : [],
      ...h(this.model) ? [m.GridLines] : [],
      ...T(this.model) ? [m.LeaderLines] : []
    ];
    const t = this.textProperties.map((s) => this.renderTextElement(s, this.textPropertyChange)), e = this.symbolProperties.map((s) => s === i.Background ? this.renderTextElement(s, this.backgroundChange) : this.renderTextElement(s, this.symbolPropertyChange));
    return { textElements: t, symbolElements: e };
  }
  renderTextElement(t, e) {
    const s = G(t), o = this.getFormatValue(t), a = typeof o == "string" ? o : "", c = this.selectedTexts.includes(t) || this.selectedSymbols.includes(t) || this.selectedBackground.includes(t);
    return S`<calcite-list-item class=${g(b.element)} .label=${this._messages[t]} .description=${a} .value=${t} .selected=${c} @click=${e} ${$(this.updateSelectableElements)}>${s !== void 0 ? S`<calcite-icon slot=content-start scale=s .icon=${s}></calcite-icon>` : null}</calcite-list-item>`;
  }
  render() {
    const { textElements: t, symbolElements: e } = this.renderFormatElements();
    return S`<div class=${g(b.sectionLabel)}>${this._messages.textElements}</div><calcite-list label class=${g(b.elementList)} selection-mode=multiple selection-appearance=border @calciteListChange=${this.correctTextElementSelection}>${t}</calcite-list><div class=${g(b.sectionLabel)}>${this._messages.symbolElements}</div><calcite-list label class=${g(b.elementList)} selection-mode=single selection-appearance=border>${e}</calcite-list>`;
  }
}
A("arcgis-charts-config-format", _);
export {
  _ as ArcgisChartsConfigFormat
};
