import { W as _ } from "./series-types.js";
import "@arcgis/toolkit/intl";
import { isEmpty as c, isEqual as O } from "lodash-es";
import "d3-array";
import { as as w, at as d, ci as l, y as x, bf as P, aP as U } from "./interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import "./runtime.js";
import "@arcgis/toolkit/dom";
import { g as X, a as A, s as y, u as g, p as Y, d as W } from "./data2.js";
import { substitute as k } from "@arcgis/core/intl.js";
import { C as z, M as D, b as E, a as V } from "./model-with-multi-axes.js";
import { M as B, a as G, b as N, c as q } from "./model-with-data-labels.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
const v = (t) => {
  y({ config: t, value: null, axisIndex: 0, isMax: !1 }), y({ config: t, value: null, axisIndex: 0, isMax: !0 }), y({ config: t, value: null, axisIndex: 1, isMax: !1 }), y({ config: t, value: null, axisIndex: 1, isMax: !0 });
}, S = (t) => {
  const { name: e, axisIndex: i, config: s, layerInfo: r } = t, { layerFieldsInfo: o } = r, n = o.find((h) => h.name === e), a = n !== void 0 && P(n);
  Y(s, i, a);
};
function F(t, e, i) {
  const s = p(t, e, i), r = X(t), o = x(t);
  return s === r || o;
}
function C(t, e) {
  const { layerFieldsInfo: i } = e, s = l(i, u(t)), r = A(1, t), o = x(t);
  return s === r || o;
}
function L(t, e) {
  const { layerFieldsInfo: i } = e, s = m(t), r = l(i, s), o = A(0, t), n = x(t);
  return r === o || n;
}
function p(t, e, i) {
  const s = m(t), r = u(t), { layerFieldsInfo: o } = e, n = l(o, s), a = l(o, r);
  return k(i.titleLabels.xAndY, { x: n, y: a });
}
const I = (t) => {
  const { x: e, y: i, config: s, layerInfo: r, updateChartTitle: o, updateXAxisTitle: n, updateYAxisTitle: a, commonStrings: h } = t, { layerFieldsInfo: f } = r, b = l(f, e), M = l(f, i);
  !c(e) && n && g(s, 0, b), !c(i) && a && g(s, 1, M), !c(e) && !c(i) && s.title && o && (s.title.content.text = p(s, r, h));
}, m = (t) => t.series[0]?.x ?? "", u = (t) => t.series[0]?.y ?? "", j = (t) => {
  const { fieldName: e, config: i, layerInfo: s, commonStrings: r } = t, o = F(i, s, r), n = L(i, s), a = C(i, s);
  v(i), i.series[0] && (i.series[0].x = e), I({
    x: e,
    y: u(i),
    config: i,
    layerInfo: s,
    updateChartTitle: o,
    commonStrings: r,
    updateXAxisTitle: n,
    updateYAxisTitle: a
  }), S({
    name: e,
    axisIndex: 0,
    config: i,
    layerInfo: s
  });
}, H = (t) => {
  const { fieldName: e, config: i, layerInfo: s, commonStrings: r } = t, o = F(i, s, r), n = L(i, s), a = C(i, s);
  v(i), i.series[0] && (i.series[0].y = e), I({
    x: m(i),
    y: e,
    config: i,
    layerInfo: s,
    commonStrings: r,
    updateChartTitle: o,
    updateXAxisTitle: n,
    updateYAxisTitle: a
  }), S({
    name: e,
    axisIndex: 1,
    config: i,
    layerInfo: s
  });
}, J = (t) => {
  const e = {};
  return t.series[0]?.markerSymbol ?? e;
}, K = (t, e) => {
  e.series[0] && (e.series[0].markerSymbol = t);
}, Q = (t) => (t.series[0]?.overlays?.trendLine?.visible ?? !0) && (t.series[0]?.overlays?.trendLine?.created ?? !1), R = (t) => {
  const e = {};
  return t.series[0]?.overlays?.trendLine?.symbol ?? e;
}, Z = (t, e) => {
  e.series[0].overlays ??= d(), e.series[0].overlays.trendLine ??= d().trendLine, e.series[0].overlays.trendLine.symbol = t;
}, $ = (t, e) => {
  e.series[0].overlays ??= d(), e.series[0].overlays.trendLine ??= d().trendLine, e.series[0].overlays.trendLine.visible = t;
}, ee = (t, e) => {
  !(e.series[0]?.overlays?.trendLine?.created ?? !1) && t && (e.series[0].overlays ??= d(), e.series[0].overlays.trendLine ??= d().trendLine, e.series[0].overlays.trendLine.created = t), $(t, e);
}, T = (t) => t.series[0]?.sizePolicy ?? w(), te = (t, e) => {
  e.series[0] && (t !== void 0 && t.field?.trim() !== "" ? e.series[0].sizePolicy = { ...e.series[0].sizePolicy, ...t } : e.series[0].sizePolicy = void 0);
}, ie = (t) => t?.series?.[0]?.overlays, se = (t, e) => {
  e?.series[0] !== void 0 && (e.series[0].overlays = t);
}, re = (t) => t.series.find((e) => e.additionalTooltipFields !== void 0)?.additionalTooltipFields ?? [], oe = (t, e) => {
  e.series.forEach((i) => {
    Array.isArray(t) ? i.additionalTooltipFields = t : typeof t == "string" ? i.additionalTooltipFields = t.trim() === "" ? [] : [t] : i.additionalTooltipFields = [];
  });
};
class ne extends z {
  constructor() {
    super(...arguments), this._chartType = _.ScatterSeries;
  }
  async setup(e) {
    await this.loadConfigFromLayer(e), typeof this.resolveSetup == "function" && this.resolveSetup();
  }
  // ---------------------------------------------------------------------------------------------
  // #region Data Props
  // ---------------------------------------------------------------------------------------------
  /**
   * X-axis field.
   */
  get xAxisField() {
    return m(this._config);
  }
  set xAxisField(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      j({ fieldName: e, config: this._config, layerInfo: this.layerInfo, commonStrings: this.commonStrings }), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("xAxisField");
    });
  }
  /**
   * Y-axis field.
   */
  get yAxisField() {
    return u(this._config);
  }
  set yAxisField(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      H({ fieldName: e, config: this._config, layerInfo: this.layerInfo, commonStrings: this.commonStrings }), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("yAxisField");
    });
  }
  /**
   * Whether the linear trend line is shown.
   */
  get showLinearTrend() {
    return Q(this._config);
  }
  set showLinearTrend(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      ee(e, this._config), this.emitConfigUpdate("showLinearTrend");
    });
  }
  /**
   * Line symbol for the linear trend line.
   */
  get linearTrendSymbol() {
    return R(this._config);
  }
  set linearTrendSymbol(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      Z(e, this._config), this.emitConfigUpdate("linearTrendSymbol");
    });
  }
  /**
   * Marker symbol used for the scatterplot points when using a fixed symbol (i.e. no size policy is set).
   */
  get fixedMarkerSymbol() {
    return J(this._config);
  }
  set fixedMarkerSymbol(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      K(e, this._config), this.emitConfigUpdate("fixedMarkerSymbol");
    });
  }
  /**
   * Size policy for the scatterplot points. This is used to scale the size of the marker symbol based on a given field.
   */
  get sizePolicy() {
    return T(this._config);
  }
  set sizePolicy(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      const i = T(this._config);
      O(i, e) || (te(e, this._config), this.emitConfigUpdate("sizePolicy"));
    });
  }
  /**
   * Chart overlays. The scatterplot implements only 1 overlay, **trendLine**.
   */
  get seriesOverlays() {
    return ie(this._config);
  }
  set seriesOverlays(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      e !== void 0 && (se(e, this._config), this.emitConfigUpdate("seriesOverlays"));
    });
  }
  /**
   * Additional tooltip display fields.
   *
   * **NOTE**: Only numeric fields are supported.
   */
  get additionalTooltipField() {
    return re(this._config);
  }
  set additionalTooltipField(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      oe(e, this._config), this.emitConfigUpdate("additionalTooltipField");
    });
  }
  // ---------------------------------------------------------------------------------------------
  // #region General Methods
  // ---------------------------------------------------------------------------------------------
  /**
   * Generate the proper chart title given the current config.
   *
   * @returns {string}
   */
  generateChartTitle() {
    return p(this._config, this.layerInfo, this.commonStrings);
  }
  /**
   * Generate the proper x-axis title given the current config.
   *
   * @returns {string}
   */
  generateXAxisTitle() {
    const e = this.xAxisField;
    return l(this.layerInfo.layerFieldsInfo, e);
  }
  /**
   * Generate the proper y-axis title given the current config.
   *
   * @returns {string}
   */
  generateYAxisTitle() {
    const e = this.yAxisField;
    return l(this.layerInfo.layerFieldsInfo, e);
  }
  // ---------------------------------------------------------------------------------------------
  // #region Protected methods
  // ---------------------------------------------------------------------------------------------
  generateDefaultConfig() {
    return U(this.commonStrings);
  }
}
W(ne, [
  D,
  B,
  G,
  N,
  q,
  E,
  V
]);
export {
  ne as ScatterplotModel
};
