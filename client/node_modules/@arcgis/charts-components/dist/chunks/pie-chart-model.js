import { W as n } from "./series-types.js";
import "@arcgis/toolkit/intl";
import { cloneDeep as P } from "lodash-es";
import "d3-array";
import { ak as c, aE as O, ag as h, a2 as C, p as m, cC as o, y as A, aN as I, aG as V } from "./interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import "./runtime.js";
import "@arcgis/toolkit/dom";
import { C as w } from "./model-with-multi-axes.js";
import { b as a, a as l } from "./common.js";
import { M as _, a as x, b as U, c as N } from "./model-with-data-labels.js";
import "@arcgis/core/intl.js";
import { d as v, i as M, m as k } from "./data2.js";
import { g as u, s as G, a as W, c as z, b as B, d as E, e as R, f as K, h as f, i as p, j } from "./pie-chart-data.js";
import { R as g } from "./rest-js-object-literals.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
const q = (t) => t.legend?.displayNumericValue ?? !1, H = (t, e) => {
  e.series[0]?.type === n.PieSeries && (e.legend === void 0 && (e.legend = c()), e.legend.displayNumericValue = t);
}, J = (t) => t.legend?.displayPercentage ?? !1, Q = (t, e) => {
  e.series[0]?.type === n.PieSeries && (e.legend === void 0 && (e.legend = c()), e.legend.displayPercentage = t);
}, X = (t) => t.legend?.labelMaxWidth ?? 200, Y = (t, e) => {
  e.series[0]?.type === n.PieSeries && (e.legend === void 0 && (e.legend = c()), e.legend.labelMaxWidth = t);
};
class b extends _ {
  /**
   * Gets the setting for the display of numerical value in the legend items.
   * @returns {boolean}
   * @remarks
   * This setting is only applicable to pie charts.
   */
  getDisplayNumericValue() {
    return q(this._config);
  }
  /**
   * Sets the setting for the display of numerical value in the legend items.
   * @param displayNumericValue The setting for the display of numerical value in the legend items
   * @remarks
   * This setting is only applicable to pie charts.
   */
  setDisplayNumericValue(e) {
    H(e, this._config), this.emitConfigUpdate("setDisplayNumericValue");
  }
  /**
   * Gets the setting for the display of percentage in the legend items.
   * @returns {boolean}
   * @remarks
   * This setting is only applicable to pie charts.
   */
  getDisplayPercentage() {
    return J(this._config);
  }
  /**
   * Sets the setting for the display of percentage in the legend items.
   * @param displayPercentage The setting for the display of percentage in the legend items
   * @remarks
   * This setting is only applicable to pie charts.
   */
  setDisplayPercentage(e) {
    Q(e, this._config), this.emitConfigUpdate("setDisplayPercentage");
  }
  /**
   * Gets the maximum width in pixel for the legend item labels.
   * @returns {number}
   * @remarks
   * This setting is only applicable to pie charts.
   */
  getLabelMaxWidth() {
    return X(this._config);
  }
  /**
   * Sets the maximum width in pixel for the legend item labels.
   * @param labelMaxWidth The maximum width in pixel for the legend item labels
   * @remarks
   * This setting is only applicable to pie charts.
   */
  setLabelMaxWidth(e) {
    Y(e, this._config), this.emitConfigUpdate("setLabelMaxWidth");
  }
}
v(b, [_]);
const Z = (t) => t.series?.[0]?.innerRadius, $ = (t, e) => {
  e.series?.[0] && (e.series[0].innerRadius = t);
}, ee = (t) => t.series?.[0]?.dataLabelsCharacterLimit, te = (t, e) => {
  e.series?.[0] && (e.series[0].dataLabelsCharacterLimit = t);
}, y = (t) => t.series[0]?.startAngle, ie = (t, e) => {
  e.series?.[0] && (e.series[0].startAngle = t);
}, se = (t, e) => {
  e.series?.[0] && (e.series[0].endAngle = t);
}, re = (t) => t.series?.[0]?.displayCategoryOnTooltip ?? !0, ae = (t) => t.series?.[0]?.displayNumericValueOnTooltip ?? !0, ne = (t) => t.series?.[0]?.displayPercentageOnTooltip ?? !0, oe = (t, e) => {
  e.series[0] && (e.series[0].displayPercentageOnTooltip = t);
}, le = (t) => t.series?.[0]?.valuePrefix, ge = (t, e) => {
  e.series?.[0] && (e.series[0].valuePrefix = t);
}, ce = (t) => t.series?.[0]?.valueSuffix, de = (t, e) => {
  e.series?.[0] && (e.series[0].valueSuffix = t);
}, he = (t) => t.series?.[0]?.percentagePrefix, me = (t, e) => {
  e.series?.[0] && (e.series[0].percentagePrefix = t);
}, ue = (t) => t.series?.[0]?.percentageSuffix, fe = (t, e) => {
  e.series?.[0] && (e.series[0].percentageSuffix = t);
}, pe = (t) => {
  let e;
  const i = t.series?.[0];
  return i?.displayNumericValueOnDataLabel === !0 && i?.displayPercentageOnDataLabel === !0 ? e = a.Both : i?.displayNumericValueOnDataLabel === !0 ? e = a.Value : e = a.Percentage, e;
}, ye = (t, e) => {
  const i = t === a.Value || t === a.Both, s = t === a.Percentage || t === a.Both;
  e.series?.[0] && (e.series[0].displayNumericValueOnDataLabel = i, e.series[0].displayPercentageOnDataLabel = s), e.legend && (e.legend = {
    ...e.legend,
    displayNumericValue: i,
    displayPercentage: s
  });
}, Se = (t) => t.series?.[0]?.alignDataLabels ?? !1, Oe = (t, e) => {
  e.series[0] && (e.series[0].alignDataLabels = t);
}, Ce = (t) => t.series?.[0]?.dataLabelsInside ?? !1, _e = (t, e) => {
  e.series[0] && (e.series[0].dataLabelsInside = t);
}, ve = (t) => t.series?.[0]?.dataLabelsOffset ?? 10, be = (t, e) => {
  e.series[0] && (e.series[0].dataLabelsOffset = t);
}, Le = (t) => t.series?.[0]?.numericValueFormat?.intlOptions?.minimumFractionDigits, Fe = (t, e) => {
  e.series?.[0] && (e.series[0].numericValueFormat ??= h(), e.series[0].numericValueFormat.intlOptions.minimumFractionDigits = t, e.series[0].numericValueFormat.intlOptions.maximumFractionDigits = t, e.series[0].percentValueFormat ??= h(), e.series[0].percentValueFormat.intlOptions.minimumFractionDigits = t, e.series[0].percentValueFormat.intlOptions.maximumFractionDigits = t);
}, De = (t) => t.series?.[0]?.optimizeDataLabelsOverlapping ?? !1, Te = (t, e) => {
  e.series[0] && (e.series[0].optimizeDataLabelsOverlapping = t);
}, Pe = (t) => t.series[0]?.ticks?.visible ?? !1, Ae = (t, e) => {
  e.series?.[0] && (e.series[0].ticks ??= O(), e.series[0].ticks.visible = t);
}, Ie = (t) => t.series[0]?.ticks?.lineSymbol, Ve = (t, e) => {
  t && e.series?.[0] && (e.series[0].ticks ??= O(), e.series[0].ticks.lineSymbol = P(t));
}, we = (t, e) => e.series?.[0]?.slices?.[t]?.originalLabel, xe = (t, e) => e.series?.[0]?.slices?.[t]?.label, Ue = (t, e, i) => {
  i.series?.[0]?.slices?.[e] && (i.series[0].slices[e].label = t);
}, Ne = (t, e) => e.series?.[0]?.slices?.[t]?.fillSymbol?.color, Me = (t, e, i) => {
  const s = i.series?.[0]?.slices?.[e]?.fillSymbol;
  s !== void 0 ? (s.color = t, s.outline !== void 0 ? s.outline.color = t : s.outline = { type: g.SLS, color: t }) : i.series?.[0]?.slices?.[e] !== void 0 && (i.series[0].slices[e].fillSymbol = {
    type: g.SFS,
    color: t,
    outline: { type: g.SLS, color: t }
  });
}, ke = (t) => t.series?.[0]?.slices?.map((e) => e.sliceId), S = (t, e) => {
  e.series?.[0]?.slices?.sort(
    (i, s) => t.findIndex((r) => i.sliceId === r) - t.findIndex((r) => s.sliceId === r)
  );
}, Ge = (t) => t.series?.[0]?.sliceGrouping, L = (t, e) => {
  e.series?.[0] && (e.series[0].sliceGrouping = t);
}, F = (t) => t.series?.[0]?.sliceGrouping?.percentageThreshold, We = (t, e) => {
  e.series?.[0]?.sliceGrouping !== void 0 ? e.series[0].sliceGrouping.percentageThreshold = t : e.series[0].sliceGrouping = {
    sliceId: C.defaultGroupOfSlicesId,
    percentageThreshold: t
  };
}, ze = (t) => t.series?.[0]?.slices, D = (t, e) => {
  e.series?.[0] && (e.series[0].slices = t);
}, Be = (t) => {
  D(void 0, t), L(
    {
      sliceId: C.defaultGroupOfSlicesId,
      percentageThreshold: F(t) ?? 0
    },
    t
  );
}, Ee = (t, e) => e.series[0]?.slices?.[t]?.sliceId, Re = (t, e) => e.series[0]?.slices?.findIndex((i) => i.sliceId === t), Ke = (t) => t.series[0]?.slices?.length ?? 0;
class je extends w {
  constructor() {
    super(...arguments), this._chartType = n.PieSeries, this._mode = l.Category, this._groupedSliceIds = [];
  }
  async setup(e) {
    await this.loadConfigFromLayer(e);
    const { config: i } = e;
    if (i !== void 0) {
      const s = m(i.series);
      this._mode = s !== o.PieFromFields ? l.Category : l.Fields;
    }
    typeof this.resolveSetup == "function" && this.resolveSetup();
  }
  // ---------------------------------------------------------------------------------------------
  // #region Data Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Category field for the pie chart.
   */
  get category() {
    return u(this._config);
  }
  set category(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      (!A(this._config) || e.trim() !== "") && (G({
        newCategory: e,
        config: this._config,
        layerInfo: this.layerInfo,
        commonStrings: this.commonStrings,
        mode: this._mode
      }), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("category"));
    });
  }
  /**
   * Numeric fields for the pie chart.
   */
  get numericFields() {
    return W(this._config);
  }
  set numericFields(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      typeof e == "string" && (e = [e]), (this.layerInfo !== void 0 ? M(this.layerInfo.layerFieldsInfo, e) : !0) ? (z({
        newNumericFields: e,
        config: this._config,
        layerInfo: this.layerInfo,
        commonStrings: this.commonStrings,
        mode: this._mode
      }), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("numericFields")) : console.log("Invalid numericFields");
    });
  }
  /**
   * Aggregation type for the pie chart.
   */
  get aggregationType() {
    return B(this._config, this._mode);
  }
  set aggregationType(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      E({
        newAggregationType: e,
        config: this._config,
        layerInfo: this.layerInfo,
        commonStrings: this.commonStrings,
        mode: this._mode
      }), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("aggregationType");
    });
  }
  /**
   * Gets the sort order for the pie chart.
   * @returns {PieChartDataSortingKinds}
   */
  getSortOrder() {
    return R(this._config, this._mode);
  }
  /**
   * Sets the sort order for the pie chart.
   * @param {PieChartDataSortingKinds} sortOrder The sort order.
   * @param {string[]} orderByList The list of category values.
   */
  setSortOrder(e, i) {
    K({
      newSortOrderKind: e,
      config: this._config,
      orderByList: i
    }), this.emitConfigUpdate("setSortOrder");
  }
  /**
   * List of category's values for custom sort
   */
  get orderByList() {
    return f(this._config, this._mode);
  }
  set orderByList(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      p({
        values: e,
        config: this._config,
        mode: this._mode
      }), this.emitConfigUpdate("orderByList");
    });
  }
  /**
   * The pie chart data mode (Category or Fields).
   * `category` - The chart is using values from the category field to determine each slice.
   * `fields` - The chart is using aggregated values from the numeric fields to determine each slice.
   */
  get mode() {
    return this._mode;
  }
  set mode(e) {
    this._mode = e, this.emitConfigUpdate("mode");
  }
  /**
   * Gets the list of the category values for the chart.
   * @returns {string[]}
   */
  async getCustomSortValues() {
    const e = u(this._config), i = m(this._config.series);
    let s = [];
    return i === o.PieFromFields ? s = this.numericFields : e.trim() !== "" && i === o.PieFromCategory && (s = await k({
      category: e,
      config: this._config,
      layerInfo: this.layerInfo
    })), s;
  }
  /**
   * Moves the custom sort values in-place for the order by list in the config.
   * **Note:** This method should be only used when the sort order is set to `customSort`.
   * @param {number} fromIndex The index to move the custom sort item from.
   * @param {number} toIndex The index to move the category item to.
   */
  moveCustomSortValuesInOrderByList(e, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      const s = f(this._config, this._mode), [r] = s.splice(e, 1);
      s.splice(i, 0, r), p({
        values: s,
        config: this._config,
        mode: this._mode
      }), this.emitConfigUpdate("moveCustomSortValuesInOrderByList");
    });
  }
  // ---------------------------------------------------------------------------------------------
  // #region Format Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Ticks symbol connecting slices to labels.
   */
  get ticksSymbol() {
    return Ie(this._config);
  }
  set ticksSymbol(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      Ve(e, this._config), this.emitConfigUpdate("ticksSymbol");
    });
  }
  // ---------------------------------------------------------------------------------------------
  // #region Slices Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Array of slices for the pie chart.
   */
  get slices() {
    return ze(this._config);
  }
  set slices(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      D(e, this._config), this.emitConfigUpdate("slices");
    });
  }
  /**
   * Array of grouped slice ids for the pie chart.
   */
  get groupedSliceIds() {
    return this._groupedSliceIds;
  }
  set groupedSliceIds(e) {
    this._groupedSliceIds = e, this.emitConfigUpdate("groupedSliceIds");
  }
  /**
   * Slice grouping configuration for the pie chart.
   */
  get sliceGrouping() {
    return Ge(this._config);
  }
  set sliceGrouping(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      L(e, this._config), this.emitConfigUpdate("sliceGrouping");
    });
  }
  /**
   * Inner radius size for the pie chart.
   */
  get innerRadiusSize() {
    return Z(this._config) ?? 0;
  }
  set innerRadiusSize(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      $(e, this._config), this.emitConfigUpdate("innerRadiusSize");
    });
  }
  /**
   * Threshold below which slices will be grouped.
   */
  get groupingThreshold() {
    return F(this._config) ?? 0;
  }
  set groupingThreshold(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      We(e, this._config), this.emitConfigUpdate("groupingThreshold");
    });
  }
  /**
   * Character limit for the slice labels.
   */
  get labelCharacterLimit() {
    return ee(this._config) ?? null;
  }
  set labelCharacterLimit(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      te(e, this._config), this.emitConfigUpdate("labelCharacterLimit");
    });
  }
  /**
   * Number of decimal places to display in the slice values.
   */
  get decimalPlaces() {
    return Le(this._config) ?? 1;
  }
  set decimalPlaces(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      Fe(e, this._config), this.emitConfigUpdate("decimalPlaces");
    });
  }
  /**
   * Display type for the pie chart slices. Specifies whether to display the slices as a percentage, value, or both.
   */
  get displayType() {
    return pe(this._config);
  }
  set displayType(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      ye(e, this._config), this.emitConfigUpdate("displayType");
    });
  }
  // ---------------------------------------------------------------------------------------------
  // #region Protected methods
  // ---------------------------------------------------------------------------------------------
  generateDefaultConfig() {
    const e = I(this.commonStrings);
    return e.series = [V(this.commonStrings, this.layerInfo?.objectIdField)], e;
  }
  // ---------------------------------------------------------------------------------------------
  // #region Series Methods
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets the original name of the slice based on the slice index.
   * @param {number} sliceIndex - The index of the slice.
   * @returns {Date | number | string | null | undefined}
   */
  getOriginalSliceName(e) {
    return we(e, this._config);
  }
  /**
   * Gets the name of the slice based on the slice index. If the index is out of bounds, this function will return `undefined`.
   * @param {number} sliceIndex The index of the slice.
   * @returns {string | undefined}
   */
  getSliceName(e) {
    return xe(e, this._config);
  }
  /**
   * Sets name of the slice based on the slice index.
   * @param {string} name The name for the slice.
   * @param {number} sliceIndex The index of the slice.
   */
  setSliceName(e, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      Ue(e, i, this._config), this.emitConfigUpdate("setSliceName");
    });
  }
  /**
   * Gets the color of the slice based on the slice index. If the index is out of bounds, this function will return `undefined`.
   * @param {number} sliceIndex The index of the slice.
   * @returns {Color | undefined}
   */
  getSliceColor(e) {
    return Ne(e, this._config);
  }
  /**
   * Sets the color of the slice based on the slice index.
   * @param {Color | undefined} color The color for the slice.
   * @param {number} sliceIndex The index of the slice.
   */
  setSliceColor(e, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      Me(e, i, this._config), this.emitConfigUpdate("setSliceColor");
    });
  }
  /**
   * Order of the slice array by returning an array of slice ids
   */
  get orderOfSlices() {
    return ke(this._config);
  }
  set orderOfSlices(e) {
    e !== void 0 && this.guardSetterFromAsyncOverwrite(() => {
      S(e, this._config), this.emitConfigUpdate("orderOfSlices");
    });
  }
  /**
   * Moves a series from one index in the series array to another.
   * @param {number} fromIndex Index to move the series from.
   * @param {number} toIndex Index to move the series to.
   */
  moveSeries(e, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      const s = this.orderOfSlices;
      if (s !== void 0) {
        const [r] = s.splice(e, 1);
        s.splice(i, 0, r), S(s, this._config), this.emitConfigUpdate("moveSeries");
      }
    });
  }
  /**
   * Gets the slice id for a given slice index. If the index is out of bounds, this function will return `undefined`.
   * @param {number} sliceIndex The index of the slice.
   * @returns {string | undefined}
   */
  getSliceId(e) {
    return Ee(e, this._config);
  }
  /**
   * Gets the slice index for a given slice id. If the `sliceId` is not found, this function will return `undefined`.
   * @param {string} sliceId The id of the slice.
   * @returns {number | undefined}
   */
  getSliceIndex(e) {
    return Re(e, this._config);
  }
  /**
   * Gets the length of the slices array.
   * @returns {number}
   */
  getSlicesLength() {
    return Ke(this._config);
  }
  /**
   * Resets the slices styling to the default styling.
   */
  resetSlices() {
    this.guardSetterFromAsyncOverwrite(() => {
      Be(this._config), this.emitConfigUpdate("resetSlices");
    });
  }
  /**
   * Returns whether the series styling is able to be reset.
   * @returns {boolean}
   */
  resetAvailable() {
    const e = !this.colorMatch;
    let i = !1;
    const s = this.slices?.length ?? 0;
    for (let r = 0; r < s; r += 1) {
      const d = this.getOriginalSliceName(r), T = this.getSliceName(r);
      if (d !== void 0 && d?.toString() !== T?.toString()) {
        i = !0;
        break;
      }
    }
    return this.sliceGrouping?.originalLabel !== void 0 && this.sliceGrouping?.label !== this.sliceGrouping.originalLabel && (i = !0), e || i;
  }
  /**
   * Visibility of the ticks.
   */
  get ticksVisibility() {
    return Pe(this._config);
  }
  set ticksVisibility(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      Ae(e, this._config), this.emitConfigUpdate("ticksVisibility");
    });
  }
  /**
   * Start angle of the pie chart.
   */
  get startAngle() {
    return y(this._config);
  }
  set startAngle(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      ie(e, this._config), this.emitConfigUpdate("startAngle");
    });
  }
  /**
   * End angle of the pie chart.
   */
  get endAngle() {
    return y(this._config);
  }
  set endAngle(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      se(e, this._config), this.emitConfigUpdate("endAngle");
    });
  }
  /**
   * Display category value on tooltip setting from the chart config.
   * @remarks If the setting is not found in the config, it will default to `true`.
   */
  get displayCategoryValueOnTooltip() {
    return re(this._config);
  }
  set displayCategoryValueOnTooltip(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      this._config.series[0].displayCategoryOnTooltip = e, this.emitConfigUpdate("displayCategoryValueOnTooltip");
    });
  }
  /**
   * Display numeric value on tooltip setting from the chart config.
   * @remarks If the setting is not found in the config, it will default to `true`.
   */
  get displayNumericValueOnTooltip() {
    return ae(this._config);
  }
  set displayNumericValueOnTooltip(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      this._config.series[0].displayNumericValueOnTooltip = e, this.emitConfigUpdate("displayNumericValueOnTooltip");
    });
  }
  /**
   * Display percentage on tooltip setting from the chart config.
   * @remarks If the setting is not found in the config, it will default to `true`.
   */
  get displayPercentageOnTooltip() {
    return ne(this._config);
  }
  set displayPercentageOnTooltip(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      oe(e, this._config), this.emitConfigUpdate("displayPercentageOnTooltip");
    });
  }
  /**
   * Prefix of the values of the slices.
   */
  get valuePrefix() {
    return le(this._config);
  }
  set valuePrefix(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      ge(e, this._config), this.emitConfigUpdate("valuePrefix");
    });
  }
  /**
   * Suffix of the values of the slice.
   */
  get valueSuffix() {
    return ce(this._config);
  }
  set valueSuffix(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      de(e, this._config), this.emitConfigUpdate("valueSuffix");
    });
  }
  /**
   * Prefix of the percentages of the slices.
   */
  get percentagePrefix() {
    return he(this._config);
  }
  set percentagePrefix(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      me(e, this._config), this.emitConfigUpdate("percentagePrefix");
    });
  }
  /**
   * Suffix of the percentages of the slices.
   */
  get percentageSuffix() {
    return ue(this._config);
  }
  set percentageSuffix(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      fe(e, this._config), this.emitConfigUpdate("percentageSuffix");
    });
  }
  /**
   * Offset for the data labels.
   */
  get dataLabelsOffset() {
    return ve(this._config);
  }
  set dataLabelsOffset(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      be(e, this._config), this.emitConfigUpdate("dataLabelsOffset");
    });
  }
  /**
   * Align data labels setting for the pie chart.
   */
  get alignDataLabels() {
    return Se(this._config);
  }
  set alignDataLabels(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      Oe(e, this._config), this.emitConfigUpdate("alignDataLabels");
    });
  }
  /**
   * Setting for placing the data labels inside of the slices.
   */
  get dataLabelsInside() {
    return Ce(this._config);
  }
  set dataLabelsInside(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      _e(e, this._config), this.emitConfigUpdate("dataLabelsInside");
    });
  }
  /**
   * Optimize data labels overlapping setting for the pie chart.
   */
  get optimizeDataLabelsOverlapping() {
    return De(this._config);
  }
  set optimizeDataLabelsOverlapping(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      Te(e, this._config), this.emitConfigUpdate("optimizeDataLabelsOverlapping");
    });
  }
  // ---------------------------------------------------------------------------------------------
  // #region General Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Generate the proper chart title given the current config.
   *
   * @returns {string}
   */
  generateChartTitle() {
    return j({
      config: this._config,
      layerInfo: this.layerInfo,
      commonStrings: this.commonStrings,
      mode: this._mode
    });
  }
}
v(je, [b, x, U, N]);
export {
  je as PieChartModel
};
