import { fetchT9nStringsBundle as _, getElementLocale as C } from "@arcgis/toolkit/intl";
import { cloneDeep as X } from "lodash-es";
import { W as p, o as v } from "./series-types.js";
import "d3-array";
import { ac as x, b5 as g, aa as f, cr as N, p as R, g as E, ba as k, ak as z, ab as W, ad as H, j as Y, a8 as y } from "./interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import { g as P } from "./runtime.js";
import "@arcgis/toolkit/dom";
import "@arcgis/core/intl.js";
import { R as u } from "./rest-js-object-literals.js";
import { c as Z, b as j } from "./index4.js";
import { G as c } from "./common.js";
import { g as b, K as A, L as $, M as q, N as K, O as Q, P as J, Q as tt, R as it, S as et, T as st, U as rt, V as ot, W as nt, X as at, Y as gt, Z as ct, _ as lt, $ as ut, a0 as ht, a1 as ft, a2 as dt, a3 as mt, j as xt, a4 as yt, a5 as bt, a as T, a6 as L, a7 as F, a8 as V, a9 as h, s as m, aa as St, ab as w, ac as G, ad as pt, ae as _t, af as Ct, ag as vt, d as S, ah as r, ai as At, aj as Tt, ak as Lt, al as Ft, am as Vt, an as wt, ao as Gt, ap as Ut, aq as Ot, ar as Bt, as as Dt, at as It, au as Mt, av as Xt, aw as Nt, ax as Rt, ay as Et } from "./data2.js";
import { getAssetPath as kt } from "@esri/calcite-components";
import { c as zt } from "./index.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
const Wt = (e) => e.title?.content, Ht = (e, t) => {
  if (e) {
    const i = b(t);
    t.title === void 0 && (t.title = x({
      text: "",
      visible: !0,
      font: f(g.ChartTitle),
      type: g.ChartTitle
    })), t.title.content = e, t.title.content.text = i;
  }
}, Yt = (e) => e.subtitle?.content, Pt = (e, t) => {
  if (e) {
    const i = b(t);
    t.subtitle === void 0 && (t.subtitle = x({
      text: "",
      visible: !0,
      font: f(g.ChartSubtitle),
      type: g.ChartSubtitle
    })), t.subtitle.content = e, t.subtitle.content.text = i;
  }
}, Zt = (e) => e.footer?.content, jt = (e, t) => {
  if (e) {
    const i = A(t);
    t.footer === void 0 && (t.footer = x({
      text: "",
      visible: !0,
      font: f(g.DescriptionText),
      type: g.DescriptionText
    })), t.footer.content = e, t.footer.content.text = i;
  }
}, $t = (e) => e.background, qt = (e, t) => {
  t.background = e;
};
class U extends EventTarget {
  constructor() {
    super(...arguments), this.dirtyAsyncSetters = [], this.asyncConfigUpdateInProgress = !1, this.dataStore = {}, this.setupFinished = new Promise((t) => {
      this.resolveSetup = t;
    });
  }
  /**
   * Checks if the current chart model is for the same chart as another chart model.
   * @param {ChartModel | undefined} otherModel The other chart model to compare to.
   */
  isSameChartAs(t) {
    const i = t?.layer;
    return i !== void 0 && this._config.id === t?.chartId && this.layerInfo?.layer.id === i.id;
  }
  /**
   * The current chart configuration object.
   */
  get config() {
    return this._config;
  }
  set config(t) {
    this.guardSetterFromAsyncOverwrite(() => {
      this._config = t, this.emitConfigUpdate("config");
    });
  }
  /**
   * The chart type.
   */
  get chartType() {
    return this._chartType;
  }
  /**
   * The associated layer.
   */
  get layer() {
    return this.layerInfo?.layer;
  }
  /**
   * The chart ID.
   */
  get chartId() {
    return this._config.id;
  }
  set chartId(t) {
    this._config.id = t;
  }
  //#end region
  // ---------------------------------------------------------------------------------------------
  // #region General Properties
  // ---------------------------------------------------------------------------------------------
  /**
   * The version of the chart configuration.
   */
  get version() {
    return $(this._config);
  }
  /**
   * The chart title text.
   * @type {string}
   */
  get titleText() {
    return b(this._config);
  }
  set titleText(t) {
    this.guardSetterFromAsyncOverwrite(() => {
      q(t, this._config), this.emitConfigUpdate("titleText");
    });
  }
  /**
   * The chart subtitle text.
   * @returns {string}
   */
  get subtitleText() {
    return K(this._config);
  }
  set subtitleText(t) {
    this.guardSetterFromAsyncOverwrite(() => {
      Q(t, this._config), this.emitConfigUpdate("subtitleText");
    });
  }
  /**
   * The chart description text.
   */
  get descriptionText() {
    return A(this._config);
  }
  set descriptionText(t) {
    this.guardSetterFromAsyncOverwrite(() => {
      J(t, this._config), this.emitConfigUpdate("descriptionText");
    });
  }
  /**
   * Whether or not the chart title is visible.
   * `true`: Chart title is visible.
   * `false`: Chart title is hidden.
   * **Note:** Even if the title is visible, it may not be displayed if the title text is empty.
   */
  get chartTitleVisibility() {
    return tt(this._config);
  }
  set chartTitleVisibility(t) {
    this.guardSetterFromAsyncOverwrite(() => {
      it(t, this._config), this.emitConfigUpdate("chartTitleVisibility");
    });
  }
  /**
   * Whether or not the chart subtitle is visible.
   * `true`: Chart subtitle is visible.
   * `false`: Chart subtitle is hidden.
   * **Note:** Even if the subtitle is visible, it may not be displayed if the subtitle text is empty.
   */
  get chartSubtitleVisibility() {
    return et(this._config);
  }
  set chartSubtitleVisibility(t) {
    this.guardSetterFromAsyncOverwrite(() => {
      st(t, this._config), this.emitConfigUpdate("chartSubtitleVisibility");
    });
  }
  /**
   * Whether or not the chart description is visible.
   * `true`: Description is visible.
   * `false`: Description is hidden.
   * **Note:** Even if the description is visible, it may not be displayed if the description text is empty.
   */
  get descriptionVisibility() {
    return rt(this._config);
  }
  set descriptionVisibility(t) {
    this.guardSetterFromAsyncOverwrite(() => {
      ot(t, this._config), this.emitConfigUpdate("descriptionVisibility");
    });
  }
  /**
   * The chart renderer.
   */
  get chartRenderer() {
    return nt(this._config);
  }
  set chartRenderer(t) {
    this.guardSetterFromAsyncOverwrite(() => {
      at(t, this._config), this.emitConfigUpdate("chartRenderer");
    });
  }
  // #endregion
  // ---------------------------------------------------------------------------------------------
  //#region Format Properties
  // ---------------------------------------------------------------------------------------------
  /**
   * The title text symbol. Contains styling information such as font, color, and symbol style.
   */
  get titleSymbol() {
    return Wt(this._config);
  }
  set titleSymbol(t) {
    this.guardSetterFromAsyncOverwrite(() => {
      Ht(t, this._config), this.emitConfigUpdate("titleSymbol");
    });
  }
  /**
   * The subtitle text symbol. Contains styling information such as font, color, and symbol style.
   */
  get subtitleSymbol() {
    return Yt(this._config);
  }
  set subtitleSymbol(t) {
    this.guardSetterFromAsyncOverwrite(() => {
      Pt(t, this._config), this.emitConfigUpdate("subtitleSymbol");
    });
  }
  /**
   * The description text symbol. Contains styling information such as font, color, and symbol style.
   */
  get descriptionSymbol() {
    return Zt(this._config);
  }
  set descriptionSymbol(t) {
    this.guardSetterFromAsyncOverwrite(() => {
      jt(t, this._config), this.emitConfigUpdate("descriptionSymbol");
    });
  }
  /**
   * The background color of the chart.
   */
  get backgroundColor() {
    return $t(this._config);
  }
  set backgroundColor(t) {
    this.guardSetterFromAsyncOverwrite(() => {
      qt(t, this._config), this.emitConfigUpdate("backgroundColor");
    });
  }
  // #endregion
  // ---------------------------------------------------------------------------------------------
  //#region Series Methods
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets the visibility of a series.
   * @param seriesIndex The series index
   * @returns {boolean}
   */
  getSeriesVisibility(t) {
    return gt(t, this._config);
  }
  /**
   * Sets the visibility of a series.
   * @param {LegendItemVisibility} props - Visibility options for the series.
   */
  setSeriesVisibility(t) {
    this.guardSetterFromAsyncOverwrite(() => {
      N({ detail: t }, this._config), this.emitConfigUpdate("setSeriesVisibility");
    });
  }
  /**
   * Gets the series ID for a given series index.
   * If the series index is out of bounds, this function will return `undefined`.
   *
   * @param {number} seriesIndex The index of the series.
   * @returns {string | undefined}
   */
  getSeriesId(t) {
    return ct(t, this._config);
  }
  /**
   * Gets the series index for a given series ID.
   * If the series ID is not found, this function will return `undefined`.
   *
   * @param {string} seriesId The ID of the series.
   * @returns {number | undefined}
   */
  getSeriesIndex(t) {
    return lt(t, this._config);
  }
  /**
   * The length of the series array.
   */
  get seriesLength() {
    return ut(this._config);
  }
  /**
   * The chart sub type of the series.
   */
  get chartSubType() {
    return R(this._config.series);
  }
  /**
   * Gets the data tooltip value format for a series.
   *
   * If the series index is out of bounds or the series list is empty, this function will return `undefined`.
   *
   * @param {number} seriesIndex The index of the series to retrieve the value format for.
   * @returns {NumberFormatOptions | undefined}
   */
  getDataTooltipValueFormat(t) {
    return ht(this._config.series, t);
  }
  /**
   * Sets the data tooltip value format for a series.
   *
   * @param {number} seriesIndex The index of the series to set the value format for.
   * @param {NumberFormatOptions | undefined} valueFormat The value format to set.
   */
  setDataTooltipValueFormat(t, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      ft({
        series: this._config.series,
        seriesIndex: t,
        valueFormat: i
      });
    });
  }
  //#endregion
  //---------------------------------------------------------------------------------------------
  // #region Data Properties
  // ---------------------------------------------------------------------------------------------
  /**
   * Whether to fetch `null` values for them to be counted or displayed as categories on the chart.
   */
  get fetchNULLValues() {
    return dt(this._config);
  }
  set fetchNULLValues(t) {
    this.guardSetterFromAsyncOverwrite(() => {
      mt(t, this._config), this.emitConfigUpdate("fetchNULLValues");
    });
  }
  /**
   * The split-by values for the chart.
   */
  get splitByValues() {
    return xt(this._config);
  }
  /**
   * Gets the data filter for the bar chart.
   * @returns {WebChartDataFilters | undefined}
   */
  getDataFilters() {
    return yt(this._config);
  }
  /**
   * Sets the data filter for the chart.
   * @param {WebChartDataFilters | undefined} newDataFilters The new data filter.
   */
  async setDataFilters(t) {
    bt(t, this._config), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("setDataFilters");
  }
  // #endregion
  // ---------------------------------------------------------------------------------------------
  //#region Protected Methods
  // ---------------------------------------------------------------------------------------------
  /**
   * Emits a config update event.
   * @category Protected
   */
  emitConfigUpdate(t) {
    this.dispatchEvent(
      new CustomEvent("arcgisChartsModelConfigChange", {
        detail: { config: this._config, setterName: t }
      })
    );
  }
  /**
   * A function that loads the config based on the provided props.
   * @category Protected
   * @param params.layer The layer to be used as the data source for the chart.
   * @param params.iLayer The layer description to use if the layer is not provided
   * @param params.config The config object to be loaded.
   */
  async loadConfigFromLayer(t) {
    const { layer: i, iLayer: s, config: a } = t;
    this.commonStrings = await _(
      C(document.documentElement).t9nLocale,
      P("./assets/common/t9n"),
      "messages."
    );
    let n = i;
    if (!n && s && (n = await E(s)), n) {
      const l = await k(n, !0), { objectIdField: M } = n;
      this.layerInfo = {
        layer: n,
        layerFieldsInfo: l,
        objectIdField: M
      };
    }
    this._config = a !== void 0 ? await zt(a) : this.generateDefaultConfig(), this._config.legend !== void 0 && this._config.legend?.title === void 0 && (this._config.legend.title = z().title), s && (this._config.iLayer = s);
  }
  /**
   * Guards a setter from being called while an async config update is in progress so that the value being set is not overwritten by the async config update.
   * @param setter The setter callback to call after setup or async config update is finished.
   */
  async guardSetterFromAsyncOverwrite(t) {
    t(), this.asyncConfigUpdateInProgress && (await this.setupFinished, t());
  }
  // #endregion
}
class O extends U {
  /**
   * The x-axis title text.
   */
  get xAxisTitleText() {
    return T(0, this._config);
  }
  set xAxisTitleText(t) {
    this.guardSetterFromAsyncOverwrite(() => {
      L(t, 0, this._config), this.emitConfigUpdate("xAxisTitleText");
    });
  }
  /**
   * Whether the x-axis title is visible.
   * true: X-axis title is visible.
   * false: X-axis title is hidden.
   */
  get xAxisTitleVisibility() {
    return F(0, this._config);
  }
  set xAxisTitleVisibility(t) {
    this.guardSetterFromAsyncOverwrite(() => {
      V(t, 0, this._config), this.emitConfigUpdate("xAxisTitleVisibility");
    });
  }
  /**
   * Maximum bound set for the x-axis. Null indicates no explicit maximum.
   */
  get maxXBound() {
    return h({ config: this._config, axisIndex: 0, isMax: !0 });
  }
  set maxXBound(t) {
    this.guardSetterFromAsyncOverwrite(() => {
      m({ config: this._config, value: t, axisIndex: 0, isMax: !0 }), this.emitConfigUpdate("maxXBound");
    });
  }
  /**
   * Minimum bound set for the x-axis. Null indicates no explicit minimum.
   */
  get minXBound() {
    return h({ config: this._config, axisIndex: 0, isMax: !1 });
  }
  set minXBound(t) {
    this.guardSetterFromAsyncOverwrite(() => {
      St(this._config, t), this.emitConfigUpdate("minXBound");
    });
  }
  /**
   * X-axis title text symbol (font, color, style).
   */
  get xAxisTitleSymbol() {
    return w(this._config, 0);
  }
  set xAxisTitleSymbol(t) {
    this.guardSetterFromAsyncOverwrite(() => {
      G({ symbol: t, axisIndex: 0, config: this._config }), this.emitConfigUpdate("xAxisTitleSymbol");
    });
  }
  /**
   * Axis labels text symbol (font, color, style).
   */
  get axisLabelsSymbol() {
    return pt(this._config);
  }
  set axisLabelsSymbol(t) {
    this.guardSetterFromAsyncOverwrite(() => {
      _t(t, this._config), this.emitConfigUpdate("axisLabelsSymbol");
    });
  }
  /**
   * Axis lines symbol (line width, style, color).
   */
  get axisLinesSymbol() {
    return Ct(this._config);
  }
  set axisLinesSymbol(t) {
    this.guardSetterFromAsyncOverwrite(() => {
      vt(t, this._config), this.emitConfigUpdate("axisLinesSymbol");
    });
  }
}
const Kt = (e) => {
  for (const t of e.axes ?? [])
    for (const i of t?.guides ?? [])
      if (i.label !== void 0)
        return i.label;
}, Qt = (e, t) => {
  for (const i of t.axes ?? [])
    for (const s of i?.guides ?? []) {
      const a = s.label?.text ?? "";
      s.label = X(e), s.label !== void 0 && (s.label.text = a);
    }
};
function o(e) {
  return {
    ...e,
    axis: e.orientation === c.X ? e.config.axes?.[0] : e.config.axes?.[1],
    index: e.index ?? 0,
    orientation: e.orientation ?? c.Y
  };
}
const Jt = (e) => {
  const { axis: t, index: i } = o(e);
  return t?.guides?.[i]?.visible ?? !0;
}, ti = (e) => {
  const { visible: t, axis: i, index: s } = o(e);
  i?.guides?.[s] !== void 0 && (i.guides[s].visible = t);
}, B = (e) => {
  const t = Y(e.start, e.end);
  Z(e.style) && t === u.SFS ? e.style = { type: u.SFS, color: e.style.color } : j(e.style) && t === u.SLS && (e.style = { type: u.SLS, color: e.style.color });
}, ii = (e) => {
  const { axis: t, index: i } = o(e);
  return t?.guides?.[i]?.start ?? null;
}, ei = (e) => {
  const { start: t, axis: i, index: s } = o(e);
  i?.guides?.[s] !== void 0 && (i.guides[s].start = t, B(i.guides[s]));
}, si = (e) => {
  const { axis: t, index: i } = o(e);
  return t?.guides?.[i]?.end;
}, ri = (e) => {
  const { end: t, axis: i, index: s } = o(e);
  i?.guides?.[s] !== void 0 && (i.guides[s].end = t, B(i.guides[s]));
}, oi = (e) => {
  const { axis: t, index: i } = o(e);
  return t?.guides?.[i]?.name;
}, ni = (e) => {
  const { name: t, axis: i, index: s } = o(e);
  i?.guides?.[s] !== void 0 && (i.guides[s].name = t);
}, ai = (e) => {
  const { axis: t, index: i } = o(e);
  return t?.guides?.[i]?.label?.text;
}, gi = (e) => {
  const { labelText: t, axis: i, index: s } = o(e), a = i?.guides?.[s]?.label ?? W(t, f(g.GuideLabel), g.GuideLabel);
  i?.guides?.[s] !== void 0 && (i.guides[s].label = { ...a, text: t });
}, ci = (e) => {
  const { axis: t, index: i } = o(e);
  return t?.guides?.[i]?.above ?? !1;
}, li = (e) => {
  const { above: t, axis: i, index: s } = o(e);
  i?.guides?.[s] !== void 0 && (i.guides[s].above = t);
}, ui = (e) => {
  const { axis: t, index: i } = o(e);
  return t?.guides?.[i]?.style;
}, hi = (e) => {
  const { style: t, axis: i, index: s } = o(e);
  i?.guides?.[s] !== void 0 && (i.guides[s].style = t);
}, D = (e) => {
  const { config: t, name: i, index: s, orientation: a } = e, n = a === c.X ? t.axes?.[0] : t.axes?.[1];
  if (n !== void 0) {
    n.guides = n.guides ?? [];
    const l = {
      type: p.Guide,
      name: i,
      start: n.valueFormat.type === p.DateAxisFormat ? "" : 0,
      style: H()
    };
    s !== void 0 && s < n.guides.length ? n.guides.splice(s, 0, l) : n.guides.push(l);
  }
}, I = (e) => {
  const { config: t, index: i, orientation: s } = e, a = s === c.X ? t.axes?.[0] : t.axes?.[1];
  a?.guides !== void 0 && (i !== void 0 && i < a.guides.length ? a.guides.splice(i, 1) : a.guides.pop());
}, fi = (e) => {
  const { axis: t, index: i } = o(e);
  return t?.guides?.[i]?.tooltipReverseColor ?? !1;
}, di = (e) => {
  const { reverseColor: t, axis: i, index: s } = o(e);
  i?.guides?.[s] !== void 0 && (i.guides[s].tooltipReverseColor = t);
};
class d extends U {
  /**
   * The guide labels text symbol (font, color, style).
   * @returns {WebChartTextSymbol | undefined}
   */
  get guideLabelsSymbol() {
    return Kt(this._config);
  }
  set guideLabelsSymbol(t) {
    this.guardSetterFromAsyncOverwrite(() => {
      Qt(t, this._config), this.emitConfigUpdate("guideLabelsSymbol");
    });
  }
  /**
   * Gets whether a guide is visible.
   * @param {number} [index] Default `0`. The index of the guide in the list of guides for the given axis orientation.
   * @param {GuideOrientation} [orientation] Default `y`. The axis orientation of the guide.
   * @returns {boolean}
   */
  getGuideVisibility(t, i) {
    return Jt({ config: this._config, index: t, orientation: i });
  }
  /**
   * Sets whether a guide is visible
   * @param {boolean} visible New visibility to set.
   * @param {number} [index] Default `0`. The index of the guide in the list of guides for the given axis orientation.
   * @param {GuideOrientation} [orientation] Default `y`. The axis orientation of the guide.
   */
  setGuideVisibility(t, i, s) {
    this.guardSetterFromAsyncOverwrite(() => {
      ti({ visible: t, config: this._config, index: i, orientation: s }), this.emitConfigUpdate("setGuideVisibility");
    });
  }
  /**
   * Gets the start value of a guide.
   * @param {number} [index] Default `0`. The index of the guide in the list of guides for the given axis orientation.
   * @param {GuideOrientation} [orientation] Default `y`. The axis orientation of the guide.
   * @returns {Date | number | string | null}
   */
  getGuideStart(t, i) {
    return ii({ config: this._config, index: t, orientation: i });
  }
  /**
   * Sets the start value of a guide.
   * @param {Date | number | string | null} start New start value to set.
   * @param {number} [index] Default `0`. The index of the guide in the list of guides for the given axis orientation.
   * @param {GuideOrientation} [orientation] Default `y`. The axis orientation of the guide.
   */
  setGuideStart(t, i, s) {
    this.guardSetterFromAsyncOverwrite(() => {
      ei({ start: t, config: this._config, index: i, orientation: s }), this.emitConfigUpdate("setGuideStart");
    });
  }
  /**
   * Gets the end value of a guide.
   * @param {number} [index] Default `0`. The index of the guide in the list of guides for the given axis orientation.
   * @param {GuideOrientation} [orientation] Default `y`. The axis orientation of the guide.
   * @returns {Date | number | string | null}
   */
  getGuideEnd(t, i) {
    return si({ config: this._config, index: t, orientation: i });
  }
  /**
   * Sets the end value of a guide.
   * @param {Date | number | string | null | undefined} end New end value to set.
   * @param {number} [index] Default `0`. The index of the guide in the list of guides for the given axis orientation.
   * @param {GuideOrientation} [orientation] Default `y`. The axis orientation of the guide.
   */
  setGuideEnd(t, i, s) {
    this.guardSetterFromAsyncOverwrite(() => {
      ri({ end: t, config: this._config, index: i, orientation: s }), this.emitConfigUpdate("setGuideEnd");
    });
  }
  /**
   * Gets the name of a guide.
   * @param {number} [index] Default `0`. The index of the guide in the list of guides for the given axis orientation.
   * @param {GuideOrientation} [orientation] Default `y`. The axis orientation of the guide.
   * @returns {string | undefined}
   */
  getGuideName(t, i) {
    return oi({ config: this._config, index: t, orientation: i });
  }
  /**
   * Sets the name of a guide.
   * @param {string} name New name to set.
   * @param {number} [index] Default `0`. The index of the guide in the list of guides for the given axis orientation.
   * @param {GuideOrientation} [orientation] Default `y`. The axis orientation of the guide.
   */
  setGuideName(t, i, s) {
    this.guardSetterFromAsyncOverwrite(() => {
      ni({ name: t, config: this._config, index: i, orientation: s }), this.emitConfigUpdate("setGuideName");
    });
  }
  /**
   * Gets the guide label text.
   * @param {number} [index] Default `0`. The index of the guide in the list of guides for the given axis orientation.
   * @param {GuideOrientation} [orientation] Default `y`. The axis orientation of the guide.
   * @returns {string | undefined}
   */
  getGuideLabelText(t, i) {
    return ai({ config: this._config, index: t, orientation: i });
  }
  /**
   * Sets the guide label text.
   * @param {string} labelText New label text to set.
   * @param {number} [index] Default `0`. The index of the guide in the list of guides for the given axis orientation.
   * @param {GuideOrientation} [orientation] Default `y`. The axis orientation of the guide.
   */
  setGuideLabelText(t, i, s) {
    this.guardSetterFromAsyncOverwrite(() => {
      gi({ labelText: t, config: this._config, index: i, orientation: s }), this.emitConfigUpdate("setGuideLabelText");
    });
  }
  /**
   * Gets whether the guide should be rendered above the other chart elements.
   * @param {number} [index] Default `0`. The index of the guide in the list of guides for the given axis orientation.
   * @param {GuideOrientation} [orientation] Default `y`. The axis orientation of the guide.
   * @returns {boolean}
   */
  getGuideAbove(t, i) {
    return ci({ config: this._config, index: t, orientation: i });
  }
  /**
   * Sets whether the guide should be rendered above the other chart elements.
   * @param {boolean} above New above boolean to set.
   * @param {number} [index] Default `0`. The index of the guide in the list of guides for the given axis orientation.
   * @param {GuideOrientation} [orientation] Default `y`. The axis orientation of the guide.
   */
  setGuideAbove(t, i, s) {
    this.guardSetterFromAsyncOverwrite(() => {
      li({ above: t, config: this._config, index: i, orientation: s }), this.emitConfigUpdate("setGuideAbove");
    });
  }
  /**
   * Gets the guide style.
   * @param {number} [index] Default `0`. The index of the guide in the list of guides for the given axis orientation.
   * @param {GuideOrientation} [orientation] Default `y`. The axis orientation of the guide.
   * @returns {ISimpleFillSymbol | ISimpleLineSymbol | undefined}
   */
  getGuideStyle(t, i) {
    return ui({ config: this._config, index: t, orientation: i });
  }
  /**
   * Sets the guide style.
   * @param {ISimpleFillSymbol | ISimpleLineSymbol} style New style to set.
   * @param {number} [index] Default `0`. The index of the guide in the list of guides for the given axis orientation.
   * @param {GuideOrientation} [orientation] Default `y`. The axis orientation of the guide.
   */
  setGuideStyle(t, i, s) {
    this.guardSetterFromAsyncOverwrite(() => {
      hi({ style: t, config: this._config, index: i, orientation: s }), this.emitConfigUpdate("setGuideStyle");
    });
  }
  /**
   * Gets whether the tooltip text color should be reversed for a guide.
   * @param index - The index of the guide in the list of guides for the given axis orientation.
   * @param orientation - The axis orientation of the guide.
   * @returns {boolean}
   */
  getTooltipReverseColor(t, i) {
    return fi({ config: this._config, index: t, orientation: i });
  }
  /**
   * Sets whether the tooltip text color should be reversed for a guide.
   * @param reverseColor - New reverseColor boolean to set.
   * @param index - The index of the guide in the list of guides for the given axis orientation.
   * @param orientation - The axis orientation of the guide.
   */
  setTooltipReverseColor(t, i, s) {
    this.guardSetterFromAsyncOverwrite(() => {
      di({ reverseColor: t, config: this._config, index: i, orientation: s }), this.emitConfigUpdate("setTooltipReverseColor");
    });
  }
}
class mi extends d {
  // ---------------------------------------------------------------------------------------------
  // Guides Methods
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets the number guides in the X-axis guides list.
   * @returns {number | undefined} The number of X-axis guides.
   */
  getXGuidesLength() {
    return this._config.axes?.[0]?.guides?.length;
  }
  /**
   * Adds an X-axis guide.
   * @param {string} name The name of the guide.
   * @param {number} [index] The index to insert the new guide in the list of X-axis guides. If left `undefined`, the guide is appended to the end of the list.
   */
  addXAxisGuide(t, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      D({
        config: this._config,
        name: t,
        index: i,
        orientation: c.X
      }), this.emitConfigUpdate("addXAxisGuide");
    });
  }
  /**
   * Deletes an X-axis guide.
   * @param {number} [index] The index of the guide to delete in the list of X-axis guides. If left `undefined`, the last guide in the list is deleted.
   */
  deleteXAxisGuide(t) {
    this.guardSetterFromAsyncOverwrite(() => {
      I({
        config: this._config,
        index: t,
        orientation: c.X
      }), this.emitConfigUpdate("deleteXAxisGuide");
    });
  }
}
S(mi, [d]);
class xi extends d {
  /**
   * Gets the number guides in the Y-axis guides list.
   * @returns {number | undefined} The number of Y-axis guides.
   */
  getYGuidesLength() {
    return this._config.axes?.[1]?.guides?.length;
  }
  /**
   * Adds a Y-axis guide.
   * @param {string} name The name of the guide.
   * @param {number} [index] The index to insert the new guide in the list of Y-axis guides. If left `undefined`, the guide is appended to the end of the list.
   */
  addYAxisGuide(t, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      D({
        config: this._config,
        name: t,
        index: i,
        orientation: c.Y
      }), this.emitConfigUpdate("addYAxisGuide");
    });
  }
  /**
   * Deletes a Y-axis guide.
   * @param {number} [index] The index of the guide to delete in the list of Y-axis guides. If left `undefined`, the last guide in the list is deleted.
   */
  deleteYAxisGuide(t) {
    this.guardSetterFromAsyncOverwrite(() => {
      I({
        config: this._config,
        index: t,
        orientation: c.Y
      }), this.emitConfigUpdate("deleteYAxisGuide");
    });
  }
}
S(xi, [d]);
const yi = (e) => e.horizontalAxisLabelsBehavior ?? v.Rotate, bi = (e, t) => {
  t.horizontalAxisLabelsBehavior = e;
}, Si = (e) => e.verticalAxisLabelsBehavior ?? v.Wrap, pi = (e, t) => {
  t.verticalAxisLabelsBehavior = e;
}, _i = (e) => e.cursorCrosshair?.horizontalLineVisible ?? !1, Ci = (e, t) => {
  t.cursorCrosshair === void 0 && (t.cursorCrosshair = y()), t.cursorCrosshair.horizontalLineVisible = e;
}, vi = (e) => e.cursorCrosshair?.verticalLineVisible ?? !1, Ai = (e, t) => {
  t.cursorCrosshair === void 0 && (t.cursorCrosshair = y()), t.cursorCrosshair.verticalLineVisible = e;
}, Ti = (e) => e.cursorCrosshair?.style, Li = (e, t) => {
  t.cursorCrosshair === void 0 && (t.cursorCrosshair = y()), t.cursorCrosshair.style = e;
}, Fi = (e) => e.cursorCrosshair, Vi = (e, t) => {
  t.cursorCrosshair = e;
};
class wi extends O {
  /**
   * Gets the title text of the specified axis.
   * @param {number} axisIndex The index of the axis (0 for X-axis, 1 for Y-axis, 2 for second Y-axis).
   * @returns {string}
   */
  getAxisTitleText(t) {
    return r({
      config: this._config,
      axisIndex: t,
      func: (i) => T(i, this._config)
    }) ?? "";
  }
  /**
   * Sets the title text for the specified axis.
   * **Note:** The title text for the second Y-axis (axisIndex 2) will only be applied if there is a second Y-axis in the chart. To enable the second Y-axis, use the `setAssignToSecondValueAxis(true, 1)` method to assign a series to the second Y-axis.
   * @param {string} titleText The title text for the axis.
   * @param {number} axisIndex The index of the axis (0 for X-axis, 1 for Y-axis, 2 for second Y-axis).
   */
  setAxisTitleText(t, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      r({
        config: this._config,
        axisIndex: i,
        func: (s) => {
          L(t, s, this._config), this.emitConfigUpdate("setAxisTitleText");
        }
      });
    });
  }
  /**
   * Gets the visibility of the specified axis title.
   * @param {number} axisIndex The index of the axis (0 for X-axis, 1 for Y-axis, 2 for second Y-axis).
   * @returns {boolean}
   */
  getAxisTitleVisibility(t) {
    return r({
      config: this._config,
      axisIndex: t,
      func: (i) => F(i, this._config)
    }) ?? !1;
  }
  /**
   * Sets the visibility of the specified axis title.
   * **Note:** The title visibility for the second Y-axis (axisIndex 2) will only be applied if there is a second Y-axis in the chart. To enable the second Y-axis, use the `setAssignToSecondValueAxis(true, 1)` method to assign a series to the second Y-axis.
   * @param {boolean} isVisible The visibility state for the axis title.
   * @param {number} axisIndex The index of the axis (0 for X-axis, 1 for Y-axis, 2 for second Y-axis).
   */
  setAxisTitleVisibility(t, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      r({
        config: this._config,
        axisIndex: i,
        func: (s) => {
          V(t, s, this._config), this.emitConfigUpdate("setAxisTitleVisibility");
        }
      });
    });
  }
  /**
   * Gets the maximum bound for the specified axis.
   * @param {number} axisIndex The index of the axis (0 for X-axis, 1 for Y-axis, 2 for second Y-axis).
   *@returns {number}
   */
  getMaxBound(t) {
    return r({
      config: this._config,
      axisIndex: t,
      func: (i) => h({ config: this._config, axisIndex: i, isMax: !0 })
    }) ?? Number.NaN;
  }
  /**
   * Sets the maximum bound for the specified axis.
   * **Note:** The maximum bound for the second Y-axis (axisIndex 2) will only be applied if there is a second Y-axis in the chart. To enable the second Y-axis, use the `setAssignToSecondValueAxis(true, 1)` method to assign a series to the second Y-axis.
   * @param {number | null} newMaxBound The value to set as the maximum bound.
   * @param {number} axisIndex The index of the axis (0 for X-axis, 1 for Y-axis, 2 for second Y-axis).
   */
  setMaxBound(t, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      r({
        config: this._config,
        axisIndex: i,
        func: (s) => {
          m({ config: this._config, value: t, axisIndex: s, isMax: !0 }), this.emitConfigUpdate("setMaxBound");
        }
      });
    });
  }
  /**
   * Gets the minimum bound for the specified axis.
   * @param {number} axisIndex The index of the axis (0 for X-axis, 1 for Y-axis, 2 for second Y-axis).
   * @returns {number}
   */
  getMinBound(t) {
    return r({
      config: this._config,
      axisIndex: t,
      func: (i) => h({ config: this._config, axisIndex: i, isMax: !1 })
    }) ?? Number.NaN;
  }
  /**
   * Sets the minimum bound for the specified axis.
   * **Note:** The minimum bound for the second Y-axis (axisIndex 2) will only be applied if there is a second Y-axis in the chart. To enable the second Y-axis, use the `setAssignToSecondValueAxis(true, 1)` method to assign a series to the second Y-axis.
   * @param {number | null} newMinBound The value to set as the minimum bound.
   * @param {number} axisIndex The index of the axis (0 for X-axis, 1 for Y-axis, 2 for second Y-axis).
   */
  setMinBound(t, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      r({
        config: this._config,
        axisIndex: i,
        func: (s) => {
          m({ config: this._config, value: t, axisIndex: s, isMax: !1 }), this.emitConfigUpdate("setMinBound");
        }
      });
    });
  }
  /**
   * Gets the value format for the specified axis.
   * @param {number} axisIndex The index of the axis (0 for X-axis, 1 for Y-axis, 2 for second Y-axis).
   * @returns {CategoryFormatOptions | DateTimeFormatOptions | NumberFormatOptions | undefined}
   */
  getAxisValueFormat(t) {
    return r({
      config: this._config,
      axisIndex: t,
      func: (i) => Ft(i, this._config)
    });
  }
  /**
   * Sets the value format for the specified axis.
   * **Note:** The value format for the second Y-axis (axisIndex 2) will only be applied if there is a second Y-axis in the chart. To enable the second Y-axis, use the `setAssignToSecondValueAxis(true, 1)` method to assign a series to the second Y-axis.
   * @param {number} axisIndex The index of the axis (0 for X-axis, 1 for Y-axis, 2 for second Y-axis).
   * @param {CategoryFormatOptions | DateTimeFormatOptions | NumberFormatOptions} valueFormat The value format to set.
   */
  setAxisValueFormat(t, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      r({
        config: this._config,
        axisIndex: t,
        func: (s) => {
          Vt({
            config: this._config,
            valueFormat: i,
            axisIndex: s,
            commonStrings: this.commonStrings
          }), this.emitConfigUpdate("setAxisValueFormat");
        }
      });
    });
  }
  /**
   * Gets whether logarithmic scale is enabled for the specified axis.
   * @param {number} axisIndex The index of the axis (0 for X-axis, 1 for Y-axis, 2 for second Y-axis).
   *
   * `true`: Logarithmic scale is enabled for the specified axis.
   *
   * `false`: Logarithmic scale is disabled for the specified axis.
   *
   * @returns {boolean}
   */
  getLogarithmic(t) {
    return r({
      config: this._config,
      axisIndex: t,
      func: (i) => wt(this._config, i)
    }) ?? !1;
  }
  /**
   * Sets whether logarithmic scale is enabled for the specified axis.
   * `true`: Enable logarithmic scale for the specified axis.
   * `false`: Disable logarithmic scale for the specified axis.
   * **Note:** The logarithmic scale for the second Y-axis (axisIndex 2) will only be applied if there is a second Y-axis in the chart. To enable the second Y-axis, use the `setAssignToSecondValueAxis(true, 1)` method to assign a series to the second Y-axis.
   * @param {boolean} isLogarithmic Whether to enable logarithmic scale for the specified axis.
   * @param {number} axisIndex The index of the axis (0 for X-axis, 1 for Y-axis, 2 for second Y-axis).
   */
  setLogarithmic(t, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      r({
        config: this._config,
        axisIndex: i,
        func: (s) => {
          Gt({
            config: this._config,
            isLogarithmic: t,
            axisIndex: s
          }), this.emitConfigUpdate("setLogarithmic");
        }
      });
    });
  }
  /**
   * Gets the scrollbar configuration for the specified axis.
   * @param {number} axisIndex The index of the axis (0 for X-axis, 1 for Y-axis, 2 for second Y-axis).
   * @returns {WebChartAxisScrollBar | undefined}
   */
  getAxisScrollbar(t) {
    return r({
      config: this._config,
      axisIndex: t,
      func: (i) => this._config.axes?.[i]?.scrollbar
    });
  }
  /**
   * Sets the scrollbar configuration for the specified axis.
   * **Note:** The scrollbar configuration for the second Y-axis (axisIndex 2) will only be applied if there is a second Y-axis in the chart. To enable the second Y-axis, use the `setAssignToSecondValueAxis(true, 1)` method to assign a series to the second Y-axis.
   * @param {WebChartAxisScrollBar} scrollbar The scrollbar configuration to set.
   * @param {number} axisIndex The index of the axis (0 for X-axis, 1 for Y-axis, 2 for second Y-axis).
   */
  setAxisScrollbar(t, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      r({
        config: this._config,
        axisIndex: i,
        func: (s) => {
          Ut({
            config: this._config,
            scrollbar: t,
            axisIndex: s
          }), this.emitConfigUpdate("setAxisScrollbar");
        }
      });
    });
  }
  /**
   * Gets the specified title text symbol. Contains styling information such as font, color, and symbol style.
   * @param {number} axisIndex The index of the axis to get the title symbol for
   * @returns {WebChartTextSymbol | undefined}
   */
  getAxisTitleSymbol(t) {
    return r({
      config: this._config,
      axisIndex: t,
      func: (i) => w(this._config, i)
    });
  }
  /**
   * Sets the title text symbol for the specified axis. Contains styling information such as font, color, and symbol style.
   * **Note:** The title text symbol for the second Y-axis (axisIndex 2) will only be applied if there is a second Y-axis in the chart. To enable the second Y-axis, use the `setAssignToSecondValueAxis(true, 1)` method to assign a series to the second Y-axis.
   * @param {WebChartTextSymbol | undefined} titleSymbol The title text symbol to set.
   * @param {number} axisIndex The index of the axis (0 for X-axis, 1 for Y-axis, 2 for second Y-axis).
   */
  setAxisTitleSymbol(t, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      r({
        config: this._config,
        axisIndex: i,
        func: (s) => {
          G({ symbol: t, config: this._config, axisIndex: s }), this.emitConfigUpdate("setAxisTitleSymbol");
        }
      });
    });
  }
  /**
   * Gets the horizontal axis labels behavior for the chart.
   * @returns {WebChartLabelBehavior}
   */
  getHorizontalAxisLabelsBehavior() {
    return yi(this._config);
  }
  /**
   * Sets the horizontal axis labels behavior for the chart.
   * **Note:** The horizontal axis labels behavior for the second Y-axis (axisIndex 2) will only be applied if there is a second Y-axis in the chart. To enable the second Y-axis, use the `setAssignToSecondValueAxis(true, 1)` method to assign a series to the second Y-axis.
   * @param horizontalBehavior The behavior for the horizontal axis labels.
   */
  setHorizontalAxisLabelsBehavior(t) {
    this.guardSetterFromAsyncOverwrite(() => {
      bi(t, this._config), this.emitConfigUpdate("setHorizontalAxisLabelsBehavior");
    });
  }
  /**
   * Gets the vertical axis labels behavior for the chart.
   * @returns {WebChartLabelBehavior}
   */
  getVerticalAxisLabelsBehavior() {
    return Si(this._config);
  }
  /**
   * Sets the vertical axis labels behavior for the chart.
   * **Note:** The vertical axis labels behavior for the second Y-axis (axisIndex 2) will only be applied if there is a second Y-axis in the chart. To enable the second Y-axis, use the `setAssignToSecondValueAxis(true, 1)` method to assign a series to the second Y-axis.
   * @param verticalBehavior The behavior for the vertical axis labels.
   */
  setVerticalAxisLabelsBehavior(t) {
    this.guardSetterFromAsyncOverwrite(() => {
      pi(t, this._config), this.emitConfigUpdate("setVerticalAxisLabelsBehavior");
    });
  }
  /**
   * Gets the grid lines symbol. Contains styling information such as line width, line style, and line color.
   * @returns {ISimpleLineSymbol | undefined}
   */
  getGridLinesSymbol() {
    return At(this._config);
  }
  /**
   * Sets the grid lines symbol. Contains styling information such as line width, line style, and line color.
   * **Note:** To set the grid lines symbol for the second Y-axis (axisIndex 2), ensure there is a second Y-axis in the chart by using the `setAssignToSecondValueAxis(true, 1)` method to assign a series to the second Y-axis.
   * @param {ISimpleLineSymbol | undefined} linesSymbol The grid lines symbol.
   * @param {number[]} axisIndices The indices of the axes to set the grid lines symbol for.
   */
  setGridLinesSymbol(t, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      Array.isArray(i) && Tt(t, this._config, i), this.emitConfigUpdate("setGridLinesSymbol");
    });
  }
  /**
   * Get the default x-axis title text.
   * @returns {Promise<string>}
   */
  async getDefaultXAxisTitleText() {
    return (await _(
      C(document.documentElement).t9nLocale,
      kt("./assets/common/t9n"),
      "messages."
    )).utilsStrings.statistics.count;
  }
  /**
   * Gets the display zero line setting for the specified axis.
   * @param axisIndex The index of the axis to get the display zero line for.
   * @returns {boolean}
   * @remarks
   * a. This setting is only applicable to the axis of type ValueAxis.
   * b. To get the setting for the x-axis, the axisIndex should be `0`. For the y-axis, the axisIndex should be `1`.
   * c. If the displayZeroLine is not set on the axis, the default value of `false` will be returned.
   */
  getDisplayZeroLine(t) {
    return r({
      config: this._config,
      axisIndex: t,
      func: (i) => Ot(this._config, i)
    }) ?? !1;
  }
  /**
   * Sets the display zero line setting for the specified axis.
   * @param displayZeroLine The display zero line setting for the axis.
   * @param axisIndex The index of the axis to set the display zero line for.
   * @remarks
   * a. This setting is only applicable to the axis of type ValueAxis.
   * b. To set the setting for the x-axis, the axisIndex should be `0`. For the y-axis, the axisIndex should be `1`.
   *
   * **Note:** To set the display zero line for the second Y-axis (axisIndex 2), ensure there is a second Y-axis in the chart by using the `setAssignToSecondValueAxis(true, 1)` method to assign a series to the second Y-axis.
   */
  setDisplayZeroLine(t, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      r({
        config: this._config,
        axisIndex: i,
        func: (s) => {
          Bt(this._config, t, s), this.emitConfigUpdate("setDisplayZeroLine");
        }
      });
    });
  }
  /**
   * Gets the display cursor tooltip setting for the specified axis.
   * @param axisIndex The index of the axis to get the display cursor tooltip for.
   * @returns {boolean}
   * @remarks
   * a. To get the setting for the x-axis, the axisIndex should be `0`. For the y-axis, the axisIndex should be `1`.
   * b. If the displayCursorTooltip is not set on the axis, the default value of `false` will be returned.
   */
  getDisplayCursorTooltip(t) {
    return r({
      config: this._config,
      axisIndex: t,
      func: (i) => Dt(this._config, i)
    }) ?? !1;
  }
  /**
   * Sets the display cursor tooltip setting for the specified axis.
   * @param displayCursorTooltip The display cursor tooltip setting for the axis.
   * @param axisIndex The index of the axis to set the display cursor tooltip for.
   * @remarks
   * a. To set the setting for the x-axis, the axisIndex should be `0`. For the y-axis, the axisIndex should be `1`.
   *
   * **Note:** To set the display cursor tooltip for the second Y-axis (axisIndex 2), ensure there is a second Y-axis in the chart by using the `setAssignToSecondValueAxis(true, 1)` method to assign a series to the second Y-axis.
   */
  setDisplayCursorTooltip(t, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      r({
        config: this._config,
        axisIndex: i,
        func: (s) => {
          It({
            config: this._config,
            displayCursorTooltip: t,
            axisIndex: s
          }), this.emitConfigUpdate("setDisplayCursorTooltip");
        }
      });
    });
  }
  /**
   * Gets the buffer setting for the specified axis.
   * @param axisIndex The index of the axis
   * @returns {boolean}
   * @remarks
   * a. This setting is only applicable to the axis of type ValueAxis.
   * b. To get the setting for the x-axis, the axisIndex should be `0`. For the y-axis, the axisIndex should be `1`.
   * c. If the `buffer` is not set on the axis, the default value of `false` will be returned.
   */
  getBuffer(t) {
    return r({
      config: this._config,
      axisIndex: t,
      func: (i) => Mt(this._config, i)
    }) ?? !1;
  }
  /**
   * Sets the buffer for the specified axis.
   * @param buffer The setting for the buffer
   * @param axisIndex The index of the axis
   * @remarks
   * a. This setting is only applicable to the axis of type ValueAxis.
   * b. To set the setting for the x-axis, the axisIndex should be `0`. For the y-axis, the axisIndex should be `1`.
   *
   * **Note:** To set the buffer for the second Y-axis (axisIndex 2), ensure there is a second Y-axis in the chart by using the `setAssignToSecondValueAxis(true, 1)` method to assign a series to the second Y-axis.
   */
  setBuffer(t, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      r({
        config: this._config,
        axisIndex: i,
        func: (s) => {
          Xt({
            config: this._config,
            buffer: t,
            axisIndex: s
          }), this.emitConfigUpdate("setBuffer");
        }
      });
    });
  }
  /**
   * Gets the tick spacing setting for the specified axis.
   * @param axisIndex The index of the axis
   * @returns {number}
   * @remarks
   * a. To get the setting for the x-axis, the axisIndex should be `0`. For the y-axis, the axisIndex should be `1`.
   */
  getTickSpacing(t) {
    return Lt(this._config, t);
  }
  /**
   * Sets the tick spacing for the specified axis.
   * @param tickSpacing The value to set for the tick spacing
   * @param axisIndex The index of the axis
   * @remarks
   * a. To set the setting for the x-axis, the axisIndex should be `0`. For the y-axis, the axisIndex should be `1`.
   *
   * **Note:** To set the tick spacing for the second Y-axis (axisIndex 2), ensure there is a second Y-axis in the chart by using the `setAssignToSecondValueAxis(true, 1)` method to assign a series to the second Y-axis.
   */
  setTickSpacing(t, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      r({
        config: this._config,
        axisIndex: i,
        func: (s) => {
          Nt({
            config: this._config,
            tickSpacing: t,
            axisIndex: s
          }), this.emitConfigUpdate("setTickSpacing");
        }
      });
    });
  }
  /**
   * Gets the integer only values setting for the specified axis.
   * @param axisIndex The index of the axis
   * @returns {boolean}
   * @remarks
   * a. This setting is only applicable to the axis of type ValueAxis.
   * b. To get the setting for the x-axis, the axisIndex should be `0`. For the y-axis, the axisIndex should be `1`.
   * c. If the `integerOnlyValues` is not set on the axis, the default value of `false` will be returned.
   */
  getIntegerOnlyValues(t) {
    return r({
      config: this._config,
      axisIndex: t,
      func: (i) => Rt(this._config, i)
    }) ?? !1;
  }
  /**
   * Sets the integer only values setting for the specified axis.
   * @param integerOnlyValues The boolean value to set for the integer only values setting
   * @param axisIndex The index of the axis
   * @remarks
   * a. This setting is only applicable to the axis of type ValueAxis.
   * b. To set the setting for the x-axis, the axisIndex should be `0`. For the y-axis, the axisIndex should be `1`.
   *
   * **Note:** To set the integer only values for the second Y-axis (axisIndex 2), ensure there is a second Y-axis in the chart by using the `setAssignToSecondValueAxis(true, 1)` method to assign a series to the second Y-axis.
   */
  setIntegerOnlyValues(t, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      r({
        config: this._config,
        axisIndex: i,
        func: (s) => {
          Et({
            config: this._config,
            integerOnlyValues: t,
            axisIndex: s
          }), this.emitConfigUpdate("setIntegerOnlyValues");
        }
      });
    });
  }
  /**
   * Visibility of the horizontal line of the cursor's crosshair.
   * @remarks if the cursor crosshair or its horizontal line visibility is not set, the default value of `false` will be returned.
   *
   * **Note:** To set the cursor crosshair horizontal line visibility for the second Y-axis (axisIndex 2), ensure there is a second Y-axis in the chart by using the `setAssignToSecondValueAxis(true, 1)` method to assign a series to the second Y-axis.
   */
  get cursorCrosshairHorizontalLineVisibility() {
    return _i(this._config);
  }
  set cursorCrosshairHorizontalLineVisibility(t) {
    this.guardSetterFromAsyncOverwrite(() => {
      Ci(t, this._config), this.emitConfigUpdate("cursorCrosshairHorizontalLineVisibility");
    });
  }
  /**
   * Visibility of the vertical line of the cursor's crosshair.
   * @remarks if the cursor crosshair or its vertical line visibility is not set, the default value of `false` will be returned.
   *
   * **Note:** To set the cursor crosshair vertical line visibility for the second Y-axis (axisIndex 2), ensure there is a second Y-axis in the chart by using the `setAssignToSecondValueAxis(true, 1)` method to assign a series to the second Y-axis.
   */
  get cursorCrosshairVerticalLineVisibility() {
    return vi(this._config);
  }
  set cursorCrosshairVerticalLineVisibility(t) {
    this.guardSetterFromAsyncOverwrite(() => {
      Ai(t, this._config), this.emitConfigUpdate("cursorCrosshairVerticalLineVisibility");
    });
  }
  /**
   * Style of the cursor's crosshair from the chart config.
   * **Note:** To set the cursor crosshair style for the second Y-axis (axisIndex 2), ensure there is a second Y-axis in the chart by using the `setAssignToSecondValueAxis(true, 1)` method to assign a series to the second Y-axis.
   */
  get cursorCrosshairStyle() {
    return Ti(this._config);
  }
  set cursorCrosshairStyle(t) {
    t && this.guardSetterFromAsyncOverwrite(() => {
      Li(t, this._config), this.emitConfigUpdate("cursorCrosshairStyle");
    });
  }
  /**
   * Cursor crosshair from the chart config.
   * **Note:** To set the cursor crosshair for the second Y-axis (axisIndex 2), ensure there is a second Y-axis in the chart by using the `setAssignToSecondValueAxis(true, 1)` method to assign a series to the second Y-axis.
   */
  get cursorCrosshair() {
    return Fi(this._config);
  }
  set cursorCrosshair(t) {
    t && this.guardSetterFromAsyncOverwrite(() => {
      Vi(t, this._config), this.emitConfigUpdate("cursorCrosshair");
    });
  }
}
S(wi, [O]);
export {
  U as C,
  wi as M,
  xi as a,
  mi as b,
  O as c
};
