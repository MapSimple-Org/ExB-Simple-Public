import "@arcgis/toolkit/intl";
import { isEqual as x } from "lodash-es";
import { e as F, W as v, a as l } from "./series-types.js";
import { aB as B, aq as I, aw as O, ai as b, ag as U, b as m, y as M, ci as L } from "./interfaces.js";
import "d3-array";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import "./runtime.js";
import "@arcgis/toolkit/dom";
import { C as T, M as w, b as D, a as P } from "./model-with-multi-axes.js";
import { l as n, j as a, k as g } from "./index4.js";
import { q as V, r as N, t as W, v as k, w as E, x as R, y as z, z as K, A as j, B as q, C as G, b as _, f as h, h as c, u as X, s as f, e as Y, i as H, D as y, E as p, F as u, G as J, H as Q, k as Z, I as S, J as $, d as ee } from "./data2.js";
import { b as C, c as A, a as te } from "./data.js";
import { S as ie } from "./common.js";
import { M as se, a as re, b as oe, c as ne } from "./model-with-data-labels.js";
import { M as ae } from "./model-with-rotation.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
class le extends T {
  /**
   * Time interval size for a temporal bar/line chart.
   */
  get temporalBinningSize() {
    return V(this._config);
  }
  set temporalBinningSize(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      N(e, this._config), this.emitConfigUpdate("temporalBinningSize");
    });
  }
  /**
   * Time interval units for a temporal bar/line chart.
   */
  get temporalBinningUnit() {
    return W(this._config);
  }
  set temporalBinningUnit(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      k(e, this._config), this.emitConfigUpdate("temporalBinningUnit");
    });
  }
  /**
   * Time aggregation type for a temporal bar/line chart.
   */
  get timeAggregationType() {
    return E(this._config);
  }
  set timeAggregationType(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      R(e, this._config), this.emitConfigUpdate("timeAggregationType");
    });
  }
  /**
   * Whether to trim incomplete time intervals for a temporal bar/line chart.
   */
  get trimIncompleteTimeInterval() {
    return z(this._config);
  }
  set trimIncompleteTimeInterval(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      K(e, this._config), this.emitConfigUpdate("trimIncompleteTimeInterval");
    });
  }
  /**
   * Policy which tells the chart how to handle null values.
   *
   * `null`: Break the bar where null values are present.
   *
   * `zero`: Treats null values as zero.
   *
   * `interpolate`: Bar series: same effect as `null` - Line series: connects the lines across null values.
   */
  get nullPolicy() {
    return j(this._config);
  }
  set nullPolicy(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      q(e, this._config), this.emitConfigUpdate("nullPolicy");
    });
  }
  /**
   * Resets the time interval to default for a temporal line chart.
   */
  resetTimeInterval() {
    this.guardSetterFromAsyncOverwrite(() => {
      G(this._config), this.emitConfigUpdate("resetTimeInterval");
    });
  }
}
const ge = (s, e) => e.series?.[s].assignToSecondValueAxis ?? !1, he = (s) => {
  const { assign: e, seriesIndex: t, config: i, commonStrings: r } = s;
  e && i.axes !== void 0 && !i.axes?.[2] && (i.axes[2] = O(r, v.BarSeries)[1]), i.series && i.series.forEach((o, d) => {
    d === t ? o.assignToSecondValueAxis = e : d !== t && o?.assignToSecondValueAxis !== !0 && (o.assignToSecondValueAxis = !1);
  }), i.axes?.[2] && !i.series.some((o) => o.assignToSecondValueAxis) && i.axes.splice(2, 1);
}, ce = (s, e) => e.series?.[s]?.name, de = (s, e, t) => {
  t.series?.[e] && (t.series[e].name = s);
}, me = (s, e) => {
  const t = e.series?.[s];
  let i;
  return n(t) ? i = t.fillSymbol?.color : a(t) && (i = t.lineSymbol?.color), i;
}, fe = (s, e, t) => {
  const i = t.series?.[e];
  i && (n(i) ? i.fillSymbol = {
    ...B(e),
    ...i.fillSymbol,
    color: s
  } : a(i) && (i.lineSymbol = {
    ...I(e),
    ...i.lineSymbol,
    color: s
  }));
}, ye = (s) => s.series.map((e) => e.id), pe = (s, e) => {
  e.series?.sort(
    (t, i) => s.findIndex((r) => t.id === r) - s.findIndex((r) => i.id === r)
  );
}, ue = (s) => s.stackedType ?? F.Side, Se = (s) => {
  const { newStackedType: e, config: t, layerInfo: i, commonStrings: r } = s;
  if (t.stackedType = e, i !== void 0) {
    const o = _({
      config: t,
      layerInfo: i,
      commonStrings: r,
      numericFields: c(t),
      aggregationType: h(t)
    });
    X(t, 1, o);
  }
  t.axes?.[1] && (e === F.Stacked100 ? t.axes[1].valueFormat = b() : t.axes[1].valueFormat = U()), f({ config: t, value: null, axisIndex: 1, isMax: !1 }), f({ config: t, value: null, axisIndex: 1, isMax: !0 });
}, Ce = (s) => {
  let e;
  const t = s.series.find(
    (i) => (n(i) || a(i) || g(i)) && i.nullCategory !== void 0
  );
  return (n(t) || a(t) || g(t)) && (e = t?.nullCategory), e;
}, Ae = (s, e) => {
  s.series.forEach((t) => {
    (n(t) || a(t) || g(t)) && (t.nullCategory = e);
  });
};
class Fe extends T {
  constructor() {
    super(...arguments), this._xAxisField = "", this._aggregationType = l.Count, this._splitByField = "", this._numericFields = [];
  }
  // #endregion
  // ---------------------------------------------------------------------------------------------
  // #region Data Props
  // ---------------------------------------------------------------------------------------------
  /**
   * The x-axis field for the chart.
   */
  get xAxisField() {
    return this._xAxisField;
  }
  set xAxisField(e) {
    if (this._xAxisField = e, this.dirtyAsyncSetters.push("xAxisField"), e.trim() === "" || e === m) {
      const r = this.numericFields;
      this.resetConfig(), this.numericFields = r;
    }
    this.processSeriesRebuild();
  }
  /**
   * The aggregation type for the bar chart. Must be one of the values allowed by `WebChartStatisticType`.
   */
  get aggregationType() {
    return this._aggregationType;
  }
  set aggregationType(e) {
    this._aggregationType = e, this.dirtyAsyncSetters.push("aggregationType"), this.processSeriesRebuild();
  }
  /**
   * The split-by field for the chart.
   */
  get splitByField() {
    return this._splitByField;
  }
  set splitByField(e) {
    this.layerInfo?.layerFieldsInfo && Y(this.layerInfo?.layerFieldsInfo, e) && (this._splitByField = e, this.dirtyAsyncSetters.push("splitByField"), this.processSeriesRebuild());
  }
  /**
   * The numeric fields array for the chart.
   */
  get numericFields() {
    return this._numericFields;
  }
  set numericFields(e) {
    typeof e == "string" && (e = [e]);
    const t = H(this.layerInfo?.layerFieldsInfo ?? [], e), i = (this.xAxisField === "" || this.xAxisField === m) && e.length === 0;
    if (t && !i) {
      const r = this.layerInfo?.objectIdField ?? "";
      e.length === 0 ? (e.push(r), this._aggregationType = l.Count) : this._aggregationType === l.Count && e.length >= 1 && !e.includes(r) && (this._aggregationType = l.Sum), this._numericFields = e, this.dirtyAsyncSetters.push("numericFields"), this.numericFields.length > 1 && (this._splitByField = "", this.dirtyAsyncSetters.push("splitByField")), this.processSeriesRebuild();
    } else i && this.resetConfig();
  }
  /**
   * Gets whether the series should be assigned to the second value axis.
   * @param seriesIndex - The index of the series.
   * @returns {boolean}
   */
  getAssignToSecondValueAxis(e) {
    return ge(e, this._config);
  }
  /**
   * Sets whether the series should be assigned to the second value axis.
   * @param assign - The value for the setting.
   * @param seriesIndex - The index of the series.
   */
  setAssignToSecondValueAxis(e, t) {
    this.guardSetterFromAsyncOverwrite(() => {
      he({ assign: e, seriesIndex: t, config: this._config, commonStrings: this.commonStrings }), this.emitConfigUpdate("setAssignToSecondValueAxis");
    });
  }
  /**
   * Gets the sort order for the bar chart.
   * @returns {"xAxisAsc" | "xAxisDesc" | "yAxisAsc" | "yAxisDesc" | "customSort"}
   */
  getSortOrder() {
    return y(this._config);
  }
  /**
   * Sets the sort order for the bar chart.
   * @param {"xAxisAsc" | "xAxisDesc" | "yAxisAsc" | "yAxisDesc"}  newSortOrder The new sort order.
   * @param {string[]} orderByList The list of category's values to order by.
   */
  setSortOrder(e, t) {
    this.guardSetterFromAsyncOverwrite(() => {
      C(e, this._config, t), this.emitConfigUpdate("setSortOrder");
    });
  }
  /**
   * Gets the list of the category values for the chart.
   * @returns {string[]}
   */
  async getCustomSortValues() {
    return await p(this._config, this.layerInfo);
  }
  /**
   * Sets the data filter for the bar chart.
   * @param {WebChartDataFilters | undefined} newDataFilter The new data filter.
   */
  async setDataFilters(e) {
    super.setDataFilters(e);
    const t = y(this._config);
    if (t === ie.customSort) {
      const i = await p(this._config, this.layerInfo);
      C(t, this._config, i);
    }
    this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("setDataFilter");
  }
  /**
   * The list of custom sort values for custom sort
   */
  get orderByList() {
    return A(this._config);
  }
  set orderByList(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      !M(this._config) && (u(e, this._config), this.emitConfigUpdate("orderByList"));
    });
  }
  /**
   * Updates the series based on the layer filter.
   * @async **This method is `async` and must be awaited for the changes to take effect.**
   */
  async updateSeriesFromLayerFilter() {
    this.layerInfo !== void 0 && (this.dirtyAsyncSetters.push("updateSeriesFromLayerFilter"), await this.processSeriesRebuild());
  }
  /**
   * Whether temporal binning is enabled for all series in the config.
   * **Note:** Setting this prop removes any existing temporal binning settings if `value` is set to `false`.
   */
  get binTemporalData() {
    return J(this._config);
  }
  set binTemporalData(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      Q(e, this._config), this.emitConfigUpdate("enableTemporalBinning");
    });
  }
  // #endregion
  // ---------------------------------------------------------------------------------------------
  // #region Series Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets the name of the series based on the series index.
   * If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {string | undefined}
   */
  getSeriesName(e) {
    return ce(e, this._config);
  }
  /**
   * Sets name of the series based on the series index.
   * @param {string} name The name for the series.
   * @param {number} seriesIndex The index of the series.
   */
  setSeriesName(e, t) {
    this.guardSetterFromAsyncOverwrite(() => {
      de(e, t, this._config), this.emitConfigUpdate("setSeriesName");
    });
  }
  /**
   * Gets the color of the series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {Color | undefined}
   */
  getSeriesColor(e) {
    return me(e, this._config);
  }
  /**
   * Sets the color of the series based on the series index.
   * @param {Color | undefined} newColor The new color for the series.
   * @param {number} seriesIndex The index of the series.
   */
  setSeriesColor(e, t) {
    this.guardSetterFromAsyncOverwrite(() => {
      fe(e, t, this._config), this.emitConfigUpdate("setSeriesColor");
    });
  }
  /**
   * Gets the order of the series array by returning an array of series ids.
   * @returns {string[]}
   */
  getOrderOfSeries() {
    return ye(this._config);
  }
  /**
   * Sets the order of the series array by providing an array of series ids.
   * @param {string[]} newOrder The new order of the series array.
   */
  setOrderOfSeries(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      pe(e, this._config), this.emitConfigUpdate("setOrderOfSeries");
    });
  }
  /**
   * How the bars/lines should be placed when multiple series are rendered in the same chart, say when "split by" operation is executed on any field or
   * when multiple attributes/fields corresponding to the same set of classes are to be visualized.
   *
   * Currently this property is only used for bar and line series.
   *
   * @default sideBySide
   *
   * @returns {WebChartStackedKinds | undefined}
   */
  get stackedType() {
    return ue(this._config);
  }
  set stackedType(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      Se({
        newStackedType: e,
        config: this._config,
        layerInfo: this.layerInfo,
        commonStrings: this.commonStrings
      }), this.emitConfigUpdate("stackedType");
    });
  }
  /**
   * Moves a series from one index in the series array to another.
   * @param {number} fromIndex Index to move the series from.
   * @param {number} toIndex Index to move the series to.
   */
  moveSeries(e, t) {
    this.guardSetterFromAsyncOverwrite(() => {
      const i = this.getOrderOfSeries(), [r] = i.splice(e, 1);
      i.splice(t, 0, r), this.setOrderOfSeries(i), this.emitConfigUpdate("moveSeries");
    });
  }
  /**
   * Moves the custom sort values in-place for the order by list in the config.
   * **Note:** This method should be only used when the sort order is set to `SerialChartDataSortingKinds.customSort`.
   * @param {number} fromIndex The index to move the custom sort value from.
   * @param {number} toIndex The index to move the custom sort value to.
   */
  moveCustomSortValuesInOrderByList(e, t) {
    this.guardSetterFromAsyncOverwrite(() => {
      const i = A(this._config), [r] = i.splice(e, 1);
      i.splice(t, 0, r), u(i, this._config), this.emitConfigUpdate("moveCustomSortValuesInOrderByList");
    });
  }
  /**
   * The null category configuration of the bar chart.
   *
   * @requires the following to be set on the model for the null category to be applied:
   * - `fetchNULLValues` to be set to `true` on the model.
   * - `colorMatch` to be set to `false` on the model
   */
  get nullCategory() {
    return Ce(this._config);
  }
  set nullCategory(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      const t = this.nullCategory;
      x(t, e) || (Ae(this._config, e), this.emitConfigUpdate("setNullCategory"));
    });
  }
  /**
   * Sets up the local props based on the current config.
   * @category Protected
   */
  setupLocalProps() {
    this._xAxisField = te(this._config), this._aggregationType = h(this._config), this._splitByField = Z(this._config), this._numericFields = c(this._config);
  }
  /**
   * Resets the config to the default config
   * @category Protected
   */
  resetConfig() {
    const e = this._config.id;
    this._config = this.generateDefaultConfig(), this._config.id = e, this.setupLocalProps(), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("resetConfig");
  }
  /**
   * Determines if we can rebuild the series synchronously.
   * We can call the build new series function synchronously when either is true:
   * - there is no split-by field
   * - there are multiple numeric fields
   * @category Protected
   */
  canUseSynchronousSeriesRebuild() {
    return this.splitByField === "" || this.numericFields.length > 1;
  }
  /**
   * Processes the series rebuild.
   * If multiple async setters are called in succession, this function will only rebuild the series once after all setters have been called.
   * @category Protected
   * @async
   */
  async processSeriesRebuild() {
    if (this.layerInfo !== void 0) {
      const e = this.dirtyAsyncSetters[this.dirtyAsyncSetters.length - 1];
      if (this.canUseSynchronousSeriesRebuild())
        this.dirtyAsyncSetters = [], S(this.getBuildNewSeriesProps());
      else if (!this.asyncConfigUpdateInProgress) {
        for (this.asyncConfigUpdateInProgress = !0, this.setupFinished = new Promise((t) => {
          this.resolveSetup = t;
        }); this.dirtyAsyncSetters.length > 0; )
          this.dirtyAsyncSetters = [], await S(this.getBuildNewSeriesProps());
        this.asyncConfigUpdateInProgress = !1, this.resolveSetup?.();
      }
      this.setupLocalProps(), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate(e);
    }
  }
  // #endregion
  // #region Private Methods
  /**
   * Gets the properties needed to build a new series array.
   */
  getBuildNewSeriesProps() {
    return {
      xAxisField: this.xAxisField,
      splitByField: this.splitByField,
      numericFields: this.numericFields,
      aggregationType: this.aggregationType,
      config: this._config,
      layerInfo: this.layerInfo,
      commonStrings: this.commonStrings
    };
  }
  // #endregion
  // ---------------------------------------------------------------------------------------------
  // #region Public Methods
  // ---------------------------------------------------------------------------------------------
  /**
   * Generate the proper chart title given the current config.
   */
  generateChartTitle() {
    return this.layerInfo !== void 0 ? $(this._config, this.layerInfo, this.commonStrings) : "";
  }
  /**
   * Generate the proper x-axis title given the current config.
   */
  generateXAxisTitle() {
    return this.layerInfo !== void 0 ? L(this.layerInfo.layerFieldsInfo, this._xAxisField) : "";
  }
  /**
   * Generate the proper y-axis title given the current config.
   */
  generateYAxisTitle() {
    return this.layerInfo !== void 0 ? _({
      config: this._config,
      layerInfo: this.layerInfo,
      commonStrings: this.commonStrings,
      numericFields: c(this._config),
      aggregationType: h(this._config)
    }) : "";
  }
  // #endregion
}
ee(Fe, [
  w,
  se,
  re,
  oe,
  ae,
  ne,
  D,
  P,
  le
]);
export {
  Fe as S,
  de as a,
  ce as g,
  fe as s
};
