import "@arcgis/toolkit/intl";
import { capitalize as c } from "lodash-es";
import { u as g, W as o, a as y, g as p, t as n } from "./series-types.js";
import { bn as A, b as O, d as L, a3 as $, p as D, c7 as N, cC as I, c as _, a as P } from "./interfaces.js";
import "d3-array";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import "./runtime.js";
import "@arcgis/toolkit/dom";
import { a as W, S as a } from "./common.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
const U = (r) => {
  let e = a.xAxisAsc;
  const i = r.orderOptions?.data?.orderType ?? n.Category, s = r.orderOptions?.data?.orderBy ?? p.Ascending;
  return i === n.Category && Array.isArray(s) ? e = a.customSort : i === n.Category ? s === p.Ascending ? e = a.xAxisAsc : e = a.xAxisDesc : s === p.Ascending ? e = a.yAxisAsc : e = a.yAxisDesc, e;
}, v = (r) => {
  const e = g(r.series);
  let i = !1;
  return (e === o.BarSeries || e === o.LineSeries) && (i = U(r) === a.customSort), i;
}, ee = (r) => {
  let e = [];
  const i = r.orderOptions?.data?.orderType;
  return v(r) && i === n.Category && (e = r.orderOptions?.data?.orderBy), e;
}, re = (r, e, i) => {
  let s = n.Category, t = p.Ascending;
  const l = g(e.series);
  e.orderOptions ??= {}, r === a.customSort && i !== void 0 ? (t = [...i], e.orderOptions.data = {
    orderType: s,
    orderBy: t
  }) : (l === o.BarSeries || l === o.LineSeries) && (s = r === a.xAxisAsc || r === a.xAxisDesc ? n.Category : n.YValue, t = r === a.xAxisAsc || r === a.yAxisAsc ? p.Ascending : p.Descending, e.orderOptions.data = {
    orderType: s,
    orderBy: t
  });
}, se = (r) => r?.series?.[0]?.x ?? "", ie = (r) => {
  const {
    config: e,
    xAxisField: i,
    numericFields: s,
    aggregationType: t,
    mode: l,
    layer: f,
    numericFieldIndex: u,
    seriesIndex: C,
    splitByField: h = "",
    fieldList: S
  } = r, b = g(e.series), T = D(e.series), B = f ? N(f).objectIdField : "FID", F = s.length === 1 && s[0] === B;
  let d = "y", m = "y";
  switch (b) {
    case o.PieSeries: {
      t !== y.NoAggregation ? l === W.Category ? (d = `${t}_${s[0]}_0`.toUpperCase(), m = F ? c(y.Count) : c(`${t} of ${s[0]}`)) : d = P : d = s[0];
      break;
    }
    case o.BarSeries:
    case o.LineSeries:
    case o.ComboLineAndBarSeries:
    case o.RadarSeries: {
      if (h === "" || s.length > 1)
        V({
          fieldName: i,
          numericFields: s,
          fieldList: S ?? []
        }) || T === I.BarAndLineFromFields ? d = _ : (d = `${t}_${s[u ?? 0]}_${u ?? 0}`.toUpperCase(), m = F ? c(y.Count) : c(`${t} of ${s[u ?? 0]}`));
      else {
        const x = s[0];
        d = `${t}_${x}_${C ?? 0}`.toUpperCase(), m = F ? c(y.Count) : c(`${t} of ${x}`);
      }
      break;
    }
  }
  return {
    name: d,
    description: m
  };
};
function E(r) {
  const { fieldName: e, fieldList: i } = r, s = A(i ?? [], e);
  return e === O || e === L || e === $ || e === void 0 || e.trim() === "" || s === void 0;
}
function V(r) {
  const { fieldName: e, fieldList: i, numericFields: s } = r, t = s.filter((l) => A(i ?? [], l)?.type !== "esriFieldTypeOID");
  return E({ fieldName: e, fieldList: i }) && (t?.length ?? 0) > 0;
}
export {
  se as a,
  re as b,
  ee as c,
  ie as g,
  V as s,
  E as x
};
