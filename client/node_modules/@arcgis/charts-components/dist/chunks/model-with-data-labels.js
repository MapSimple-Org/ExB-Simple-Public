import { C as d } from "./model-with-multi-axes.js";
import { d as g } from "./series-types.js";
import "@arcgis/toolkit/intl";
import { cloneDeep as h } from "lodash-es";
import "d3-array";
import { ak as o, ac as l, b5 as s, aa as n } from "./interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import "./runtime.js";
import "@arcgis/toolkit/dom";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
const b = (t) => t.colorMatch ?? !0, c = (t, e) => {
  e.colorMatch = t;
};
class $ extends d {
  /**
   * Whether the chart should attempt to match the data source's colors.
   *
   * `true`: Attempt to match the data source's colors.
   *
   * `false`: Use the colors defined in the config.
   */
  get colorMatch() {
    return b(this._config);
  }
  set colorMatch(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      c(e, this._config), this.emitConfigUpdate("colorMatch");
    });
  }
}
const m = (t) => {
  let e = !1;
  return t.legend !== void 0 && (e = t.legend.visible ?? !0), e;
}, v = (t, e) => {
  e.legend === void 0 && (e.legend = o()), e.legend.visible = t;
}, f = (t) => t.legend?.title?.content, p = (t, e) => {
  e.legend === void 0 && (e.legend = o()), (e.legend.title === void 0 || t === void 0) && (e.legend.title = l({
    text: "",
    visible: !0,
    font: n(s.LegendTitle),
    type: s.LegendTitle
  })), t !== void 0 && (e.legend.title.content = t);
}, L = (t) => t.legend?.body, y = (t, e) => {
  e.legend === void 0 && (e.legend = o()), e.legend.body = t ?? l({
    text: "",
    visible: !0,
    font: n(s.LegendText),
    type: s.LegendText
  }).content;
}, a = (t) => t.legend?.title?.content.text ?? "", T = (t, e) => {
  if (e.legend?.title !== void 0)
    e.legend.title.content.text = t;
  else if (e.legend === void 0 && t !== void 0) {
    const i = o();
    i.title !== void 0 && (i.title.content.text = t, i.title.visible = !0, e.legend = i);
  }
}, u = (t) => t.legend?.title?.visible ?? !1, x = (t, e) => {
  if (e.legend?.title !== void 0)
    e.legend.title.visible = t;
  else if (e.legend !== void 0 && e.legend?.title === void 0 && t)
    e.legend.title = l({
      text: a(e),
      visible: t,
      font: n(s.LegendTitle),
      type: s.LegendTitle
    });
  else if (e.legend === void 0) {
    const i = o();
    i.title = l({
      text: a(e),
      visible: t,
      font: n(s.LegendTitle),
      type: s.LegendTitle
    }), e.legend = i;
  }
}, C = (t) => t.legend?.position ?? g.Right, M = (t, e) => {
  if (e.legend !== void 0)
    e.legend.position = t;
  else if (e.legend === void 0) {
    const i = o();
    i.position = t, e.legend = i;
  }
}, _ = (t) => t.legend?.roundMarkers ?? !1, S = (t, e) => {
  e.legend === void 0 && (e.legend = o()), e.legend.roundMarkers = t;
}, V = (t) => t.legend?.maxHeight ?? void 0, D = (t, e) => {
  e.legend === void 0 && (e.legend = o()), e.legend.maxHeight = t;
};
class I extends d {
  // ---------------------------------------------------------------------------------------------
  // Data Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Whether the legend title is visible.
   *
   * `true`: Legend title is visible.
   *
   * `false`: Legend title is hidden.
   */
  get legendVisibility() {
    return m(this._config);
  }
  set legendVisibility(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      v(e, this._config), this.emitConfigUpdate("legendVisibility");
    });
  }
  // ---------------------------------------------------------------------------------------------
  // General Props
  // ---------------------------------------------------------------------------------------------
  /**
   * The legend title text.
   */
  get legendTitleText() {
    return a(this._config);
  }
  set legendTitleText(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      T(e, this._config), this.emitConfigUpdate("legendTitleText");
    });
  }
  /**
   * Whether the legend title is visible.
   *
   * `true`: Legend title is visible.
   *
   * `false`: Legend title is hidden.
   */
  get legendTitleVisibility() {
    return u(this._config);
  }
  set legendTitleVisibility(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      x(e, this._config), this.emitConfigUpdate("legendTitleVisibility");
    });
  }
  /**
   * Legend position: top, bottom, left, or right.
   */
  get legendPosition() {
    return C(this._config);
  }
  set legendPosition(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      M(e, this._config), this.emitConfigUpdate("legendPosition");
    });
  }
  // ---------------------------------------------------------------------------------------------
  // Format Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Legend title text symbol (font, color, style).
   */
  get legendTitleSymbol() {
    return f(this._config);
  }
  set legendTitleSymbol(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      p(e, this._config), this.emitConfigUpdate("legendTitleSymbol");
    });
  }
  /**
   * Legend item text symbol (font, color, style).
   */
  get legendTextSymbol() {
    return L(this._config);
  }
  set legendTextSymbol(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      y(e, this._config), this.emitConfigUpdate("legendTextSymbol");
    });
  }
  /**
   * Maximum legend height.
   */
  get legendMaxHeight() {
    return V(this._config);
  }
  set legendMaxHeight(e) {
    e !== void 0 && this.guardSetterFromAsyncOverwrite(() => {
      D(e, this._config), this.emitConfigUpdate("legendMaxHeight");
    });
  }
  /**
   * Whether legend markers are rounded.
   */
  get legendRoundMarker() {
    return _(this._config);
  }
  set legendRoundMarker(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      S(e, this._config), this.emitConfigUpdate("legendRoundMarker");
    });
  }
}
const F = (t, e) => t.series?.[e ?? 0]?.dataTooltipVisible ?? !0, R = (t, e, i) => {
  i && t.series?.[i] ? t.series[i].dataTooltipVisible = e : t.series && t.series.forEach((r) => {
    r.dataTooltipVisible = e;
  });
}, w = (t, e) => t.series?.[e ?? 0]?.dataTooltipReverseColor ?? !1, A = (t, e, i) => {
  i && t.series?.[i] ? t.series[i].dataTooltipReverseColor = e : t.series && t.series.forEach((r) => {
    r.dataTooltipReverseColor = e;
  });
};
class ee extends d {
  /**
   * Gets the visibility of the data tooltips.
   * @param seriesIndex The index of the series.
   * @returns {boolean}
   * @remarks
   * a. If the seriesIndex is provided, the visibility for that series will be returned. Otherwise, the visibility of the first series will be returned.
   * b. If the visibility is not set on the series, the default value of `true` will be returned.
   */
  getDataTooltipVisibility(e) {
    return F(this._config, e);
  }
  /**
   * Sets the visibility of the data tooltips.
   * @param visibility The visibility of the data tooltips.
   * @param seriesIndex The index of the series to set the visibility.
   * @remarks If the seriesIndex is provided, the visibility will be set for that series only. Otherwise, the visibility will be set for all series.
   */
  setDataTooltipVisibility(e, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      R(this._config, e, i), this.emitConfigUpdate("setDataTooltipVisibility");
    });
  }
  /**
   * Gets the setting of the `dataTooltipReverseColor` property.
   * @param seriesIndex The index of the series.
   * @returns {boolean}
   * @remarks
   * a. If the seriesIndex is provided, the dataTooltipReverseColor for that series will be returned. Otherwise, the same property of the first series will be returned.
   * b. If the dataTooltipReverseColor is not set on the series, the default value of `false` will be returned.
   */
  getDataTooltipReverseColor(e) {
    return w(this._config, e);
  }
  /**
   * Sets the setting of the `dataTooltipReverseColor` property.
   * @param reverseColor Indicator of whether to reverse the color.
   * @param seriesIndex The index of the series to set the reverse color.
   * @remarks If the seriesIndex is provided, the reverse color will be set for that series only. Otherwise, the reverse color will be set for all series.
   */
  setDataTooltipReverseColor(e, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      A(this._config, e, i), this.emitConfigUpdate("setDataTooltipReverseColor");
    });
  }
}
const O = (t) => t.series[0]?.dataLabels?.visible ?? !1, U = (t, e) => {
  e.series.forEach((i) => {
    i.dataLabels !== void 0 ? i.dataLabels.visible = t : i.dataLabels = l({
      text: "",
      visible: t,
      font: n(s.DataLabels),
      type: s.DataLabels
    });
  });
}, k = (t) => {
  for (const e of t.series)
    if (e.dataLabels !== void 0)
      return e.dataLabels.content;
}, H = (t, e) => {
  for (const i of e.series)
    (i.dataLabels === void 0 || t === void 0) && (i.dataLabels = l({
      text: "",
      visible: !0,
      font: n(s.DataLabels),
      type: s.DataLabels
    })), t !== void 0 && (i.dataLabels.content = h(t));
};
class te extends d {
  // ---------------------------------------------------------------------------------------------
  // Data Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Whether data labels are visible.
   * true: visible, false: hidden.
   */
  get dataLabelsVisibility() {
    return O(this._config);
  }
  set dataLabelsVisibility(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      U(e, this._config), this.emitConfigUpdate("dataLabelsVisibility");
    });
  }
  // ---------------------------------------------------------------------------------------------
  // Format Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Data labels text symbol (font, color, style).
   */
  get dataLabelsSymbol() {
    return k(this._config);
  }
  set dataLabelsSymbol(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      H(e, this._config), this.emitConfigUpdate("dataLabelsSymbol");
    });
  }
}
export {
  I as M,
  ee as a,
  $ as b,
  te as c
};
