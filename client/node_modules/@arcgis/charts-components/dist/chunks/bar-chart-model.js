import { W as a } from "./series-types.js";
import "@arcgis/toolkit/intl";
import "lodash-es";
import "d3-array";
import { aJ as n, aC as d, a6 as c, Y as l } from "./interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import "./runtime.js";
import "@arcgis/toolkit/dom";
import { S as m, s as f, a as h } from "./serial-chart-model.js";
import { c as r } from "./data2.js";
import { g as S, s as g, a as p, b as u } from "./bar-chart-series.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
class j extends m {
  constructor() {
    super(...arguments), this._chartType = a.BarSeries;
  }
  async setup(e) {
    await this.loadConfigFromLayer(e), this.setupLocalProps(), e.config !== void 0 && await this.updateSeriesFromLayerFilter(), typeof this.resolveSetup == "function" && this.resolveSetup();
  }
  // #endregion
  // ---------------------------------------------------------------------------------------------
  // #region Protected Methods
  // ---------------------------------------------------------------------------------------------
  generateDefaultConfig() {
    const e = n(this.commonStrings);
    return e.series = [
      d({
        objectIDField: this.layerInfo?.objectIdField,
        commonStrings: this.commonStrings
      })
    ], e;
  }
  // #endregion
  // ---------------------------------------------------------------------------------------------
  // #region Series Methods
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets whether to hide oversized data labels of the side-by-side series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {boolean | undefined}
   */
  getSeriesHideOversizedSideBySideLabels(e) {
    return S(e, this._config);
  }
  /**
   * Sets whether to hide oversized data labels of the side-by-side series based on the series index.
   * @param {boolean} hide The value for hiding oversized data labels.
   * @param {number} seriesIndex The index of the series.
   */
  setSeriesHideOversizedSideBySideLabels(e, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      g(e, i, this._config), this.emitConfigUpdate("setSeriesHideOversizedSideBySideLabels");
    });
  }
  /**
   * Gets whether to hide oversized stacked labels of the series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {boolean | undefined}
   */
  getSeriesHideOversizedStackedLabels(e) {
    return p(e, this._config);
  }
  /**
   * Sets whether to hide oversized stacked labels of the series based on the series index.
   * @param {boolean} hide The value for hiding oversized stacked labels.
   * @param {number} seriesIndex The index of the series.
   */
  setSeriesHideOversizedStackedLabels(e, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      u(e, i, this._config), this.emitConfigUpdate("setSeriesHideOversizedStackedLabels");
    });
  }
  // #endregion
  // #region Reset Methods
  /**
   * Resets the series styling to the default styling.
   */
  resetSeriesStyling() {
    this.guardSetterFromAsyncOverwrite(() => {
      for (let e = 0; e < this.seriesLength; e += 1) {
        const i = this.getSeriesId(e), t = c({
          colorIndex: e,
          opacity: l
        });
        if (f(t, e, this._config), this.layerInfo !== void 0) {
          const s = r({
            config: this._config,
            seriesIndex: e,
            layerInfo: this.layerInfo,
            commonStrings: this.commonStrings
          });
          s !== this.layerInfo.objectIdField && h(s ?? i, e, this._config);
        }
      }
      this._config.colorMatch = !0, this.emitConfigUpdate("resetSeriesStyling");
    });
  }
  /**
   * Returns whether the series styling is able to be reset.
   * @returns {boolean}
   */
  resetAvailable() {
    const e = !this.colorMatch;
    let i = !1;
    if (!e && this.layerInfo !== void 0)
      for (let t = 0; t < this.seriesLength; t += 1) {
        const s = r({
          config: this._config,
          seriesIndex: t,
          layerInfo: this.layerInfo,
          commonStrings: this.commonStrings
        }), o = this.getSeriesName(t);
        if (s !== void 0 && s !== this.layerInfo.objectIdField && s !== o) {
          i = !0;
          break;
        }
      }
    return e || i;
  }
  // #endregion
}
export {
  j as BarChartModel
};
