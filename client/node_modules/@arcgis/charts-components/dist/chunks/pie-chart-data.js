import "@arcgis/toolkit/intl";
import { memoize as j, isEmpty as W, isNull as E, cloneDeep as R } from "lodash-es";
import { a as m, g as b, t as F, W as $ } from "./series-types.js";
import { R as G } from "./rest-js-object-literals.js";
import { d as A, ak as U, aX as z, ci as B, y as I, aG as _, a as P } from "./interfaces.js";
import "d3-array";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import "./runtime.js";
import "@arcgis/toolkit/dom";
import { substitute as h } from "@arcgis/core/intl.js";
import { a as u, P as g } from "./common.js";
import { b as L, u as x, g as k, a as M } from "./data2.js";
import { g as X } from "./data.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
function N(r) {
  const { config: t, layerInfo: e, mode: i, commonStrings: s } = r, a = e !== void 0 ? O({ config: t, layerInfo: e, commonStrings: s, mode: i }) : "", l = k(t), c = I(t);
  return a === l || c;
}
function q(r) {
  const { config: t, layerInfo: e, mode: i, commonStrings: s } = r, a = e !== void 0 ? L({
    config: t,
    layerInfo: e,
    commonStrings: s,
    numericFields: f(t),
    aggregationType: T(t, i)
  }) : "", l = M(1, t), c = I(t);
  return a === l || c;
}
const v = (r) => r.series?.[0]?.x ?? "";
function H(r, t) {
  const e = r.series?.[0];
  return [`${t === u.Category ? e.y : P} ${b.Descending}`];
}
const V = (r, t) => {
  let e = g.valueDesc;
  const i = r.orderOptions?.data?.orderType ?? H(r, t), s = r.orderOptions?.data?.orderBy ?? b.Descending;
  return i === F.Category && Array.isArray(s) ? e = g.customSort : i === F.Category ? s === b.Ascending ? e = g.labelAsc : e = g.labelDesc : s === b.Ascending ? e = g.valueAsc : e = g.valueDesc, e;
}, f = j(
  // without memoizing, the worst case efficiency is O(series.length), best case is O(1)
  // with memoizing, the worst case efficiency for repeated calls becomes O(1)
  (r) => {
    let t = [];
    return t = r.series?.[0]?.query?.outStatistics?.map(
      (e) => e.onStatisticField
    ) ?? [r.series?.[0]?.y ?? ""], [...new Set(t.filter((e) => e !== ""))];
  },
  // using series array address as key, since a change to the numeric fields will always rebuild a fresh series array
  (r) => r.series
), T = (r, t) => {
  const e = f(r);
  let i;
  return t === u.Fields && e.length === 0 ? i = m.Sum : i = r.series?.[0]?.query?.outStatistics?.[0]?.statisticType ?? m.NoAggregation, i;
};
function w(r) {
  const { config: t, layerInfo: e, mode: i, commonStrings: s } = r, { objectIdField: a } = e ?? {}, l = _(s, a), c = v(t), d = t.series[0]?.dataLabels, o = {
    ...l,
    x: i === u.Category ? c : A,
    slices: t.series?.[0]?.slices,
    dataLabels: {
      ...l.dataLabels,
      type: l.dataLabels?.type ?? $.Text,
      content: { ...l.dataLabels?.content, ...d?.content, type: G.TS },
      visible: d?.visible ?? !1
    },
    innerRadiusSize: t.series?.[0]?.innerRadius,
    sliceGrouping: t.series?.[0]?.sliceGrouping,
    dataLabelsCharacterLimit: t.series?.[0]?.dataLabelsCharacterLimit,
    numericValueFormat: t.series?.[0]?.numericValueFormat,
    percentValueFormat: t.series?.[0]?.percentValueFormat,
    displayCategoryOnDataLabel: t.series?.[0]?.displayCategoryOnDataLabel,
    displayNumericValueOnDataLabel: t.series?.[0]?.displayNumericValueOnDataLabel,
    displayPercentageOnDataLabel: t.series?.[0]?.displayPercentageOnDataLabel
  }, n = T(t, i);
  if (n !== m.NoAggregation && a !== void 0) {
    const y = `${n}_${a}_0`.toUpperCase();
    o.y = i === u.Category ? y : P, o.query = {
      outStatistics: i === u.Category ? [
        {
          statisticType: n,
          onStatisticField: a,
          outStatisticFieldName: y
        }
      ] : []
    };
  }
  return i === u.Category && o.query !== void 0 ? o.query.groupByFieldsForStatistics = [c] : delete o.query?.groupByFieldsForStatistics, R(o);
}
function O(r) {
  const { config: t, layerInfo: e, mode: i, commonStrings: s } = r, { layerFieldsInfo: a, objectIdField: l } = e, c = v(t), d = f(t), o = T(t, i), n = d.length === 0 || d.includes(l), y = z(o, s), p = n ? "" : d.map((Y) => B(a ?? [], Y)).join(", "), S = B(a ?? [], c);
  let C = "", D;
  return i === u.Fields ? D = d.length === 0 : D = c === "", D ? C = s.utilsStrings.chartType.pieChart : o === m.NoAggregation ? C = h(s.titleLabels.aggrFieldsByCategory, {
    aggregationFields: n ? l : p,
    category: S
  }) : o === m.Count ? C = h(s.titleLabels.aggrTypeCategory, {
    aggregationType: y,
    category: S
  }) : d.length > 0 && (S === A || W(S) || E(S) ? C = h(s.titleLabels.aggrTypeOfAggrFields, {
    aggregationType: y,
    aggregationFields: p
  }) : C = h(s.titleLabels.aggrTypeOfAggrFieldsByCategory, {
    aggregationType: y,
    aggregationFields: p,
    category: S
  })), C;
}
const Fe = (r) => {
  const { newSortOrderKind: t, config: e, orderByList: i } = r;
  e.orderOptions ??= {}, t === g.customSort && i !== void 0 ? e.orderOptions.data = {
    orderType: F.Category,
    orderBy: [...i]
  } : e.orderOptions.data = {
    orderType: t === g.labelAsc || t === g.labelDesc ? F.Category : F.YValue,
    orderBy: t === g.labelAsc || t === g.valueAsc ? b.Ascending : b.Descending
  };
}, Te = (r) => {
  const { newCategory: t, config: e, layerInfo: i, mode: s, commonStrings: a } = r, l = e.series?.length ?? 0, c = N({ config: e, layerInfo: i, commonStrings: a, mode: s }), d = q({ config: e, layerInfo: i, commonStrings: a, mode: s });
  if (e.series.forEach((o) => {
    o.x = s === u.Category ? t : A, o.query !== void 0 && t !== A ? o.query.groupByFieldsForStatistics = [t] : delete o.query?.groupByFieldsForStatistics;
  }), l === 0) {
    const o = [w({ config: e, layerInfo: i, mode: s, commonStrings: a })];
    e.series = o;
  }
  if (i !== void 0) {
    if (d) {
      const n = L({
        config: e,
        layerInfo: i,
        numericFields: f(e),
        aggregationType: T(e, s),
        commonStrings: a
      });
      x(e, 1, n);
    }
    e.title && c && (e.title.content.text = O({ config: e, layerInfo: i, commonStrings: a, mode: s }));
    const o = s === u.Fields ? f(e).filter((n) => n !== i.objectIdField) : f(e);
    J({ newNumericFields: o, config: e, layerInfo: i, mode: s, commonStrings: a });
  }
};
function K(r) {
  const { numericFields: t, aggregationType: e, config: i, layerInfo: s, mode: a, commonStrings: l } = r, { layerFieldsInfo: c } = s, d = [], o = w({
    config: i,
    layerInfo: s,
    mode: a,
    commonStrings: l
  }), n = {
    ...o,
    query: {
      ...o.query
    }
  };
  t.length <= 1 ? n.query.where = o.query?.where : delete n.query.where;
  const y = X({
    config: i,
    xAxisField: v(i),
    numericFields: t,
    aggregationType: e,
    mode: a,
    layer: s.layer,
    fieldList: c
  }).name;
  if (e !== m.NoAggregation)
    if (a === u.Category) {
      if (t.length > 0) {
        const p = t[0];
        n.query.outStatistics = [
          {
            ...o.query?.outStatistics?.[0] ?? {},
            onStatisticField: p,
            outStatisticFieldName: y,
            statisticType: e
          }
        ];
      }
    } else
      for (const p of t)
        n.query.outStatistics?.push({
          onStatisticField: p,
          outStatisticFieldName: p,
          statisticType: e
        });
  else
    n.query = {};
  n.y = y, d.push(n), i.series = d;
}
const Se = (r) => {
  const { newAggregationType: t, config: e, layerInfo: i, mode: s, commonStrings: a } = r, l = f(e), c = N({ config: e, layerInfo: i, commonStrings: a, mode: s }), d = q({ config: e, layerInfo: i, commonStrings: a, mode: s });
  if (K({
    config: e,
    layerInfo: i,
    numericFields: l,
    aggregationType: t,
    commonStrings: a,
    mode: s
  }), d) {
    const p = L({
      config: e,
      layerInfo: i,
      commonStrings: a,
      numericFields: f(e),
      aggregationType: T(e, s)
    });
    x(e, 1, p);
  }
  e.title && c && (e.title.content.text = O({ config: e, layerInfo: i, commonStrings: a, mode: s }));
  const o = e.series?.[0]?.displayCategoryOnDataLabel, n = e.series?.[0]?.displayNumericValueOnDataLabel, y = e.series?.[0]?.displayPercentageOnDataLabel;
  e.legend = {
    ...e.legend ?? U(),
    displayNumericValue: n,
    displayPercentage: y,
    displayCategory: o
  };
}, J = (r) => {
  let { newNumericFields: t } = r;
  const { config: e, layerInfo: i, mode: s, commonStrings: a } = r, { objectIdField: l } = i ?? {};
  let c = T(e, s);
  const d = N({ config: e, layerInfo: i, commonStrings: a, mode: s }), o = q({ config: e, layerInfo: i, commonStrings: a, mode: s });
  if (t = t === "" ? [] : t, t = typeof t == "string" ? [t] : t, l !== void 0 && (t.length === 0 && s === u.Category ? (t.push(l), c = m.Count) : c === m.Count && t.length >= 1 && !t.includes(l) && (c = m.Sum)), i !== void 0) {
    if (K({
      config: e,
      layerInfo: i,
      commonStrings: a,
      numericFields: t,
      aggregationType: c,
      mode: s
    }), o) {
      const n = L({
        config: e,
        layerInfo: i,
        commonStrings: a,
        numericFields: f(e),
        aggregationType: T(e, s)
      });
      x(e, 1, n);
    }
    e.title && d && (e.title.content.text = O({ config: e, layerInfo: i, commonStrings: a, mode: s }));
  } else
    e.series.forEach((n) => {
      delete n.query, n.y = t[0];
    });
}, Ce = (r, t) => {
  let e = [];
  const i = r.orderOptions?.data?.orderType, s = V(r, t), a = r.orderOptions?.data?.orderBy;
  return s === g.customSort && i === F.Category && Array.isArray(a) && (e = a), e;
}, be = (r) => {
  const { values: t, config: e, mode: i } = r;
  e.orderOptions ??= {};
  const s = e.orderOptions?.data?.orderType;
  V(e, i) === g.customSort && s === F.Category && (e.orderOptions.data = {
    orderType: F.Category,
    orderBy: [...t]
  });
};
export {
  f as a,
  T as b,
  J as c,
  Se as d,
  V as e,
  Fe as f,
  v as g,
  Ce as h,
  be as i,
  O as j,
  Te as s
};
