import { substitute as V } from "@arcgis/core/intl.js";
import { cloneDeep as R, memoize as le, isEmpty as he } from "lodash-es";
import { e as ve, a as I, u as Ie, W as O, g as U, t as k, m as $, n as Be, i as z } from "./series-types.js";
import { a as re, R as Ce } from "./rest-js-object-literals.js";
import { ae as Y, ce as Le, aX as oe, ci as D, ac as B, aa as C, b5 as h, aw as Ne, ad as Ve, r as L, bh as De, bK as ne, bi as Z, bj as _, cm as Oe, l as G, cA as qe, p as Q, cC as E, m as we, b as K, bg as Me, y as H, az as ke, aA as je, aC as Pe, bf as ie, af as Ue, ag as Ee } from "./interfaces.js";
import "@arcgis/toolkit/intl";
import "d3-array";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import "./runtime.js";
import { q as Ke, l as v, n as Xe, o as Re, j as T, k as A } from "./index4.js";
import "@arcgis/toolkit/dom";
import { S as w } from "./common.js";
import { a as P, s as ce, g as J } from "./data.js";
import { u as de } from "./index2.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
function se(t, e, i) {
  const s = t?.axes?.[e];
  s?.title !== void 0 ? s.title.content.text = i : s !== void 0 && (s.title = B({
    text: i,
    visible: !0,
    font: C(h.AxisTitle)
  }));
}
function ue(t) {
  const { config: e, layerInfo: i, commonStrings: s, numericFields: a, aggregationType: l } = t;
  let r = "";
  if (e)
    if (Le(e) === ve.Stacked100)
      r = s.utilsStrings.statistics.percent;
    else {
      const y = oe(l, s);
      if (a.length === 1) {
        const n = D(i.layerFieldsInfo, a[0]);
        l === I.NoAggregation ? r = n : l === I.Count && a[0] === i.objectIdField ? r = s.utilsStrings.statistics.count : r = V(s.axisLabels.aggregationOfFieldName, {
          aggregation: y,
          fieldName: n
        });
      } else a.length > 1 && (l === I.NoAggregation ? r = s.axisLabels.values : r = V(s.axisLabels.aggregationOfValues, {
        aggregation: y
      }));
    }
  return r;
}
const ye = (t, e, i) => t.axes?.[e] ?? Ne(i, t.type)[e], ge = (t) => {
  const { config: e, axis: i, axisIndex: s } = t;
  e.axes !== void 0 && (e.axes[s] = i);
}, Ot = (t) => {
  const { config: e, axisIndex: i, isMax: s } = t;
  let a = Number.NaN;
  return s ? a = e.axes?.[i]?.maximum : a = e.axes?.[i]?.minimum, a ?? Number.NaN;
}, b = (t) => {
  const { config: e, value: i, axisIndex: s, isMax: a } = t, l = e?.axes?.[s];
  l !== void 0 && (a ? l.maximum = i : l.minimum = i);
}, qt = (t, e) => {
  b({ config: t, value: e, axisIndex: 0, isMax: !1 });
}, fe = (t) => t.axes?.[0]?.valueFormat ?? Y(), We = (t, e, i) => {
  const s = ye(t, 0, e);
  if (s !== void 0 && i !== void 0) {
    const a = {
      ...s,
      valueFormat: i
    };
    ge({ config: t, axis: a, axisIndex: 0 });
  }
}, ae = (t, e, i) => {
  const s = t.axes?.[e];
  s !== void 0 && (s.integerOnlyValues = i);
}, $e = (t) => {
  const e = Ie(t.series);
  return e === O.BarSeries || e === O.ComboLineAndBarSeries || e === O.LineSeries;
}, ze = (t) => {
  const { axisIndex: e, config: i, isMultiAxis: s } = t;
  let a = !1;
  return e === 0 || e === 1 && s ? a = !0 : e === 2 && (a = $e(i)), a;
}, wt = (t) => {
  const { axisIndex: e, func: i, config: s } = t;
  return ze({ axisIndex: e, config: s, isMultiAxis: !0 }) ? i(e) : void 0;
}, Mt = (t, e) => {
  let i;
  const s = e.axes?.[t]?.valueFormat;
  return (t === 0 || t >= 1 && Ke(s)) && (i = s), i;
}, kt = (t) => {
  const { config: e, commonStrings: i, valueFormat: s, axisIndex: a = 0 } = t, l = ye(e, a, i);
  if (l !== void 0 && s !== void 0) {
    const r = {
      ...l,
      valueFormat: s
    };
    ge({
      config: e,
      axis: r,
      axisIndex: a
    });
  }
}, jt = (t, e) => t.axes?.[e]?.isLogarithmic ?? !1, Pt = (t) => {
  const { config: e, isLogarithmic: i, axisIndex: s } = t, a = e.axes?.[s];
  a && (a.isLogarithmic = i, b({ config: e, value: null, axisIndex: s, isMax: !0 }), b({ config: e, value: null, axisIndex: s, isMax: !1 }));
}, Ut = (t) => {
  const { config: e, scrollbar: i, axisIndex: s } = t;
  e.axes?.[s] !== void 0 && (e.axes[s].scrollbar = i);
}, Et = (t) => t.version, Ye = (t) => t.title?.content.text ?? "", Kt = (t, e) => {
  e.title !== void 0 ? e.title.content.text = t : e.title === void 0 && t !== void 0 && (e.title = B({
    text: t,
    visible: !0,
    font: C(h.ChartTitle)
  }));
}, Xt = (t) => t.subtitle?.content.text ?? "", Rt = (t, e) => {
  e.subtitle !== void 0 ? e.subtitle.content.text = t : e.subtitle === void 0 && t !== void 0 && (e.subtitle = B({
    text: t,
    visible: !0,
    font: C(h.ChartSubtitle)
  }));
}, Wt = (t) => t.footer?.content.text ?? "", $t = (t, e) => {
  e.footer !== void 0 ? e.footer.content.text = t : e.footer === void 0 && t !== void 0 && (e.footer = B({
    text: t,
    visible: !0,
    font: C(h.DescriptionText)
  }));
}, zt = (t) => t.title ? t.title.visible ?? !0 : !1, Yt = (t, e) => {
  e.title !== void 0 ? e.title.visible = t : e.title === void 0 && (e.title = B({
    text: "",
    visible: t,
    font: C(h.ChartTitle)
  }));
}, Zt = (t) => t.subtitle ? t.subtitle.visible ?? !0 : !1, _t = (t, e) => {
  e.subtitle !== void 0 ? e.subtitle.visible = t : e.subtitle === void 0 && (e.subtitle = B({
    text: "",
    visible: t,
    font: C(h.ChartSubtitle)
  }));
}, Ze = (t) => t.footer?.visible ?? !1, Gt = (t, e) => {
  e.footer !== void 0 ? e.footer.visible = t : e.footer === void 0 && t !== Ze(e) && (e.footer = B({
    text: "",
    visible: !0,
    font: C(h.DescriptionText)
  }));
}, Qt = (t) => t.chartRenderer, Ht = (t, e) => {
  e.chartRenderer = t;
}, Jt = (t, e) => t.axes?.[e]?.title?.content, ei = (t) => {
  const { config: e, axisIndex: i, symbol: s } = t, a = e.axes?.[i];
  if (a !== void 0) {
    const l = a.title?.content.text;
    (a.title === void 0 || s === void 0) && (a.title = B({
      text: "",
      visible: !0,
      font: C(h.AxisTitle),
      type: h.AxisTitle
    })), s !== void 0 && (a.title.content = s), a.title.content.text = l;
  }
}, ti = (t) => {
  for (const e of t.axes ?? [])
    if (e?.labels !== void 0)
      return e.labels.content;
}, ii = (t, e) => {
  for (const i of e.axes ?? [])
    if (i !== void 0) {
      const s = i.labels?.content.text;
      t === void 0 ? i.labels = B({
        text: "",
        visible: !0,
        font: C(h.AxisLabels),
        type: h.AxisLabels
      }) : i.labels.content = R(t), i.labels.content.text = s;
    }
}, si = (t) => {
  for (const e of t.axes ?? [])
    if (e?.lineSymbol !== void 0)
      return e.lineSymbol;
}, ai = (t, e) => {
  for (const i of e.axes ?? [])
    i !== void 0 && (i.lineSymbol = R(t) ?? Ve());
}, li = (t) => {
  for (const e of t.axes ?? [])
    if (e?.grid !== void 0)
      return e.grid;
}, ri = (t, e, i) => {
  const s = e.axes;
  i.forEach((a) => {
    s?.[a] !== void 0 && (s[a].grid = R(t));
  });
}, ee = (t, e) => e.axes?.[t]?.title?.content.text ?? "", oi = (t, e, i) => {
  const s = i.axes?.[e];
  s?.title !== void 0 ? s.title.content.text = t : s !== void 0 && s?.title === void 0 && (s.title = B({
    text: t,
    visible: !0,
    font: C(h.AxisTitle)
  }));
}, ni = (t, e) => e.axes?.[t]?.title?.visible ?? !1, ci = (t, e, i) => {
  const s = i.axes?.[e];
  s?.title !== void 0 ? s.title.visible = t : s !== void 0 && s?.title === void 0 && (s.title = B({
    text: ee(e, i),
    visible: t,
    font: C(h.AxisTitle)
  }));
}, di = (t, e) => t.axes?.[e]?.displayZeroLine ?? !1, ui = (t, e, i) => {
  t.axes?.[i] !== void 0 && (t.axes[i].displayZeroLine = e);
}, yi = (t, e) => t.axes?.[e]?.displayCursorTooltip ?? !1, gi = (t) => {
  const { config: e, displayCursorTooltip: i, axisIndex: s } = t;
  e.axes?.[s] !== void 0 && (e.axes[s].displayCursorTooltip = i);
}, fi = (t, e) => t.axes?.[e]?.buffer ?? !1, mi = (t) => {
  const { config: e, buffer: i, axisIndex: s } = t, a = e.axes?.[s];
  a !== void 0 && (a.buffer = i);
}, xi = (t, e) => t.axes?.[e]?.tickSpacing, pi = (t) => {
  const { config: e, tickSpacing: i, axisIndex: s } = t;
  e.axes?.[s] !== void 0 && (e.axes[s].tickSpacing = i);
}, Si = (t, e) => t.axes?.[e]?.integerOnlyValues ?? !1, bi = (t) => {
  const { config: e, integerOnlyValues: i, axisIndex: s } = t;
  e.axes?.[s] !== void 0 && (e.axes[s].integerOnlyValues = i);
}, _e = (t) => {
  let e;
  const i = t.series[0];
  return L(i) && (e = i.temporalBinning?.size), e;
}, Ge = (t) => {
  let e;
  const i = t.series[0];
  return L(i) && (e = i.temporalBinning?.unit), e;
}, Qe = (t) => {
  let e;
  const i = t.series[0];
  return L(i) && (e = i.temporalBinning?.timeAggregationType), e;
}, He = (t) => {
  let e;
  const i = t.series[0];
  return L(i) && (e = i.temporalBinning?.trimIncompleteTimeInterval), e;
}, Je = (t) => {
  let e;
  const i = t.series[0];
  return L(i) && (e = i.temporalBinning?.nullPolicy), e;
}, me = (t, e) => {
  e?.series?.forEach((i) => {
    L(i) && (i.temporalBinning ??= {}, i.temporalBinning.size = t);
  }), b({ config: e, value: null, axisIndex: 1, isMax: !1 }), b({ config: e, value: null, axisIndex: 1, isMax: !0 });
}, et = (t, e) => {
  e?.series?.forEach((i) => {
    L(i) && (i.temporalBinning ??= {}, i.temporalBinning.nullPolicy = t);
  }), b({ config: e, value: null, axisIndex: 1, isMax: !1 }), b({ config: e, value: null, axisIndex: 1, isMax: !0 });
}, Fi = (t, e) => {
  e.series?.forEach((i) => {
    L(i) && (i.temporalBinning ??= {}, i.temporalBinning.unit = t);
  }), b({ config: e, value: null, axisIndex: 1, isMax: !1 }), b({ config: e, value: null, axisIndex: 1, isMax: !0 });
}, Ti = (t, e) => {
  e.series?.forEach((i) => {
    L(i) && (i.temporalBinning ??= {}, i.temporalBinning.timeAggregationType = t);
  }), b({ config: e, value: null, axisIndex: 1, isMax: !1 }), b({ config: e, value: null, axisIndex: 1, isMax: !0 });
}, Ai = (t, e) => {
  e.series?.forEach((i) => {
    L(i) && (i.temporalBinning ??= {}, i.temporalBinning.trimIncompleteTimeInterval = t);
  }), b({ config: e, value: null, axisIndex: 1, isMax: !1 }), b({ config: e, value: null, axisIndex: 1, isMax: !0 });
}, hi = (t) => {
  me(0, t);
};
async function tt(t) {
  const { config: e, layer: i, xAxisField: s, splitByField: a, layerFieldsInfo: l, aggregationFields: r, fetchNullValues: c } = t, n = l.filter((f) => f.name === a)[0]?.type, x = c !== !0 ? `${a} IS NOT NULL` : "", d = s && c !== !0 ? `${s} IS NOT NULL` : "", { where: p } = e?.dataFilters ?? {}, m = {
    where: ne([p, x, d]),
    // excluding the null values from the list
    orderByFields: Oe(a) ? [] : [`${a} ${U.Ascending}`],
    // default sorting ascending for split-by field
    geometry: e?.dataFilters?.geometry
  }, g = i;
  let u = "";
  r.length === 0 ? u = g?.objectIdField ?? "" : [u] = r;
  let S = await de({
    queryObject: g,
    category: e?.series[0].x ?? "",
    splitByField: a,
    queryConfig: m
  });
  if (e) {
    const f = e?.series.map((o) => G({ where: o.query?.where })?.toString() ?? "").filter((o) => o !== void 0 && o !== "");
    S = qe({
      arrayA: S,
      arrayB: f,
      getKey: (o) => o === null ? null : o?.toString()
    });
  }
  return { categoriesArray: S, splitByFieldType: n, numericalField: u };
}
function vi(t, e) {
  let i = e === "";
  for (const s of t)
    if (e === s.name) {
      i = !0;
      break;
    }
  return i;
}
function Ii(t, e) {
  const i = De(t);
  let s = e.length === 0, a = 0;
  for (const l of e) {
    for (const r of i)
      if (l === r && (a += 1), a === e.length) {
        s = !0;
        break;
      }
    if (s)
      break;
  }
  return s;
}
function Bi(t, e) {
  e.forEach((i) => {
    Object.getOwnPropertyNames(i.prototype).forEach((s) => {
      Object.defineProperty(
        t.prototype,
        s,
        Object.getOwnPropertyDescriptor(i.prototype, s) || /* @__PURE__ */ Object.create(null)
      );
    });
  });
}
async function it(t) {
  const { layerInfo: e, config: i, category: s } = t, { layer: a } = e, { where: l } = i?.dataFilters ?? {}, { fetchNullValues: r } = i?.series?.[0]?.query ?? {}, c = r !== !0 ? `${s} IS NOT NULL` : "", y = {
    where: ne([l, c]),
    // excluding the null values from the list
    orderByFields: [],
    geometry: i?.dataFilters?.geometry
  }, n = Z(a);
  return (
    // fetch unique category values asynchronously
    (await de({ queryObject: a, category: s, queryConfig: y })).map((d) => {
      const p = String(d);
      return _({
        fieldName: s,
        fieldValueToMatch: p,
        subtypeInfo: n,
        // use the retrieved subtype information
        fieldList: e.layerFieldsInfo
        // list of field information from the layer
      }) ?? p;
    })
  );
}
const Ci = (t, e) => e.series[t]?.id, Li = (t, e) => e.series.findIndex((i) => i.id === t), st = (t) => t.series.length ?? 0, Ni = (t, e) => e.series[t].visible ?? !0;
function Vi(t, e) {
  let i;
  return t.length !== 0 && e < t.length && (i = t[e].dataTooltipValueFormat), i;
}
function Di(t) {
  const { series: e, seriesIndex: i, valueFormat: s } = t;
  e.length !== 0 && i < e.length && (e[i].dataTooltipValueFormat = s);
}
function j(t) {
  const { seriesIndex: e, xAxisField: i, aggregationType: s, config: a, layerInfo: l, commonStrings: r } = t, { objectIdField: c } = l ?? {};
  let y;
  const n = a.series[e ?? 0];
  let x = !1, d = !1;
  if (n === void 0) {
    const g = a.series;
    x = g.slice(0, e).every((u) => T(u)), d = g.slice(0, e).every((u) => A(u));
  } else
    x = T(n), d = A(n);
  x ? y = ke({
    commonStrings: r,
    seriesIndex: e,
    objectIDField: c
  }) : d ? y = je({
    commonStrings: r,
    seriesIndex: e,
    objectIDField: c
  }) : y = Pe({
    seriesIndex: e,
    objectIDField: c,
    commonStrings: r
  });
  const p = a.series[0]?.dataLabels, m = {
    ...y,
    x: i,
    y: "",
    dataLabels: {
      ...y.dataLabels,
      type: y.dataLabels?.type ?? O.Text,
      content: { ...y.dataLabels?.content, ...p?.content, type: Ce.TS },
      visible: p?.visible ?? !1
    }
  };
  if (m.query = {
    groupByFieldsForStatistics: [i]
  }, s !== I.NoAggregation && c !== void 0) {
    const g = `${s}_${c}_0`.toUpperCase();
    m.y = g, m.query.outStatistics = [
      {
        statisticType: s,
        onStatisticField: c,
        outStatisticFieldName: g
      }
    ];
  }
  if (T(m) || A(m) || v(m) && a.series[0]?.binTemporalData) {
    let g;
    if (a?.series?.[0] !== void 0 && (g = Q(a.series)), g !== E.BarAndLineNoAggregation && g !== E.BarAndLineSplitByNoAggregation) {
      let u = Ge(a);
      u === z.Quarter && (u = z.Month), m.temporalBinning = {
        size: _e(a),
        unit: u,
        timeAggregationType: Qe(a),
        trimIncompleteTimeInterval: He(a),
        nullPolicy: Je(a)
      };
    }
  }
  return R(m);
}
function xe(t, e, i) {
  const { layerFieldsInfo: s, objectIdField: a } = e, l = P(t), r = te(t), c = Se(t), y = X(t), n = r.length === 0 || r.includes(a), x = oe(c, i), d = n ? "" : r.map((o) => D(s ?? [], o)).join(", "), p = D(s ?? [], l), m = D(s ?? [], y), g = t.series.some((o) => v(o)), u = g ? "category" : "xAxisField", S = p;
  let f = "";
  if (ce({
    fieldName: l,
    numericFields: r,
    fieldList: s
  }))
    f = V(i.titleLabels.aggrTypeOfAggrFields, {
      aggregationType: x,
      aggregationFields: d
    });
  else if (c === I.NoAggregation) {
    const o = n ? a : d;
    if (y === "") {
      const q = g ? "aggrTypeCategory" : "aggrTypeXAxisField";
      f = V(i.titleLabels[q], {
        aggregationType: o,
        [u]: S
      });
    } else {
      const q = g ? "aggrTypeCategoryBySplitBy" : "aggrTypeXAxisFieldBySplitBy";
      f = V(i.titleLabels[q], {
        aggregationType: o,
        [u]: S,
        splitByField: m
      });
    }
  } else if (c === I.Count)
    if (y === "") {
      const o = g ? "aggrTypeCategory" : "aggrTypeXAxisField";
      f = V(i.titleLabels[o], {
        aggregationType: x,
        [u]: S
      });
    } else {
      const o = g ? "aggrTypeCategoryBySplitBy" : "aggrTypeXAxisFieldBySplitBy";
      f = V(i.titleLabels[o], {
        aggregationType: x,
        [u]: S,
        splitByField: m
      });
    }
  else if (y !== "") {
    const o = g ? "aggrTypeOfAggrFieldByCategoryBySplitByField" : "aggrTypeOfAggrFieldByXAxisFieldBySplitByField";
    f = V(i.titleLabels[o], {
      aggregationType: x,
      aggregationField: d,
      [u]: S,
      splitByField: m
    });
  } else if (r.length > 0) {
    const o = g ? "aggrTypeOfAggrFieldsByCategory" : "aggrTypeOfAggrFieldsByXAxisField";
    f = V(i.titleLabels[o], {
      aggregationType: x,
      aggregationFields: d,
      [u]: S
    });
  }
  return f;
}
const pe = (t) => G({
  where: t.query?.where,
  normalize: !1,
  escape: !1
}) ?? "", Se = (t) => t?.series?.[0]?.query?.outStatistics?.[0]?.statisticType ?? I.NoAggregation, X = le(
  (t) => {
    const e = t?.series?.[0]?.query?.where?.split("=")[0].trim() ?? "";
    return we(t?.series?.[0]?.query?.where) ? "" : e;
  },
  (t) => t?.series?.[0]?.query?.where
), te = le(
  // without memoizing, the worst case efficiency is O(series.length), best case is O(1)
  // with memoizing, the worst case efficiency for repeated calls becomes O(1)
  (t) => {
    let e = [];
    if (X(t) === "")
      e = t?.series.map((i) => {
        const s = i.query?.outStatistics?.map((a) => a.onStatisticField) ?? [];
        return s?.length > 0 ? s : i.y;
      }).flat() ?? [];
    else {
      const i = t?.series?.[0], s = i?.query?.outStatistics?.[0]?.onStatisticField ?? [i?.y].flat()[0];
      e = s !== void 0 ? [s] : [];
    }
    return [...new Set(e.filter((i) => i !== ""))];
  },
  // using series array address as key, since a change to the numeric fields will always rebuild a fresh series array
  (t) => t?.series
);
function at(t) {
  const { numericFields: e, aggregationType: i, config: s, layerInfo: a } = t;
  let l = !1;
  i === I.Count ? l = !0 : i === I.NoAggregation && (l = e.every((y) => {
    const n = a.layerFieldsInfo.find((x) => x.name === y);
    return n !== void 0 ? ie(n) : !1;
  })), ae(s, 1, l);
  const r = s.series.some((y) => T(y)), c = s.series.some((y) => A(y));
  if (r || c) {
    const y = P(s), n = a.layerFieldsInfo.find((d) => d.name === y), x = n !== void 0 && ie(n);
    ae(s, 0, x);
  }
}
const lt = (t) => {
  let e = w.xAxisAsc;
  const i = t.orderOptions?.data?.orderType ?? k.Category, s = t.orderOptions?.data?.orderBy ?? U.Ascending;
  return i === k.Category && Array.isArray(s) ? e = w.customSort : i === k.Category ? s === U.Ascending ? e = w.xAxisAsc : e = w.xAxisDesc : s === U.Ascending ? e = w.yAxisAsc : e = w.yAxisDesc, e;
};
function rt(t) {
  const { xAxisField: e, numericFields: i, aggregationType: s, config: a, layerInfo: l, commonStrings: r } = t, { layerFieldsInfo: c } = l;
  let y = !1;
  const n = j({
    config: a,
    xAxisField: e,
    aggregationType: s,
    layerInfo: l,
    seriesIndex: 0,
    commonStrings: r
  }), x = J({
    config: a,
    xAxisField: e,
    numericFields: i,
    aggregationType: s,
    layer: l.layer,
    fieldList: c
  }).name, d = {
    ...n,
    id: `series_${Date.now()}`,
    name: r.axisLabels.values,
    x: K,
    y: x
  }, p = [];
  for (const g of i)
    p.push({
      onStatisticField: g,
      outStatisticFieldName: `${g}_0`.toUpperCase(),
      statisticType: s
    });
  d.query = { outStatistics: p };
  const m = a.series[0];
  return m !== void 0 && (d.id = m.id, a.colorMatch || (v(m) && v(d) ? d.fillSymbol = m.fillSymbol : (T(d) && T(m) || A(d) && A(m)) && (d.lineSymbol = m.lineSymbol, d.markerSymbol = m.markerSymbol), y = !0), d.id = m.id, m.name !== n.name && (d.name = m.name)), a.series.length === 1 && !a.colorMatch && (v(d) ? d.fillSymbol = a.series[0].fillSymbol : (T(d) || A(d)) && (d.lineSymbol = a.series[0].lineSymbol, d.markerSymbol = a.series[0].markerSymbol), y = !0), a.colorMatch = !y, [d];
}
function be(t) {
  const { xAxisField: e, numericFields: i, aggregationType: s, config: a, layerInfo: l, commonStrings: r } = t, { layerFieldsInfo: c, objectIdField: y } = l, n = [];
  let x = !1;
  for (let d = 0; d < i.length; d += 1) {
    const p = j({
      config: a,
      xAxisField: e,
      aggregationType: s,
      layerInfo: l,
      seriesIndex: d,
      commonStrings: r
    }), m = J({
      config: a,
      xAxisField: e,
      numericFields: i,
      aggregationType: s,
      layer: l.layer,
      numericFieldIndex: d,
      fieldList: c
    }).name, g = i[d];
    let u = {
      ...p,
      query: {
        ...p.query
      }
    };
    g !== y && (u = {
      ...u,
      id: g,
      name: D(c, g)
    });
    let S = g;
    u.query !== void 0 && (s !== I.NoAggregation ? (S = m, u.query.outStatistics = [
      {
        ...p.query?.outStatistics?.[0] ?? {},
        onStatisticField: g,
        outStatisticFieldName: m,
        statisticType: s
      }
    ]) : delete u.query.outStatistics), u.y = S;
    const f = a.series.find(
      (o) => o.query?.outStatistics?.[0]?.onStatisticField === g && o.query.where === void 0
    );
    if (f !== void 0 && typeof f.y == "string" && f.y.trim() !== "") {
      a.colorMatch || (v(u) && v(f) ? u.fillSymbol = f.fillSymbol : (T(u) && T(f) || A(u) && A(f)) && (u.lineSymbol = f.lineSymbol, u.markerSymbol = f.markerSymbol), x = !0);
      const o = j({
        config: a,
        xAxisField: e,
        aggregationType: s,
        layerInfo: l,
        seriesIndex: d,
        commonStrings: r
      });
      u.id = f.id, f.id !== o.id && f.name !== o.name && (u.id = f.id, u.name = f.name);
    }
    n.push(u);
  }
  return a.series.length === 1 && n.length === 1 && !a.colorMatch && (v(a.series[0]) && v(n[0]) ? n[0].fillSymbol = a.series[0].fillSymbol : (T(a.series[0]) && T(n[0]) || A(a.series[0]) && A(n[0])) && (n[0].lineSymbol = a.series[0].lineSymbol, n[0].markerSymbol = a.series[0].markerSymbol), x = !0), a.colorMatch = !x, n;
}
async function ot(t) {
  const { splitByField: e, xAxisField: i, numericFields: s, aggregationType: a, config: l, layerInfo: r, commonStrings: c } = t, { layer: y, layerFieldsInfo: n } = r, { fetchNullValues: x } = l?.series?.[0]?.query ?? {}, d = i !== K ? i : void 0, { categoriesArray: p, splitByFieldType: m, numericalField: g } = await tt({
    config: l,
    layer: y,
    layerFieldsInfo: n,
    xAxisField: d,
    aggregationFields: s,
    splitByField: e,
    fetchNullValues: x
  });
  let u = [], S = !1;
  if (p.length === 0) {
    u = be({
      xAxisField: i,
      numericFields: s,
      aggregationType: a,
      config: l,
      layerInfo: r,
      commonStrings: c
    });
    for (const f of u)
      f.query && (f.query.where = `${e}=''`);
  } else
    for (let f = 0; f < p.length; f += 1) {
      const o = p[f], q = J({
        config: l,
        xAxisField: i,
        numericFields: s,
        aggregationType: a,
        layer: r.layer,
        seriesIndex: f,
        splitByField: e,
        fieldList: n
      }).name, M = j({
        config: l,
        xAxisField: i,
        aggregationType: a,
        layerInfo: r,
        seriesIndex: f,
        commonStrings: c
      }), Fe = {
        fieldName: e,
        fieldValueToMatch: o ?? "",
        subtypeInfo: Z(r.layer),
        fieldList: r.layerFieldsInfo
      }, Te = _(Fe), W = `${o}`, F = {
        ...M,
        id: W,
        name: Te ?? W,
        y: q,
        query: {
          ...M.query,
          where: `${e}=${m === re.String && o !== null ? `'${o}'` : o}`,
          outStatistics: a !== I.NoAggregation ? [
            {
              ...M.query?.outStatistics?.[0] ?? {},
              onStatisticField: g,
              outStatisticFieldName: q,
              statisticType: a
            }
          ] : void 0
        }
      };
      a === I.NoAggregation && (F.query !== void 0 && (delete F.query.outStatistics, delete F.query.groupByFieldsForStatistics), F.y = g);
      const N = l.series.find(
        (Ae) => String(pe(Ae)).trim().replace(/'/gu, "") === W
      );
      N !== void 0 && (l.colorMatch || (v(F) && v(N) ? F.fillSymbol = N.fillSymbol : (T(F) && T(N) || A(F) && A(N)) && (F.lineSymbol = N.lineSymbol, F.markerSymbol = N.markerSymbol), S = !0), F.id = N.id, F.name = N.name), u.push(F);
    }
  return l.colorMatch = !S, u;
}
const Oi = async (t) => {
  const { xAxisField: e, splitByField: i, numericFields: s, aggregationType: a, config: l, layerInfo: r, commonStrings: c } = t, { layerFieldsInfo: y } = r ?? {}, n = st(l), x = P(l), d = nt(l, r, c), p = ct(l, r, c), m = dt(l, r);
  let g = fe(l);
  const u = l.series.some((o) => v(o)), S = Xe(l.series), f = Re(l.series);
  if (y !== void 0) {
    const o = Me(y);
    !o.includes(x) && o.includes(e) ? g = Ue() : o.includes(x) && !o.includes(e) && (u ? g = Y() : g = Ee()), y.find((M) => M.name === e)?.type === re.String && (g = Y()), g !== void 0 && We(l, c, g);
  }
  if (n === 0 && (l.series = [
    j({ config: l, xAxisField: e, aggregationType: a, layerInfo: r, commonStrings: c })
  ]), l.series.forEach((o) => {
    o.x = e, o.query !== void 0 && (o.query.groupByFieldsForStatistics = [e]);
  }), i === "" || s.length > 1 ? ce({
    fieldName: e,
    numericFields: s,
    fieldList: y
  }) ? l.series = rt({
    config: l,
    layerInfo: r,
    xAxisField: e,
    numericFields: s,
    aggregationType: a,
    commonStrings: c
  }) : l.series = be({
    config: l,
    layerInfo: r,
    xAxisField: e,
    numericFields: s,
    aggregationType: a,
    commonStrings: c
  }) : (await Promise.resolve(), l.series = await ot({
    config: l,
    layerInfo: r,
    splitByField: i,
    xAxisField: e,
    numericFields: s,
    aggregationType: a,
    commonStrings: c
  })), m) {
    const o = D(y, e);
    se(l, 0, o);
  }
  if (p) {
    const o = ue({
      config: l,
      layerInfo: r,
      commonStrings: c,
      numericFields: s,
      aggregationType: a
    });
    se(l, 1, o);
  }
  if (l.title && d && (l.title.content.text = xe(l, r, c)), b({ config: l, value: null, axisIndex: 1, isMax: !1 }), b({ config: l, value: null, axisIndex: 1, isMax: !0 }), at({ numericFields: s, aggregationType: a, config: l, layerInfo: r }), S || f) {
    b({ config: l, value: null, axisIndex: 0, isMax: !1 }), b({ config: l, value: null, axisIndex: 0, isMax: !0 }), me(0, l);
    const o = g?.type === O.DateAxisFormat ? $.Null : $.Interpolate;
    et(o, l);
  }
}, qi = (t) => {
  const { config: e, seriesIndex: i, layerInfo: s, commonStrings: a } = t, l = e.series?.[i], r = X(e);
  let c;
  if (Q(e.series) === E.BarAndLineFromFields)
    c = a.axisLabels.values;
  else if (he(r)) {
    const n = l.query?.outStatistics?.[0]?.onStatisticField;
    n !== void 0 && n !== s.objectIdField && (c = D(s.layerFieldsInfo, n));
  } else {
    const n = String(pe(l)).trim().replace(/'/gu, ""), x = {
      fieldName: X(e),
      fieldValueToMatch: n ?? "",
      subtypeInfo: Z(s.layer),
      fieldList: s.layerFieldsInfo
    };
    c = _(x) ?? n;
  }
  return c ?? l.id;
}, wi = (t, e) => {
  e.orderOptions ??= {};
  const i = e.orderOptions?.data?.orderType;
  lt(e) === w.customSort && i === k.Category && (e.orderOptions.data = {
    orderType: k.Category,
    orderBy: [...t]
  });
}, Mi = async (t, e) => {
  const i = P(t), s = fe(t)?.type, a = te(t), l = Q(t.series);
  let r = [];
  return s === O.CategoryAxisFormat && (l === E.BarAndLineFromFields || i === K ? r = a.map((c) => D(e?.layerFieldsInfo, c)) : i.trim() !== "" && i !== K && e !== void 0 && (r = await it({
    layerInfo: e,
    config: t,
    category: i
  }))), r;
};
function nt(t, e, i) {
  const s = xe(t, e, i), a = Ye(t), l = H(t);
  return s === a || l;
}
function ct(t, e, i) {
  const s = ue({
    config: t,
    layerInfo: e,
    commonStrings: i,
    numericFields: te(t),
    aggregationType: Se(t)
  }), a = ee(1, t), l = H(t);
  return s === a || l;
}
function dt(t, e) {
  const i = D(e.layerFieldsInfo, P(t)), s = ee(0, t), a = H(t);
  return i === s || a;
}
function ki(t) {
  return t.series[0]?.binTemporalData ?? !1;
}
function ji(t, e) {
  e?.series.forEach((i) => {
    (i?.type === O.BarSeries || i?.type === O.LineSeries) && (i.binTemporalData = t, t ? i.temporalBinning = {
      unit: z.Day,
      size: 0,
      timeAggregationType: Be.Start,
      trimIncompleteTimeInterval: !0,
      nullPolicy: $.Null
    } : delete i.temporalBinning);
  });
}
const Pi = (t, e) => {
  e.series.forEach((i) => {
    i.query && (i.query.fetchNullValues = t);
  });
}, Ui = (t) => t.series.some((e) => e.query?.fetchNullValues), Ei = (t) => (
  // TODO: Look into split-by values gotchas cases once done
  t.series.map((e) => String(G({ where: e.query?.where }))).filter((e) => e !== void 0 && e.trim() !== "")
), Ki = (t) => t.dataFilters, Xi = (t, e) => {
  t !== void 0 ? e.dataFilters = t : delete e.dataFilters;
};
export {
  st as $,
  Je as A,
  et as B,
  hi as C,
  lt as D,
  Mi as E,
  wi as F,
  ki as G,
  ji as H,
  Oi as I,
  xe as J,
  Wt as K,
  Et as L,
  Kt as M,
  Xt as N,
  Rt as O,
  $t as P,
  zt as Q,
  Yt as R,
  Zt as S,
  _t as T,
  Ze as U,
  Gt as V,
  Qt as W,
  Ht as X,
  Ni as Y,
  Ci as Z,
  Li as _,
  ee as a,
  Vi as a0,
  Di as a1,
  Ui as a2,
  Pi as a3,
  Ki as a4,
  Xi as a5,
  oi as a6,
  ni as a7,
  ci as a8,
  Ot as a9,
  qt as aa,
  Jt as ab,
  ei as ac,
  ti as ad,
  ii as ae,
  si as af,
  ai as ag,
  wt as ah,
  li as ai,
  ri as aj,
  xi as ak,
  Mt as al,
  kt as am,
  jt as an,
  Pt as ao,
  Ut as ap,
  di as aq,
  ui as ar,
  yi as as,
  gi as at,
  fi as au,
  mi as av,
  pi as aw,
  Si as ax,
  bi as ay,
  ue as b,
  qi as c,
  Bi as d,
  vi as e,
  Se as f,
  Ye as g,
  te as h,
  Ii as i,
  Ei as j,
  X as k,
  fe as l,
  it as m,
  We as n,
  tt as o,
  ae as p,
  _e as q,
  me as r,
  b as s,
  Ge as t,
  se as u,
  Fi as v,
  Qe as w,
  Ti as x,
  He as y,
  Ai as z
};
