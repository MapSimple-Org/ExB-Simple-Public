import "@arcgis/toolkit/intl";
import { memoize as X, isEmpty as ye, isEqual as ue, cloneDeep as j } from "lodash-es";
import { W as f, t as p, g as h } from "./series-types.js";
import { a as fe } from "./rest-js-object-literals.js";
import { ao as q, i as O, a3 as C, y as V, m as me, I as Se, bg as pe, ci as w, bi as J, bj as R, ap as _, ad as G, a1 as H, aD as Q, b2 as K, az as ge, af as xe, ae as be } from "./interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import "./runtime.js";
import { g as P, p as he } from "./index4.js";
import "@arcgis/toolkit/dom";
import { substitute as M } from "@arcgis/core/intl.js";
import { u as D, a as z, l as Z, m as Fe, n as Ae, s as U, g as Be, o as Ce } from "./data2.js";
import { B as u } from "./common.js";
import "d3-array";
import { s as W } from "./data.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
const ns = (s, e) => e?.series?.[s]?.name, as = (s, e, t) => {
  const o = t;
  o?.series?.[e] !== void 0 && (o.series[e].name = s);
}, cs = (s, e) => {
  let t;
  const o = e.series?.[s];
  return o?.type === f.BoxPlotSeries ? t = o.fillSymbol?.color : o?.type === f.LineSeries && (t = o.lineSymbol?.color), t;
}, we = (s) => {
  const e = s.series[0];
  return s.showMean === !0 && P(e) ? e.fillSymbol?.color : void 0;
}, Le = (s, e) => {
  const t = e.series[0];
  e.showMean === !0 && P(t) && (t.fillSymbol !== void 0 ? t.fillSymbol.color = s : t.fillSymbol = {
    ...q(),
    color: s
  });
}, ds = (s, e, t) => {
  const i = t?.series?.[e];
  i?.type === f.BoxPlotSeries && i.fillSymbol !== void 0 ? i.fillSymbol.color = s : i?.type === f.LineSeries && i.lineSymbol !== void 0 && (i.lineSymbol.color = s, i.markerSymbol !== void 0 && (i.markerSymbol.color = s));
}, Te = (s) => s.series.map((e) => e.id), ve = (s, e) => {
  e?.series?.sort(
    (t, o) => s.findIndex((i) => t.id === i) - s.findIndex((i) => o.id === i)
  );
}, ys = (s, e, t) => {
  const o = Te(t), [i] = o.splice(s, 1);
  o.splice(e, 0, i), ve(o, t);
}, us = (s) => N(s) ? s.series.findIndex((e) => e.type === f.BoxPlotSeries) : -1;
function Me(s, e, t) {
  const o = le(s, e, t), i = Be(s), r = V(s);
  return o === i || r;
}
function ee(s, e, t) {
  const o = T(s, e, t), i = z(1, s), r = V(s);
  return o === i || r;
}
function Ie(s) {
  const { config: e, layerInfo: t, newCategory: o } = s, { layerFieldsInfo: i } = t, r = L(e), l = o !== C ? w(i, r) : "", n = z(0, e), a = V(e);
  return l === n || a || n.trim() === "";
}
const L = (s) => O(s)?.x ?? C, Oe = X(
  (s) => {
    const e = O(s), t = e?.query?.where?.split("=")[0].trim() ?? "";
    return me(e?.query?.where) ? "" : t;
  },
  (s) => O(s)?.query?.where
), se = X(
  // without memoizing, the worst case efficiency is O(series.length), best case is O(1)
  // with memoizing, the worst case efficiency for repeated calls becomes O(1)
  (s) => Se(s?.series).filter((e) => e !== ""),
  // using series array address as key, since a change to the numeric fields will always rebuild a fresh series array
  (s) => s?.series
), I = (s) => {
  const { category: e, seriesIndex: t, y: o, commonStrings: i } = s, l = {
    ...Q(i, t),
    x: e === void 0 || e === "" ? C : e,
    y: o,
    query: {}
  };
  return j(l);
}, Pe = (s) => {
  const { category: e, seriesIndex: t, y: o, commonStrings: i } = s, l = {
    ...ge({ commonStrings: i, seriesIndex: t }),
    x: e === void 0 || e === "" ? C : e,
    y: o,
    query: {}
  };
  return j(l);
};
function te(s) {
  const { x: e, y: t, seriesTemplate: o, commonStrings: i } = s, { id: r, fillSymbol: l } = o ?? {}, n = Q(i), a = r ?? `series_${Date.now()}`;
  return n.id = a, n.name = a, n.x = e, n.y = t, l ? n.fillSymbol = l : n.fillSymbol && (n.fillSymbol.color = K, n.fillSymbol?.outline && (n.fillSymbol.outline.color = K)), n;
}
function ie(s) {
  const { numericFields: e, config: t, layerInfo: o, category: i, commonStrings: r } = s, { layerFieldsInfo: l } = o, n = [], a = i ?? L(t);
  let y = !1;
  const c = W({
    fieldName: a,
    numericFields: e,
    fieldList: l
  });
  if (e.length === 0) {
    const m = I({
      y: "",
      seriesIndex: 0,
      category: a,
      commonStrings: r
    });
    n.push(m);
  } else if (c) {
    const m = e.length > 1 ? e : e[0], F = I({
      y: m,
      seriesIndex: 0,
      category: a,
      commonStrings: r
    }), x = e.length > 1 ? r.axisLabels.values : w(o.layerFieldsInfo, e[0]), g = {
      ...F,
      id: e[0],
      name: x,
      x: c ? C : a
    }, S = t.series.find((d) => ue(m, d.y) && d.query?.where === void 0);
    S !== void 0 && (!t.colorMatch && "fillSymbol" in S && (g.fillSymbol = S.fillSymbol, y = !0), g.id = S.id, g.name = S.name), n.push(g);
  } else
    for (let m = 0; m < e.length; m += 1) {
      const F = e[m], x = I({
        y: F,
        seriesIndex: m,
        category: a,
        commonStrings: r
      }), g = w(l, F), S = {
        ...x,
        id: F,
        name: g,
        x: a
      }, d = t.series.find((B) => F === B.y);
      d !== void 0 && (!t.colorMatch && "fillSymbol" in d && (S.fillSymbol = d.fillSymbol, y = !0), S.id = d.id, S.name = d.name), n.push(S);
    }
  return t.series.length === 1 && n.length === 1 && !t.colorMatch && "fillSymbol" in t.series[0] && (n[0].fillSymbol = t.series[0].fillSymbol, y = !0), t.colorMatch = !y, n;
}
const oe = (s) => s?.query?.where?.split("=")[1].trim().replace(/'/gu, "") ?? "", De = (s) => s.series.some((e) => e.type === f.LineSeries) && s.series.some((e) => e.type === f.BoxPlotSeries);
function Ve(s, e, t) {
  const o = [];
  return s.forEach((i) => {
    if (i.type === f.BoxPlotSeries) {
      const { type: r, fillSymbol: l, ...n } = i;
      o.push({
        ...n,
        type: f.LineSeries,
        lineSymbol: {
          ...G({ width: H }),
          ...l !== void 0 ? { color: l.color } : {}
        },
        markerSymbol: {
          ..._(),
          ...l !== void 0 ? { color: l.color } : {}
        }
      });
    }
  }), o.unshift(
    te({
      x: s[0].x,
      y: s[0].y,
      seriesTemplate: t,
      commonStrings: e
    })
  ), o;
}
function ke(s) {
  const e = s.slice(1), t = [];
  return e.forEach((o) => {
    if (o.type === f.LineSeries) {
      const { type: i, lineSymbol: r, markerSymbol: l, ...n } = o, a = q();
      t.push({
        ...n,
        type: f.BoxPlotSeries,
        fillSymbol: {
          ...a,
          color: r?.color
        }
      });
    }
  }), t;
}
function re(s) {
  const { formerSeries: e, newSeries: t, showMean: o } = s;
  let i = t;
  const r = (a) => a.type === (o ? f.LineSeries : f.BoxPlotSeries), l = e.filter(r).map((a) => a.id), n = t.filter(r).map((a) => a.id);
  return l.length === n.length && JSON.stringify(l) !== JSON.stringify(n) && (i = i.sort(
    (a, y) => l.findIndex((c) => c === a.id) - l.findIndex((c) => c === y.id)
  )), i;
}
async function Ne(s) {
  const { config: e, layerInfo: t, commonStrings: o, splitByField: i, numericFields: r, category: l } = s, { layer: n, layerFieldsInfo: a } = t, { fetchNullValues: y } = O(e)?.query ?? {}, c = l ?? L(e), { categoriesArray: m, splitByFieldType: F } = await Ce({
    config: e,
    layer: n,
    layerFieldsInfo: a,
    xAxisField: E(c) ? void 0 : c,
    aggregationFields: r,
    splitByField: i,
    fetchNullValues: y
  });
  let x = [], g = !1;
  const S = De(e);
  if (m.length === 0) {
    x = ie({
      numericFields: r,
      category: c,
      config: e,
      layerInfo: t,
      commonStrings: o
    });
    for (const d of x)
      d.query && (d.query.where = `${i}=''`);
  } else
    for (let d = 0; d < m.length; d += 1) {
      const B = m[d], v = {
        y: r,
        seriesIndex: d,
        category: c,
        commonStrings: o
      }, Y = S ? Pe(v) : I(v), ae = {
        fieldName: i,
        fieldValueToMatch: B ?? "",
        subtypeInfo: J(t.layer),
        fieldList: t.layerFieldsInfo
      }, ce = R(ae), k = `${B}`, A = {
        ...Y,
        id: k,
        name: ce ?? k,
        x: c === void 0 || c === "" ? C : c,
        query: {
          ...Y.query,
          where: `${i}=${F === fe.String && B !== null ? `'${B}'` : B}`
        }
      }, b = e.series.find((de) => oe(de) === k);
      b !== void 0 && (e.colorMatch || (A.type === f.BoxPlotSeries ? P(b) ? A.fillSymbol = b.fillSymbol : A.fillSymbol = {
        ...q(),
        color: b.lineSymbol?.color
      } : P(b) ? (A.lineSymbol = {
        ...G({ width: H }),
        ...b.fillSymbol !== void 0 ? { color: b.fillSymbol.color } : {}
      }, A.markerSymbol = {
        ..._(),
        ...b.fillSymbol !== void 0 ? { color: b.fillSymbol.color } : {}
      }) : (A.lineSymbol = b.lineSymbol, A.markerSymbol = b.markerSymbol), g = !0), A.id = b.id, A.name = b.name), x.push(A);
    }
  if (x = re({
    formerSeries: e.series,
    newSeries: x,
    showMean: N(e)
  }), e.colorMatch = !g, N(e)) {
    const d = e.series.find((v) => v.type === f.BoxPlotSeries), B = te({
      x: c,
      y: r,
      seriesTemplate: d,
      commonStrings: o
    });
    x.unshift(B);
  }
  return x;
}
const fs = async (s) => {
  const { splitByField: e, numericFields: t, category: o, config: i, layerInfo: r, commonStrings: l } = s, { layerFieldsInfo: n } = r, a = We(o, t, e), y = pe(n), c = L(i), m = Me(i, r, l), F = ee(i, r, l), x = Ie({ config: i, layerInfo: r, newCategory: o });
  let g = Z(i);
  if (!y.includes(c) && y.includes(o) ? g = xe() : y.includes(c) && !y.includes(o) && (g = be()), g !== void 0 && Ae(i, l, g), $(a ? { newShowMeanLines: i.showMean, config: i, commonStrings: l } : { newShowMeanLines: !1, config: i, commonStrings: l }), i.series = a ? await Ne({
    config: i,
    layerInfo: r,
    splitByField: e,
    numericFields: t,
    category: o,
    commonStrings: l
  }) : ie({
    numericFields: t,
    config: i,
    layerInfo: r,
    category: o,
    commonStrings: l
  }), x) {
    const d = W({
      fieldName: o,
      numericFields: t,
      fieldList: n
    }) ? "" : w(n, o);
    D(i, 0, d);
  }
  if (F) {
    const S = T(i, r, l);
    D(i, 1, S);
  }
  i?.title !== void 0 && m && (i.title.content.text = le(i, r, l)), U({ config: i, value: null, axisIndex: 1, isMax: !1 }), U({ config: i, value: null, axisIndex: 1, isMax: !0 });
}, qe = (s) => s?.standardizeValues ?? !1;
function T(s, e, t) {
  const { layerFieldsInfo: o } = e;
  let r = qe(s) ? t.axisLabels.standardizedValues : t.axisLabels.values, l = s?.series?.map((n) => n.y).flat();
  return l = [...new Set(l)], l.length === 1 && (r = w(o, l[0])), r;
}
function le(s, e, t) {
  const { layerFieldsInfo: o } = e, i = L(s), r = se(s), l = Oe(s), n = r.map((c) => w(o ?? [], c)).join(", "), a = w(o ?? [], i);
  let y = "";
  return r.length > 0 && (i !== C && l !== "" ? y = M(t.titleLabels.distributionOfFieldsByCategoryAndSplitBy, {
    valueFields: n,
    category: a,
    splitByField: l
  }) : i !== C ? y = M(t.titleLabels.distributionOfFieldsByCategory, {
    valueFields: n,
    category: a
  }) : l !== "" ? y = M(t.titleLabels.distributionOfFieldsByCategory, {
    valueFields: n,
    category: l
  }) : y = M(t.titleLabels.distributionOfField, {
    valueField: n
  })), y;
}
const ms = (s) => {
  const { series: e, splitByField: t, layerInfo: o, commonStrings: i } = s;
  let r = typeof e.y == "string" ? w(o.layerFieldsInfo, e.y) : i.axisLabels.values;
  ye(t) || (r = oe(e));
  const l = {
    fieldName: t,
    fieldValueToMatch: r ?? "",
    subtypeInfo: J(o.layer),
    fieldList: o.layerFieldsInfo
  };
  return r = R(l) ?? r, r ?? e.id;
}, Ss = (s) => s?.showOutliers ?? !1, ps = (s) => {
  const { newShowOutliers: e, config: t, layerInfo: o, commonStrings: i } = s;
  if (t.showOutliers = e, ee(t, o, i)) {
    const l = T(t, o, i);
    D(t, 1, l);
  }
}, gs = (s) => {
  const { newStandardizeValues: e, config: t, layerInfo: o, commonStrings: i } = s, r = z(1, t), l = T(t, o, i), n = V(t);
  if (t.standardizeValues = e, r === l || n) {
    const a = T(t, o, i);
    D(t, 1, a);
  }
}, ne = (s) => {
  let e = u.xAxisAsc;
  const t = s.orderOptions?.data?.orderType ?? p.Category, o = s.orderOptions?.data?.orderBy ?? h.Ascending;
  switch (t) {
    case p.Category:
      e = Array.isArray(o) ? u.customSort : o === h.Ascending ? u.xAxisAsc : u.xAxisDesc;
      break;
    case p.Mean:
      e = o === h.Ascending ? u.meanAsc : u.meanDesc;
      break;
    case p.Median:
      e = o === h.Ascending ? u.medianAsc : u.medianDesc;
      break;
  }
  return e;
}, xs = (s, e, t) => {
  let o = p.Category, i = h.Ascending;
  if (e.orderOptions = e.orderOptions ?? {}, s === u.customSort && t !== void 0)
    e.orderOptions.data = {
      orderType: p.Category,
      orderBy: t
    };
  else {
    switch (s) {
      case u.xAxisAsc: {
        o = p.Category, i = h.Ascending;
        break;
      }
      case u.xAxisDesc: {
        o = p.Category, i = h.Descending;
        break;
      }
      case u.meanAsc: {
        o = p.Mean, i = h.Ascending;
        break;
      }
      case u.meanDesc: {
        o = p.Mean, i = h.Descending;
        break;
      }
      case u.medianAsc: {
        o = p.Median, i = h.Ascending;
        break;
      }
      case u.medianDesc: {
        o = p.Median, i = h.Descending;
        break;
      }
    }
    e.orderOptions.data = {
      orderType: o,
      orderBy: i
    };
  }
}, N = (s) => s.showMean ?? !1, $ = (s) => {
  const { newShowMeanLines: e = !1, config: t, commonStrings: o, previousMeanLinesBoxColor: i } = s, r = e ? i : we(t), l = (e ?? !1) !== (t.showMean ?? !1);
  if (t.showMean = e, l) {
    let n;
    e ? n = he(t.series) ? Ve(t.series, o) : t.series : n = ke(t.series), n && (n = re({
      formerSeries: t.series,
      newSeries: n,
      showMean: e
    }), t.series = n);
  }
  return e && i !== void 0 && Le(i, t), { previousMeanLinesBoxColor: r };
}, bs = (s) => {
  let e = [];
  const t = s.orderOptions?.data?.orderType;
  return ne(s) === u.customSort && t === p.Category && (e = s.orderOptions?.data?.orderBy), e;
}, hs = (s, e) => {
  e.orderOptions ??= {};
  const t = e.orderOptions?.data?.orderType;
  ne(e) === u.customSort && t === p.Category && (e.orderOptions.data = {
    orderType: p.Category,
    orderBy: s
  });
}, Fs = async (s, e) => {
  const t = L(s), o = Z(s)?.type, i = se(s);
  let r = [];
  return o === f.CategoryAxisFormat && (W({
    fieldName: t,
    numericFields: i,
    fieldList: e.layerFieldsInfo
  }) ? r = i : E(t) || (r = await Fe({
    layerInfo: e,
    config: s,
    category: t
  }))), r;
}, E = (s) => s.trim() === "" || s === C, ze = (s, e) => e.length > 1 && !E(s), We = (s, e, t) => !ze(s, e) && t !== "";
export {
  us as A,
  le as B,
  T as C,
  ms as D,
  ps as a,
  qe as b,
  gs as c,
  ne as d,
  xs as e,
  Fs as f,
  Ss as g,
  bs as h,
  hs as i,
  N as j,
  $ as k,
  we as l,
  Le as m,
  L as n,
  Oe as o,
  se as p,
  We as q,
  fs as r,
  ze as s,
  ns as t,
  as as u,
  cs as v,
  ds as w,
  Te as x,
  ve as y,
  ys as z
};
