import "@arcgis/toolkit/intl";
import "lodash-es";
import "./series-types.js";
import "d3-array";
import { ap as o } from "./interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import "./runtime.js";
import { j as t, k as a } from "./index4.js";
import "@arcgis/toolkit/dom";
import { s as l, b as m, g as S, a as k } from "./series.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
const N = (s, e) => {
  if (t(e.series[s]) || a(e.series[s]))
    return S(e.series[s]);
}, z = (s, e, r) => {
  (t(r.series[e]) || a(r.series[e])) && l(s, r.series[e]);
}, W = (s, e) => {
  if (t(e.series[s]) || a(e.series[s]))
    return k(e.series[s]);
}, O = (s, e, r) => {
  (t(r.series[e]) || a(r.series[e])) && m(s, r.series[e]);
}, w = (s, e) => t(e.series[s]) || a(e.series[s]) ? e.series[s].markerSymbol?.color : void 0, F = (s, e, r) => {
  if (t(r.series[e]) || a(r.series[e])) {
    const i = r.series[e];
    i.markerSymbol === void 0 && (i.markerSymbol = o()), i.markerSymbol.color = s;
  }
}, q = (s, e) => t(e.series[s]) || a(e.series[s]) ? e.series?.[s]?.markerSymbol?.style : void 0, D = (s, e, r) => {
  if (t(r.series[e]) || a(r.series[e])) {
    const i = r.series[e];
    i.markerSymbol === void 0 && (i.markerSymbol = o()), i.markerSymbol.style = s;
  }
}, R = (s, e) => t(e.series[s]) || a(e.series[s]) ? e.series?.[s]?.markerSymbol?.size : void 0, E = (s, e, r) => {
  if (t(r.series[e]) || a(r.series[e])) {
    const i = r.series[e];
    i.markerSymbol === void 0 && (i.markerSymbol = o()), i.markerSymbol.size = s;
  }
}, G = (s, e) => t(e.series[s]) || a(e.series[s]) ? e.series?.[s]?.lineSmoothed ?? !1 : !1, H = (s) => {
  const { smoothed: e, seriesIndex: r, config: i } = s;
  (t(i.series[r]) || a(i.series[r])) && (i.series[r].lineSmoothed = e);
}, J = (s, e) => t(e.series[s]) || a(e.series[s]) ? e.series[s].showArea ?? !1 : !1, K = (s) => {
  const { visible: e, seriesIndex: r, config: i } = s;
  (t(i.series[r]) || a(i.series[r])) && (i.series[r].showArea = e);
}, P = (s, e) => t(e.series[s]) || a(e.series[s]) ? e.series[s].markerVisible ?? !0 : !1, Q = (s) => {
  const { visible: e, seriesIndex: r, config: i } = s;
  (t(i.series[r]) || a(i.series[r])) && (i.series[r].markerVisible = e);
}, U = (s, e) => t(e.series[s]) || a(e.series[s]) ? e.series[s].areaColor : void 0, X = (s, e) => t(e.series[s]) || a(e.series[s]) ? e.series?.[s]?.connectLines : void 0, Y = (s) => {
  const { connect: e, seriesIndex: r, config: i } = s;
  (t(i.series[r]) || a(i.series[r])) && (i.series[r].connectLines = e);
}, Z = (s, e) => t(e.series[s]) || a(e.series[s]) ? e.series[s].stackNegativeValuesToBaseline ?? !0 : !1, _ = (s) => {
  const { stackNegativeValuesToBaseline: e, seriesIndex: r, config: i } = s;
  (t(i.series[r]) || a(i.series[r])) && (i.series[r].stackNegativeValuesToBaseline = e);
};
export {
  z as a,
  O as b,
  D as c,
  E as d,
  W as e,
  w as f,
  N as g,
  q as h,
  R as i,
  G as j,
  H as k,
  J as l,
  K as m,
  P as n,
  Q as o,
  U as p,
  Z as q,
  _ as r,
  F as s,
  X as t,
  Y as u
};
