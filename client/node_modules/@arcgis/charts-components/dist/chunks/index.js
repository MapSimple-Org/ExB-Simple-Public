import { getElementLocale as De } from "@arcgis/toolkit/intl";
import { cloneDeep as s, isEmpty as S } from "lodash-es";
import { c7 as Me, f as te, h as We, u as qe, W as Ie, a2 as Ne, g as Ee, p as C, B as Ve, cC as c, bm as F, bo as Z, k as Ge, l as _e, a3 as ze, cE as je, cv as T, d as Y, cm as re, aI as He, bK as Re, aZ as $e, r as Qe } from "./interfaces.js";
import { p as J, u as B, W as l, a as b, g as m, t as v, c as Ye, o as U, i as g } from "./series-types.js";
import { h as Ke, i as Xe, a as Ze } from "./index4.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
var P = /* @__PURE__ */ ((r) => (r.NONE = "none", r.ROTATE = "rotate", r.STAGGER = "stagger", r.WRAP = "wrap", r))(P || {});
function ie(r) {
  const { configToUpdate: e, chartContainer: i, layer: t } = r, o = s(e);
  if (o.series[0]?.type === l.HeatSeries && t?.capabilities?.queryAttributeBins?.supportsFirstDayOfWeek === !0 && (!("firstDayOfWeek" in e) || e.firstDayOfWeek === void 0 || e.firstDayOfWeek === null)) {
    const { lang: n } = De(i ?? document.documentElement);
    try {
      o.firstDayOfWeek = je.local().setLocale(n.replaceAll("_", "-")).startOf("week", { useLocaleWeeks: !0 }).weekday;
    } catch {
    }
  }
  return o;
}
function Je(r) {
  const e = s(r);
  return S(r.axes) || (e.axes = r.axes?.map((i) => {
    const t = i;
    return delete t.calculateAutomaticMaximum, delete t.calculateAutomaticMinimum, t.title?.content.font?.style !== void 0 && (t.title.content.font.style = t.title.content.font.style.toLowerCase()), t;
  })), e;
}
function Ue(r) {
  const e = s(r);
  return S(r.series) || (e.series = r.series.map((i, t) => {
    const o = i;
    i.id === void 0 && (o.id = `Series ${Date.now()}-${t}`);
    const n = B(r.series, t);
    return (n === l.BarSeries || n === l.LineSeries || n === l.RadarSeries) && o.query?.outStatistics?.[0]?.statisticType === "median" && (o.query.outStatistics[0].statisticType = b.ContinuousPercentile), n === l.BarSeries && o.multipleBarType !== void 0 && (o.stackedType = o.multipleBarType, delete o.multipleBarType), n === l.PieSeries && o.sliceGrouping !== void 0 && (o.sliceGrouping.sliceId = Ne.defaultGroupOfSlicesId, o.sliceGrouping.groupName !== void 0 && (o.sliceGrouping = {
      ...o.sliceGrouping,
      label: o.sliceGrouping.groupName
    }, delete o.sliceGrouping.groupName), o.sliceGrouping.groupSliceSymbol !== void 0 && (o.sliceGrouping = {
      ...o.sliceGrouping,
      fillSymbol: o.sliceGrouping.groupSliceSymbol
    }, delete o.sliceGrouping.groupSliceSymbol)), o;
  })), e;
}
async function ee(r, e) {
  const i = [];
  return await Promise.all(
    r.map(async (t) => {
      if (!re(t)) {
        const o = T(t, !1);
        if (o.fieldToSort !== void 0) {
          const n = await F({
            queryObject: e,
            fieldToMatch: o.fieldToSort
          });
          n !== void 0 && i.push(
            o.orderBy === void 0 ? n : `${n} ${o.orderBy}`
          );
        }
      }
    })
  ), i;
}
async function oe(r, e) {
  const i = { ...r };
  let t = e;
  if (!t) {
    const o = Ke(r) ? r.iLayer : r.dataSource?.layer;
    o && (t = await Ee(o));
  }
  if (t) {
    const o = C(i.series), n = B(i.series), u = i.series && i.series.length > 0 && i.series[0].x.trim() === "" || n === l.GaugeSeries && !Ve(r) || o === c.PieFromFields || o === c.BarAndLineFromFields || o === c.BoxPlotMonoField || o === c.BoxPlotMonoFieldAndSplitBy || o === c.BoxPlotMultiFields || o === c.BoxPlotMultiFieldsAndSplitBy, h = n === l.ScatterSeries || o === c.BarAndLineNoAggregation || o === c.BarAndLineSplitByNoAggregation || o === c.BoxPlotMonoField || o === c.BoxPlotMonoFieldAndSplitBy || o === c.BoxPlotMonoFieldAndCategory || o === c.BoxPlotMonoFieldAndCategoryAndSplitBy || o === c.PieNoAggregation;
    if (i.series = await Promise.all(
      r.series.map(async (a) => {
        const d = { ...a };
        if (u || (d.x = await F({ queryObject: t, fieldToMatch: a.x })), "y" in d && h) {
          const y = d.y;
          if (Array.isArray(y)) {
            const f = await Z({
              fieldsList: y,
              queryObject: t
            });
            f !== void 0 && "y" in d && (d.y = f);
          } else "y" in d && typeof y == "string" && (d.y = await F({ queryObject: t, fieldToMatch: y }));
        }
        if (a.query !== void 0) {
          let { where: y, groupByFieldsForStatistics: f, outStatistics: p } = a.query;
          if (f = await Z({ fieldsList: f, queryObject: t }), p !== void 0 && (p = await Promise.all(
            p.map(async (O) => {
              const x = { ...O };
              return x.onStatisticField = await F({
                queryObject: t,
                fieldToMatch: O.onStatisticField
              }), x;
            })
          )), y !== void 0 && o === c.BarAndLineSplitBy) {
            const O = Ge(a.query?.where), x = _e({
              where: a.query?.where,
              normalize: !1,
              escape: !1
            });
            y = `${await F({ queryObject: t, fieldToMatch: O })}=${x}`;
          }
          d.query !== void 0 && (y !== void 0 && (d.query.where = y), f !== void 0 && (d.query.groupByFieldsForStatistics = f), p !== void 0 && (d.query.outStatistics = p));
        }
        return d;
      })
    ), i.series[0]?.query !== void 0) {
      const a = i.series[0].query;
      let { orderByFields: d } = a;
      d !== void 0 && d.length > 0 && (d = await ee(d, t), d.length > 0 && a.orderByFields !== void 0 && (i.series[0].query.orderByFields = d));
    }
    if (i.orderOptions?.orderByFields !== void 0) {
      let { orderByFields: a } = i.orderOptions;
      a !== void 0 && a.length > 0 && (a = await ee(a, t), a.length > 0 && (i.orderOptions.orderByFields = a));
    }
    if (n === l.GaugeSeries && r.axes?.[0] !== void 0) {
      const { minimumFromField: a, maximumFromField: d } = r.axes[0];
      if (a !== void 0) {
        const y = typeof a == "string" ? a : a.onStatisticField, f = await F({ queryObject: t, fieldToMatch: y });
        let p = a;
        typeof r.axes[0].minimumFromField == "string" ? p = f : typeof a == "object" && (p = {
          ...a,
          onStatisticField: f
        }), r.axes[0].minimumFromField = p;
      }
      if (d !== void 0) {
        const y = typeof d == "string" ? d : d.onStatisticField, f = await F({ queryObject: t, fieldToMatch: y });
        let p = d;
        typeof r.axes[0].maximumFromField == "string" ? p = f : typeof d == "object" && (p = {
          ...d,
          onStatisticField: f
        }), r.axes[0].maximumFromField = p;
      }
    }
  }
  return i;
}
function se(r) {
  const e = s(r);
  if (!S(r.series) && B(r.series) === l.BoxPlotSeries) {
    const t = e.series[0];
    t && (t.showOutliers !== void 0 && (r.showOutliers === void 0 && (e.showOutliers = t.showOutliers), delete t.showOutliers), t.standardizeValues !== void 0 && (r.standardizeValues === void 0 && (e.standardizeValues = t.standardizeValues), delete t.standardizeValues), t.showMean !== void 0 && (r.showMean === void 0 && (e.showMean = t.showMean), delete t.showMean));
  }
  return e;
}
function ne(r) {
  const e = {
    orderType: v.Category,
    orderBy: m.Ascending
  }, i = r.query?.orderByFields?.[0];
  if (i !== void 0) {
    const { outStatisticFieldName: t, statisticType: o } = r.query?.outStatistics?.[0] ?? {}, n = T(i);
    t !== void 0 && n.fieldToSort === t && o !== void 0 && (o === b.Average || o === "mean" ? e.orderType = v.Mean : o === b.ContinuousPercentile && (e.orderType = v.Median)), e.orderBy = n.orderBy ?? m.Ascending;
  }
  return e;
}
function ae(r) {
  let e = !1;
  const i = Array.from(new Set(r.series.map((t) => t.type)));
  return i.length === 2 && i.includes(l.BoxPlotSeries) && i.includes(l.LineSeries) && (e = r.series.find((o) => o.type === l.LineSeries)?.query?.outStatistics?.[0] !== void 0), e;
}
function de(r) {
  const e = s(r);
  if (!S(e.series) && B(r.series) === l.BoxPlotSeries) {
    if (e.orderOptions?.data === void 0) {
      const t = ne(r.series[0]);
      t.orderType !== void 0 && (e.orderOptions ??= {}, e.orderOptions.data = {
        orderType: t.orderType,
        orderBy: t.orderBy
      });
    }
    if (e.series = r.series.map((t) => {
      const o = t;
      return S(o.x?.trim()) && (o.x = ze), delete o.query?.orderByFields, o;
    }), ae(e)) {
      e.showMean = !0;
      const t = e.series.find(
        (o) => o.type === l.BoxPlotSeries
      );
      e.series.forEach((o) => {
        o.type === l.LineSeries && (delete o.query?.groupByFieldsForStatistics, delete o.query?.outStatistics, delete o.query?.orderByFields, t && (o.y = t.y));
      });
    }
    e.series = r.series.map((t) => {
      const o = t;
      return delete o.query?.outStatistics, o;
    });
  }
  return e;
}
function et(r) {
  const e = s(r);
  return e.legend !== void 0 && !Number.isFinite(e.legend.maxHeight) && (e.legend.maxHeight = Number.NaN), e;
}
function le(r) {
  const e = s(r);
  return "dataSource" in e && e.dataSource.layer && (e.iLayer = e.dataSource.layer, delete e.dataSource), e;
}
function ce(r) {
  const e = s(r), i = /* @__PURE__ */ new Set(), t = e.id ?? "";
  return i.add(t), e.series.forEach((o) => {
    let n = o.id;
    i.has(n) && (n = `${n}_${Date.now()}`, o.id = n), i.add(n);
  }), e;
}
async function ue(r) {
  const { configToUpdate: e, layer: i, chartContainer: t } = r;
  let o = s(e);
  return o = Je(o), o = Ue(o), o = await oe(o, i), o = se(o), o = de(o), o = et(o), o = ce(o), o = ie({ configToUpdate: o, chartContainer: t, layer: i }), o;
}
function ye(r) {
  const e = s(r);
  return e?.orderOptions?.orderByFields !== void 0 && C(r.series) === c.PieFromFields && (e.orderOptions.orderByFields = r?.orderOptions?.orderByFields?.map(
    (i) => {
      let t = s(i);
      return i !== void 0 && i.includes("arcgis_charts_pie_category_from_fields_name") && (t = i.replace(
        "arcgis_charts_pie_category_from_fields_name",
        Y
      )), t;
    }
  )), e;
}
function tt(r) {
  const e = s(r);
  if (!S(r.series) && e.axes?.[0] !== void 0 && B(r.series) === l.GaugeSeries && r.axes?.[0] !== void 0) {
    const t = r.axes[0];
    t.ticks !== void 0 && Object.hasOwn(t.ticks, "spacing") && delete t.ticks.spacing, e.axes[0] = t;
  }
  return e;
}
function fe(r) {
  const e = s(r), { extent: i } = e.series[0]?.query ?? {};
  return i !== void 0 && (e.dataFilters = {
    ...e.dataFilters,
    geometry: i
  }, e.series.forEach((t) => {
    "query" in t && "extent" in t.query && delete t.query.extent;
  })), e;
}
function K(r) {
  const e = s(r);
  return S(r.series) || (Xe(r) && r.rotated === void 0 && (e.rotated = r.series[0].rotated ?? He()), e.series.forEach((i) => {
    i.rotated !== void 0 && delete i.rotated;
  })), e;
}
function pe(r) {
  const e = s(r), i = r.dataSource;
  return "dataSource" in e && !S(i) && (i.type === "featureLayer" && e.dataSource !== void 0 && (e.dataSource.type = "layer"), "featureLayer" in i && (e.dataSource.layer = i.featureLayer, delete e.dataSource.featureLayer)), e;
}
function me(r) {
  const e = s(r);
  if ("dataSource" in r) {
    const i = r.dataSource;
    if (i.filter !== void 0 && i.filter.trim() !== "") {
      const t = Re([i.filter, e.dataFilters?.where]);
      e.dataFilters = {
        ...e.dataFilters,
        where: t
      }, delete e.dataSource.filter;
    }
  }
  return e;
}
function ve(r) {
  return r !== "originalValue";
}
function X(r) {
  let e;
  switch (r) {
    case "mean":
      e = v.Mean;
      break;
    case "median":
      e = v.Median;
      break;
    case "category":
      e = v.Category;
      break;
  }
  return e;
}
function Se(r) {
  const e = s(r);
  if (!S(r.series) && B(r.series) === l.PieSeries) {
    const t = e.series[0];
    if (t) {
      if (t.sortLabelsBy === "originalValue")
        e.sortLabelsBy = t.sortLabelsBy;
      else if (t.sortLabelsBy !== void 0 && e.orderOptions?.data === void 0) {
        const o = w(e);
        o !== void 0 && (e.orderOptions ??= {}, e.orderOptions.data = o);
      }
      t.sortLabelsBy && delete t.sortLabelsBy;
    }
  }
  return e;
}
function he(r) {
  const e = s(r);
  return S(r.series) || (Ze(r) && r.stackedType === void 0 && (e.stackedType = r.series[0].stackedType ?? $e()), e.series.forEach((i) => {
    "stackedType" in i && delete i.stackedType;
  })), e;
}
function Be(r) {
  const e = s(r), i = r.sortOptions?.sortSeriesBy;
  return e.orderOptions === void 0 && typeof i == "string" && (e.orderOptions ??= {}, e.orderOptions.series = {
    orderBy: i === "DESC" ? m.Descending : m.Ascending
  }), e;
}
function ge(r) {
  const e = s(r);
  return e.colorMatch === void 0 && e.series[0]?.colorType !== void 0 && (e.colorMatch = e.series[0]?.colorType === Ye.Match), e.series.forEach((i) => {
    i.colorType !== void 0 && delete i.colorType;
  }), e;
}
function Fe(r) {
  const e = s(r);
  if (e.sortDataBy !== void 0) {
    if (e.orderOptions?.data === void 0) {
      const i = r.sortDataBy, t = X(i?.sortType);
      t !== void 0 && (e.orderOptions ??= {}, e.orderOptions.data = {
        orderType: t,
        orderBy: i?.sortOrder ?? m.Ascending
      });
    }
    delete e.sortDataBy;
  }
  return e;
}
function be(r) {
  const e = s(r);
  return e.axes?.forEach((i) => {
    i !== void 0 && i.scrollbarVisible !== void 0 && i.scrollbar?.visible === void 0 && (i.scrollbar = {
      ...i.scrollbar,
      visible: i.scrollbarVisible
    }, delete i.scrollbarVisible);
  }), e;
}
function Oe(r) {
  const e = s(r), i = e.series[0]?.query?.orderByFields;
  if (i !== void 0 && i.length > 0 && e.orderOptions?.orderByFields === void 0) {
    e.orderOptions ??= {};
    let t = !0;
    if (i.length === 1) {
      const { fieldToSort: o, orderBy: n } = T(i[0]);
      let u;
      o === r.series[0].x || o === Y ? u = v.Category : "y" in r.series[0] && o === r.series[0].y && (u = v.YValue), u !== void 0 && (t = !1, e.orderOptions.data === void 0 && (e.orderOptions.data = {
        orderType: u,
        orderBy: n?.toUpperCase() === "DESC" ? m.Descending : m.Ascending
      }));
    }
    t && (e.orderOptions.orderByFields = i);
  }
  return e.series.forEach((t) => {
    delete t.query?.orderByFields;
  }), e;
}
function w(r) {
  let e, i = r.orderOptions?.orderByFields?.[0];
  if (r.series?.length > 0) {
    const t = B(r.series), o = C(r.series);
    if (t !== l.PieSeries && o !== c.BarAndLineFromFields && (i = i ?? r.series[0].x), i && !re(i)) {
      const { fieldToSort: n, orderBy: u } = T(i);
      let h;
      n === r.series[0].x || n === Y ? h = v.Category : "y" in r.series[0] && n === r.series[0].y && (h = v.YValue), h !== void 0 && (e = {
        orderType: h,
        orderBy: u?.toUpperCase() === "DESC" ? m.Descending : m.Ascending
      });
    }
  }
  return e;
}
function xe(r) {
  const e = s(r), i = r, t = r, o = r, n = r, u = r;
  if (e) {
    if (e.orderOptions?.series === void 0 && i.sortOptions?.sortSeriesBy !== void 0 && (e.orderOptions ??= {}, e.orderOptions.series = {
      preferLabel: ve(
        t.sortLabelsBy ?? i.sortOptions.sortSeriesBy.sortType
      ),
      orderBy: i.sortOptions.sortSeriesBy.sortOrder ?? m.Ascending
    }), t.sortLabelsBy === "originalValue" || n.orderOptions?.data?.preferDataLabel === !1 || u.orderOptions?.data?.preferLabel === !1)
      e.orderOptions?.data && delete e.orderOptions.data;
    else if (e.orderOptions?.data === void 0)
      if (B(e.series) === l.BoxPlotSeries) {
        if (t.sortLabelsBy || o.sortOptions?.sortDataBy !== void 0) {
          const a = X(o.sortOptions?.sortDataBy?.sortType);
          a !== void 0 && (e.orderOptions ??= {}, e.orderOptions.data = {
            orderType: a,
            orderBy: o.sortOptions?.sortDataBy?.sortOrder ?? m.Ascending
          });
        }
      } else {
        const a = w(e);
        a !== void 0 && (e.orderOptions ??= {}, e.orderOptions.data = a);
      }
    "sortLabelsBy" in e && delete e.sortLabelsBy, "sortOptions" in e && delete e.sortOptions;
  }
  return e;
}
function Ce(r) {
  const e = s(r);
  if (e) {
    const i = C(e.series);
    if ((i === c.BarAndLineFromFields || i === c.PieFromFields) && e.orderOptions?.data === void 0 && e.orderOptions?.orderByFields !== void 0) {
      const t = w(e);
      t !== void 0 && (e.orderOptions ??= {}, e.orderOptions.data = t, delete e.orderOptions.orderByFields);
    }
  }
  return e;
}
function rt(r) {
  const e = s(r);
  return e.horizontalAxisLabelsBehavior === P.NONE && (e.horizontalAxisLabelsBehavior = U.Hide), e.verticalAxisLabelsBehavior === P.NONE && (e.verticalAxisLabelsBehavior = U.Hide), e;
}
function Te(r) {
  const e = s(r), i = e.series[0];
  if (i && !i.temporalBinning && Qe(e.series[0]) && ("timeIntervalSize" in i || "timeIntervalUnits" in i || "timeAggregationType" in i || "trimIncompleteTimeInterval" in i || "nullPolicy" in i)) {
    if (i.temporalBinning = {}, i.timeIntervalSize !== void 0 && (i.temporalBinning.size = i.timeIntervalSize, delete i.timeIntervalSize), i.timeIntervalUnits) {
      let t;
      switch (i.timeIntervalUnits) {
        case "esriTimeUnitsSeconds":
          t = g.Second;
          break;
        case "esriTimeUnitsMinutes":
          t = g.Minute;
          break;
        case "esriTimeUnitsHours":
          t = g.Hour;
          break;
        case "esriTimeUnitsDays":
          t = g.Day;
          break;
        case "esriTimeUnitsWeeks":
          t = g.Week;
          break;
        case "esriTimeUnitsMonths":
          t = g.Month;
          break;
        case "esriTimeUnitsYears":
          t = g.Year;
          break;
      }
      t !== void 0 && (i.temporalBinning.unit = t), delete i.timeIntervalUnits;
    }
    i.timeAggregationType && (i.temporalBinning.timeAggregationType = i.timeAggregationType, delete i.timeAggregationType), i.trimIncompleteTimeInterval !== void 0 && (i.temporalBinning.trimIncompleteTimeInterval = i.trimIncompleteTimeInterval, delete i.trimIncompleteTimeInterval), i.nullPolicy && (i.temporalBinning.nullPolicy = i.nullPolicy, delete i.nullPolicy);
  }
  return e;
}
function we(r) {
  const e = s(r);
  return e.series.forEach((i) => {
    i.query?.outStatistics?.forEach((t) => {
      t.statisticType === "percentile_cont" ? t.statisticType = b.ContinuousPercentile : t.statisticType === "percentile_disc" && (t.statisticType = b.DiscretePercentile);
    });
  }), e;
}
function Pe(r) {
  const e = s(r);
  return e.subtitle === void 0 && e.subTitle && (e.subtitle = e.subTitle), delete e.subTitle, e;
}
function Le(r) {
  const e = s(r), i = e.series[0];
  return i?.temporalBinning && delete i.temporalBinning?.type, e;
}
function ke(r) {
  let e = s(r);
  return e = ye(e), e;
}
function L(r) {
  let e = s(r);
  return e = tt(e), e;
}
function k(r) {
  let e = s(r);
  return e = fe(e), e;
}
function A(r) {
  let e = s(r);
  return e = K(e), e;
}
function D(r) {
  let e = s(r);
  return e = pe(e), e;
}
function M(r) {
  let e = s(r);
  return e = me(e), e;
}
function W(r) {
  let e = s(r);
  return e = Se(e), e;
}
function q(r) {
  let e = s(r);
  return e = Be(e), e;
}
function I(r) {
  let e = s(r);
  return e = ge(e), e;
}
function N(r) {
  return be(r);
}
function E(r) {
  let e = s(r);
  return r.series[0]?.type === l.BoxPlotSeries && (e = Fe(e)), e;
}
function V(r) {
  return he(r);
}
function G(r) {
  return xe(r);
}
function _(r) {
  return le(r);
}
function z(r) {
  return Ce(r);
}
function j(r) {
  return rt(r);
}
function H(r) {
  return Te(r);
}
function R(r) {
  return we(r);
}
function $(r) {
  let e = s(r);
  return e = K(e), Pe(e);
}
function Q(r) {
  let e = s(r);
  return e = Le(e), e;
}
function Ae(r) {
  const { versionsToConvert: e = [], configToUpdate: i } = r;
  let t = s(i);
  return e.length > 0 && t !== void 0 && (t = Oe(t), e.includes(te) || e.includes(qe) ? (t = ke(t), t = L(t), t = k(t), t = A(t), t = D(t), t = M(t), t = W(t), t = q(t), t = I(t), t = N(t), t = E(t), t = V(t), t = G(t), t = _(t), t = z(t), t = j(t), t = H(t), t = R(t), t = $(t), t = Q(t)) : e.forEach((o) => {
    if (t !== void 0)
      switch (o) {
        case "1.0.1":
          t = L(t);
          break;
        case "3.4.0":
          t = k(t);
          break;
        case "4.0.0":
          t = A(t);
          break;
        case "4.0.1":
          t = D(t);
          break;
        case "6.4.0":
          t = M(t);
          break;
        case "7.5.1":
          t = W(t);
          break;
        case "8.0.0":
          t = q(t);
          break;
        case "9.2.0":
          t = I(t);
          break;
        case "9.7.0":
          t = N(t);
          break;
        case "10.0.0":
          t = E(t);
          break;
        case "11.0.0":
          t = V(t);
          break;
        case "14.0.1":
          t = G(t);
          break;
        case "16.0.0":
          t = _(t);
          break;
        case "16.1.0":
          t = z(t);
          break;
        case "18.1.3":
          t = j(t);
          break;
        case "20.1.0":
          t = H(t);
          break;
        case "21.0.0":
          t = R(t);
          break;
        case "23.2.0":
          t = $(t);
          break;
        case "24.3.0":
          t = Q(t);
          break;
      }
  }), t.version = Ie), t;
}
async function lt(r, e, i) {
  let t = r;
  if (r) {
    const o = Me(e);
    t = await ue({ configToUpdate: r, layer: o, chartContainer: i });
    const n = r.version ?? te, { versionStatus: u, versions: h } = We(n);
    (u === J.Older || u === J.Unrecognized) && (t = Ae({
      versionsToConvert: h,
      configToUpdate: t
    }));
  }
  return t;
}
const ct = {
  matchChartFieldsToLayerFields: oe,
  moveSeriesQueryExtent: fe,
  moveSeriesRotatedPropToChart: K,
  renameDataSourceProperties: pe,
  copyDataSourceFilterToConfig: me,
  adjustPieFromFieldsDefaultNameAndValue: ye,
  moveBoxPlotSeriesPropsToChart: se,
  movePieSeriesSortLabelsPropToChart: Se,
  getProBoxPlotSortDataOption: ne,
  isBoxPlotConfigWithMeanLinesFromPro: ae,
  preventDuplicatedIds: ce,
  adjustBoxPlotConfig: de,
  convertSortSeriesByToObject: Be,
  moveBoxPlotSortDataByProp: Fe,
  handleColorMatchChanges: ge,
  moveScrollbarVisible: be,
  moveSeriesStackedTypePropToChart: he,
  convertBoxplotOldToNewDataSortType: X,
  getDataOrderFromOrderByFields: w,
  convertWebChartDataValueTypes: ve,
  moveOrConvertSeriesOrderByFieldsToChartOrderOptions: Oe,
  handleOrderOptionsChanges: xe,
  applyDataOrderInstructionForFromFieldsCharts: Ce,
  convertTemporalBinningProps: Te,
  convertRESTStatisticTypeToWebChartStatisticType: we,
  renameChartSubtitle: Pe,
  applyMandatoryConversions: ue,
  convertTo1x0x1: ke,
  convertTo2x0x0: L,
  convertTo3x5x0: k,
  convertTo4x0x1: A,
  convertTo5x0x0: D,
  convertTo7x0x0: M,
  convertTo7x6x0: W,
  convertTo8x0x1: q,
  convertTo9x3x0: I,
  convertTo10x0x0: N,
  convertTo11x0x0: E,
  convertTo12x0x0: V,
  convertTo15x0x0: G,
  convertTo16x1x0: _,
  convertTo16x1x1: z,
  convertTo19x0x0: j,
  convertTo20x2x0: H,
  convertTo21x1x0: R,
  convertTo23x3x0: $,
  convertTo24x4x0: Q,
  convertTemporalBinningProps2: Le,
  applyConversions: Ae,
  convertDataSourceToILayer: le,
  applyDefaultFirstDayOfWeek: ie
};
export {
  ct as a,
  lt as c
};
