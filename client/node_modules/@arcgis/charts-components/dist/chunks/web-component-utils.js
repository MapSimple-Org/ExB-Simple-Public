import { W as P, u as Q } from "./series-types.js";
import { isEqual as X, capitalize as g, isNumber as A, zip as E } from "lodash-es";
import { b as k } from "./interfaces3.js";
import { a as _ } from "./common.js";
import { p as v, c7 as Y, cC as d, I as T, b3 as h, a3 as D, bg as U, P as B, b0 as W, b1 as K } from "./interfaces.js";
import { g as J } from "./histogram-data.js";
import { a as ee, g as Z } from "./data.js";
import { f as te, h as oe, j as q, k as ie } from "./data2.js";
import { g as ae, a as se, b as le } from "./pie-chart-data.js";
import { j as ne, n as N, p as G, o as R } from "./box-plot-data.js";
import { C as M } from "./interfaces4.js";
import { g as re } from "./index3.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
const we = [
  P.BarSeries,
  P.BoxPlotSeries,
  P.LineSeries,
  P.PieSeries,
  P.HistogramSeries,
  P.ScatterSeries
], ve = 1, Oe = { PNG: "png" };
function ce(u, e) {
  return !X(u, e);
}
function Ve(u, e) {
  return ce(u, e) || u !== e;
}
function ue(u) {
  return (new Intl.NumberFormat(u, {
    minimumFractionDigits: 1,
    maximumFractionDigits: 1
  }).formatToParts(1.1).find((n) => n.type === "decimal")?.value ?? ".") === "." ? "," : ";";
}
const z = (u) => {
  const { value: e, quoteAll: t = !1, locale: n = "en" } = u;
  let i = e == null ? "" : String(e);
  if (Number.isFinite(Number(i))) {
    const a = Number(i);
    i = new Intl.NumberFormat(n, {
      minimumFractionDigits: 0,
      maximumFractionDigits: 2
    }).format(a).replace(/\u202F/gu, " ");
  }
  return (t || /[",\r\n]/u.test(i)) && (i = `"${i.replace(/"/gu, '""')}"`), i;
};
function ke(u, e = {}) {
  const { columns: t, delimiter: n, includeHeader: i = !0, quoteAll: o = !1, locale: a } = e, m = u.length === 0;
  let r = "";
  if (!m) {
    const f = t ?? Object.keys(u[0]), F = [], p = a ?? re().formatLocale, y = n ?? ue(p);
    if (r += `sep=${y}\r
`, i) {
      const s = f.map((c) => z({ value: c, quoteAll: o, locale: p }));
      F.push(s.join(y));
    }
    u.forEach((s) => {
      const c = f.map((l) => z({ value: s[l], quoteAll: o, locale: p }));
      F.push(c.join(y));
    }), r += F.join(`\r
`);
  }
  return r;
}
function Te(u) {
  const { rawData: e, config: t, layer: n, fieldList: i } = u;
  let o = e;
  if (t !== void 0 && Array.isArray(e) && e.length > 0) {
    const a = Q(t?.series);
    a === P.HistogramSeries ? o = de(t, e) : a === P.BarSeries || a === P.LineSeries || a === P.ComboLineAndBarSeries ? o = fe({
      config: t,
      rows: e,
      layer: n,
      fieldList: i
    }) : a === P.PieSeries ? o = ye({
      config: t,
      rows: e,
      layer: n,
      fieldList: i
    }) : a === P.BoxPlotSeries && (o = ge({
      config: t,
      rows: e,
      fieldList: i
    }));
  }
  return o;
}
function de(u, e) {
  const t = J(u), n = `${g(k.Min)} of ${t}`, i = `${g(k.Max)} of ${t}`, o = `${g(k.Count)} of ${t}`;
  return e.map((a) => {
    const { minValue: m, maxValue: r, count: f } = a, F = A(m), p = A(r), y = A(f), s = {};
    return F && (s[n] = m.toFixed(2)), p && (s[i] = r.toFixed(2)), F && p && (s.Label = `${m.toFixed(2)} - ${r.toFixed(2)}`), y && (s[o] = f), s;
  });
}
function H(u, e, t) {
  const n = Object.keys(u);
  let i = [];
  return t ? i = t.map((o) => n.find((a) => a.toLowerCase().includes(o.toLowerCase())) || "") : i = n.filter((a) => a.toLowerCase().includes(e.toLowerCase())), i.filter((o) => o.trim() !== "");
}
function fe(u) {
  const { config: e, rows: t, layer: n, fieldList: i } = u, o = ee(e), a = te(e), m = g(a), r = oe(e), f = v(e.series), F = q(e), p = ie(e), y = Y(n)?.objectIdField ?? "FID", s = r.length === 1 && r[0] === y;
  let c;
  switch (f) {
    case d.BarAndLineNoAggregation:
      c = t.map((l) => {
        const x = C({
          field: o,
          value: l[o],
          fieldList: i
        }), b = { [o]: x };
        return Object.assign(b, ...r.map((S) => ({ [S]: l[S] }))), b;
      });
      break;
    case d.BarAndLineFromFields:
      c = E(r, t).map(([l, x]) => {
        const b = T(e.series)[0], S = {};
        return x !== void 0 && l !== void 0 && (S.Field = x[o], S.Value = x[b]), S;
      });
      break;
    case d.BarAndLineMonoField:
    case d.BarAndLineMultiFields:
      c = t.map((l) => {
        const x = C({
          field: o,
          value: l[o],
          fieldList: i
        }), b = { [o]: x };
        return r.forEach((S, L) => {
          const O = Z({
            config: e,
            xAxisField: o,
            numericFields: r,
            aggregationType: a,
            layer: n,
            numericFieldIndex: L,
            fieldList: i
          }), V = T(e.series)[L];
          let I = V, j = V;
          V.toLowerCase() === O.name.toLowerCase() && (I = O.description, j = O.name), b[I] = l[j];
        }), b;
      });
      break;
    case d.BarAndLineSplitBy:
      c = t.flatMap((l) => {
        const x = H(l, r[0]), b = C({
          field: o,
          value: l[o],
          fieldList: i
        });
        return F.map(
          (S, L) => ({
            [o]: b,
            [p]: S,
            [s ? m : `${m} of ${r[0]}`]: l[x[L]]
          })
        );
      });
      break;
    case d.BarAndLineSplitByNoAggregation:
      c = t.map((l) => {
        const x = C({
          field: o,
          value: l[o],
          fieldList: i
        }), b = H(l, r[0], F);
        return {
          [o]: x,
          [p]: l[p],
          [r[0]]: l[b[0]]
        };
      });
      break;
    default:
      c = t;
  }
  return c;
}
function me(u, e = 2) {
  if (u.length === 0)
    return [];
  const t = u.reduce((n, i) => {
    for (const [o, a] of Object.entries(i))
      typeof a == "number" && Number.isFinite(a) && (n[o] = (n[o] ?? 0) + a);
    return n;
  }, {});
  return u.map((n) => {
    const i = { ...n };
    for (const [o, a] of Object.entries(n))
      if (typeof a == "number" && t[o] > 0) {
        const m = a / t[o] * 100;
        i[`${o}${h}`] = `${m.toFixed(e)}%`;
      }
    return i;
  });
}
function ye(u) {
  const { config: e, rows: t, layer: n, fieldList: i } = u, o = ae(e), a = v(e.series);
  let m = me(t, 2);
  const r = se(e), f = a !== d.PieFromFields ? _.Category : _.Fields, F = le(e, f), p = Z({
    config: e,
    xAxisField: o,
    numericFields: r,
    aggregationType: F,
    mode: f,
    layer: n,
    fieldList: i
  }), y = T(e.series)[0];
  return a === d.PieFromCategory ? m = m.map((s) => {
    const c = C({
      field: o,
      value: s[o],
      fieldList: i
    }), l = { [o]: c };
    let x = y, b = y;
    return y.toLowerCase() === p.name.toLowerCase() && (x = p.description, b = p.name), l[x] = s[b], l[g(h.trim())] = s[`${b}${h}`], l;
  }) : a === d.PieFromFields && (m = E(r, m).map(([s, c]) => {
    const l = {};
    return c !== void 0 && s !== void 0 && (l.Field = c[o], l.Value = c[y], l[g(h.trim())] = c[`${y}${h}`]), l;
  })), m;
}
function w(u) {
  const { rawData: e, keyBase: t = "", outRow: n } = u;
  for (const [i, o] of Object.entries(B)) {
    const a = e[t + o];
    a !== void 0 && (n[i] = A(a) ? a.toFixed(2) : a);
    const m = e[t + o + W];
    m !== void 0 && (n[`${i} Outlier`] = A(m) ? m.toFixed(2) : m);
    const r = e[t + o + K];
    r !== void 0 && (n[`${i} Z-Score`] = A(r) ? r.toFixed(2) : r);
  }
}
function $(u) {
  const { rawData: e, outRow: t, config: n, boxPlotSubType: i, fieldList: o } = u, a = N(n), m = G(n), r = R(n);
  let f = B.Outlier;
  const F = D;
  switch (i) {
    case d.BoxPlotMonoFieldAndCategory: {
      const s = C({
        field: a,
        value: e[a],
        fieldList: o
      });
      t[a] = s, t[g(B.Outlier)] = e[f];
      break;
    }
    case d.BoxPlotMultiFieldsAndCategory: {
      t[g(a)] = e[a], f = `${m.find(
        (c) => Object.keys(e).some((l) => l.toLowerCase().includes(c.toLowerCase()))
      ) ?? ""}_${f}`, t[g(B.Outlier)] = e[f];
      break;
    }
    case d.BoxPlotMonoFieldAndSplitBy:
    case d.BoxPlotMultiFieldsAndSplitBy: {
      const s = e[r];
      f = `${s}_${f}`, t.Field = e[F], t[g(r)] = s, t[g(B.Outlier)] = e[f];
      break;
    }
    case d.BoxPlotMonoFieldAndCategoryAndSplitBy: {
      const s = e[r];
      f = `${s}_${f}`, t[g(a)] = e[a], t[g(r)] = s, t[g(B.Outlier)] = e[f];
      break;
    }
    case d.BoxPlotMonoField:
    case d.BoxPlotMultiFields:
    default: {
      t.Field = e[F], t[g(B.Outlier)] = e[f];
      break;
    }
  }
  const p = `${f}${K}`, y = e[p];
  y !== void 0 && (t[`${g(B.Outlier)} Z-Score`] = A(y) ? y.toFixed(2) : y);
}
function pe(u) {
  const { rawData: e, outRow: t, config: n, splitByValue: i } = u, o = v(n.series), a = e[`${i}_${B.Average}`], m = R(n), r = N(n);
  let f = "";
  switch (o) {
    case d.BoxPlotMonoFieldAndSplitBy: {
      f = `${i}_${m}`, t.Field = e[D], t[g(m)] = e[f];
      break;
    }
    case d.BoxPlotMultiFieldsAndSplitBy: {
      f = `${i}_${B.Average}`, t.Field = e[D], t[g(m)] = e[f];
      break;
    }
    case d.BoxPlotMonoFieldAndCategoryAndSplitBy: {
      f = `${i}_${B.Average}`, t[r] = e[r], t[g(m)] = i;
      break;
    }
  }
  t[g(B.Average)] = A(a) ? a.toFixed(2) : a;
  const F = `${a}${K}`, p = e[F];
  p !== void 0 && (t[`${g(B.Average)} Z-Score`] = A(p) ? p.toFixed(2) : p);
}
function ge(u) {
  const { config: e, rows: t, fieldList: n } = u, i = v(e.series);
  let o = i;
  const a = ne(e), m = Array.isArray(t) && t.length > 0 && t.every((s) => s[M.boxPlot.boxPlotMeanLineMarkerId] !== void 0);
  a && !m && (i === d.BoxPlotMonoFieldAndSplitBy ? o = d.BoxPlotMonoField : i === d.BoxPlotMultiFieldsAndSplitBy ? o = d.BoxPlotMultiFields : i === d.BoxPlotMonoFieldAndCategoryAndSplitBy && (o = d.BoxPlotMonoFieldAndCategory));
  const r = N(e), f = G(e), F = q(e), p = R(e);
  let y;
  switch (o) {
    case d.BoxPlotMonoField:
    case d.BoxPlotMonoFieldAndCategory: {
      y = t.map((s) => {
        const c = {};
        if (s[M.boxPlot.boxPlotOutlierId])
          $({ rawData: s, outRow: c, config: e, boxPlotSubType: o });
        else {
          if (o === d.BoxPlotMonoFieldAndCategory) {
            const l = C({
              field: r,
              value: s[r],
              fieldList: n
            });
            c[r] = l;
          } else o === d.BoxPlotMonoField && (c.Field = s[D]);
          w({ rawData: s, outRow: c });
        }
        return c;
      });
      break;
    }
    case d.BoxPlotMultiFields: {
      y = t.flatMap((s) => {
        const c = {};
        return s[M.boxPlot.boxPlotOutlierId] ? $({
          rawData: s,
          outRow: c,
          config: e,
          boxPlotSubType: o
        }) : (c.Field = s[D], w({ rawData: s, outRow: c })), [c];
      });
      break;
    }
    case d.BoxPlotMultiFieldsAndCategory: {
      y = t.flatMap(
        (s) => f.map((c) => {
          const l = {};
          let x = "";
          if (l.Field = c, s[M.boxPlot.boxPlotOutlierId])
            $({
              rawData: s,
              outRow: l,
              config: e,
              boxPlotSubType: o
            });
          else {
            if (o === d.BoxPlotMultiFieldsAndCategory) {
              const b = C({
                field: r,
                value: s[r],
                fieldList: n
              });
              l[r] = b, x = `${c}_`;
            }
            w({ rawData: s, outRow: l, keyBase: x });
          }
          return l;
        })
      );
      break;
    }
    case d.BoxPlotMonoFieldAndSplitBy:
    case d.BoxPlotMultiFieldsAndSplitBy:
    case d.BoxPlotMonoFieldAndCategoryAndSplitBy: {
      y = t.flatMap((s) => {
        if (s[M.boxPlot.boxPlotOutlierId]) {
          const c = {};
          return $({
            rawData: s,
            outRow: c,
            config: e,
            boxPlotSubType: o
          }), [c];
        } else return s[M.boxPlot.boxPlotMeanLineMarkerId] ? F?.map((c) => {
          const l = {};
          return pe({
            rawData: s,
            outRow: l,
            splitByValue: c,
            config: e
          }), l;
        }) : F.map((c) => {
          const l = {};
          if (o === d.BoxPlotMonoFieldAndCategoryAndSplitBy) {
            const x = C({
              field: r,
              value: s[r],
              fieldList: n
            });
            l[r] = x;
          }
          return s[M.boxPlot.boxPlotOutlierId] ? $({
            rawData: s,
            outRow: l,
            config: e,
            boxPlotSubType: o
          }) : (l[p] = c, w({ rawData: s, outRow: l, keyBase: `${c}_` })), l;
        });
      });
      break;
    }
    default:
      y = t;
  }
  return y;
}
const Fe = (u) => {
  let e = !1;
  return (typeof u == "string" || typeof u == "number") && (e = !Number.isNaN(new Date(u).getTime())), e;
}, C = (u) => {
  const { field: e, value: t, fieldList: n } = u;
  let i = !1;
  return n !== void 0 && n.length > 0 && (i = U(n).some((a) => a === e)), Fe(t) && i ? new Date(t).toISOString() : t;
};
export {
  Oe as D,
  ce as a,
  ke as b,
  Ve as h,
  ve as m,
  we as s,
  Te as t
};
