import { C as s } from "./model-with-multi-axes.js";
import { s as a } from "./serial-chart-model.js";
import { g as n, a as o, e as g, b as h, f as c, s as S, h as l, c as f, i as d, d as m, j as k, k as u, t as C, u as M, l as _, m as i, n as y, o as L, p as A, q as p, r as v } from "./baseline-stacking.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
class w extends s {
  /**
   * Gets the line style of the series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {RESTSimpleLineSymbolStyle | undefined}
   */
  getSeriesLineStyle(e) {
    return n(e, this._config);
  }
  /**
   * Sets the line style of the series based on the series index.
   * @param {RESTSimpleLineSymbolStyle | undefined} style The new style for the series.
   * @param {number} seriesIndex The index of the series.
   */
  setSeriesLineStyle(e, t) {
    this.guardSetterFromAsyncOverwrite(() => {
      o(e, t, this._config), this.emitConfigUpdate("setSeriesLineStyle");
    });
  }
  /**
   * Gets the line width of the series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {number | undefined}
   */
  getSeriesLineWidth(e) {
    return g(e, this._config);
  }
  /**
   * Sets the line width of the series based on the series index.
   * @param {number | undefined} width The new width for the series.
   * @param {number} seriesIndex The index of the series.
   */
  setSeriesLineWidth(e, t) {
    this.guardSetterFromAsyncOverwrite(() => {
      h(e, t, this._config), this.emitConfigUpdate("setSeriesLineWidth");
    });
  }
  /**
   * Gets the marker color of the series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {Color | undefined}
   */
  getSeriesMarkerColor(e) {
    return c(e, this._config);
  }
  /**
   * Sets the marker color of the series based on the series index.
   * @param {Color | undefined} color The new color for the series.
   * @param {number} seriesIndex The index of the series.
   */
  setSeriesMarkerColor(e, t) {
    this.guardSetterFromAsyncOverwrite(() => {
      S(e, t, this._config), this.emitConfigUpdate("setSeriesMarkerColor");
    });
  }
  /**
   * Gets the marker style of the series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {RESTSimpleMarkerSymbolStyle | undefined}
   */
  getSeriesMarkerStyle(e) {
    return l(e, this._config);
  }
  /**
   * Sets the marker style of the series based on the series index.
   * @param {RESTSimpleMarkerSymbolStyle | undefined} style The new style for the series.
   * @param {number} seriesIndex The index of the series.
   */
  setSeriesMarkerStyle(e, t) {
    this.guardSetterFromAsyncOverwrite(() => {
      f(e, t, this._config), this.emitConfigUpdate("setSeriesMarkerStyle");
    });
  }
  /**
   * Gets the marker size of the series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {number | undefined}
   */
  getSeriesMarkerSize(e) {
    return d(e, this._config);
  }
  /**
   * Sets the marker size of the series based on the series index.
   * @param {number | undefined} size The new size for the series.
   * @param {number} seriesIndex The index of the series.
   */
  setSeriesMarkerSize(e, t) {
    this.guardSetterFromAsyncOverwrite(() => {
      m(e, t, this._config), this.emitConfigUpdate("setSeriesMarkerSize");
    });
  }
  /**
   * Specify whether line segments of the series should be smoothed.
   * @param {number} seriesIndex - The index of the series.
   *
   * @default false
   * @returns {boolean}
   */
  isLineSmoothed(e) {
    return k(e, this._config);
  }
  /**
   * Specify whether line segments of the series should be smoothed.
   * @param {boolean} smoothed - `true` if line segment of the series should be smoothed, `false` otherwise.
   * @param {number} seriesIndex - The index of the series.
   */
  setLineSmoothed(e, t) {
    this.guardSetterFromAsyncOverwrite(() => {
      u({
        smoothed: e,
        seriesIndex: t,
        config: this._config
      }), this.emitConfigUpdate("setLineSmoothed");
    });
  }
  /**
   * Specify the color of the filled area for line chart.
   * @param {number} seriesIndex - The index of the series.
   *
   * @returns {boolean | undefined}
   */
  getConnectLines(e) {
    return C(e, this._config);
  }
  /**
   * Specify whether to connect the lines when there's a gap in the data.
   * **Note:** Can be overridden by the temporal data setting `nullPolicy`.
   * @param {boolean | undefined} connect - Whether to connect the gap in the data
   * @param {number} seriesIndex - The index of the series.
   */
  setConnectLines(e, t) {
    this.guardSetterFromAsyncOverwrite(() => {
      M({
        connect: e,
        seriesIndex: t,
        config: this._config
      }), this.emitConfigUpdate("setConnectLines");
    });
  }
  /**
   * Specify whether the line series should show area.
   * @param {number} seriesIndex - The index of the series.
   *
   * @default false
   * @returns {boolean}
   */
  isAreaVisible(e) {
    return _(e, this._config);
  }
  /**
   * Specify whether the line series should show area.
   * @param {boolean} visible - `true` if the line series should show area, `false` otherwise.
   * @param {number} seriesIndex - The index of the series.
   */
  setAreaVisible(e, t) {
    this.guardSetterFromAsyncOverwrite(() => {
      i({
        visible: e,
        seriesIndex: t,
        config: this._config
      }), this.emitConfigUpdate("setAreaVisible");
    });
  }
  /**
   * Indicate whether to show or hide the markers/bullets of the line series.
   * @param {number} seriesIndex - The index of the series.
   *
   * @default true
   * @returns {boolean}
   */
  isMarkerVisible(e) {
    return y(e, this._config);
  }
  /**
   * Indicate whether to show or hide the markers/bullets of the line series.
   * @param {boolean} visible - `true` if the markers/bullets of the line series should be shown, `false` otherwise.
   * @param {number} seriesIndex - The index of the series.
   */
  setMarkerVisible(e, t) {
    this.guardSetterFromAsyncOverwrite(() => {
      L({
        visible: e,
        seriesIndex: t,
        config: this._config
      }), this.emitConfigUpdate("setMarkerVisible");
    });
  }
  /**
   * Specify the color of the filled area for line chart.
   * **Note:** `areaColor` will be applied only if `showArea` is true, and is defaulted to the line color if not provided.
   * @param {number} seriesIndex - The index of the series.
   * @returns {Color | undefined}
   */
  getAreaColor(e) {
    return A(e, this._config);
  }
  /**
   * Specify the color of the filled area for line chart.
   * @param {Color | undefined} color - The color of the filled area for line chart.
   * @param {number} seriesIndex - The index of the series.
   */
  setAreaColor(e, t) {
    this.guardSetterFromAsyncOverwrite(() => {
      i({
        visible: !0,
        seriesIndex: t,
        config: this._config
      }), a(e, t, this._config), this.emitConfigUpdate("setAreaColor");
    });
  }
}
class F extends s {
  /**
   * Specify how negative values are treated in stacked series.
   * **Note:** If true, negative values will be stacked on the base line. If false, negative values will be stacked in relation to their previous values in the stack.
   * @param {number} seriesIndex - The index of the series.
   * @default true
   * @returns {boolean}
   */
  isNegativeValuesStackedToBaseline(e) {
    return p(e, this._config);
  }
  /**
   * Specify how negative values are treated in stacked series.
   * **Note:** If true, negative values will be stacked on the base line. If false, negative values will be stacked in relation to their previous values in the stack.
   * @param {boolean} stackNegativeValuesToBaseline - `true` if negative values should be stacked on the base line, `false` otherwise.
   * @param {number} seriesIndex - The index of the series.
   */
  setNegativeValuesStackedToBaseline(e, t) {
    v({
      stackNegativeValuesToBaseline: e,
      seriesIndex: t,
      config: this._config
    }), this.emitConfigUpdate("setNegativeValuesStackedToBaseline");
  }
}
export {
  F as M,
  w as a
};
