import { a as d, d as l, W as C } from "./series-types.js";
import "@arcgis/toolkit/intl";
import "lodash-es";
import "d3-array";
import { y as m, ci as p, cm as S, aQ as T } from "./interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import "./runtime.js";
import "@arcgis/toolkit/dom";
import "@arcgis/core/intl.js";
import { a as _, c as A } from "./model-with-data-labels.js";
import "./model-with-multi-axes.js";
import { S as x, g as v, a as B } from "./serial-chart-model.js";
import { a as y, u as h, d as L } from "./data2.js";
import { r as f } from "./config-update.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
const w = (t) => {
  const { xField: e, config: i, layerInfo: s } = t, { layerFieldsInfo: r } = s, g = y(0, i), n = u(i), a = m(i), o = i.series[0];
  if (typeof e == "string" && n !== e && o && (o.x = e, f(i), n === g || a)) {
    const c = p(r, e);
    h(i, 0, c);
  }
}, u = (t) => t.series[0].x ?? "", O = (t, e) => {
  const i = t.series[0];
  i.heatRulesType = e;
}, P = (t) => t.series[0].heatRulesType, U = (t, e) => {
  const i = t.series[0];
  i.gradientRules = e;
}, R = (t) => t.series[0].gradientRules, b = (t) => {
  const { yField: e, config: i, layerInfo: s } = t, { layerFieldsInfo: r } = s, g = y(1, i), n = F(i), a = m(i), o = i.series[0];
  if (typeof e == "string" && n !== e && o && (o.y = e, f(i), n === g || a)) {
    const c = p(r, e);
    h(i, 1, c);
  }
}, F = (t) => t.series[0].y ?? "", N = (t, e) => {
  const i = e.series[0];
  i.xTemporalBinning = t;
}, W = (t) => t.series[0].xTemporalBinning, I = (t, e) => {
  const i = e.series[0];
  i.yTemporalBinning = t;
}, E = (t) => t.series[0].yTemporalBinning, G = (t, e) => {
  const i = e.series[0];
  i.gridLine && (i.gridLine.width = t);
}, M = (t) => t.series[0].gridLine?.width, X = (t, e) => {
  const i = e.series[0], s = t?.length === 4 && t.every((r) => typeof r == "number");
  i.gridLine && s && (i.gridLine.color = t);
}, Y = (t) => t.series[0].gridLine?.color, H = (t, e) => {
  const i = e.legend;
  t === l.Bottom && i && (i.position = l.Bottom);
}, q = (t) => t.legend?.position ?? l.Bottom, $ = (t) => t.series[0].query?.outStatistics?.[0]?.onStatisticField, D = (t, e) => {
  const i = e.series[0].query?.outStatistics?.[0];
  i && (i.onStatisticField = t, i.outStatisticFieldName = `${i.statisticType}_${t}`);
}, V = (t) => t.series[0].query?.outStatistics?.[0].statisticType ?? d.Count, j = (t, e) => {
  const i = e.series[0]?.query?.outStatistics?.[0];
  i && t !== d.NoAggregation && (i.statisticType = t, i.outStatisticFieldName = `${t}_${i.onStatisticField}`);
}, Q = (t) => t.nullPolicy, Z = (t, e) => {
  e.nullPolicy = t;
}, k = (t) => t.series[0].emptyCells?.text, z = (t, e) => {
  e.series[0].emptyCells ? e.series[0].emptyCells.text = t : e.series[0].emptyCells = { text: t };
}, J = (t) => t.series[0].emptyCells?.symbol, K = (t, e) => {
  e.series[0].emptyCells ? e.series[0].emptyCells.symbol = t : e.series[0].emptyCells = { symbol: t };
};
class ee extends x {
  constructor() {
    super(...arguments), this._chartType = C.HeatSeries;
  }
  generateChartTitle() {
    throw new Error("Method not implemented.");
  }
  async setup(e) {
    await this.loadConfigFromLayer(e), typeof this.resolveSetup == "function" && this.resolveSetup();
  }
  /**
   * The x axis field used by the heat chart
   */
  get xAxisField() {
    return u(this._config);
  }
  set xAxisField(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      w({
        xField: e,
        config: this._config,
        layerInfo: this.layerInfo
      }), this.emitConfigUpdate("xAxisField");
    });
  }
  /**
   * The y axis field used by the heat chart
   */
  get yAxisField() {
    return F(this._config);
  }
  set yAxisField(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      b({
        yField: e,
        config: this._config,
        layerInfo: this.layerInfo
      }), this.emitConfigUpdate("yAxisField");
    });
  }
  /**
   * The x temporal binning used by the heat chart
   */
  get xTemporalBinning() {
    return W(this._config);
  }
  set xTemporalBinning(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      N(e, this._config), this.emitConfigUpdate("xTemporalBinning");
    });
  }
  /**
   * The y temporal binning used by the heat chart
   */
  get yTemporalBinning() {
    return E(this._config);
  }
  set yTemporalBinning(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      I(e, this._config), this.emitConfigUpdate("yTemporalBinning");
    });
  }
  /**
   * The grid line width used by the heat chart
   */
  get gridLineWidth() {
    return M(this._config);
  }
  set gridLineWidth(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      G(e, this._config), this.emitConfigUpdate("gridLineWidth");
    });
  }
  /**
   * The grid line color used by the heat chart
   */
  get gridLineColor() {
    return Y(this._config);
  }
  set gridLineColor(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      X(e, this._config), this.emitConfigUpdate("gridLineColor");
    });
  }
  /**
   * The name of the series that is used by the heat chart
   */
  get seriesName() {
    return v(0, this._config);
  }
  set seriesName(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      typeof e == "string" && (B(e, 0, this.config), this.emitConfigUpdate("seriesName"));
    });
  }
  /**
   * The heat rules type used by the heat chart
   */
  get heatRulesType() {
    return P(this._config);
  }
  set heatRulesType(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      O(this._config, e), this.emitConfigUpdate("heatRulesType");
    });
  }
  /**
   * The grandient rules used by the heat chart
   */
  get gradientRules() {
    return R(this._config);
  }
  set gradientRules(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      U(this._config, e), this.emitConfigUpdate("gradientRules");
    });
  }
  /**
   * The numeric fields used by the heat chart. Only the first field in the array will be used.
   * An empty string will be ignored.
   */
  get numericFields() {
    const e = $(this._config);
    return e !== void 0 ? [e] : [];
  }
  set numericFields(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      const i = e[0];
      S(i) || (D(i, this._config), this.emitConfigUpdate("numericFields"));
    });
  }
  /**
   * The aggregation type for the heat chart. Must be one of the values allowed by WebChartStatisticType.
   */
  get aggregationType() {
    return V(this._config);
  }
  set aggregationType(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      j(e, this._config), this.emitConfigUpdate("aggregationType");
    });
  }
  /**
   * Split-by field is not used by heat chart
   */
  get splitByField() {
    return "";
  }
  set splitByField(e) {
  }
  /**
   * The heat charts legend's title (not supported yet)
   */
  set legendTitleText(e) {
    this.guardSetterFromAsyncOverwrite(() => {
    });
  }
  get legendPosition() {
    return q(this._config);
  }
  /**
   * The heat charts legend's position
   */
  set legendPosition(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      e === l.Bottom && (H(e, this._config), this.emitConfigUpdate("legendVisibility"));
    });
  }
  /**
   * The heat chart's rotatedState (not supported)
   */
  set rotatedState(e) {
    this.guardSetterFromAsyncOverwrite(() => {
    });
  }
  get nullPolicy() {
    return Q(this._config);
  }
  /**
   * The heat charts null policy
   */
  set nullPolicy(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      Z(e, this._config), this.emitConfigUpdate("nullPolicy");
    });
  }
  get emptyCellText() {
    return k(this._config);
  }
  /**
   * The heat charts empty cell text
   */
  set emptyCellText(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      z(e, this._config), this.emitConfigUpdate("emptyCellText");
    });
  }
  get emptyCellSymbol() {
    return J(this._config);
  }
  /**
   * The heat charts empty cell symbol
   */
  set emptyCellSymbol(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      K(e, this._config), this.emitConfigUpdate("emptyCellSymbol");
    });
  }
  /**
   * Generates the default config for the heat chart
   */
  generateDefaultConfig() {
    const e = T(this.commonStrings, this.layerInfo?.objectIdField);
    return e.axes?.forEach((i) => {
      i && (i.valueFormat = { intlOptions: { timeZone: void 0 }, type: "date" });
    }), e;
  }
}
L(ee, [_, A]);
export {
  ee as HeatChartModel
};
