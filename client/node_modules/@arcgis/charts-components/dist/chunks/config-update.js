import { W as S, d as Ii, u as Q, m as ne, b as _, g as fe, t as be, e as ke, a as P, n as G, i as j, S as zt, o as $i } from "./series-types.js";
import "@arcgis/toolkit/intl";
import { cloneDeep as Ce, isArray as vt, isEmpty as Ri, isEqual as Le, sortBy as Ot } from "lodash-es";
import { extent as ki, mean as ji, max as Qi, min as Wi, sum as Hi, rollup as zi } from "d3-array";
import { b6 as pt, cC as h, p as V, cb as Gt, c7 as z, a6 as Ut, s as Gi, E as _t, d as ae, a as pe, U as Y, co as lt, b4 as $e, I as re, r as se, q as Ne, bd as Qe, aV as Re, a2 as nt, T as xe, ci as ht, cm as Z, l as me, ct as Ui, cc as qt, ce as Yt, P as I, k as K, G as U, a4 as k, cx as Kt, D as R, bX as _i, J as Nt, bC as ge, bK as W, F as Yi, i as we, A as je, cf as Et, aW as Ue, m as Tt, ba as Te, c3 as We, a3 as Jt, cF as Ki, B as Xt, ch as he, bB as _e, bO as Ji, c1 as Xi, b7 as Vt, S as Zi, bk as Zt, bz as ea, bl as ta, b$ as ia, c0 as ei, bv as aa, cn as mt, c5 as na, b8 as ra, bw as sa, V as oa, n as Se, bQ as ti, bD as la, bp as ii, bE as ca, bF as ua, cE as ie, R as da, Q as It, bG as ai, bY as fa, by as ma, bi as ni, bx as ga, bA as ya, bg as pa, bj as ha, Y as ri, b9 as Sa } from "./interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import Fa from "@arcgis/core/request.js";
import "./runtime.js";
import "@arcgis/toolkit/dom";
import { b as ba, R as rt, a as Ye, j as te } from "./rest-js-object-literals.js";
import { C as b } from "./interfaces4.js";
import * as xa from "@arcgis/core/renderers/support/jsonUtils.js";
import * as gt from "@arcgis/core/symbols/support/symbolUtils.js";
import Ca from "@arcgis/core/Graphic.js";
import { u as yt } from "./index2.js";
import { substitute as ue } from "@arcgis/core/intl.js";
import { d as Ba } from "./index3.js";
import $t from "@arcgis/core/layers/support/FeatureFilter.js";
import va from "@arcgis/core/smartMapping/statistics/histogram.js";
import Rt from "@arcgis/core/smartMapping/statistics/summaryStatistics.js";
import { linearRegression as Na, linearRegressionLine as Ta, rSquared as Aa } from "simple-statistics";
import { c as Pa } from "./index.js";
import { h as La } from "./index4.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
async function Ma(t, e) {
  const i = e.errors[t];
  throw new pt(e.modalHeaders.error, i ?? e.errors.simpleError);
}
function ye(t) {
  return t.axes?.[0]?.valueFormat?.type;
}
function oo(t) {
  return t.intlOptions;
}
function J(t) {
  return t?.type === S.NumberAxisFormat;
}
function lo(t) {
  return J(t) && t.intlOptions?.style === "percent";
}
function de(t) {
  return t?.type === S.CategoryAxisFormat;
}
function Pe(t) {
  return t?.type === S.DateAxisFormat;
}
function co(t) {
  const { oldConfig: e, newConfig: i, rotationChanged: a } = t;
  return a ? [!0, !0] : [
    e.horizontalAxisLabelsBehavior !== i.horizontalAxisLabelsBehavior,
    e.verticalAxisLabelsBehavior !== i.verticalAxisLabelsBehavior
  ];
}
function wa(t) {
  return J(t?.[1]?.valueFormat) && (t?.[2]?.valueFormat === void 0 || J(t[2].valueFormat));
}
function Da(t) {
  return J(t?.[1]?.valueFormat) && (t?.[2]?.valueFormat === void 0 || J(t[2].valueFormat));
}
function Oa(t) {
  return (de(t?.[0]?.valueFormat) || Pe(t?.[0]?.valueFormat)) && J(t?.[1]?.valueFormat) && (t?.[2]?.valueFormat === void 0 || J(t[2].valueFormat));
}
function qa(t) {
  return de(t?.[0]?.valueFormat) && de(t?.[1]?.valueFormat) || Pe(t?.[0]?.valueFormat) && de(t?.[1]?.valueFormat) || Pe(t?.[0]?.valueFormat) && Pe(t?.[1]?.valueFormat);
}
function Ea(t) {
  return (de(t?.[0]?.valueFormat) || Pe(t?.[0]?.valueFormat)) && J(t?.[1]?.valueFormat);
}
function Va(t) {
  return J(t?.[0]?.valueFormat) && J(t?.[1]?.valueFormat);
}
function Ia(t) {
  return J(t?.[0]?.valueFormat) && J(t?.[1]?.valueFormat);
}
function $a(t) {
  return J(t?.[0]?.valueFormat);
}
async function uo(t) {
  const { chartType: e, axesConfig: i, errorStrings: a } = t;
  let n, r;
  switch (e) {
    case S.GaugeSeries:
      n = $a, r = "invalidValueFormatForGauge";
      break;
    case S.ScatterSeries:
      n = Va, r = "invalidValueFormatForScatterplot";
      break;
    case S.HistogramSeries:
      n = Ia, r = "invalidValueFormatForHistogram";
      break;
    case S.LineSeries:
      n = wa, r = "invalidValueFormatForLineChart";
      break;
    case S.BarSeries:
      n = Da, r = "invalidValueFormatForBarChart";
      break;
    case S.ComboLineAndBarSeries:
      n = Ea, r = "invalidValueFormatForComboBarLineChart";
      break;
    case S.BoxPlotSeries:
      n = Oa, r = "invalidValueFormatForBoxPlot";
      break;
    case S.HeatSeries:
      n = qa, r = "invalidValueFormatForHeatChart";
      break;
  }
  n !== void 0 && r !== void 0 && (n(i) || await Ma(r, a));
}
function Ra(t) {
  const { isXAxis: e, chartType: i, valueFormat: a, isAxisForHistogramOverlaySeries: n } = t;
  return e && (de(a) || i === S.HistogramSeries && !n || i === S.BarSeries && J(a));
}
function fo(t) {
  const { chartConfig: e, isSecondValueAxis: i, seriesIds: a } = t;
  let n = a;
  return e.axes?.length === 3 && (n = e.series.map((r) => {
    let s = "";
    return (a === void 0 || a.includes(r.id)) && (i === !0 && "assignToSecondValueAxis" in r && r.assignToSecondValueAxis === !0 || i !== !0 && (!("assignToSecondValueAxis" in r) || r.assignToSecondValueAxis !== !0)) && ({ id: s } = r), s;
  }).filter((r) => r !== "")), n;
}
const si = {
  ...b,
  chartPadding: 5,
  footerContainer: { ...b.footerContainer, paddingTop: 0, paddingBottom: 0 },
  headerContainer: { ...b.headerContainer, paddingBottom: 0 },
  chartContainer: { ...b.chartContainer },
  dataLabel: { ...b.dataLabel, verticalCenter: "bottom" },
  scrollbarPadding: 12,
  // setting a high z index so guide will be on top when above is set to true
  zIndexes: {
    guide: 100,
    scatterplotTrendLine: 2,
    // set layer to 1 so bullets will be above axis and trendlines
    bulletMarkers: 1
  },
  verticalSurfaceGuideLabels: {
    // The alignments are directly handled by adjustGuideLabelsPositionCallback()
    wrap: !0
  },
  verticalLineGuideLabels: {
    // The alignments are directly handled by adjustGuideLabelsPositionCallback()
    wrap: !0,
    rotation: 90
  },
  horizontalSurfaceGuideLabels: {
    // The alignments are directly handled by adjustGuideLabelsPositionCallback()
    wrap: !0
  },
  horizontalLineGuideLabels: {
    // The alignments are directly handled by adjustGuideLabelsPositionCallback()
    wrap: !0
  },
  overlayId: {
    scatterplotTrendLine: "arcgis_charts_scatter_plot_trendline",
    histogramMean: "arcgis_charts_histogram_mean",
    histogramMedian: "arcgis_charts_histogram_median",
    histogramStdDev: "arcgis_charts_histogram_std_dev",
    histogramNormalDistribution: "arcgis_charts_histogram_normal_distribution"
  },
  axisLabelSpacing: {
    verticalAxisLabelSidePadding: 8,
    horizontalAxisLabelPaddingTop: 6
  },
  legendPadding: 20,
  heatChart: {
    gradientHeatRules: {
      minColor: [255, 255, 200, 255],
      // light yellow
      maxColor: [255, 0, 0, 255],
      // red
      outsideRangeLowerColor: [250, 250, 250, 255],
      // white
      outsideRangeUpperColor: [0, 0, 255, 255]
      // blue
    },
    legend: {
      position: Ii.Bottom,
      chartPadding: 40,
      legendPadding: 20,
      size: 20
    },
    emptyCells: {
      symbol: {
        type: rt.SFS,
        style: ba.Solid,
        color: b.grayColor
      },
      text: "null"
    }
  },
  heatChartLabelPadding: {
    paddingTop: 2
  },
  heatChartFirstDayOfWeek: 7
};
function ka(t, e) {
  return t[0].dataTransformationType !== e[0].dataTransformationType;
}
function ja(t, e) {
  return t[0].binCount !== e[0].binCount;
}
function mo(t, e) {
  let i = !0;
  const a = Q(t?.series), n = Q(e?.series);
  return a !== n && (i = a === S.ComboLineAndBarSeries && (n === S.BarSeries || n === S.LineSeries) || n === S.ComboLineAndBarSeries && (a === S.BarSeries || a === S.LineSeries) || a === S.BarSeries && n === S.LineSeries || a === S.LineSeries && n === S.BarSeries), i;
}
function St(t, e) {
  return t !== void 0 && e !== void 0 && e > 0;
}
function go(t) {
  const { chartConfig: e, queryObject: i, chartData: a } = t;
  let n = [];
  const r = V(e.series), s = Gt(e), o = z(i), c = e.chartRenderer ?? o?.renderer?.toJSON();
  return n = e.series.map((l, u) => {
    const d = Q([l]);
    let f;
    return (d === S.BarSeries || d === S.LineSeries || d === S.RadarSeries) && (l.type === S.BarSeries ? f = l.fillSymbol?.color : (l.type === S.RadarSeries || l.type === S.LineSeries) && (f = l.lineSymbol?.color), s ? f = Ps({
      dataItem: a[0],
      seriesConfig: l,
      chartSubType: r,
      colorMatch: s,
      rendererType: c?.type
    })?.color : f === void 0 && (f = Ut({ colorIndex: u }))), f;
  }).filter((l) => l !== void 0), n;
}
function Ft(t) {
  return t !== h.PieNoAggregation && t !== h.BarAndLineNoAggregation && t !== h.BarAndLineSplitByNoAggregation;
}
function Qa(t) {
  const e = V(t.series);
  return e === h.BarAndLineFromFields || e === h.PieFromFields || e === h.BoxPlotMonoField || e === h.BoxPlotMultiFields || e === h.BoxPlotMonoFieldAndSplitBy || e === h.BoxPlotMultiFieldsAndSplitBy;
}
function He(t) {
  return t && "showMean" in t && typeof t.showMean == "boolean" ? t.showMean : !1;
}
function Wa(t) {
  return t && "showOutliers" in t && typeof t.showOutliers == "boolean" ? t.showOutliers : void 0;
}
function yo() {
  return `{name} {${b.originalCategoryValue}} {dateY} {valueX} {dateX} {valueY}`;
}
function Ha(t) {
  let e;
  return t?.[0] !== void 0 && (e = t.reduce(
    (i, a) => ({
      ...i,
      xmin: Math.min(i.xmin, a.xmin),
      xmax: Math.max(i.xmax, a.xmax),
      ymin: Math.min(i.ymin, a.ymin),
      ymax: Math.max(i.ymax, a.ymax)
    }),
    t[0]
  )), e;
}
function ze(t) {
  const {
    value: e,
    dataContext: i,
    specificField: a,
    preferLabel: n,
    keepNullValues: r = !1,
    useRendererLabel: s = !1,
    config: o
  } = t;
  let c = e;
  const { originalCategoryValue: l, originalDateValue: u, typeOrDomainIdValue: d } = b;
  if (i !== void 0) {
    const f = s ? xs(i) : void 0;
    a !== void 0 && i[a] !== void 0 ? c = i[a] : f !== void 0 ? c = f : n === !1 && i[d] !== void 0 ? c = i[d] : i[u] !== void 0 ? c = i[u] : i[l] !== void 0 ? c = i[l] : i[ae] !== void 0 && (c = i[ae]), !r && c === null && (c = "null", o?.series?.[0].type === S.BarSeries && (c = o.series?.[0]?.nullCategory?.text ?? si.nullCategory?.text ?? c));
  }
  return c;
}
function za(t) {
  return t?.[b.typeOrDomainIdValue] !== void 0 ? t?.[b.typeOrDomainIdValue] : t?.[b.originalCategoryValue];
}
function Ge(t) {
  const {
    arrayToSort: e,
    orderBy: i,
    sortingField: a,
    forceAscendingOrder: n,
    isNonAggregated: r,
    sortByCategory: s,
    preferLabel: o,
    isPieOrByFieldsChart: c
  } = t;
  if (e !== void 0 && e.length > 1) {
    const l = i === fe.Descending && n !== !0;
    e.sort((u, d) => {
      let f = 0, m = u[a];
      s === !0 && !c && (m = ze({
        value: `${u[a]?.toString()}`,
        dataContext: u,
        preferLabel: o
      }));
      let g = d[a];
      return s === !0 && !c && (g = ze({
        value: `${d[a]?.toString()}`,
        dataContext: d,
        preferLabel: o
      })), r === !0 && l && s === !0 && (m = Number.isNaN(Number.parseFloat(`${m?.toString()}`)) ? m : Number.parseFloat(m), g = Number.isNaN(Number.parseFloat(`${g?.toString()}`)) ? g : Number.parseFloat(g)), s === !0 && (u[b.originalCategoryValue] === null || m === null) || u[nt.defaultGroupOfSlicesId] === !0 ? f = 1 : s === !0 && (d[b.originalCategoryValue] === null || g === null) || d[nt.defaultGroupOfSlicesId] === !0 ? f = -1 : typeof m == "string" && typeof g == "string" ? (f = m.localeCompare(g, void 0, { numeric: !0 }), l && (f *= -1)) : m === void 0 ? f = l ? -1 : 1 : g === void 0 ? f = l ? 1 : -1 : m !== null && g !== null && (m > g ? f = l ? -1 : 1 : m < g && (f = l ? 1 : -1)), f;
    });
  }
}
function Ga(t) {
  const { arrayToSort: e, orderBy: i, sortingField: a, fieldList: n, isByFieldsChart: r, preferLabel: s } = t;
  e !== void 0 && e.length > 1 && !Z(a) && i !== void 0 && i.length > 0 && e.sort((o, c) => {
    let l = o[a];
    s && r && typeof l == "string" && (l = ht(n, l));
    let u = i.indexOf(l?.toString() ?? "");
    u === -1 && (u = i.length);
    let d = c[a];
    s && r && typeof d == "string" && (d = ht(n, d));
    let f = i.indexOf(d?.toString() ?? "");
    return f === -1 && (f = i.length), u - f;
  });
}
function oi(t, e) {
  const i = t;
  if (e?.[0] !== void 0 && V(e) === h.PieFromFields) {
    const { x: a, y: n } = e[0];
    (vt(t) ? i : i.dataItems).forEach((o) => (ae in o && a !== ae && (o[a] = o[a] !== void 0 ? o[a] : o[ae], delete o[ae]), pe in o && n !== pe && (o[n] = o[n] !== void 0 ? o[n] : o[pe], delete o[pe]), o));
  }
  return i;
}
function li(t, e) {
  const i = Q(e);
  let a = t;
  const n = e?.[0];
  if ((i === S.PieSeries || i === S.BoxPlotSeries || i === S.LineSeries || i === S.RadarSeries || i === S.BarSeries || i === S.ComboLineAndBarSeries) && n !== void 0) {
    const r = vt(t);
    let s = r ? t : t.dataItems;
    if (t !== void 0) {
      const { originalCategoryValue: o, originalDateValue: c, xAxisField: l, typeOrDomainIdValue: u } = b, { x: d } = n;
      s = s.map((f) => {
        let m = f[d];
        f[u] !== void 0 ? m = f[u] : f[c] !== void 0 ? m = f[c] : f[o] !== void 0 && (m = f[o]);
        const g = { ...f, [d]: m };
        return delete g[c], delete g[u], delete g[o], delete g[l], g;
      }), r ? a = s : "dataItems" in a && (a.dataItems = s);
    }
  }
  return a;
}
function bt(t) {
  const e = { ...t };
  delete e[b.technicalSortingFieldBySum], delete e[b.technicalSortingFieldByPercent], delete e[b.pieChart.technicalFieldSlicePercent], delete e[b.pieChart.technicalFieldGroupedSlices], delete e[b.typeOrDomainFieldName], delete e[b.lastTemporalBin], delete e[b.originalServerBinningRange], delete e[b.technicalFieldSplitByField], delete e[Y.uniqueIdsName], Object.keys(e).filter(
    (n) => n.includes(b.rendererSymbolField)
  ).forEach((n) => delete e[n]);
  const a = lt(e);
  return a.isInItem && delete e[a.expr ?? ""], e;
}
function Ua(t, e) {
  let i = t;
  const a = Q(e);
  let n = _t(i);
  if (n !== void 0)
    switch (a) {
      case S.ComboLineAndBarSeries:
      case S.BarSeries:
      case S.LineSeries:
      case S.RadarSeries:
      case S.PieSeries:
        {
          n = n.map(bt), i = { dataItems: n };
          const { timeIntervalInfo: r, serverLimitReached: s } = t ?? {};
          Ri(r) || (i.timeIntervalInfo = r), s !== void 0 && (i.serverLimitReached = s);
        }
        break;
      case S.ScatterSeries:
        i = {
          ...i,
          dataItems: n.map(bt)
        };
        break;
    }
  return i;
}
function ci(t) {
  const { data: e, seriesConfig: i } = t;
  let a = Ce(e);
  return a !== void 0 && (a = li(a, i), a = Ua(a, i), a = oi(a, i)), a;
}
function ui(t) {
  const { statsMap: e, dataContext: i, chartLimits: a } = t;
  let n = !1;
  if (e !== void 0) {
    const { maxScatterPointsBeforeAggregation: r } = Re(a), { queryNumberOfFeatures: s } = b.scatterplotAggregationFields;
    n = (e.get(s) ?? Number.NaN) >= r;
  } else i !== void 0 && (n = b.scatterplotAggregationFields.dataContextXMinField in i);
  return n;
}
function _a(t) {
  let e = !0;
  const i = Q(t.series);
  if (i === S.BarSeries || i === S.LineSeries || i === S.ComboLineAndBarSeries) {
    const a = V(t.series);
    e = a !== h.BarAndLineNoAggregation && a !== h.BarAndLineSplitByNoAggregation;
  }
  return e;
}
function Ya(t) {
  return V(t.series) !== h.PieNoAggregation;
}
function Ka(t) {
  const { dataContext: e, chartConfig: i, chartLimits: a } = t;
  let n = !0;
  if (i !== void 0)
    switch (Q(i.series)) {
      case S.BarSeries:
      case S.LineSeries:
      case S.ComboLineAndBarSeries:
        n = _a(i);
        break;
      case S.ScatterSeries:
        n = ui({ dataContext: e, chartLimits: a });
        break;
      case S.PieSeries:
        n = Ya(i);
        break;
    }
  return n;
}
function Ja(t, e) {
  let i = t;
  switch (e) {
    case _.Log:
      i = `log(${t})`;
      break;
    case _.Sqrt:
      i = `power(CAST(${t} AS FLOAT),0.5)`;
      break;
  }
  return i;
}
function Ve(t) {
  let e = new Date(t).valueOf();
  return Number.isNaN(e) || (e = new Intl.DateTimeFormat("en-US", b.dateFormatUTC).format(t).replace(",", "")), e;
}
function st(t) {
  const { dataToConvert: e, x: i, y: a, fieldList: n } = t, r = [];
  if (e) {
    const s = e[xe];
    Object.entries(e).forEach(([o]) => {
      if (o !== "" && o !== xe && o in e) {
        const c = {
          [i]: ht(n, o),
          [a]: e[o],
          [b.xAxisField]: o,
          [b.originalCategoryValue]: o
        };
        s !== void 0 && (c[xe] = s), e[`${b.rendererSymbolField}_${o}`] !== void 0 && (c[b.rendererSymbolField] = e[`${b.rendererSymbolField}_${o}`]), r.push(c);
      }
    });
  }
  return r;
}
function Xa(t, e) {
  return JSON.stringify(t.series[0]?.valueConversion) !== JSON.stringify(e.series[0]?.valueConversion);
}
function Za(t, e) {
  return JSON.stringify(t.series[0]?.xTemporalBinning) !== JSON.stringify(e.series[0]?.xTemporalBinning) || JSON.stringify(t.series[0]?.yTemporalBinning) !== JSON.stringify(e.series[0]?.yTemporalBinning) || (t.firstDayOfWeek ?? 7) !== (e.firstDayOfWeek ?? 7) || t.outTimeZone !== e.outTimeZone || (t.nullPolicy ?? ne.Null) !== (e.nullPolicy ?? ne.Null);
}
function en(t) {
  const { oldConfig: e, newConfig: i, fieldList: a } = t, n = e.series[0], r = i.series[0];
  let s = !1;
  if (n.type === S.ScatterSeries && r.type === S.ScatterSeries && a && a.length > 0) {
    const o = new Set(n.additionalTooltipFields || []), c = new Set(r.additionalTooltipFields || []);
    if (!Le(o, c)) {
      const l = Array.from(c).filter((u) => !o.has(u));
      l.length > 0 && (s = a?.some((u) => l.includes(u.name) && !Qe(u)));
    }
  }
  return s;
}
function po(t, e) {
  return (t.colorMatch ?? !1) !== (e.colorMatch ?? !1);
}
function ho(t, e) {
  return (t.legend?.visible ?? !1) !== (e.legend?.visible ?? !1) || JSON.stringify(t.legend?.body) !== JSON.stringify(e.legend?.body);
}
function So(t, e) {
  return JSON.stringify(t.series[0]?.gradientRules) !== JSON.stringify(e.series[0]?.gradientRules);
}
function Fo(t) {
  const { oldConfig: e, newConfig: i } = t;
  let a = !1;
  const n = e.series[0], r = i.series[0], s = Q(e.series), o = Q(i.series);
  if (s === S.PieSeries && o === S.PieSeries) {
    const { slices: c, sliceGrouping: l } = n, { slices: u, sliceGrouping: d } = r, f = c?.map((p) => ({
      sliceId: p.sliceId,
      label: p.label
    })), m = u?.map((p) => ({
      sliceId: p.sliceId,
      label: p.label
    })), g = l?.label, y = d?.label;
    a = JSON.stringify(f) !== JSON.stringify(m) || JSON.stringify(g) !== JSON.stringify(y);
  }
  return a;
}
function kt(t, e) {
  return e.length !== t.length;
}
function tn(t) {
  const { oldSeries: e, newConfig: i, oldTimeIntervalInfo: a, setTimeBinningInfoWhenNotProvided: n } = t, r = i.series?.[0];
  let s = !1, o = !1, c = !1;
  if (se(r) && Ne({
    seriesConfig: r,
    xAxisValueFormatType: ye(i),
    setTimeBinningInfoWhenNotProvided: n
  })) {
    const l = e[0];
    s = JSON.stringify(l.temporalBinning) !== JSON.stringify(r.temporalBinning), o = a?.unit !== r.temporalBinning?.unit, c = n === !0 && (r.temporalBinning?.size ?? 0) <= 0;
  }
  return { timeBinningChanged: s, timeIntervalUnitChanged: o, newTimeBinningWillBeCalculated: c };
}
function an(t) {
  const { oldConfig: e, newConfig: i, behaviorAfterLimit: a } = t, n = e.series, r = i.series;
  let s = !1, o = !1;
  (a === $e.RenderUpToTheLimit || e.orderOptions?.data === void 0 || i.orderOptions?.data === void 0) && (o = !Le(e.orderOptions?.orderByFields, i.orderOptions?.orderByFields));
  const c = Ot(
    n.map((u) => u.query),
    ["where", "outStatistics[0].outStatisticFieldName", "outStatistics[0].onStatisticField"]
  ), l = Ot(
    r.map((u) => u.query),
    ["where", "outStatistics[0].outStatisticFieldName", "outStatistics[0].onStatisticField"]
  );
  return s = !Le(c, l), s || o;
}
function nn(t, e) {
  let i = !1;
  if (e[0].x !== t[0].x)
    i = !0;
  else {
    const a = Q(t);
    if (a !== S.HistogramSeries && a !== S.GaugeSeries) {
      const n = re(t).sort(), r = re(e).sort();
      i = JSON.stringify(n) !== JSON.stringify(r);
    }
  }
  return i;
}
function rn(t, e) {
  return (t ?? !1) !== (e?.filterBySelection ?? !1);
}
function di(t) {
  const { currentSelectionOIDs: e, options: i } = t;
  let a = !1;
  return i?.filterBySelection === !0 && (a = e?.length !== i?.selectionData?.selectionOIDs?.length || !Le(e, i?.selectionData?.selectionOIDs)), a;
}
function sn(t, e) {
  return se(t.series[0]) && se(e.series[0]) && (t.series[0].binTemporalData ?? b.binTemporalData) !== (e.series[0].binTemporalData ?? b.binTemporalData);
}
function bo(t, e) {
  return t?.length !== e?.length || t?.some((i, a) => {
    const n = me({ where: i?.query?.where }), r = me({ where: e?.[a]?.query?.where });
    return n !== r;
  });
}
function xo(t, e) {
  const i = re(t), a = re(e);
  return JSON.stringify(i) !== JSON.stringify(a);
}
function on(t, e) {
  return He(t) !== He(e);
}
function ln(t, e) {
  const i = t.axes?.[0].valueFormat.type, a = e.axes?.[0].valueFormat.type, n = V(e.series), r = n === h.BarAndLineNoAggregation || n === h.BarAndLineSplitByNoAggregation, s = i === S.DateAxisFormat && a === S.NumberAxisFormat, o = i === S.NumberAxisFormat && a === S.DateAxisFormat;
  return i !== a && (r || s || o);
}
function Co(t) {
  const {
    forceDataUpdate: e,
    oldConfig: i,
    newConfig: a,
    options: n,
    formerFilterBySelection: r,
    timeIntervalInfo: s,
    currentSelectionOIDs: o,
    fieldList: c
  } = t, { series: l } = a, { series: u } = i, d = Q(l);
  let f = !1, m = !1, g = !1;
  const y = {
    common: {
      queryChanged: !1,
      xOrYChanged: !1,
      numberOfSeriesChanged: !1,
      configFiltersChanged: !1,
      filterBySelectionChanged: !1,
      dataForFilterBySelectionChanged: !1,
      binTemporalDataChanged: !1,
      timeBinningChanged: !1,
      timeIntervalUnitChanged: !1,
      newTimeBinningWillBeCalculated: !1,
      valueFormatChangeRequiresNewData: !1
    },
    histogram: { dataPropsChanged: !1 },
    gauge: { valueConversionChanged: !1 },
    boxPlot: { showMeanChanged: !1 },
    heatChart: {
      binningChanged: !1
    },
    scatterPlot: {
      tooltipFieldsChanged: !1
    }
  };
  switch (y.common.queryChanged = an({
    oldConfig: i,
    newConfig: a,
    behaviorAfterLimit: n?.chartLimits?.behaviorAfterLimit
  }), y.common.configFiltersChanged = Gi(i, a), y.common.xOrYChanged = nn(u, l), y.common.filterBySelectionChanged = rn(r, n), y.common.dataForFilterBySelectionChanged = di({
    currentSelectionOIDs: o,
    options: n
  }), y.common.binTemporalDataChanged = sn(i, a), y.common.valueFormatChangeRequiresNewData = ln(
    i,
    a
  ), y.common = {
    ...y.common,
    ...tn({
      oldSeries: u,
      newConfig: a,
      oldTimeIntervalInfo: s,
      setTimeBinningInfoWhenNotProvided: n?.setTimeBinningInfoWhenNotProvided
    })
  }, m = Object.values(y.common).some((p) => p), d) {
    case S.HistogramSeries:
      y.histogram.dataPropsChanged = ja(u, l) || ka(u, l);
      break;
    case S.LineSeries:
    case S.BarSeries:
    case S.ComboLineAndBarSeries:
      y.common.numberOfSeriesChanged = kt(u, l);
      break;
    case S.BoxPlotSeries:
      y.common.numberOfSeriesChanged = kt(u, l), y.boxPlot.showMeanChanged = on(i, a);
      break;
    case S.GaugeSeries:
      y.gauge.valueConversionChanged = Xa(i, a);
      break;
    case S.HeatSeries:
      y.heatChart.binningChanged = Za(i, a);
      break;
    case S.ScatterSeries:
      y.scatterPlot.tooltipFieldsChanged = en({
        oldConfig: i,
        newConfig: a,
        fieldList: c
      });
      break;
  }
  return (y.gauge.valueConversionChanged || y.histogram.dataPropsChanged || y.common.numberOfSeriesChanged || y.common.binTemporalDataChanged || y.boxPlot.showMeanChanged || y.heatChart.binningChanged || y.scatterPlot.tooltipFieldsChanged) && (g = !0), f = e === !0 || m || g, { dataUpdateNeeded: f, updateNeededDetails: y };
}
function Bo(t) {
  return t.common.timeIntervalUnitChanged || t.common.newTimeBinningWillBeCalculated || t.common.dataForFilterBySelectionChanged || t.common.filterBySelectionChanged || t.common.configFiltersChanged || t.common.numberOfSeriesChanged || t.common.queryChanged || t.common.xOrYChanged;
}
function cn(t, e) {
  let i = !0;
  if (t !== void 0 && t.length > 1 && !Z(e)) {
    let a = 0, n = 0, r = 0;
    t.forEach((s) => {
      const o = s[e];
      !Ui(o) || o === 0 ? r += 1 : o > 0 ? a += 1 : n += 1;
    }), i = r === t.length || a >= 0 && n === 0 || a === 0 && n >= 0;
  }
  return i;
}
function it(t) {
  const { countTotal: e, countPerSeries: i, numberOfSeries: a } = t;
  let n;
  const r = [];
  return typeof e == "number" && Number.isFinite(e) && r.push(e), typeof i == "number" && Number.isFinite(i) && r.push(i * a), r.length > 0 && (n = Math.min(...r)), n;
}
function fi(t, e) {
  let i;
  const {
    maxBarChartSeriesCount: a,
    maxBarUniqueSeriesCountTotal: n,
    maxBarTwoSeriesCountPerSeries: r,
    maxBarTwoSeriesCountTotal: s,
    maxBarThreePlusSeriesCountPerSeries: o,
    maxBarThreePlusSeriesCountTotal: c,
    maxLineChartSeriesCount: l,
    maxLineUniqueSeriesCountTotal: u,
    maxLineTwoSeriesCountPerSeries: d,
    maxLineTwoSeriesCountTotal: f,
    maxLineThreePlusSeriesCountPerSeries: m,
    maxLineThreePlusSeriesCountTotal: g,
    maxPieChartSliceCountTotal: y,
    maxGaugeByFeaturesLimit: p
  } = Re(e), C = Q(t.series), F = t.series.length === 0 ? 1 : t.series.length, x = V(t.series);
  switch (C) {
    case S.ComboLineAndBarSeries:
    case S.BarSeries:
      F <= a && (F === 1 ? i = n : F === 2 ? i = it({
        countTotal: s,
        countPerSeries: r,
        numberOfSeries: F
      }) : F > 2 && (i = it({
        countTotal: c,
        countPerSeries: o,
        numberOfSeries: F
      })));
      break;
    case S.LineSeries:
      F <= l && (F === 1 ? i = u : F === 2 ? i = it({
        countTotal: f,
        countPerSeries: d,
        numberOfSeries: F
      }) : F > 2 && (i = it({
        countTotal: g,
        countPerSeries: m,
        numberOfSeries: F
      })));
      break;
    case S.PieSeries:
      i = y;
      break;
    case S.GaugeSeries:
      i = p;
      break;
    case S.ScatterSeries:
    // handled through the aggregation feature
    case S.HistogramSeries:
    // handled through the number of bins
    case S.BoxPlotSeries:
  }
  return (x === h.BarAndLineNoAggregation || x === h.BarAndLineMultiFields) && i !== void 0 && (i = Math.ceil(i / F)), i;
}
function jt(t, e) {
  let i = t;
  if (Number.isFinite(t)) {
    const { factor: a, offset: n } = e ?? {};
    Number.isFinite(a) && (i *= a), Number.isFinite(n) && (i += n);
  }
  return i;
}
function un(t) {
  let e = !1;
  if (t !== void 0) {
    const i = t.replace(" ", ""), a = /^%(0*100{1,1}\.?((?:\.)0*)?$)|(^%0*\d{0,2}\.?((?:\.)\d*)?)$/u, n = /^(0*100{1,1}\.?((?:\.)0*)?%$)|(^0*\d{0,2}\.?((?:\.)\d*)?%)$/u;
    e = a.test(i) || n.test(i);
  }
  return e;
}
function vo(t) {
  let e;
  if (un(t)) {
    const i = /%(\d{1,3}(.\d+)?)$/u, a = /(\d{1,3}(.\d+)?)%$/u, n = t.replace(" ", ""), r = i.exec(n)?.[1] ?? a.exec(n)?.[1];
    r !== void 0 && (e = Number(r));
  }
  return e;
}
const oe = {
  DataProcessComplete: "arcgisChartsJSDataProcessComplete",
  DataFetchComplete: "arcgisChartsJSDataFetchComplete",
  LegendItemVisibilityChange: "arcgisChartsJSLegendItemVisibilityChange",
  UpdateComplete: "arcgisChartsJSUpdateComplete",
  RenderingComplete: "arcgisChartsJSRenderingComplete",
  SeriesColorsChange: "arcgisChartsJSSeriesColorChange",
  AxesMinMaxChange: "arcgisChartsJSAxesMinMaxChange",
  SelectionComplete: "arcgisChartsJSSelectionComplete",
  TooManySelectedElements: "arcgisChartsJSTooManySelectedElements",
  BadDataWarningRaise: "arcgisChartsJSBadDataWarningRaise",
  SeriesOrder: "arcgisChartsJSSeriesOrder"
};
function le(t) {
  return {
    detail: t,
    composed: !0,
    cancelable: !0,
    bubbles: !0
  };
}
function No(t) {
  const { data: e, seriesConfig: i, htmlContainer: a } = t;
  if (a && e) {
    const n = ci({ data: e, seriesConfig: i });
    a.dispatchEvent(
      new window.CustomEvent(oe.DataProcessComplete, le(n))
    );
  }
}
function To(t) {
  const { data: e, chartConfig: i, htmlContainer: a } = t;
  if (a && e) {
    const n = gs(e, i);
    a.dispatchEvent(new window.CustomEvent(oe.DataFetchComplete, le(n)));
  }
}
function Ao(t, e) {
  e && e.dispatchEvent(
    new window.CustomEvent(oe.LegendItemVisibilityChange, le(t))
  );
}
function Po(t, e) {
  e && e.dispatchEvent(new window.CustomEvent(oe.UpdateComplete, le(t)));
}
function Lo(t) {
  t && t.dispatchEvent(new window.CustomEvent(oe.RenderingComplete, le()));
}
function Mo(t) {
  const { data: e, seriesConfig: i, htmlContainer: a } = t;
  if (a) {
    const n = e;
    let r = Ce(e.selectionItems);
    r && (r = li(r, i), r = r.map(bt), r = oi(r, i), n.selectionItems = r), a.dispatchEvent(new window.CustomEvent(oe.SelectionComplete, le(n)));
  }
}
function wo(t) {
  t && t.dispatchEvent(new window.CustomEvent(oe.TooManySelectedElements, le()));
}
function Do(t) {
  const { data: e, htmlContainer: i, chartId: a, colorMatchApplied: n } = t;
  i && i.dispatchEvent(
    new window.CustomEvent(
      oe.SeriesColorsChange,
      le({
        chartId: a,
        data: e,
        colorMatchApplied: n
      })
    )
  );
}
function Oo(t, e) {
  e && e.dispatchEvent(new window.CustomEvent(oe.AxesMinMaxChange, le(t)));
}
function qo(t, e) {
  e && e.dispatchEvent(new window.CustomEvent(oe.BadDataWarningRaise, le(t)));
}
function dn(t) {
  const { data: e, htmlContainer: i } = t;
  i && e && i.dispatchEvent(new window.CustomEvent(oe.SeriesOrder, le(e)));
}
function Eo(t, e) {
  let i, a, n, r;
  return se(t.series[0]) && (i = t.series[0].temporalBinning?.unit, n = t.series[0].temporalBinning?.size), se(e.series[0]) && (a = e.series[0].temporalBinning?.unit, r = e.series[0].temporalBinning?.size), St(i, n) && !St(a, r);
}
function Vo(t, e) {
  return t.axes?.length === 3 && e.axes?.length === 2 || t.axes?.length === 2 && e.axes?.length === 3;
}
function Io(t, e) {
  return JSON.stringify(t.series.map((i) => i.assignToSecondValueAxis ?? !1)) !== JSON.stringify(e.series.map((i) => i.assignToSecondValueAxis ?? !1));
}
function $o(t, e) {
  const i = t.axes?.map((n) => n?.guides?.map((r) => r?.above === !0)), a = e.axes?.map((n) => n?.guides?.map((r) => r?.above === !0));
  return JSON.stringify(i) !== JSON.stringify(a);
}
function Ro(t, e) {
  return qt(t) !== qt(e);
}
function ko(t) {
  return Q(t.series) !== S.BoxPlotSeries ? b.xAxisField : t.series[0].x;
}
function jo(t) {
  const e = Yt(t);
  return e === ke.Stacked || e === ke.Stacked100;
}
function Qo(t, e) {
  return (t.showOutliers ?? b.boxPlot.boxPlotOutliersVisibility) !== (e.showOutliers ?? b.boxPlot.boxPlotOutliersVisibility);
}
function Wo(t, e) {
  return (t.standardizeValues ?? b.boxPlot.boxPlotStandardizeValuesVisibility) !== (e.standardizeValues ?? b.boxPlot.boxPlotStandardizeValuesVisibility);
}
function Ho(t, e) {
  return JSON.stringify(t.chartRenderer) !== JSON.stringify(e.chartRenderer);
}
function zo(t, e) {
  const i = t.axes?.[0].valueFormat.type === S.DateAxisFormat ? t.axes[0].valueFormat.intlOptions.timeZone : void 0, a = e.axes?.[0].valueFormat.type === S.DateAxisFormat ? e.axes[0].valueFormat.intlOptions.timeZone : void 0;
  return i !== a;
}
function fn(t, e) {
  return t.series.map((i) => i.name).join() !== e.series.map((i) => i.name).join();
}
function mn(t, e) {
  const i = t.orderOptions?.series, a = e.orderOptions?.series, n = (i?.orderBy ?? fe.Ascending) !== (a?.orderBy ?? fe.Ascending), r = (i?.preferLabel ?? !0) !== (a?.preferLabel ?? !0);
  return n || r;
}
function Go(t, e) {
  return mn(t, e) || fn(t, e);
}
function gn(t) {
  const e = V(t.series);
  let i;
  if (t.orderOptions?.data !== void 0) {
    let a = t.orderOptions?.data?.orderType ?? be.Category, n = t.orderOptions?.data?.orderBy;
    if (a === be.Category)
      a = t.series[0].x;
    else {
      a === be.Mean ? a = I.Average : a === be.Median && (a = I.Median);
      const r = e === h.BoxPlotMultiFieldsAndCategory && typeof t.series[0].y == "string" ? t.series[0].y : void 0, s = K(t.series[0].query?.where), o = me({
        where: t.series[0].query?.where
      });
      a = U({
        key: a,
        y: r,
        chartSubType: e,
        splitBy: s,
        splitByValue: o
      }), Array.isArray(n) && (n = fe.Ascending);
    }
    i = {
      sortingField: a,
      orderBy: n ?? fe.Ascending,
      preferLabel: t.orderOptions.data.preferLabel ?? !0
    };
  }
  return i;
}
function yn(t) {
  let e;
  if (!mi(t) && t.series?.length > 0 && t.orderOptions?.data?.orderType === be.Category) {
    let a;
    de(t.axes?.[0]?.valueFormat) ? a = k.xField : de(t.axes?.[1]?.valueFormat) && (a = k.yField), a && (e = {
      sortingField: a,
      orderBy: t.orderOptions?.data?.orderBy ?? fe.Ascending
    });
  }
  return e;
}
function pn(t) {
  const e = t.series[0], { x: i, y: a } = e, n = V(t.series) === h.PieFromFields, r = V(t.series) === h.BarAndLineFromFields;
  let s, o = "", c;
  if (t.orderOptions?.data !== void 0) {
    if (o = t.orderOptions?.data?.orderType ?? be.Category, c = t.orderOptions?.data?.orderBy, o === be.Category ? o = n ? ae : i : o = n ? pe : [a].flat()[0], o !== void 0 && o !== "") {
      const l = Yt(t);
      if (Q(t.series) !== S.PieSeries && o !== i && t.series?.length > 1)
        switch (l) {
          case ke.Stacked:
            o = b.technicalSortingFieldBySum;
            break;
          case ke.Stacked100:
            o = b.technicalSortingFieldByPercent;
            break;
          case ke.Side:
            typeof a == "string" && (o = a);
            break;
        }
      s = {
        sortingField: o,
        orderBy: c ?? fe.Ascending,
        preferLabel: t.orderOptions.data.preferLabel ?? !0
      };
    }
  } else (r || n) && t.series[0].query?.outStatistics && (c = t.series[0].query.outStatistics.map((l) => l.onStatisticField), c?.length > 1 && (s = {
    sortingField: si.originalCategoryValue,
    orderBy: c,
    preferLabel: !1
  }));
  return s;
}
function xt(t) {
  let e;
  const i = Q(t.series);
  if (i === S.HeatSeries)
    e = yn(t);
  else if (t.series?.length > 0)
    switch (i) {
      case S.BoxPlotSeries:
        e = gn(t);
        break;
      case S.LineSeries:
      case S.BarSeries:
      case S.PieSeries:
        e = pn(t);
        break;
    }
  return e;
}
function Uo(t) {
  const { oldConfig: e, newConfig: i, dataUpdateNeeded: a } = t, n = V(i.series);
  let r = !1, s = !1;
  if (n !== h.BoxPlotMonoField && n !== h.BoxPlotMonoFieldAndSplitBy && i.orderOptions?.data !== void 0) {
    const o = xt(e), c = xt(i);
    s = e.orderOptions?.data?.orderType !== i.orderOptions?.data?.orderType || o?.sortingField !== c?.sortingField || o?.orderBy !== c?.orderBy || (o?.preferLabel ?? !0) !== (c?.preferLabel ?? !0), r = s || a;
  }
  return r;
}
function _o(t, e) {
  const i = [], a = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  return t.forEach((r, s) => n.set(r.id, s)), e.forEach((r, s) => {
    let o = n.get(r.id);
    if (o !== void 0) {
      const c = /* @__PURE__ */ new Set();
      for (; a.has(o) && !c.has(o); )
        c.add(o), o = a.get(o) ?? o;
      o !== s && (i.push([o, s]), a.set(s, o));
    }
  }), i;
}
function Yo(t, e) {
  const i = Ce(t);
  if (i && i.series.length > 1) {
    const { preferLabel: a, orderBy: n } = i.orderOptions?.series ?? {};
    if (n !== void 0) {
      let r;
      if (a === !1) {
        const s = V(i.series);
        r = Kt(s) ? "splitByValue" : "name";
      } else
        r = "name";
      i.series.sort((s, o) => {
        let c, l;
        r === "splitByValue" ? (c = me({ where: s.query?.where }) ?? "", l = me({ where: o.query?.where }) ?? "") : (c = s.name, l = o.name);
        const [u, d] = n.toUpperCase() === fe.Descending ? [l, c] : [c, l];
        return typeof u == "string" && typeof d == "string" ? u.localeCompare(d) : Number(u) - Number(d);
      });
    }
  }
  return dn({
    data: i?.series.map((a) => a.id),
    htmlContainer: e
  }), i;
}
function hn(t) {
  const e = { ...t };
  return t.showMean === !0 && (e.series = [e.series[0]], e.series[0].query?.where !== void 0 && delete e.series[0].query.where), e;
}
function mi(t) {
  let e = !1;
  return t && (e = t.series[0].type === S.HeatSeries && de(t.axes?.[0]?.valueFormat) && de(t.axes?.[1]?.valueFormat)), e;
}
function ot(t) {
  const { dataInfo: e, chartType: i, subError: a } = t;
  switch (e.valid = !1, i) {
    case S.BarSeries:
    case S.ComboLineAndBarSeries:
      e.invalidType = R.BarElementExceedsLimit;
      break;
    case S.LineSeries:
      e.invalidType = R.LineChartExceedsLimit;
      break;
    case S.PieSeries:
      e.invalidType = R.PieChartExceedsLimit;
      break;
    case S.GaugeSeries:
      e.invalidType = R.GaugeExceedsLimit;
      break;
    case S.BoxPlotSeries:
      a?.outlierLimit === !0 ? e.invalidType = R.BoxPlotOutliersExceedsLimit : e.invalidType = R.BoxPlotExceedsLimit;
      break;
    case S.HeatSeries:
      e.invalidType = R.HeatChartExceedsLimit;
      break;
  }
}
function Sn(t, e) {
  t.valid = !1, t.invalidType = e;
}
async function Ko(t) {
  const {
    invalidType: e,
    chartLimits: i,
    elementCount: a,
    seriesCount: n,
    queryObject: r,
    filterBySelection: s,
    formatLocale: o = Ba(document.documentElement),
    isTemporalLineChart: c,
    errorStrings: l
  } = t;
  let u = l.errors.defaultInvalidChart, d;
  const f = new Intl.NumberFormat(o), m = Re(i), { maxCategoryCount: g } = m;
  let y = l.modalHeaders.invalidChart;
  switch (e) {
    case R.BarElementExceedsLimit: {
      y = l.modalHeaders.tooManyFeatures;
      let C = Number.NaN, F = Number.NaN, x = "";
      n !== void 0 && (n <= m.maxBarChartSeriesCount ? n === 1 ? (x = l.errors.uniqueSeriesBarCountCannotExceedLimit, C = m.maxBarUniqueSeriesCountTotal) : n === 2 ? (x = l.errors.twoSeriesBarCountCannotExceedLimit, C = m.maxBarTwoSeriesCountTotal, F = m.maxBarTwoSeriesCountPerSeries) : n > 2 && (x = l.errors.threePlusSeriesBarCountCannotExceedLimit, C = m.maxBarThreePlusSeriesCountTotal, F = m.maxBarThreePlusSeriesCountPerSeries) : (x = l.errors.barSeriesCountCannotExceedLimit, F = m.maxBarChartSeriesCount));
      const B = f.format(C), N = f.format(F), v = a !== void 0 ? f.format(a) : "";
      u = ue(x, {
        totalLimit: B,
        seriesLimit: N,
        elementCount: v
      }), d = {
        actualCount: a ?? Number.NaN,
        totalLimit: C,
        seriesLimit: F
      };
      break;
    }
    case R.LineChartExceedsLimit:
      {
        y = l.modalHeaders.tooManyFeatures;
        let C = Number.NaN, F = Number.NaN, x = "";
        n !== void 0 && (n <= m.maxLineChartSeriesCount ? n === 1 ? (x = c ? l.errors.uniqueTemporalSeriesLineCountCannotExceedLimit : l.errors.uniqueSeriesLineCountCannotExceedLimit, C = m.maxLineUniqueSeriesCountTotal) : n === 2 ? (x = c ? l.errors.twoTemporalSeriesLineCountCannotExceedLimit : l.errors.twoSeriesLineCountCannotExceedLimit, C = m.maxLineTwoSeriesCountTotal, F = m.maxLineTwoSeriesCountPerSeries) : n > 2 && (x = c ? l.errors.threePlusTemporalSeriesLineCountCannotExceedLimit : l.errors.threePlusSeriesLineCountCannotExceedLimit, C = m.maxLineThreePlusSeriesCountTotal, F = m.maxLineThreePlusSeriesCountPerSeries) : (x = l.errors.lineSeriesCountCannotExceedLimit, F = m.maxLineChartSeriesCount));
        const B = f.format(C), N = f.format(F), v = a !== void 0 ? f.format(a) : "";
        u = ue(x, {
          elementCount: v,
          seriesLimit: N,
          totalLimit: B
        }), d = {
          actualCount: a ?? Number.NaN,
          totalLimit: C,
          seriesLimit: F
        };
      }
      break;
    case R.BoxPlotExceedsLimit:
      {
        y = l.modalHeaders.tooManyFeatures;
        let C = Number.NaN, F = Number.NaN, x = "";
        n !== void 0 && (n <= m.maxBoxPlotSeriesCount ? n === 1 ? (x = l.errors.uniqueSeriesBoxCountCannotExceedLimit, C = m.maxBoxUniqueSeriesCountTotal) : n === 2 ? (x = l.errors.twoSeriesBoxCountCannotExceedLimit, C = m.maxBoxTwoSeriesCountTotal, F = m.maxBoxTwoSeriesCountPerSeries) : n > 2 && (x = l.errors.threePlusBoxLineCountCannotExceedLimit, C = m.maxBoxThreePlusSeriesCountTotal, F = m.maxBoxThreePlusSeriesCountPerSeries) : (x = l.errors.boxSeriesCountCannotExceedLimit, F = m.maxBoxPlotSeriesCount));
        const B = f.format(C), N = f.format(F), v = a !== void 0 ? f.format(a) : "";
        u = ue(x, {
          elementCount: v,
          seriesLimit: N,
          totalLimit: B
        }), d = {
          actualCount: a ?? Number.NaN,
          totalLimit: C,
          seriesLimit: F
        };
      }
      break;
    case R.BoxPlotOutliersExceedsLimit:
      {
        y = l.modalHeaders.tooManyFeatures;
        const C = l.errors.boxSeriesOutlierCannotExceedLimit, F = m.maxBoxPlotOutlierLimit, x = f.format(F);
        u = ue(C, {
          totalLimit: x
        }), d = { actualCount: a ?? Number.NaN, totalLimit: F };
      }
      break;
    case R.HeatChartExceedsLimit:
      {
        y = l.modalHeaders.tooManyFeatures;
        const C = l.errors.heatChartCannotExceedLimit, F = m.maxHeatChartCellLimit, x = f.format(F), B = a !== void 0 ? f.format(a) : "";
        u = ue(C, {
          featureCount: B,
          totalLimit: x
        }), d = {
          actualCount: a ?? Number.NaN,
          totalLimit: F
        };
      }
      break;
    case R.PieChartExceedsLimit:
      {
        y = l.modalHeaders.tooManyFeatures;
        const C = l.errors.pieChartSlicesCannotExceedLimit, F = m.maxPieChartSliceCountTotal, x = f.format(F), B = a !== void 0 ? f.format(a) : "";
        u = ue(C, {
          sliceCount: B,
          totalLimit: x
        }), d = {
          actualCount: a ?? Number.NaN,
          totalLimit: F
        };
      }
      break;
    case R.GaugeExceedsLimit:
      {
        y = l.modalHeaders.tooManyFeatures;
        const C = l.errors.gaugeCannotExceedLimit, F = m.maxGaugeByFeaturesLimit, x = f.format(F), B = a !== void 0 ? f.format(a) : "";
        u = ue(C, {
          featureCount: B,
          totalLimit: x
        }), d = {
          actualCount: a ?? Number.NaN,
          totalLimit: F
        };
      }
      break;
    case R.PieChartMixOfNegativePositiveSlices:
      y = l.modalHeaders.cannotCombineNegativeAndPositiveSlices, u = l.errors.pieChartCannotHaveMixtureOfPositiveAndNegativeSlices;
      break;
    case R.NegativeValueInSqrtCalculation:
      y = l.modalHeaders.invalidData, u = l.errors.negativeValueInDataForSqrtTransformation;
      break;
    case R.NegativeValueInLogCalculation:
      y = l.modalHeaders.invalidData, u = l.errors.negativeValueInDataForLogTransformation;
      break;
    case R.HistogramEmptyField:
      u = l.errors.histogramEmptyField;
      break;
    case R.EmptyDataSet:
      y = l.modalHeaders.noDataAvailable, s === !0 ? u = l.errors.noDataFBSMessage : _i(r) ? u = l.errors.noDataFBEMessage : u = l.errors.noDataMessage;
      break;
    case R.NegativeValueInXAxisLogScale:
      u = l.errors.logarithmicXAxisNotPossible;
      break;
    case R.NegativeValueInYAxisLogScale:
      u = l.errors.logarithmicYAxisNotPossible;
      break;
    case R.BadData:
  }
  if (u === l.errors.defaultInvalidChart && (e === R.BarElementExceedsLimit || e === R.LineChartExceedsLimit || e === R.HeatChartExceedsLimit || e === R.PieChartExceedsLimit || e === R.GaugeExceedsLimit || e === R.BoxPlotExceedsLimit) && typeof a == "number" && typeof n == "number" && a / n > g) {
    const C = a / n;
    u = ue(l.errors.categoryCountCannotExceedLimit, {
      categoryCount: f.format(C),
      maxCategoryCount: f.format(g)
    });
  }
  return {
    keyword: e ?? R.BadData,
    header: y,
    message: u,
    params: d
  };
}
function Ie(t, e) {
  return `${e}_${t}`;
}
function Ct(t) {
  const { value: e, mean: i, stdDev: a } = t;
  return (e - i) / a;
}
function At(t) {
  const { dataItem: e, chartSubType: i, y: a, splitByValue: n, meanPerField: r, stdDevPerField: s } = t, o = e;
  let c = {
    chartSubType: i,
    y: a,
    splitByValue: n
  };
  const l = U({
    ...c,
    key: I.Average
  }), u = U({
    ...c,
    key: I.StandardDeviation
  }), d = r ?? Number(e[l]), f = s ?? Number(e[u]);
  return Number.isFinite(d) && Number.isFinite(f) && Object.values(I).forEach((m) => {
    const g = U({
      key: m,
      y: a,
      chartSubType: i,
      splitByValue: n
    }), y = e[g];
    if (y != null) {
      let p = Number(y);
      if (Number.isFinite(p)) {
        c = {
          ...c,
          key: m,
          showOutliers: !1,
          standardizeValues: !0
        };
        let C = U(c);
        if (o[C] = Ct({ mean: d, stdDev: f, value: p }), m === I.Min || m === I.Max) {
          c = {
            ...c,
            key: m,
            showOutliers: !0,
            standardizeValues: !0
          }, C = U(c), c = {
            ...c,
            standardizeValues: !1,
            splitByValue: n
          };
          const F = U(c);
          p = Number(e[F]), Number.isFinite(p) && (o[C] = Ct({
            mean: d,
            stdDev: f,
            value: p
          }));
        }
      }
    }
  }), o;
}
function Fn(t) {
  const { data: e, yList: i, calculateZScore: a = !1 } = t, n = e[0], r = /* @__PURE__ */ new Map();
  return i.forEach((o) => {
    let c = {};
    Object.keys(n).forEach((l) => {
      l.startsWith(o) ? c[l.replace(`${o}_`, "")] = n[l] : l.includes(b.rendererSymbolField) && (c[l] = n[l]), c[b.boxPlot.boxPlotCategory] = o, a && (c = At({
        dataItem: c,
        chartSubType: h.BoxPlotMultiFields
      }));
    }), r.set(o, c);
  }), Array.from(r.values());
}
function bn(t) {
  const { data: e, splitByField: i, y: a } = t, n = {
    [b.boxPlot.boxPlotCategory]: a
  };
  return e.forEach((s) => {
    const o = s[i];
    o !== void 0 && Object.keys(s).forEach((c) => {
      c === b.rendererSymbolField ? n[`${c}_${o?.toString()}`] = s[c] : c === b.boxPlot.boxPlotMeanLineMarkerId ? n[c] = s[c] : n[`${o?.toString()}_${c}`] = s[c];
    });
  }), [n];
}
function xn(t) {
  const { splitByField: e, data: i, yList: a, calculateZScore: n = !1, meanAndStdDevPerField: r } = t, s = /* @__PURE__ */ new Map();
  return i.forEach((c) => {
    const l = c[e];
    a.forEach((u) => {
      let d = {
        [b.boxPlot.boxPlotCategory]: u
      };
      Object.entries(c).forEach(([f, m]) => {
        f.startsWith(`${u}_`) ? d[`${l}_${f.replace(`${u}_`, "")}`] = m : f.includes(b.rendererSymbolField) ? d[`${f}_${l}`] = m : f === b.boxPlot.boxPlotMeanLineMarkerId && (d[f] = c[f]);
      }), n && (d = At({
        dataItem: d,
        chartSubType: h.BoxPlotMultiFieldsAndSplitBy,
        splitByValue: l,
        meanPerField: r?.[Ie(u, P.Average)],
        stdDevPerField: r?.[Ie(u, P.StandardDeviation)]
      })), s.set(u, {
        ...s.get(u) ?? {},
        ...d
      });
    });
  }), Array.from(s.values());
}
function Cn(t) {
  const { data: e, yList: i, calculateZScore: a = !1, meanAndStdDevPerField: n } = t, r = e;
  return a && r.forEach((s) => {
    i.forEach((o) => {
      At({
        dataItem: s,
        chartSubType: h.BoxPlotMultiFieldsAndCategory,
        y: o,
        meanPerField: n?.[Ie(o, P.Average)],
        stdDevPerField: n?.[Ie(o, P.StandardDeviation)]
      });
    });
  }), r;
}
function Bn(t) {
  const { splitByField: e, x: i, data: a } = t, n = /* @__PURE__ */ new Map();
  return a.forEach((s) => {
    const o = s[i], c = { [i]: o }, l = s[e];
    Object.entries(s).forEach(([u, d]) => {
      if (u.includes(b.rendererSymbolField))
        c[`${b.rendererSymbolField}_${l?.toString()}`] = d;
      else if (u === b.boxPlot.boxPlotMeanLineMarkerId)
        c[u] = s[u];
      else if (u !== e && u !== i) {
        const f = u !== b.xAxisField && u !== b.originalCategoryValue ? `${l?.toString()}_${u}` : u;
        c[f] = d;
      }
    }), n.set(o, {
      ...n.get(o) ?? {},
      ...c
    });
  }), Array.from(n.values());
}
function vn(t, e) {
  const { series: i } = t, a = i[0], { y: n } = a, r = V(t.series), s = {
    y: r === h.BoxPlotMultiFieldsAndCategory ? n : void 0,
    chartSubType: r
  }, o = t.series.map((c) => {
    let l = me({
      where: c.query?.where,
      normalize: !1,
      escape: !0
    });
    return l !== null && `${l}`.startsWith("'") && `${l}`.endsWith("'") && (l = l.substring(1, l.length - 1)), l;
  });
  o.length === 0 && o.push(" "), e.forEach((c) => {
    o.forEach((l) => {
      s.splitByValue = l;
      const u = U({
        ...s,
        key: I.Min,
        showOutliers: !0
      }), d = U({
        ...s,
        key: I.Min,
        showOutliers: !1
      }), f = U({
        ...s,
        key: I.Max,
        showOutliers: !0
      }), m = U({
        ...s,
        key: I.Max,
        showOutliers: !1
      });
      c[f] === void 0 && c[m] !== void 0 && (c[f] = c[m]), c[u] === void 0 && c[d] !== void 0 && (c[u] = c[d]);
    });
  });
}
function Nn(t, e) {
  let i, a;
  const n = t[e[I.IQR]], r = t[e[I.FirstQuartile]], s = t[e[I.ThirdQuartile]];
  return Number.isFinite(n) && Number.isFinite(r) && Number.isFinite(s) && (i = r - n * 1.5, a = s + n * 1.5), { outlierMinThreshold: i, outlierMaxThreshold: a };
}
function Qt(t) {
  const { yField: e, xField: i, xValue: a, splitByField: n, splitByValue: r, outlierMaxThreshold: s, outlierMinThreshold: o, target: c } = t;
  let l;
  if (i !== void 0 && a !== void 0) {
    const m = typeof a != "string" ? a : `'${Et(a)}'`;
    l = `${i}=${m.toString()}`;
  }
  let u;
  if (n !== void 0 && r !== void 0) {
    const m = typeof r != "string" ? r : `'${Et(r)}'`;
    u = `${n}=${m.toString()}`;
  }
  let d;
  return c === "outliers" && o !== s ? d = `(${e}<${o} OR ${e}>${s})` : c === "alternativeData" && (o === s ? d = `(${e}=${o})` : d = `(${e}>=${o} AND ${e}<=${s})`), [l, u, d].filter((m) => m !== void 0).join(" AND ");
}
function gi(t) {
  const { data: e, yField: i, x: a, chartSubType: n, splitByField: r } = t, s = n === h.BoxPlotMonoField || n === h.BoxPlotMonoFieldAndCategory || n === h.BoxPlotMonoFieldAndSplitBy || n === h.BoxPlotMonoFieldAndCategoryAndSplitBy ? void 0 : i, o = je(s), c = [], l = [], { maxOperandsPerWhereClause: u } = Ue();
  let d = [], f = [], m = 1;
  return e.forEach((g, y) => {
    const { outlierMinThreshold: p, outlierMaxThreshold: C } = Nn(g, o);
    if (typeof p == "number" && typeof C == "number") {
      const F = {
        yField: i,
        outlierMinThreshold: p,
        outlierMaxThreshold: C
      };
      (n === h.BoxPlotMonoFieldAndCategory || n === h.BoxPlotMultiFieldsAndCategory || n === h.BoxPlotMonoFieldAndCategoryAndSplitBy) && a !== void 0 && a in g && (F.xField = a, F.xValue = ze({
        value: g[a],
        dataContext: g,
        keepNullValues: !0,
        specificField: b.typeOrDomainIdValue
      })), (n === h.BoxPlotMonoFieldAndSplitBy || n === h.BoxPlotMultiFieldsAndSplitBy || n === h.BoxPlotMonoFieldAndCategoryAndSplitBy) && r !== void 0 && r in g && (F.splitByField = r, F.splitByValue = g[r]), d.push(Qt({ ...F, target: "outliers" })), f.push(Qt({ ...F, target: "alternativeData" })), (m % u === 0 || y === e.length - 1) && (c.push(W(d, "OR")), l.push(W(f, "OR")), d = [], f = []);
    }
    m += 1;
  }), { outliersFilterBatches: c, dataWithoutOutliersFilterBatches: l };
}
function Tn(t) {
  const { data: e, outlierDataItem: i, chartSubType: a, x: n, y: r, meanAndStdDevPerField: s, splitByField: o } = t;
  let c = s?.[Ie(r, P.Average)], l = s?.[Ie(r, P.StandardDeviation)];
  if (c === void 0 && l === void 0)
    switch (a) {
      case h.BoxPlotMultiFields: {
        const u = je(r), d = e[0];
        c = Number(d[u[I.Average]]), l = Number(d[u[I.StandardDeviation]]);
        break;
      }
      case h.BoxPlotMultiFieldsAndCategory: {
        const u = e.find((d) => d[n] === i[n]);
        if (u !== void 0) {
          const d = je(r);
          c = Number(u[d[I.Average]]), l = Number(u[d[I.StandardDeviation]]);
        }
        break;
      }
      case h.BoxPlotMultiFieldsAndSplitBy: {
        const u = e.find((d) => d[o] === i[o]);
        if (u !== void 0) {
          const d = je(r);
          c = Number(u[d[I.Average]]), l = Number(u[d[I.StandardDeviation]]);
        }
        break;
      }
    }
  return { mean: c, stdDev: l };
}
async function An(t) {
  const { seriesConfig: e, data: i, uniqueQuery: a, queryObject: n, meanAndStdDevPerField: r, abortKey: s } = t, o = V(e), c = e[0], { x: l } = c, u = K(c.query?.where), d = z(n), f = re(e), m = [];
  for (let p = 0; p < f.length; p += 1) {
    const C = f[p], { outliersFilterBatches: F } = gi({
      data: i,
      yField: C,
      x: l,
      chartSubType: o,
      splitByField: u
    });
    for (let x = 0; x < F.length; x += 1) {
      const B = F[x];
      if (B !== "") {
        const N = [];
        l !== b.boxPlot.boxPlotCategory && N.push(l), N.push(C), u !== "" && N.push(u), N.push(d.objectIdField);
        const v = {
          ...a,
          where: W([a.where, B]),
          groupByFieldsForStatistics: void 0,
          outStatistics: void 0,
          orderByFields: void 0,
          num: void 0,
          outFields: N
        };
        m.push(
          ge({
            queryObject: n,
            queryConfig: v,
            featureCount: 1,
            // TODO: pre-count to trigger batching
            abortKey: s
          })
        );
      }
    }
  }
  const g = await Promise.all(m), y = /* @__PURE__ */ new Map();
  for (let p = 0; p < g.length; p += 1) {
    const C = g[p], F = f[p];
    C.forEach((x) => {
      const B = { ...x.attributes };
      if (B[F] !== void 0) {
        l === b.boxPlot.boxPlotCategory && (B[b.boxPlot.boxPlotCategory] = F);
        let N = {
          key: I.Outlier,
          chartSubType: o
        };
        switch (o) {
          case h.BoxPlotMonoFieldAndSplitBy:
          case h.BoxPlotMultiFieldsAndSplitBy:
          case h.BoxPlotMonoFieldAndCategoryAndSplitBy:
            N = {
              ...N,
              splitByValue: B[u]
            };
            break;
          case h.BoxPlotMultiFieldsAndCategory:
            N = {
              ...N,
              y: F
            };
            break;
        }
        const v = U(N), A = B[F];
        B[v] = A;
        const w = `${B[l]}-${B[u]}-${A}`, L = y.get(w);
        if (B[Y.uniqueIdsName] = [
          ...L?.[Y.uniqueIdsName] ?? [],
          B[d.objectIdField]
        ], delete B[d.objectIdField], Yi(o)) {
          const D = U({
            ...N,
            standardizeValues: !0
          }), { mean: M, stdDev: O } = Tn({
            data: i,
            outlierDataItem: B,
            chartSubType: o,
            x: l,
            y: F,
            splitByField: u,
            meanAndStdDevPerField: r
          });
          M !== void 0 && O !== void 0 && (B[D] = Ct({
            value: A,
            mean: M,
            stdDev: O
          }));
        }
        delete B[F], B[b.boxPlot.boxPlotOutlierId] = !0, y.set(w, B);
      }
    });
  }
  return Array.from(y.values());
}
async function Pn(t) {
  const { data: e, queryObject: i, uniqueQuery: a, elementCount: n, chartConfig: r, chartLimits: s, abortKey: o } = t;
  let c = [];
  const { series: l, showMean: u } = r, d = Nt({ showMean: u, seriesConfig: l }), f = V(l), m = we(r), { x: g } = m, y = K(m.query?.where), p = [];
  for (let F = 0; F < d.length; F += 1) {
    const x = d[F], { dataWithoutOutliersFilterBatches: B } = gi({
      data: e,
      yField: x,
      x: g,
      chartSubType: f,
      splitByField: y
    });
    for (let N = 0; N < B.length; N += 1) {
      const v = B[N], A = {
        ...a,
        where: W([a.where, v])
      };
      A.outStatistics !== void 0 && (A.outStatistics = A.outStatistics?.filter(
        (w) => (w.statisticType === P.Minimum || w.statisticType === P.Maximum) && w.onStatisticField === x
      ).map((w) => ({
        ...w,
        outStatisticFieldName: `${w.outStatisticFieldName}${b.boxPlot.boxPlotOutliersSuffix}`
      }))), p.push(
        ut({
          queryObject: i,
          uniqueQuery: A,
          chartConfig: r,
          elementCount: n,
          isTimeBinningSeries: !1,
          showMean: u,
          chartLimits: s,
          abortKey: o
        })
      );
    }
  }
  const C = await Promise.all(p);
  for (let F = 0; F < C.length; F += 1)
    c.push(...C[F]);
  return f !== h.BoxPlotMonoFieldAndCategoryAndSplitBy && (c = Lt({
    data: c,
    x: y !== void 0 && y !== "" ? y : g
  })), c;
}
async function Ln(t) {
  const { queryObject: e, uniqueQuery: i, chartConfig: a, abortKey: n } = t;
  let r;
  const { series: s, showMean: o } = a, c = V(s);
  if (c === h.BoxPlotMultiFieldsAndCategory || c === h.BoxPlotMultiFieldsAndSplitBy) {
    const l = Nt({ showMean: o, seriesConfig: s }), u = {
      ...i
    };
    delete u.outStatistics, delete u.groupByFieldsForStatistics, delete u.orderByFields;
    const d = [];
    for (let m = 0; m < l.length; m += 1) {
      const g = l[m];
      d.push(
        {
          statisticType: P.Average,
          onStatisticField: g,
          outStatisticFieldName: `${P.Average}_${g}`
        },
        {
          statisticType: P.StandardDeviation,
          onStatisticField: g,
          outStatisticFieldName: `${P.StandardDeviation}_${g}`
        }
      );
    }
    u.outStatistics = d;
    const f = await ge({
      queryObject: e,
      queryConfig: u,
      featureCount: 1,
      abortKey: n
    });
    f.length > 0 && (r = f[0].attributes);
  }
  return r;
}
function Mn(t) {
  const { data: e, additionalData: i, chartConfig: a } = t, n = a.series[0], { x: r } = n, s = K(n.query?.where);
  return e.map((o) => {
    let c = o;
    const l = i.find(
      (u) => u[r] === o[r] && (s === "" ? !0 : u[s] === o[s])
    );
    return l !== void 0 && (c = { ...o, ...l }), c;
  });
}
function yi(t) {
  const { chartConfig: e, data: i, calculateZScore: a = !1, meanAndStdDevPerField: n } = t, { series: r, showMean: s } = e, o = we(e), c = V(e.series), { x: l } = o, u = Nt({ showMean: s, seriesConfig: r });
  let d = i;
  if ((o.type === S.LineSeries || o.type === S.BoxPlotSeries) && i?.[0] !== void 0) {
    const f = K(o.query?.where);
    switch (c) {
      case h.BoxPlotMonoField:
        d[0][b.boxPlot.boxPlotCategory] = u[0];
        break;
      case h.BoxPlotMultiFields:
        d = Fn({
          data: i,
          yList: u,
          calculateZScore: a
        });
        break;
      case h.BoxPlotMonoFieldAndSplitBy:
        d = bn({
          data: i,
          splitByField: f,
          y: u[0]
          // there's only one `y` value for that query type
        });
        break;
      case h.BoxPlotMultiFieldsAndSplitBy:
        d = xn({
          splitByField: f,
          data: i,
          yList: u,
          meanAndStdDevPerField: n,
          calculateZScore: a
        });
        break;
      case h.BoxPlotMultiFieldsAndCategory:
        d = Cn({
          data: i,
          yList: u,
          meanAndStdDevPerField: n,
          calculateZScore: a
        });
        break;
      case h.BoxPlotMonoFieldAndCategoryAndSplitBy:
        d = Bn({
          splitByField: f,
          x: l,
          data: i
        });
        break;
      case h.BoxPlotMonoFieldAndCategory:
    }
  }
  return vn(e, d), d;
}
async function wn(t) {
  const { data: e, queryObject: i, uniqueQuery: a, fetchFullBoxPlotData: n, chartConfig: r, elementCount: s, chartLimits: o, abortKey: c } = t;
  let l = e, u = [];
  if (l !== void 0) {
    const { series: d } = r, f = await Ln({
      queryObject: i,
      uniqueQuery: a,
      chartConfig: r,
      abortKey: c
    });
    if (n !== !1) {
      u = await An({
        queryObject: i,
        uniqueQuery: a,
        seriesConfig: d,
        data: l,
        abortKey: c
      });
      const m = await Pn({
        queryObject: i,
        uniqueQuery: a,
        elementCount: s,
        data: e,
        chartConfig: r,
        chartLimits: o,
        abortKey: c
      });
      l = Mn({
        data: l,
        additionalData: m,
        chartConfig: r
      });
    }
    l = yi({
      chartConfig: r,
      data: l,
      meanAndStdDevPerField: f,
      calculateZScore: !0
    });
  }
  return { dataItems: l, outliers: u };
}
function Dn(t) {
  const { whereValue: e, outStatistics: i, y: a } = t;
  let n = Y.outStatistics.outStatisticFieldName ?? "";
  return i?.outStatisticFieldName !== void 0 ? n = i.outStatisticFieldName : i?.onStatisticField !== void 0 && i.statisticType !== void 0 ? n = `${i.statisticType}_${i.onStatisticField}_${e}` : a !== void 0 && (n = [a].flat()[0]), n;
}
function On(t) {
  const e = /* @__PURE__ */ new Map();
  for (let i = 0; i < t.length; i += 1) {
    const a = t[i], n = a.query?.where;
    if (n !== void 0 && "y" in a) {
      const r = me({ where: n, normalize: !0, escape: !1 });
      if (r !== "") {
        const s = Dn({
          whereValue: r,
          outStatistics: a.query?.outStatistics?.[0],
          y: a.y
        });
        a.y = s, e.set(r, s);
      }
    }
  }
  return e;
}
function qn(t) {
  const { uniqueQuery: e, splitByField: i, x: a } = t, n = [...e.groupByFieldsForStatistics ?? [], a, i].filter(
    (r) => r !== void 0 && r.trim() !== "" && r !== Jt
  );
  e.groupByFieldsForStatistics = Array.from(new Set(n));
}
function En(t) {
  return t.statisticType === P.ContinuousPercentile || t.statisticType === P.DiscretePercentile;
}
function Vn(t) {
  const {
    uniqueQuery: e,
    y: i,
    useGenericOutStatFieldName: a,
    queryObject: n,
    chartSubType: r,
    isTimeBinningSeries: s,
    returnFeaturesExtent: o,
    splitByField: c
  } = t, l = Y.outStatistics;
  if (e.outStatistics?.[0] !== void 0) {
    r !== h.PieFromFields && r !== h.BarAndLineFromFields && (e.outStatistics[0].outStatisticFieldName = a ? l.outStatisticFieldName : [i].flat()[0]);
    const { outStatistics: u } = e;
    for (let d = 0; d < u.length; d += 1) {
      const f = e.outStatistics[d];
      f !== void 0 && En(f) && (s && !We(n) ? (u[d].statisticType = P.Count, delete u[d].statisticParameters) : u[d] = {
        ...u[d],
        statisticParameters: u[d].statisticParameters ?? {
          value: b.defaultStatParameterValue
        }
      });
    }
  } else if (n !== void 0) {
    const { objectIdField: u } = z(n);
    e.outStatistics = [
      {
        statisticType: l.statisticType,
        onStatisticField: u,
        outStatisticFieldName: a ? l.outStatisticFieldName : [i].flat()[0]
      }
    ];
  }
  o === !0 && (!s || Z(c)) && e.outStatistics?.push({ statisticType: P.EnvelopeAggregate, onStatisticField: "1" });
}
function In(t) {
  const { chartConfig: e, fetchFullBoxPlotData: i } = t, { series: a } = e, n = He(e);
  let r = [
    { statisticType: P.Average, suffix: I.Average }
  ];
  i === !0 && (r = [
    ...r,
    { statisticType: P.Minimum, suffix: I.Min },
    {
      statisticType: P.ContinuousPercentile,
      statisticParameters: { value: 0.25 },
      suffix: I.FirstQuartile
    },
    {
      statisticType: P.ContinuousPercentile,
      statisticParameters: { value: 0.5 },
      suffix: I.Median
    },
    {
      statisticType: P.ContinuousPercentile,
      statisticParameters: { value: 0.75 },
      suffix: I.ThirdQuartile
    },
    { statisticType: P.Maximum, suffix: I.Max },
    { statisticType: P.StandardDeviation, suffix: I.StandardDeviation }
  ]);
  const s = /* @__PURE__ */ new Set();
  return n && "y" in a[0] ? [a[0].y].flat().forEach((c) => s.add(c)) : a.forEach((c) => {
    "y" in c && [c.y].flat().forEach((u) => s.add(u));
  }), [...s].flatMap(
    (c) => r.map((l) => {
      const u = {
        onStatisticField: c,
        statisticType: l.statisticType,
        outStatisticFieldName: `${c}_${l.suffix}`
      };
      return l.statisticType === P.ContinuousPercentile && (u.statisticParameters = l.statisticParameters), u;
    })
  );
}
function $n(t, e) {
  for (let i = 1; i < e.length; i += 1) {
    const a = { ...e[i].query?.outStatistics?.[0] };
    a !== void 0 && t.outStatistics !== void 0 && t.outStatistics.push(a);
  }
}
function Rn(t) {
  const { uniqueQuery: e, x: i, splitByField: a, unit: n, chartSubType: r, objectIdField: s } = t;
  if (n !== void 0) {
    const o = Ki(i, n);
    e.orderByFields = o, e.groupByFieldsForStatistics = o, r === h.BarAndLineSplitBy && !Z(a) ? e.groupByFieldsForStatistics.push(a) : r === h.BarAndLineNoAggregation && (e.groupByFieldsForStatistics.push(s), e.outStatistics = [
      {
        onStatisticField: s,
        outStatisticFieldName: `COUNT_${s}`,
        statisticType: P.Count
      }
    ]);
  }
}
function pi(t) {
  const { chartConfig: e, options: i, uniqueQuery: a } = t;
  if (i?.chartLimits?.behaviorAfterLimit === $e.RenderUpToTheLimit) {
    const n = fi(e, i?.chartLimits);
    if (n !== void 0) {
      const r = V(e.series);
      if (r === h.PieFromFields || r === h.BarAndLineFromFields) {
        if (a.outStatistics?.[0] !== void 0) {
          const s = (l, u) => l.statisticType === P.EnvelopeAggregate === u, o = a.outStatistics.filter((l) => s(l, !0)), c = a.outStatistics.filter((l) => s(l, !1));
          c.splice(n), a.outStatistics = [...c, ...o];
        }
      } else
        a.num = n;
    }
  }
}
async function ct(t) {
  const { chartConfig: e, queryConfig: i, options: a, queryObject: n, timeIntervalInfo: r, fetchFullBoxPlotData: s } = t, { setTimeBinningInfoWhenNotProvided: o, returnFeaturesExtent: c } = a ?? {}, l = e.series, u = V(l), d = we(e), { query: f, x: m } = d, g = "y" in d ? d.y : void 0, y = Ne({
    xAxisValueFormatType: ye(e),
    setTimeBinningInfoWhenNotProvided: o,
    seriesConfig: d
  });
  let p = /* @__PURE__ */ new Map(), C = !1, F = !1, x = !1, B = !1, N = !1, v = {};
  if (f !== void 0) {
    v = Ce(f);
    const E = K(f.where);
    let H = "";
    switch (i.fetchNullValues !== !0 && (m !== b.boxPlot.boxPlotCategory && (H = `${m} IS NOT NULL`), E.trim() !== "" && E !== m && !Tt(f.where) && (H = W([H, `${E} IS NOT NULL`]))), u) {
      case h.BarAndLineSplitBy: {
        p = On(l), B = !0, C = !0, F = !0;
        break;
      }
      case h.BarAndLineMultiFields:
        $n(v, l), F = !0;
        break;
      case h.PieFromFields:
      case h.BarAndLineFromFields:
        H = "", x = !0, F = !0;
        break;
      case h.BarAndLineMonoField:
      case h.PieFromCategory:
        F = !0;
        break;
      case h.BoxPlotMonoField:
      case h.BoxPlotMultiFields:
        x = !0, N = !0;
        break;
      case h.BoxPlotMonoFieldAndCategory:
      case h.BoxPlotMultiFieldsAndCategory:
      case h.BoxPlotMonoFieldAndSplitBy:
      case h.BoxPlotMonoFieldAndCategoryAndSplitBy:
      case h.BoxPlotMultiFieldsAndSplitBy: {
        N = !0, B = !0, x = !0;
        break;
      }
      case h.PieNoAggregation:
      case h.BarAndLineNoAggregation:
      case h.BarAndLineSplitByNoAggregation:
    }
    if (F && Vn({
      uniqueQuery: v,
      y: g,
      useGenericOutStatFieldName: C,
      queryObject: n,
      chartSubType: u,
      isTimeBinningSeries: y,
      returnFeaturesExtent: c,
      splitByField: E
    }), B && qn({ uniqueQuery: v, splitByField: E, x: m }), N && (v.outStatistics = In({ chartConfig: e, fetchFullBoxPlotData: s })), x ? delete v.orderByFields : i.orderByFields !== void 0 && (v.orderByFields = i.orderByFields.filter((Fe) => {
      const $ = Fe.split(" ");
      return !Z($[0]);
    })), y && se(l[0])) {
      const Fe = z(n), { objectIdField: $ } = Fe;
      (await Te(n)).find((ee) => ee.name === m)?.type !== Ye.DateOnly && Rn({
        uniqueQuery: v,
        x: m,
        splitByField: K(f.where),
        unit: r?.unit ?? l[0].temporalBinning?.unit,
        chartSubType: u,
        objectIdField: $
      });
    }
    v.where = H;
  }
  pi({ chartConfig: e, options: a, uniqueQuery: v });
  const { gdbVersion: A, geometry: w, distance: L, units: D, timeExtent: M, where: O, objectIds: q, spatialRelationship: T } = i;
  return A !== void 0 && (v.gdbVersion = A), w !== void 0 && (v.geometry = w), L !== void 0 && (v.distance = L), D !== void 0 && (v.units = D), M !== void 0 && (v.timeExtent = M), q !== void 0 && (v.objectIds = q), T !== void 0 && (v.spatialRelationship = T), O !== void 0 && (v.where = W([v.where, O])), { uniqueQuery: v, mapToStatField: p };
}
async function kn(t) {
  const { queryObject: e, queryConfig: i, chartConfig: a, abortKey: n } = t, r = a.series[0], { x: s, valueConversion: o } = r, c = Xt(a), l = await ge({
    queryObject: e,
    queryConfig: i,
    featureCount: i.num ?? 1,
    // if a chart limitation has been provided we use it, otherwise we force 1 to avoid the batching
    abortKey: n
  });
  let u = [{ [s]: null }];
  if (c)
    u = l.map((d) => {
      Mt(d.attributes, s);
      const f = jt(d.attributes[s], o);
      return { ...d.attributes, [s]: f };
    });
  else if (l.length > 0) {
    let d = l[0].attributes[s] ?? l[0].attributes[s.toUpperCase()] ?? l[0].attributes[s.toLowerCase()];
    d = jt(d, o), u = [{ [s]: d }];
  }
  return u;
}
async function jn(t) {
  const { queryObject: e, chartConfig: i, queryConfig: a, options: n, abortKey: r } = t, { chartLimits: s } = n ?? {}, o = { valid: !0 };
  if (e !== void 0) {
    const { behaviorAfterLimit: c, maxGaugeByFeaturesLimit: l } = s ?? {}, u = Xt(i);
    let d = !0, f;
    if (u && (f = (await wi({
      chartConfig: i,
      queryObject: e,
      queryConfig: a,
      behaviorAfterLimit: c,
      numberMaxOfFeaturesToFetch: l,
      isGaugeByFeature: u
    })).elementCount, n?.chartLimits?.behaviorAfterLimit !== $e.RenderUpToTheLimit && (d = he({
      count: f ?? 0,
      seriesCount: i.series.length,
      chartType: S.GaugeSeries,
      chartLimits: s
    })), n && (Number.isFinite(l) || Number.isFinite(f)))) {
      const m = Math.min(l ?? Number.NaN, f ?? Number.NaN);
      Number.isFinite(m) && (n.chartLimits = {
        ...s,
        maxGaugeByFeaturesLimit: m
      }), pi({ chartConfig: i, options: n, uniqueQuery: a });
    }
    if (Number.isNaN(d) || d) {
      const m = await kn({
        queryObject: e,
        chartConfig: i,
        queryConfig: a,
        abortKey: r
      });
      o.data = { dataItems: m }, o.count = m.length;
    } else
      o.count = f, ot({
        dataInfo: o,
        chartType: S.GaugeSeries
      });
  }
  return o;
}
async function Jo(t) {
  const { queryObject: e, chartConfig: i, queryConfig: a } = t, { minimumFromField: n, maximumFromField: r } = i.axes[0], s = [];
  let o = "", c = "";
  n !== void 0 && (typeof n == "string" ? (o = `${P.Minimum}_${n}`, s.push({
    statisticType: P.Minimum,
    onStatisticField: n,
    outStatisticFieldName: o
  })) : (o = `${n.statisticType}_${n.onStatisticField}`, s.push({
    ...n,
    outStatisticFieldName: o
  }))), r !== void 0 && (typeof r == "string" ? (c = `${P.Maximum}_${r}`, s.push({
    statisticType: P.Maximum,
    onStatisticField: r,
    outStatisticFieldName: c
  })) : (c = `${r.statisticType}_${r.onStatisticField}`, s.push({
    ...r,
    outStatisticFieldName: c
  })));
  const l = {
    ...a,
    outStatistics: s,
    orderByFields: void 0,
    groupByFieldsForStatistics: void 0,
    returnDistinctValues: void 0,
    fetchNullValues: void 0,
    num: void 0
  }, u = await _e({
    queryObject: e,
    queryConfig: l
  }), d = u.get(o), f = u.get(c);
  return { minimumFromData: d, maximumFromData: f };
}
function Qn(t = _.None, e) {
  return t === _.None || t === _.Log && e > 0 || t === _.Sqrt && e >= 0;
}
function hi(t, e) {
  const i = { valid: !1 };
  return e === !0 ? i.invalidType = R.HistogramEmptyField : t === _.Log ? i.invalidType = R.NegativeValueInLogCalculation : t === _.Sqrt && (i.invalidType = R.NegativeValueInSqrtCalculation), i;
}
function Wn(t, e) {
  let i = t;
  switch (e) {
    case _.Log:
      i = Math.log(t);
      break;
    case _.Sqrt:
      i = Math.sqrt(t);
      break;
  }
  return i;
}
function Hn(t) {
  let e = t;
  const i = t.toString().split(".");
  if (i[1] !== void 0) {
    const n = 10 ** -i[1].length;
    e = t - n;
  }
  return e;
}
function Si(t) {
  let e = "field";
  switch (t) {
    case _.Log:
      e = "natural-log";
      break;
    case _.Sqrt:
      e = "square-root";
      break;
    case _.None:
  }
  return e;
}
async function zn(t) {
  const { queryObject: e, fieldName: i, queryConfig: a, abortKey: n } = t, r = z(e), { objectIdField: s } = r, o = `${P.Count}_${s}`, c = `${P.Count}_${i}`, l = `${P.Minimum}_${i}`, u = `${P.Maximum}_${i}`, d = {
    ...a,
    outStatistics: [
      {
        statisticType: P.Count,
        onStatisticField: s,
        outStatisticFieldName: o
      },
      {
        statisticType: P.Count,
        onStatisticField: i,
        outStatisticFieldName: c
      },
      {
        statisticType: P.Minimum,
        onStatisticField: i,
        outStatisticFieldName: l
      },
      {
        statisticType: P.Maximum,
        onStatisticField: i,
        outStatisticFieldName: u
      }
    ]
  }, f = await _e({
    queryObject: e,
    queryConfig: d,
    abortKey: n
  }), m = f.get(o) ?? Number.NaN, g = f.get(c) ?? Number.NaN, y = f.get(l) ?? Number.NaN, p = f.get(u) ?? Number.NaN;
  return { countExcludingNulls: g, countIncludingNulls: m, min: y, max: p };
}
async function Gn(t) {
  const { queryConfig: e, chartConfig: i, queryObject: a, abortKey: n } = t, r = i.series[0], { x: s, dataTransformationType: o } = r;
  let c = [];
  const { countIncludingNulls: l, countExcludingNulls: u, min: d, max: f } = await zn({
    queryObject: a,
    queryConfig: e,
    fieldName: s,
    abortKey: n
  }), m = Qn(o, d), g = u < 2 || d === f, y = { ...e };
  return y.where = W([y.where, `${s} is not null`]), {
    rawData: c,
    dataCompatibleWithTransformation: m,
    dataCountIncompatible: g,
    countExcludingNulls: u,
    countIncludingNulls: l
  };
}
function Un(t) {
  const e = { ...t };
  return e.avg = e.avg ?? Number.NaN, e.count = e.count ?? Number.NaN, e.max = e.max ?? Number.NaN, e.min = e.min ?? Number.NaN, e.stddev = e.stddev ?? Number.NaN, e.sum = e.sum ?? Number.NaN, e.variance = e.variance ?? Number.NaN, e.median = e.median ?? Number.NaN, e;
}
function _n(t) {
  const { seriesConfig: e, layer: i, useFeaturesInView: a, view: n, queryConfig: r } = t, { x: s, dataTransformationType: o } = e;
  let c = {
    layer: i,
    view: n,
    field: s,
    // excluding the filters like 1=1 from the sqlWhere. It's causing query failures (see https://devtopia.esri.com/WebGIS/arcgis-charts/issues/6677)
    sqlWhere: Tt(r.where) ? void 0 : r.where,
    useFeaturesInView: a
  };
  return o !== _.None && (c = {
    ...c,
    normalizationType: Si(o)
  }), c;
}
function Yn(t) {
  const { seriesConfig: e, layer: i, useFeaturesInView: a, view: n, minValue: r, maxValue: s, queryConfig: o } = t, { x: c, binCount: l, dataTransformationType: u } = e;
  let d = {
    layer: i,
    view: n,
    field: c,
    minValue: r,
    maxValue: s,
    numBins: l ?? Zi,
    classificationMethod: "equal-interval",
    // excluding the filters like 1=tionMethod: "equal-interval",1 from the sqlWhere. It's causing query failures (see https://devtopia.esri.com/WebGIS/arcgis-charts/issues/6677)
    sqlWhere: Tt(o.where) ? void 0 : o.where,
    useFeaturesInView: a
  };
  return u !== _.None && (d = {
    ...d,
    normalizationType: Si(u)
  }), d;
}
function Kn(t, e) {
  let i = Number.NaN;
  return t !== void 0 && e !== void 0 && (i = t - e), i;
}
async function Jn(t) {
  const {
    chartConfig: e,
    queryConfig: i,
    queryObject: a,
    countExcludingNulls: n,
    countIncludingNulls: r,
    options: s,
    errorStrings: o
  } = t, c = e.series[0], { dataTransformationType: l } = c;
  let u = { valid: !0 };
  if (a !== void 0) {
    const d = z(a), m = Ji(i?.geometry)?.extent?.toJSON() !== void 0, g = s?.view, y = _n({
      seriesConfig: c,
      layer: d,
      view: g,
      useFeaturesInView: m,
      queryConfig: i
    });
    let p;
    if (g !== void 0 && (p = new $t({
      geometry: g.extent
    }), g.extent !== void 0 && Xi(d))) {
      const { distance: L, units: D } = i;
      L !== void 0 && (p.distance = L), D !== void 0 && (p.units = D);
    }
    if (i.timeExtent) {
      const L = { start: i.timeExtent[0], end: i.timeExtent[1] };
      p === void 0 ? p = new $t({ timeExtent: L }) : p.timeExtent = L;
    }
    y.filter = p;
    let C;
    y.outStatisticTypes = { exclude: ["median"] };
    try {
      C = await Rt(y);
    } catch (L) {
      throw new pt(Vt.QueryFeaturesError, o.errors.queryError, L);
    }
    y.outStatisticTypes = { include: ["median"] };
    try {
      const L = await Rt(y);
      L?.median && (C.median = L.median);
    } catch {
    }
    C = Un(C);
    const { avg: F, count: x, stddev: B, min: N, max: v, sum: A, median: w } = C;
    if (x === 0)
      u = {
        ...hi(l)
      };
    else {
      const L = Yn({
        seriesConfig: c,
        layer: d,
        view: g,
        useFeaturesInView: m,
        minValue: Hn(N),
        maxValue: v,
        valueExpression: y.valueExpression,
        queryConfig: i
      });
      L.filter = p;
      let D;
      try {
        D = await va(L);
      } catch (O) {
        throw new pt(Vt.QueryFeaturesError, o.errors.queryError, O);
      }
      const M = Kn(r, n);
      u.data = {
        mean: F,
        stddev: B,
        min: N,
        max: v,
        median: Number(w),
        bins: D?.bins,
        count: n,
        nulls: M,
        sum: A ?? void 0
      }, u.data.bins.length > 0 && (u.data.bins[u.data.bins.length - 1].isLastBin = !0);
    }
  }
  return u;
}
async function Fi(t) {
  const { chartConfig: e, queryConfig: i, queryObject: a, options: n, abortKey: r, errorStrings: s } = t, { series: o } = e, c = o[0], { rawData: l, dataCompatibleWithTransformation: u, dataCountIncompatible: d, countIncludingNulls: f, countExcludingNulls: m } = await Gn({
    queryObject: a,
    chartConfig: e,
    queryConfig: i,
    abortKey: r
  });
  let g = { valid: !0 };
  return !u || d ? g = hi(c.dataTransformationType, d) : g = await Jn({
    chartConfig: e,
    queryObject: a,
    queryConfig: i,
    countIncludingNulls: f,
    countExcludingNulls: m,
    options: n,
    errorStrings: s
  }), g;
}
async function Xn(t) {
  const { queryObject: e, queryConfig: i, chartConfig: a, x: n } = t, { series: r } = a, { dataTransformationType: s } = r[0], o = {
    ...i,
    orderByFields: [n],
    outFields: [n]
  };
  return {
    valid: !0,
    data: { dataItems: (await ge({
      queryObject: e,
      queryConfig: o
    })).map((u) => ({
      [n]: Wn(u.attributes[n], s)
    })) }
  };
}
const Me = {
  groupByCaseBegin: "CASE",
  groupByOutKeyword: "OUT",
  groupByCaseEnd: "ELSE 'OUT' END"
}, Zn = "{ groupByFieldsForStatistics } WHEN ({ y } { yMinOperand } { yValue } AND { y } { yMaxOperand } { yValuePlusStep } AND { x } { xMinOperand } { xValue } AND { x } { xMaxOperand } { xValuePlusStep }) THEN '{ xValue }|{ xValuePlusStep}|{ yValue }|{ yValuePlusStep }'";
async function er(t) {
  const { chartConfig: e, queryObject: i, queryConfig: a, abortKey: n } = t, r = e.series[0], { x: s, y: o } = r, { dataContextCountDistinctX: c, dataContextCountDistinctY: l } = b.scatterplotAggregationFields, u = {
    ...a,
    outStatistics: [
      {
        statisticType: P.Count,
        outStatisticFieldName: c,
        onStatisticField: s
      },
      {
        statisticType: P.Count,
        outStatisticFieldName: l,
        onStatisticField: o
      }
    ],
    returnDistinctValues: !0
    // this parameters guarantees the 2 count stats bring back distinct values. It has no impact on the other stats.
  };
  return await _e({
    queryObject: i,
    queryConfig: u,
    abortKey: n
  });
}
async function tr(t) {
  const { statsMap: e, chartConfig: i, queryObject: a, options: n, queryConfig: r, abortKey: s } = t, {
    dataContextXMinField: o,
    dataContextXMaxField: c,
    dataContextYMinField: l,
    dataContextYMaxField: u,
    dataContextCountDistinctX: d,
    dataContextCountDistinctY: f
  } = b.scatterplotAggregationFields;
  let m, g, y, p, C;
  const F = e.get(o), x = e.get(c), B = e.get(l), N = e.get(u);
  if (F != null && B !== void 0 && B !== null && x !== void 0 && x !== null && N !== void 0 && N !== null && !Number.isNaN(F + x + B + N)) {
    const { maxScatterPointsAfterAggregation: v } = Re(n?.chartLimits), w = Math.floor(Math.sqrt(v)), L = await er({
      queryObject: a,
      chartConfig: i,
      queryConfig: r,
      abortKey: s
    });
    y = Math.min(L.get(f) ?? Number.NaN, w), p = Math.min(L.get(d) ?? Number.NaN, w), C = p * y, m = x === F ? 0 : (x - F) / (p - 1), g = N === B ? 0 : (N - B) / (y - 1), e.set(b.scatterplotAggregationFields.xStep, m), e.set(b.scatterplotAggregationFields.yStep, g), e.set(b.scatterplotAggregationFields.rowCount, y), e.set(b.scatterplotAggregationFields.columnCount, p), e.set(b.scatterplotAggregationFields.realGridSize, C);
  }
}
function ir(t) {
  const { groupByFieldsForStatistics: e, x: i, y: a, xValue: n, yValue: r, xStep: s, yStep: o, endOfRow: c, endOfColumn: l } = t;
  let u = e === "" ? Me.groupByCaseBegin : e;
  return u = ue(Zn, {
    groupByFieldsForStatistics: u,
    x: i,
    y: a,
    xValue: `${n}`,
    yValue: `${r}`,
    xValuePlusStep: `${n + (l ? 0 : s)}`,
    yValuePlusStep: `${r + (c ? 0 : o)}`,
    xMinOperand: l ? "=" : ">=",
    // we use = to catch the last value of the column, >= otherwise
    yMinOperand: c ? "=" : ">=",
    // we use = to catch the last value of the line, >= otherwise
    xMaxOperand: l ? "=" : "<",
    // we use = to catch the last value of the column, < otherwise
    yMaxOperand: c ? "=" : "<"
    // we use = to catch the last value of the line, < otherwise
  }), u;
}
async function ar(t) {
  const { chartConfig: e, queryConfig: i, queryObject: a, xMin: n, xMax: r, yMin: s, yMax: o, abortKey: c } = t, l = e.series[0], { x: u, y: d } = l, f = { ...i };
  return f.where = W([f.where, `${u}>=${n}`, `${u}<=${r}`]), u !== d && (f.where = W([f.where, `${d}>=${s}`, `${d}<=${o}`])), await ge({
    queryObject: a,
    queryConfig: f,
    noBatch: !0,
    featureCount: 1,
    // this will skip the query counting the features
    abortKey: c
  });
}
async function nr(t) {
  const { statsMap: e, chartConfig: i, queryObject: a, queryConfig: n, useQueryAttributeBins: r, errorStrings: s, abortKey: o } = t, c = i.series[0], { x: l, y: u } = c, {
    dataContextXMinField: d,
    dataContextXMaxField: f,
    dataContextYMinField: m,
    dataContextYMaxField: g,
    queryNumberOfFeatures: y,
    queryNumberOfAggregatedFeatures: p
  } = b.scatterplotAggregationFields;
  let C;
  const F = e?.get(d) ?? Number.NaN, x = e?.get(f) ?? Number.NaN, B = e?.get(y) ?? Number.NaN, N = e?.get(m) ?? F, v = e?.get(g) ?? x;
  if (F != null && N !== void 0 && N !== null && x !== void 0 && x !== null && v !== void 0 && v !== null && !Number.isNaN(F + x + N + v)) {
    const A = z(a), { objectIdField: w } = A, L = e?.get(b.scatterplotAggregationFields.xStep), D = e?.get(b.scatterplotAggregationFields.yStep), M = e?.get(b.scatterplotAggregationFields.realGridSize), O = e?.get(b.scatterplotAggregationFields.rowCount), q = e?.get(b.scatterplotAggregationFields.columnCount), T = /* @__PURE__ */ new Map(), E = await Te(a);
    if (E?.forEach(($) => {
      Qe($) && T.set($.name, {
        onStatisticField: $.name,
        outStatisticFieldName: $.name,
        statisticType: P.Maximum
      });
    }), (E.filter(($) => c?.additionalTooltipFields?.includes($.name)) ?? [])?.forEach(($) => {
      Qe($) || T.set($.name, {
        onStatisticField: $.name,
        outStatisticFieldName: $.name,
        statisticType: P.Maximum
      });
    }), (await Zt(A)).forEach(($) => {
      T.set($, {
        onStatisticField: $,
        outStatisticFieldName: $,
        statisticType: P.Maximum
      });
    }), T.set(w, {
      onStatisticField: w,
      outStatisticFieldName: p,
      statisticType: P.Count
    }).set(l, {
      onStatisticField: l,
      outStatisticFieldName: l,
      statisticType: P.Maximum
    }).set(u, {
      onStatisticField: u,
      outStatisticFieldName: u,
      statisticType: P.Maximum
    }), L !== void 0 && D !== void 0) {
      if (r) {
        const $ = {
          ...n,
          outStatistics: [...T.values()]
        };
        C = await ea({
          queryObject: a,
          queryConfig: $,
          xStep: L,
          xMin: F,
          xMax: x,
          x: l,
          y: u,
          yStep: D,
          errorStrings: s
        });
      } else if (O !== void 0 && q !== void 0) {
        let $ = 0;
        const { maxScatterCellsPerQuery: X, maxScatterCellsPerQueryForStandard: ce } = Ue(), De = await ta(A) ? ce : X, Dt = [];
        let dt = !0, Oe = F, Ae = N, qe = "", Je = 1, ft = 1, Xe = Number.MAX_SAFE_INTEGER, Ze = Number.MIN_SAFE_INTEGER, et = Number.MAX_SAFE_INTEGER, tt = Number.MIN_SAFE_INTEGER;
        for (; ft <= q && dt; ) {
          for (Ae = N, Je = 1; Je <= O && dt; ) {
            if (qe = ir({
              groupByFieldsForStatistics: qe,
              x: l,
              y: u,
              xValue: Oe,
              yValue: Ae,
              xStep: L,
              yStep: D,
              endOfRow: Je === O,
              endOfColumn: ft === q
            }), Oe < Xe && (Xe = Oe), Oe + L > Ze && (Ze = Oe + L), Ae < et && (et = Ae), Ae + L > tt && (tt = Ae + D), $ += 1, $ % De === 0 || $ === M || $ === B) {
              qe = `${qe} ${Me.groupByCaseEnd}`;
              const Vi = {
                ...n,
                groupByFieldsForStatistics: [qe],
                outStatistics: [...T.values()]
              };
              Dt.push(
                ar({
                  chartConfig: i,
                  queryConfig: Vi,
                  queryObject: a,
                  xMin: Xe,
                  xMax: Ze,
                  yMin: et,
                  yMax: tt,
                  abortKey: o
                })
              ), Xe = Number.MAX_SAFE_INTEGER, Ze = Number.MIN_SAFE_INTEGER, et = Number.MAX_SAFE_INTEGER, tt = Number.MIN_SAFE_INTEGER, qe = "", $ === M && (dt = !1);
            }
            Ae += D, Je += 1;
          }
          Oe += L, ft += 1;
        }
        C = (await Promise.all(Dt)).flat();
      }
    }
  }
  return C;
}
const rr = {
  dataFormat: "json",
  outputFormat: "json",
  typeKey: "analyticType",
  typeValue: "LinRegR2",
  fieldValue: "onAnalyticField",
  slopePropertyList: ["Slope", "SLOPE", "slope"],
  interceptPropertyList: ["Intercept", "INTERCEPT", "intercept"],
  r2PropertyList: ["R2", "r2"]
};
async function sr(t) {
  const { queryObject: e } = t;
  let i = !1;
  const a = ia(e), n = z(e), r = ei(n);
  if (a && r.url !== void 0 && r.url !== null) {
    const s = `${r.url}/${r.layerId}?f=json`;
    try {
      const o = (await Fa(s)).data, c = o?.advancedQueryCapabilities?.supportsQueryAnalytic === !0, l = o?.sqlParserVersion === void 0 || r.version != null && r.version >= 10.91;
      i = c && l;
    } catch {
    }
  }
  return i;
}
function or(t) {
  const { x: e, y: i, trendlineXToY: a, data: n } = t, [r, s] = n ? ki(n, (c) => c[e]) : [Number.NaN, Number.NaN];
  return [
    { [e]: r ?? Number.NaN, [i]: a(r ?? Number.NaN) },
    { [e]: s ?? Number.NaN, [i]: a(s ?? Number.NaN) }
  ];
}
function lr(t) {
  const { data: e, x: i, y: a } = t;
  let n = [];
  return e !== void 0 && (n = e.filter((r) => Number.isFinite(r[i]) && Number.isFinite(r[a])).map((r) => [r[i], r[a]])), n;
}
async function cr(t) {
  const { statsMap: e, queryObject: i, chartConfig: a, queryConfig: n } = t, r = a.series[0], { x: s, y: o } = r;
  let c = Number.NaN, l = [
    { [s]: Number.NaN, [o]: Number.NaN },
    { [s]: Number.NaN, [o]: Number.NaN }
  ];
  const {
    dataFormat: u,
    outputFormat: d,
    typeKey: f,
    typeValue: m,
    fieldValue: g,
    slopePropertyList: y,
    interceptPropertyList: p,
    r2PropertyList: C
  } = rr, F = `[{"${f}": "${m}", "${g}":"${s},${o}"}]`, x = await aa({
    queryObject: i,
    queryConfig: n,
    outputFormat: d,
    dataFormat: u,
    outAnalytics: F
  });
  if (x !== void 0) {
    let B = Number.NaN, N = Number.NaN;
    const { expr: v } = mt(x, y), { expr: A } = mt(x, p), { expr: w } = mt(x, C);
    v !== void 0 && Number.isFinite(x[v]) && (B = x[v]), A !== void 0 && Number.isFinite(x[A]) && (N = x[A]), w !== void 0 && Number.isFinite(x[w]) && (c = x[w]);
    const { dataContextXMinField: L, dataContextXMaxField: D, dataContextYMinField: M, dataContextYMaxField: O } = b.scatterplotAggregationFields, q = e.get(L) ?? Number.NaN, T = e.get(D) ?? Number.NaN, E = e.get(M) ?? Number.NaN, H = e.get(O) ?? Number.NaN, $ = (T - q) / 100;
    let X = q - $, ce = Number.NaN;
    for (; !(ce >= E && ce <= H) && X <= T; )
      X += $, ce = B * X + N;
    let ee = T + $, De = Number.NaN;
    for (; !(De >= E && De <= H) && ee >= q; )
      ee -= $, De = B * ee + N;
    l = [
      { [s]: X, [o]: ce },
      { [s]: ee, [o]: De }
    ];
  }
  return { r2: c, trendLinePoints: l };
}
function bi(t) {
  const { data: e, chartConfig: i } = t, a = i.series[0], { x: n, y: r } = a;
  let { r2: s, trendLinePoints: o } = b.scatterplotSeries;
  const c = lr({ data: e, x: n, y: r });
  if (c !== void 0) {
    const l = Na(c), u = Ta(l);
    s = Aa(c, u), o = or({ x: n, y: r, trendlineXToY: u, data: e });
  }
  return { r2: s, trendLinePoints: o };
}
async function ur(t) {
  const e = await sr(t), { chartConfig: i } = t, a = i.series[0], { x: n, y: r } = a, { r2: s } = b.scatterplotSeries, o = [
    { [n]: Number.NaN, [r]: Number.NaN },
    { [n]: Number.NaN, [r]: Number.NaN }
  ];
  let c = { r2: s, trendLinePoints: o }, l = !1;
  if (e)
    try {
      c = await cr(t);
    } catch {
      l = !0;
    }
  return (!e || l) && (c = bi(t)), c;
}
async function dr(t) {
  const { chartConfig: e, queryConfig: i, queryObject: a, abortKey: n } = t, r = e.series[0], { x: s, y: o } = r;
  let c = /* @__PURE__ */ new Map();
  const {
    dataContextXMinField: l,
    dataContextXMaxField: u,
    dataContextYMinField: d,
    dataContextYMaxField: f,
    queryNumberOfFeatures: m
  } = b.scatterplotAggregationFields, { objectIdField: g } = z(a), y = [
    {
      statisticType: P.Count,
      onStatisticField: g,
      outStatisticFieldName: m
    },
    {
      statisticType: P.Minimum,
      outStatisticFieldName: l,
      onStatisticField: s
    },
    {
      statisticType: P.Maximum,
      outStatisticFieldName: u,
      onStatisticField: s
    }
  ];
  s !== o && y.push(
    {
      statisticType: P.Minimum,
      outStatisticFieldName: d,
      onStatisticField: o
    },
    {
      statisticType: P.Maximum,
      outStatisticFieldName: f,
      onStatisticField: o
    }
  );
  const p = { ...i };
  return p.outStatistics = y, c = await _e({
    queryObject: a,
    queryConfig: p,
    abortKey: n
  }), s === o && (c.set(d, c.get(l) ?? Number.NaN), c.set(f, c.get(u) ?? Number.NaN)), c;
}
function at(t) {
  const { value: e, valueMin: i, valueMax: a } = t;
  return e === i || e === a ? e : Math.random() * (a - i) + i;
}
function fr(t) {
  const { useQueryAttributeBins: e, graphic: i, x: a, y: n, yStep: r } = t, { groupByOutKeyword: s } = Me, { dataContextXMinField: o, dataContextXMaxField: c, dataContextYMinField: l, dataContextYMaxField: u } = b.scatterplotAggregationFields;
  let d = [];
  if (e && "stackedAttributes" in i && i.stackedAttributes) {
    const f = sa(a, n), m = i.attributes[f.lowerBoundaryAlias], g = i.attributes[f.upperBoundaryAlias];
    i.stackedAttributes.forEach((y) => {
      let p = y[f.stackAlias], C;
      typeof p == "number" && typeof r == "number" && (p *= r), typeof p == "number" && typeof r == "number" && (C = p + r);
      const F = y[a], x = y[n];
      typeof p == "number" && typeof C == "number" && typeof F == "number" && typeof x == "number" && d.push({
        ...y,
        [a]: at({ value: F, valueMin: m, valueMax: g }),
        [n]: at({ value: x, valueMin: p, valueMax: C }),
        [o]: Math.min(m, g),
        [c]: Math.max(m, g),
        [l]: p,
        [u]: C
      });
    });
  } else {
    const { expr: f, isInItem: m } = lt(i.attributes);
    if (m && f && i.attributes[f] !== s) {
      let [g, y, p, C] = i.attributes[f].split("|");
      g = Math.min(g, y), y = Math.max(g, y), p = Math.min(p, C), C = Math.max(p, C);
      const F = {
        ...i.attributes,
        [o]: g,
        [c]: y,
        [l]: p,
        [u]: C
      };
      F[a] = at({
        value: F[a],
        valueMin: g,
        valueMax: y
      }), F[n] = at({
        value: F[n],
        valueMin: p,
        valueMax: C
      }), d = [F];
    }
  }
  return d;
}
async function mr(t) {
  const { queryObject: e, chartConfig: i, rawData: a, isAggregationMode: n, yStep: r, useQueryAttributeBins: s } = t, o = i.series[0], { x: c, y: l } = o, d = z(e).objectIdField;
  let m = (Array.isArray(a) ? a : a?.features)?.flatMap((g) => {
    let y = [{ ...g.attributes }];
    return Mt(y[0], [c, l]), n ? y = fr({
      useQueryAttributeBins: s,
      graphic: g,
      x: c,
      y: l,
      yStep: r
    }) : y[0][Y.uniqueIdsName] = y[0][d], y;
  });
  return m = m?.filter((g) => {
    const { expr: y } = lt(g);
    return Number.isFinite(g[c]) && Number.isFinite(g[l]) && (y === void 0 || g[y] !== Me.groupByOutKeyword);
  }), m ?? [];
}
async function gr(t) {
  const { queryObject: e, queryConfig: i, chartConfig: a, featureCount: n, abortKey: r } = t, s = a.series[0], { x: o, y: c } = s, l = z(e);
  let u = [];
  const f = ((await Te(e))?.filter((p) => Qe(p) && p.name !== o && p.name !== c) ?? []).map(
    (p) => p.name
  ) ?? [], m = s?.additionalTooltipFields ?? [], g = Array.from(
    /* @__PURE__ */ new Set([o, c, l.objectIdField, ...f, ...m])
  );
  if (!ei(l).isTable) {
    const { rendererField: p, rendererNormalizationField: C } = ra(l?.renderer ?? void 0);
    Z(p) || g.push(p), Z(C) || g.push(C);
  }
  const y = {
    ...i,
    orderByFields: [`${o} ${fe.Ascending}`],
    outFields: g
  };
  return u = await ge({
    queryObject: e,
    queryConfig: y,
    featureCount: n,
    abortKey: r
  }), u;
}
async function yr(t) {
  let e;
  const {
    chartConfig: i,
    queryConfig: a,
    queryObject: n,
    statsMap: r,
    numberOfFeatures: s,
    isAggregationMode: o,
    useQueryAttributeBins: c,
    errorStrings: l,
    abortKey: u
  } = t, d = i.series[0], { x: f, y: m } = d;
  if (!Number.isNaN(s) && s > 0) {
    const g = { ...a };
    g.where = W([g.where, `${f} IS NOT NULL`, `${m} IS NOT NULL`]), o ? e = await nr({
      chartConfig: i,
      queryObject: n,
      queryConfig: g,
      statsMap: r,
      useQueryAttributeBins: c,
      errorStrings: l,
      abortKey: u
    }) : e = await gr({
      queryObject: n,
      chartConfig: i,
      queryConfig: g,
      featureCount: s,
      abortKey: u
    });
  }
  return e;
}
async function xi(t) {
  const { chartConfig: e, queryConfig: i, queryObject: a, sortData: n, calculateTrendLine: r, options: s, abortKey: o } = t, c = await dr({
    chartConfig: e,
    queryConfig: i,
    queryObject: a,
    abortKey: o
  }), { queryNumberOfFeatures: l, yStep: u } = b.scatterplotAggregationFields, { maxScatterPointsBeforeAggregation: d } = Re(s?.chartLimits), f = c?.get(l) ?? Number.NaN, m = f >= d, g = na(a);
  m && await tr({
    statsMap: c,
    chartConfig: e,
    queryObject: a,
    options: s,
    queryConfig: i,
    abortKey: o
  });
  const y = await yr({
    ...t,
    statsMap: c,
    numberOfFeatures: f,
    isAggregationMode: m,
    useQueryAttributeBins: g
  }), p = await mr({
    queryObject: a,
    chartConfig: e,
    rawData: y,
    isAggregationMode: m,
    yStep: c.get(u),
    useQueryAttributeBins: g
  });
  n !== !1 && Ge({
    arrayToSort: p,
    sortingField: e.series[0].x,
    orderBy: fe.Ascending
  });
  const { r2: C, trendLinePoints: F } = r !== !1 ? await ur({
    data: p,
    statsMap: c,
    queryConfig: i,
    options: s,
    queryObject: a,
    chartConfig: e
  }) : b.scatterplotSeries;
  return { dataItems: p, r2: C, trendLinePoints: F, aggregated: m };
}
function pr(t) {
  const { itemsA: e, itemsB: i, isPieFromFields: a, x: n, y: r, outStatisticFieldName: s } = t, o = Ce(e), c = Ce(i);
  let l = !1;
  if (o === void 0 && c !== void 0 || o !== void 0 && c === void 0)
    l = !0;
  else if (!a) {
    const u = [
      b.originalCategoryValue,
      b.originalDateValue,
      b.xAxisField,
      b.technicalSortingFieldBySum,
      b.technicalSortingFieldByPercent,
      b.pieChart.technicalFieldSlicePercent,
      b.pieChart.technicalFieldGroupedSlices,
      b.pieChart.technicalFieldSliceId,
      b.typeOrDomainFieldName,
      b.typeOrDomainIdValue,
      b.originalServerBinningRange,
      b.lastTemporalBin,
      b.technicalFieldSplitByField,
      Y.uniqueIdsName,
      k.valueField,
      ...oa
    ], d = (y, p) => {
      const C = p[b.typeOrDomainFieldName];
      typeof C == "string" && p[C] !== void 0 && (p[C] = p[b.typeOrDomainIdValue]), n && p[k.xField] !== void 0 && (p[n] = p[k.xField], delete p[k.xField]), r && p[k.yField] !== void 0 && (p[r] = p[k.yField], delete p[k.yField]), s && p[k.valueField] !== void 0 && (p[s] = p[k.valueField], delete p[k.valueField]);
      const F = {};
      return Object.keys(p).forEach((x) => {
        !u.includes(x) && !x.includes(b.rendererSymbolField) && (F[x] = p[x]);
      }), y.push(F), y;
    }, f = (y, p) => JSON.stringify(y).localeCompare(JSON.stringify(p)), m = o?.reduce(d, [])?.sort(f), g = c?.reduce(d, [])?.sort(f);
    l = m?.length !== g?.length || !Le(m, g);
  }
  return l;
}
function hr(t) {
  const { chartConfig: e, currentSelectionDataItems: i, options: a } = t, { selectionData: n } = a ?? {};
  let r = [];
  if (e !== void 0) {
    const s = e.series, o = V(s), { selectionItems: c } = n ?? {};
    if (c !== void 0 && pr({
      itemsA: c,
      itemsB: i,
      isPieFromFields: V(e.series) === h.PieFromFields,
      x: e.series[0].x,
      y: "y" in e.series[0] ? e.series[0].y.toString() : void 0,
      outStatisticFieldName: e.series[0].query?.outStatistics?.[0]?.outStatisticFieldName
    }) ? r = c : r = i ?? [], s.length > 1 && o !== h.BarAndLineNoAggregation && o !== h.BarAndLineSplitByNoAggregation) {
      const l = K(s[0].query?.where);
      r = Lt({ data: r, x: s[0].x, splitByField: l });
    }
    Ke({
      arrayToSort: r,
      chartConfig: e
    });
  }
  return r ?? [];
}
function Be(t, e) {
  let i = "";
  if (t.trim() !== "" && e !== void 0)
    if (e === null)
      i = `${t} IS NULL`;
    else {
      const a = typeof e != "number" ? "'" : "";
      i = `${t}=${a}${e.toString()}${a}`;
    }
  return i;
}
function Sr(t) {
  const { dataContext: e, xAxisField: i, yAxisField: a, options: n } = t;
  let r = "";
  const { dataContextXMinField: s, dataContextXMaxField: o, dataContextYMinField: c, dataContextYMaxField: l } = b.scatterplotAggregationFields;
  if (ui({ dataContext: e, chartLimits: n?.chartLimits })) {
    const { [s]: u, [o]: d } = e, f = i !== a ? e[c] : u, m = i !== a ? e[l] : d;
    if (!Number.isNaN(u) && !Number.isNaN(d) && !Number.isNaN(f) && !Number.isNaN(m)) {
      const g = [];
      u === d ? g.push(`${i}=${u?.toString()}`) : (g.push(`${i}>=${u?.toString()}`), g.push(`${i}<=${d?.toString()}`)), f === m ? g.push(`${a}=${f?.toString()}`) : (g.push(`${a}>=${f?.toString()}`), g.push(`${a}<=${m?.toString()}`)), r = W(g);
    }
  } else
    r = W([
      Se({ where: Be(i, e[i]) }),
      a !== void 0 ? Se({ where: Be(a, e[a]) }) : ""
    ]);
  return r;
}
function Ci(t, e) {
  let i = "";
  const a = e[b.originalServerBinningRange] ?? e[b.dateBinningRange];
  if (vt(a) && a.length === 2) {
    let [n, r] = a;
    typeof n == "number" && typeof r == "number" && Number.isFinite(n) && Number.isFinite(r) && (n = Ve(n), r = Ve(r));
    const s = e[b.lastTemporalBin] === !0 ? "<=" : "<";
    i = `${t}>='${n}' AND ${t}${s}'${r}'`;
  }
  return i;
}
function Bi(t, e) {
  let i = "";
  if (Number.isFinite(t)) {
    const a = 1 / 10 ** b.queryMaxFloatPrecision;
    i = `${e}>=${t - a} AND ${e}<=${t + a}`;
  }
  return i;
}
function vi(t) {
  const { xAxisField: e, yAxisField: i, splitBy: a, dataContext: n, xAxisFieldType: r, chartConfig: s } = t;
  let o = "";
  if (e !== void 0 && e !== b.boxPlot.boxPlotCategory) {
    let d = ze({
      value: n[e],
      dataContext: n,
      keepNullValues: !0,
      specificField: b.typeOrDomainIdValue
    });
    r === Ye.Double ? o = Bi(d, e) : (Pe(s.axes?.[0].valueFormat) && (d = Ve(d)), o = Se({
      where: Be(e, d),
      normalize: !1,
      escape: !0
    }));
  }
  const c = Se({ where: a ?? "", normalize: !1, escape: !0 });
  let l = "";
  if (Wa(s) === !0) {
    const d = V(s.series) === h.BoxPlotMultiFieldsAndCategory ? i : void 0, f = U({
      key: I.Min,
      showOutliers: !0,
      splitBy: a,
      y: d
    }), m = U({
      key: I.Max,
      showOutliers: !0,
      splitBy: a,
      y: d
    }), g = e === b.boxPlot.boxPlotCategory ? n[e] : i;
    if (!Z(g)) {
      const y = n[f], p = n[m];
      Number.isFinite(y) && Number.isFinite(p) && (l = `${g?.toString()}>=${y?.toString()} AND ${g?.toString()}<=${p?.toString()}`);
    }
  }
  return W([o, c, l]);
}
function Fr(t) {
  const { xAxisField: e, splitBy: i, dataContext: a, xAxisFieldType: n, chartConfig: r } = t;
  let s = "";
  if (b.dateBinningRange in a)
    s = Ci(e, a);
  else if (V(r.series) !== h.BarAndLineFromFields) {
    let l = ze({
      value: a[e],
      dataContext: a,
      keepNullValues: !0,
      specificField: b.typeOrDomainIdValue
    });
    n === Ye.Double ? s = Bi(l, e) : (Pe(r.axes?.[0].valueFormat) && (l = Ve(l)), s = Se({
      where: Be(e, l),
      normalize: !1,
      escape: !0
    }));
  }
  const o = Se({ where: i ?? "", normalize: !1, escape: !0 });
  return W([s, o]);
}
function br(t) {
  const { xAxisField: e, dataContext: i, chartConfig: a } = t;
  let n = b.typeOrDomainIdValue in i ? i[b.typeOrDomainIdValue] : i[b.originalCategoryValue];
  return n === void 0 && (n = i[e]), V(a.series) === h.PieFromFields ? "" : Se({
    where: Be(e, n),
    normalize: !1,
    escape: !0
  });
}
function Wt(t) {
  const { field: e, fieldType: i, fieldValue: a, unit: n, outTimeZone: r, dataTimeZone: s, runsOnClientQueryEngine: o } = t;
  let c;
  const { expression: l } = ti({
    field: e,
    fieldType: i,
    unit: n,
    addIntervalStatement: !0,
    outTimeZone: r,
    dataTimeZone: s,
    runsOnClientQueryEngine: o
  });
  return l && (c = `${l}=${a}`), c;
}
function xr(t) {
  const {
    xAxisFieldType: e,
    yAxisFieldType: i,
    dataContext: a,
    chartConfig: n,
    outTimeZone: r,
    dataTimeZone: s,
    runsOnClientQueryEngine: o
  } = t, c = n.series[0];
  let l = "";
  if (c.type === S.HeatSeries) {
    let u, d;
    const f = a[k.xField], m = a[k.yField], g = n.axes?.[0]?.valueFormat?.type, y = n.axes?.[1]?.valueFormat?.type;
    g === S.CategoryAxisFormat ? u = Se({
      where: Be(c.x, f),
      normalize: !1,
      escape: !0
    }) : u = Wt({
      field: c.x,
      fieldType: e,
      fieldValue: f,
      unit: c.xTemporalBinning?.unit,
      outTimeZone: r,
      dataTimeZone: s,
      runsOnClientQueryEngine: o
    }), y === S.CategoryAxisFormat ? d = Se({
      where: Be(c.y, m),
      normalize: !1,
      escape: !0
    }) : d = Wt({
      field: c.y,
      fieldType: i,
      fieldValue: m,
      unit: c.yTemporalBinning?.unit
    }), u && (l = W([l, u])), d && (l = W([l, d]));
  }
  return l;
}
function Cr(t) {
  const { xAxisField: e, dataContext: i, chartConfig: a } = t;
  let n = "";
  const r = a.series[0], { minValue: s, maxValue: o } = i;
  if (Number.isFinite(s) && Number.isFinite(o) && r.type === S.HistogramSeries) {
    const c = Ja(e, r.dataTransformationType), l = i.isLastBin ? "<=" : "<";
    n = W([
      `${c}>=${s?.toString()}`,
      `${c}${l}${o?.toString()}`
    ]);
  }
  return n;
}
function Xo(t) {
  const { chartConfig: e } = t, i = Q(e.series);
  let a = "";
  switch (i) {
    case S.ScatterSeries:
      a = Sr(t);
      break;
    case S.HeatSeries:
      a = xr(t);
      break;
    case S.RadarSeries:
    case S.BarSeries:
    case S.LineSeries:
    case S.ComboLineAndBarSeries:
      a = Fr(t);
      break;
    case S.BoxPlotSeries:
      a = vi(t);
      break;
    case S.HistogramSeries:
      a = Cr(t);
      break;
    case S.PieSeries:
      a = br(t);
      break;
  }
  return a;
}
async function Br(t) {
  const { numberOfQueries: e, selectionOIDs: i, chartConfig: a, queryConfig: n, options: r, errorStrings: s, queryObject: o } = t, { setTimeBinningInfoWhenNotProvided: c } = r ?? {}, { series: l } = a, u = Q(l), d = [], { maxOIDsPerSelectionQuery: f } = Ue();
  for (let g = 0; g < e; g += 1) {
    const y = g * f, p = (g + 1) * f - 1, C = i.slice(y === 0 ? 0 : y - 1, p), F = { ...n };
    switch (F.objectIds = C, u) {
      case S.HeatSeries:
        d.push(
          Di({
            completeHeatChartDataset: !1,
            // we do not want the empty bins to be added for the selection
            chartConfig: a,
            queryConfig: F,
            queryObject: o,
            errorStrings: s,
            options: r
          })
        );
        break;
      case S.PieSeries:
      case S.BarSeries:
      case S.LineSeries:
      case S.RadarSeries:
      case S.ComboLineAndBarSeries:
        if (Ne({
          xAxisValueFormatType: ye(a),
          setTimeBinningInfoWhenNotProvided: c,
          seriesConfig: l[0]
        })) {
          const x = a;
          "temporalBinning" in x.series[0] && x.series[0].temporalBinning && (x.series[0].temporalBinning.trimIncompleteTimeInterval = !1, We(o) && (delete x.series[0].temporalBinning.start, delete x.series[0].temporalBinning.end)), d.push(
            wt({
              chartConfig: x,
              queryConfig: F,
              queryObject: o,
              options: r
            })
          );
        } else
          d.push(
            fs({
              queryObject: o,
              chartConfig: a,
              options: r,
              queryConfig: F
            })
          );
        break;
      case S.BoxPlotSeries:
        d.push(
          ms({
            queryObject: o,
            chartConfig: a,
            options: r,
            errorStrings: s,
            queryConfig: F
          })
        );
        break;
      case S.ScatterSeries:
        d.push(
          xi({
            queryObject: o,
            chartConfig: a,
            queryConfig: F,
            options: r,
            errorStrings: s,
            sortData: !1,
            // sort not needed
            calculateTrendLine: !1
            // trendline not needed
          })
        );
        break;
      case S.HistogramSeries:
        d.push(
          Xn({
            queryObject: o,
            queryConfig: F,
            chartConfig: a,
            x: l[0].x
          })
        );
        break;
    }
  }
  return await Promise.all(d);
}
function vr(t) {
  const { dataFetchingResults: e, numberOfQueries: i, series: a } = t, n = Q(a), r = V(a);
  let s = [];
  const o = /* @__PURE__ */ new Map();
  for (let c = 0; c < i; c += 1) {
    const l = e[c];
    if (l !== void 0) {
      let u;
      if (n === S.ScatterSeries)
        u = l.dataItems;
      else if ("data" in l && l.data) {
        const d = l.data;
        "dataItems" in d && (u = d.dataItems), "outliers" in d && d.outliers && s.push(...d.outliers), "meanLines" in d && d.meanLines && s.push(...d.meanLines);
      }
      if (u)
        if (a[0].type === S.HeatSeries)
          i > 0 && u.forEach((d) => {
            o.set(
              `${d[k.xField]}-${d[k.yField]}`,
              d
            );
          });
        else if (a[0].type === S.ScatterSeries) {
          const { x: d, y: f } = a[0];
          s.push(
            ...u.map((m) => ({
              [d]: m[d],
              [f]: m[f]
            }))
          );
        } else l.valid && (r === h.PieFromFields ? s = st({
          dataToConvert: u[0],
          x: ae,
          y: pe
        }) : r === h.BarAndLineFromFields ? s = st({
          dataToConvert: u[0],
          x: a[0].x,
          y: a[0].y
        }) : s.push(...u));
    }
  }
  return o.size > 0 && (s = Array.from(o.values())), s;
}
async function Nr(t) {
  const {
    chartConfig: e,
    queryConfig: i,
    chartData: a,
    currentSelectionOIDs: n,
    dataWasUpdated: r,
    queryObject: s,
    options: o,
    errorStrings: c
  } = t, { series: l } = e, { selectionData: u, viewExtentUpdated: d, returnSelectionOIDs: f, chartLimits: m } = o ?? {}, { selectionItems: g, selectionOIDs: y } = u ?? {};
  let p;
  const C = Q(l), F = C !== S.HistogramSeries && C !== S.HeatSeries && g !== void 0 && g.length > 0 && !(l[0].x in g[0]) && !(ae in g[0]) && !(b.boxPlot.boxPlotCategory in g[0]);
  if (d !== !0 && f !== !1 && y !== void 0 && y.length > 0 && (r === !0 || F || y.length !== n?.length || !Le(y, n))) {
    const B = _t(a);
    if (B !== void 0 && !Ka({ dataContext: B[0], chartConfig: e, chartLimits: m }))
      p = B.filter((N) => {
        const v = N[Y.uniqueIdsName];
        return typeof v == "number" ? y?.includes(v) : !1;
      });
    else if (y?.[0] !== void 0 && i !== void 0) {
      const { maxOIDsPerSelectionQuery: N } = Ue(), v = Math.ceil(y.length / N), A = await Br({
        numberOfQueries: v,
        selectionOIDs: y,
        queryConfig: i,
        queryObject: s,
        options: o,
        errorStrings: c,
        chartConfig: e
      });
      p = vr({
        dataFetchingResults: A,
        numberOfQueries: v,
        series: l
      });
    }
  }
  return p;
}
function* Tr(t) {
  const { filterList: e, queryObject: i, queryConfig: a } = t;
  for (let n = 0; n < e.length; n += 1) {
    const r = { ...a };
    r.where = W([r.where, e[n]]), yield la({
      queryObject: i,
      queryConfig: r,
      uniqueFeature: !0
    });
  }
}
async function Zo(t) {
  const { whereList: e, queryObject: i, queryFilter: a, queryConfig: n } = t;
  let r = [];
  if (e.length > 0) {
    const s = Ue().maxElementsPerSelectionQuery, o = [], c = Math.ceil(e.length / s);
    for (let u = 0; u < c; u += 1) {
      const d = u * s, f = (u + 1) * s, m = e.slice(d === 0 ? 0 : d - 1, f);
      let g = W(m, "OR");
      g = W([a, g]), o.push(g);
    }
    const l = Tr({
      filterList: o,
      queryObject: i,
      queryConfig: n
    });
    r = (await Promise.all(l)).flat(), r = Array.from(new Set(r));
  }
  return r;
}
async function Ar(t) {
  const { queryObject: e, queryConfig: i, chartConfig: a, currentSelectionDataItems: n, options: r, errorStrings: s, abortKey: o } = t, c = V(a.series);
  let l = { valid: !0, data: { dataItems: [] } };
  if (n !== void 0 && n.length > 0) {
    const u = we(a), { x: d } = u, f = "y" in u ? u.y : "";
    let m;
    e !== void 0 && (m = (await Te(e)).find((B) => B.name === d)?.type);
    const g = [], y = n.reduce(
      (x, B) => {
        const N = [];
        if (Y.uniqueIdsName in B)
          g.push(B[Y.uniqueIdsName]);
        else {
          switch (c) {
            case h.BoxPlotMonoFieldAndSplitBy:
            case h.BoxPlotMultiFieldsAndSplitBy:
            case h.BoxPlotMonoFieldAndCategoryAndSplitBy: {
              const w = K(u.query?.where ?? ""), L = `_${I.Average}`;
              Object.keys(B).forEach((D) => {
                if (D.includes(L)) {
                  const M = D.replace(L, "");
                  M.trim() !== "" && N.push(Be(w, M));
                }
              });
              break;
            }
          }
          const v = [f].flat();
          let A = v.length === 1 ? v[0] : "";
          if (c === h.BoxPlotMultiFieldsAndCategory) {
            const w = `_${I.FirstQuartile}`, L = Object.keys(B).find((D) => D.includes(w));
            L !== void 0 && (A = L.replace(w, ""));
          }
          N.length === 0 && N.push(""), N.forEach((w) => {
            const L = vi({
              chartConfig: a,
              xAxisField: d,
              yAxisField: A,
              splitBy: w,
              dataContext: B,
              xAxisFieldType: m
            });
            x.push(L);
          });
        }
        return x;
      },
      []
    ), p = z(e);
    if (p !== void 0 && g.length > 0) {
      const { objectIdField: x } = p;
      y.push(`${x} IN (${g.join(",")})`);
    }
    const C = y.join(" OR "), F = { ...i };
    F.where = W([F.where, C]), l = await Pt({
      queryObject: e,
      chartConfig: a,
      queryConfig: F,
      options: r,
      errorStrings: s,
      abortKey: o
    });
  }
  return l;
}
async function Pr(t) {
  const {
    queryObject: e,
    queryConfig: i,
    chartConfig: a,
    currentSelectionDataItems: n,
    currentSelectionOIDs: r,
    currentChartData: s,
    options: o,
    errorStrings: c,
    abortKey: l
  } = t, { series: u } = a, d = Q(u), f = ye(a);
  let m = { valid: !0 }, g;
  di({ currentSelectionOIDs: r, options: o }) ? g = await Nr({
    chartConfig: a,
    queryConfig: i,
    chartData: s,
    currentSelectionOIDs: r,
    dataWasUpdated: !0,
    queryObject: e,
    options: o,
    errorStrings: c
  }) ?? [] : g = hr({ chartConfig: a, currentSelectionDataItems: n, options: o });
  let y = !1;
  switch (d) {
    case S.HeatSeries:
      m.data = { dataItems: g };
      break;
    case S.PieSeries:
      if (V(a.series) === h.PieFromFields) {
        const { x: p, y: C } = a.series[0], F = Ce(g);
        F.forEach((x) => {
          p in x && (x[ae] = x[p], delete x[p]), C in x && (x[pe] = x[C], delete x[C]);
        }), m.data = { dataItems: F };
      } else
        m.data = { dataItems: g };
      m.count = g.length, y = !0;
      break;
    case S.BoxPlotSeries:
      m = await Ar(t);
      break;
    case S.BarSeries:
    case S.ComboLineAndBarSeries:
    case S.RadarSeries:
    case S.LineSeries:
      if (g.length === 0 || !Ne({
        xAxisValueFormatType: f,
        setTimeBinningInfoWhenNotProvided: o?.setTimeBinningInfoWhenNotProvided,
        seriesConfig: u[0]
      }))
        m.data = { dataItems: g }, m.count = g.length * u.length, y = !0;
      else {
        const p = { ...i };
        if (n !== void 0 && n.length > 0) {
          const F = n.map(
            (B) => Ci(u[0].x, B)
          ), x = W(F, "OR");
          p.where = W([p.where, x]);
        }
        m = await wt({
          queryObject: e,
          queryConfig: p,
          chartConfig: a,
          options: o
        });
      }
      break;
    case S.HistogramSeries: {
      if (g.length === 0)
        m.data = {
          mean: Number.NaN,
          median: Number.NaN,
          stddev: Number.NaN,
          max: Number.NaN,
          min: Number.NaN,
          bins: []
        }, m.count = 0;
      else {
        const { x: p } = u[0], C = g.map((B, N) => {
          const { minValue: v, maxValue: A } = B, w = N === g.length - 1 ? "<=" : "<";
          return `${p} >= ${v} AND ${p} ${w} ${A}`;
        }), F = W(C, "OR"), x = { ...i };
        x.where = W([x.where, F]), m = await Fi({
          queryObject: e,
          chartConfig: a,
          queryConfig: x,
          options: o,
          errorStrings: c,
          abortKey: l
        });
      }
      break;
    }
    case S.ScatterSeries: {
      if (g.length === 0) {
        const { r2: p, trendLinePoints: C } = b.scatterplotSeries;
        m.data = { dataItems: [], r2: p, trendLinePoints: C, count: 0 }, m.count = 0;
      } else {
        const { r2: p, trendLinePoints: C } = bi({
          data: g,
          chartConfig: a
        });
        m.data = { dataItems: g, r2: p, trendLinePoints: C }, m.count = g.length;
      }
      break;
    }
  }
  return y && m.data !== void 0 && Ke({
    arrayToSort: "dataItems" in m.data ? m.data.dataItems : m.data,
    chartConfig: a
  }), m;
}
async function Pt(t) {
  const { queryObject: e, chartConfig: i, queryConfig: a, options: n, errorStrings: r, abortKey: s } = t;
  let o = { valid: !0 };
  const c = He(i), l = await Bt({
    queryObject: e,
    queryConfig: a,
    fetchFullBoxPlotData: !c,
    options: n,
    chartConfig: i,
    abortKey: s
  });
  if (!c)
    o = l;
  else {
    const u = { dataItems: [] };
    u.meanLines = l.data.dataItems;
    const d = hn(i), f = (await Bt({
      queryObject: e,
      queryConfig: a,
      fetchFullBoxPlotData: !0,
      options: n,
      chartConfig: d,
      abortKey: s
    })).data;
    u.dataItems = f.dataItems, u.outliers = f.outliers, o.data = u;
  }
  return o;
}
async function Lr(t) {
  const { queryObject: e, chartConfig: i, queryConfig: a, binnedServerData: n, options: r, errorStrings: s, abortKey: o, fieldList: c } = t, { series: l } = i, { filterBySelection: u } = r ?? {}, d = Q(l);
  let f = { valid: !0 };
  if (u === !0)
    f = await Pr(t);
  else
    switch (d) {
      case S.HeatSeries:
        f = await Di(t);
        break;
      case S.BoxPlotSeries:
        f = await Pt(t);
        break;
      case S.BarSeries:
      case S.ComboLineAndBarSeries:
      case S.PieSeries:
      case S.RadarSeries:
      case S.LineSeries: {
        const m = {
          queryObject: e,
          queryConfig: a,
          chartConfig: i,
          options: r,
          abortKey: o,
          fieldList: c
        };
        Ne({
          xAxisValueFormatType: ye(i),
          setTimeBinningInfoWhenNotProvided: r?.setTimeBinningInfoWhenNotProvided,
          seriesConfig: l[0]
        }) ? (n !== void 0 && (m.binnedServerData = n), f = await wt(m)) : f = await Bt(m);
        break;
      }
      case S.ScatterSeries:
        f.data = await xi({
          queryObject: e,
          queryConfig: a,
          options: r,
          chartConfig: i,
          errorStrings: s,
          abortKey: o
        });
        break;
      case S.HistogramSeries:
        f = await Fi({
          queryObject: e,
          queryConfig: a,
          chartConfig: i,
          options: r,
          abortKey: o,
          errorStrings: s
        });
        break;
      case S.GaugeSeries:
        f = await jn({
          queryObject: e,
          chartConfig: i,
          queryConfig: a,
          options: r,
          abortKey: o
        });
        break;
    }
  return f;
}
async function el(t) {
  const {
    queryObject: e,
    chartConfig: i,
    abortKey: a,
    currentSelectionDataItems: n,
    currentSelectionOIDs: r,
    currentChartData: s,
    binnedServerData: o,
    options: c,
    errorStrings: l,
    fieldList: u
  } = t;
  let d = { valid: !0 };
  const f = ii({
    queryObject: e,
    chartConfig: i,
    runtimeDataFilters: c?.runtimeDataFilters,
    ignoreViewExtent: c?.ignoreViewExtent
  });
  return ca(a), d = await Lr({
    chartConfig: i,
    queryObject: e,
    queryConfig: f,
    currentChartData: s,
    currentSelectionDataItems: n,
    currentSelectionOIDs: r,
    binnedServerData: o,
    options: c,
    abortKey: a,
    errorStrings: l,
    fieldList: u
  }), d.queryConfig = f, d;
}
function Mr(t, e, i) {
  const a = /* @__PURE__ */ new Map();
  for (let r = 0; r < t.length; r += 1)
    a.set(t[r], { [i]: t[r] });
  for (let r = 0; r < e.length; r += 1) {
    const s = e[r][i];
    (typeof s == "string" || typeof s == "number") && a.set(s, e[r]);
  }
  return [...a.values()];
}
async function wr(t) {
  const { seriesData: e, chartConfig: i, queryConfig: a, queryObject: n, categoryOrDateCount: r, behaviorAfterLimit: s, abortKey: o } = t, { series: c } = i;
  let l = e;
  const u = V(c), d = ye(i);
  if (s !== $e.RenderUpToTheLimit && n !== void 0 && r !== void 0 && r > e.length && u !== h.BarAndLineFromFields && u !== h.BarAndLineNoAggregation && u !== h.PieNoAggregation && d === S.CategoryAxisFormat) {
    const { x: f } = c[0], m = {
      ...a,
      returnDistinctValues: !0,
      outFields: [f]
    };
    delete m.outStatistics, delete m.orderByFields, delete m.groupByFieldsForStatistics;
    const y = (await ge({
      queryObject: n,
      queryConfig: m,
      featureCount: r,
      abortKey: o
    })).map((p) => p.attributes[f]).filter((p) => p != null);
    y.length > e.length && (l = Mr(y, e, f));
  }
  return l;
}
function Dr(t, e) {
  const i = t, { series: a } = e;
  if (ye(e) === S.CategoryAxisFormat && a[0].query?.outStatistics?.[0].statisticType === P.Count) {
    const n = a.reduce(
      (r, s) => {
        const o = s.query?.outStatistics?.[0].outStatisticFieldName ?? [s.y].flat()[0];
        return r[o] = 0, r;
      },
      {}
    );
    for (let r = 0; r < t.length; r += 1)
      t[r] = { ...n, ...t[r] };
  }
  return i;
}
const Ni = [
  h.BarAndLineMonoField,
  h.BarAndLineMultiFields,
  h.PieNoAggregation,
  h.PieFromCategory,
  h.BoxPlotMonoFieldAndCategory,
  h.BoxPlotMultiFieldsAndCategory,
  h.BoxPlotMonoFieldAndCategoryAndSplitBy
], Or = 8e3;
function Ti(t, e) {
  let i = t;
  return e === j.Week ? i /= 7 : e === j.Month ? i /= 30 : e === j.Year && (i /= 365), i = Math.ceil(i), i;
}
function ve(t) {
  const { date: e, unit: i, nextOrPrevious: a, size: n } = t;
  if (n !== void 0 && Number.isFinite(n)) {
    const r = a === "next" ? n : -n;
    switch (i) {
      case j.Second:
        return ie.fromMillis(e).plus({ seconds: r }).valueOf();
      case j.Minute:
        return ie.fromMillis(e).plus({ minutes: r }).valueOf();
      case j.Hour:
        return ie.fromMillis(e).plus({ hours: r }).valueOf();
      case j.Week:
      case j.Day:
        return ie.fromMillis(e).plus({ days: r }).valueOf();
      case j.Month:
        return ie.fromMillis(e).plus({ months: r }).valueOf();
      case j.Year:
        return ie.fromMillis(e).plus({ years: r }).valueOf();
    }
  }
  return e;
}
function qr(t) {
  const { binFirstOrLastIndex: e, data: i, x: a, timeIntervalInfo: n } = t, { unit: r, size: s } = n, o = r === j.Week ? (s ?? 1) * 7 : s, c = i[e][a];
  let l = e;
  const u = ve({
    date: c,
    unit: r,
    size: o,
    nextOrPrevious: "next"
  });
  let d = i[l][a];
  for (; l + 1 < i.length && d < u; )
    l += 1, d = i[l]?.[a];
  const f = l + 1 >= i.length;
  let m = l;
  f && i[m] !== void 0 && (m += 1);
  const g = f ? ve({
    date: c,
    unit: r,
    size: o,
    nextOrPrevious: "next"
  }) : i[l][a];
  return {
    binStartDate: c,
    binEndDate: g,
    last: f,
    nextBinFirstOrLastIndex: l,
    sliceStartIndex: e,
    sliceEndIndex: m
  };
}
function Er(t) {
  const { binFirstOrLastIndex: e, data: i, x: a, timeIntervalInfo: n } = t, { unit: r, size: s } = n, o = r === j.Week ? (s ?? 1) * 7 : s, c = i[e][a];
  let l = e;
  const u = ve({
    date: c,
    unit: r,
    size: o,
    nextOrPrevious: "previous"
  });
  let d = i[l][a];
  for (; l - 1 >= 0 && d > u; )
    l -= 1, d = i[l]?.[a];
  const f = l - 1 <= 0;
  let m = e;
  return f && i[m] !== void 0 && (m -= 1), f && (l = 0), {
    binStartDate: f ? ve({
      date: c,
      unit: r,
      size: o,
      nextOrPrevious: "previous"
    }) : i[l][a],
    binEndDate: c,
    nextBinFirstOrLastIndex: l,
    sliceStartIndex: l,
    sliceEndIndex: m,
    last: f
  };
}
function Vr(t) {
  const { binsToRegroup: e, statisticType: i, y: a, nullPolicy: n } = t;
  let r;
  n !== ne.Interpolate && (r = n === ne.Zero ? 0 : null);
  const s = e.filter((o) => Number.isFinite(o[a]));
  if (s.length > 0)
    switch (i) {
      case P.Count:
      case P.Sum:
        r = Hi(s, (o) => o[a]);
        break;
      case P.Minimum:
        r = Wi(s, (o) => o[a]);
        break;
      case P.Maximum:
        r = Qi(s, (o) => o[a]);
        break;
      case P.Average:
        r = ji(s, (o) => o[a]);
        break;
      case P.ContinuousPercentile:
    }
  return r;
}
function Ir(t) {
  const { data: e, seriesConfig: i, timeIntervalInfo: a, dateMinTimestamp: n, dateMaxTimestamp: r } = t;
  let s = [];
  const { unit: o } = a, c = a.size ?? 1, l = i[0], { x: u } = l;
  let d, f;
  if (se(l) && (f = l.temporalBinning?.nullPolicy, d = l.temporalBinning?.timeAggregationType), c > 1 || o === j.Week || o === j.Month || o === j.Year) {
    const { query: m } = i[0], g = re(i), { statisticType: y } = m?.outStatistics?.[0] ?? zt;
    let p = !1, C = d === G.End ? e.length - 1 : 0;
    const F = {
      binFirstOrLastIndex: C,
      data: e,
      x: u,
      timeIntervalInfo: a
    };
    for (; !p; ) {
      let x = {};
      const { binStartDate: B, binEndDate: N, last: v, nextBinFirstOrLastIndex: A, sliceStartIndex: w, sliceEndIndex: L } = d === G.End ? (
        // When grouping from the end we'll start from the last date and move backward to create the bins
        Er(F)
      ) : (
        // When grouping from the start we'll start from the first date and move forward to create the bins
        qr(F)
      );
      if (p = v, x = d === G.End ? x = e[L - 1] : x = e[C], N > r && B < r || B < n && N > n || B >= n && N <= r) {
        const D = e.slice(w, L).filter((q) => !(b.dateBinModel in q));
        g.forEach((q) => {
          x[q] = Vr({ binsToRegroup: D, statisticType: y, y: q, nullPolicy: f });
        });
        const M = D.map((q) => q[xe]).filter((q) => q !== void 0), O = Ha(M);
        O !== void 0 && (x[xe] = O), x[u] = B, x[b.xAxisField] = B, x[b.dateBinningRange] = [B, N], delete x[b.dateBinModel], s.push(x);
      } else v && d !== G.End && s.length > 0 && (s[s.length - 1][b.dateBinningRange][1] = s[s.length - 1][b.dateBinningRange][1] + 1);
      C = A, F.binFirstOrLastIndex = A;
    }
    d === G.End && (s = s.reverse());
  } else c === 1 ? s = e.map((m, g) => {
    const y = m[u];
    let p = e[g + 1]?.[u];
    return p = typeof p == "number" ? p - 1 : ve({
      date: y,
      unit: o,
      size: c,
      nextOrPrevious: "next"
    }), {
      ...m,
      [b.dateBinningRange]: [y, p]
    };
  }) : s = e;
  return s;
}
function Ai(t) {
  const { dateMinTimestamp: e, dateMaxTimestamp: i, timeIntervalInfo: a } = t, { size: n, unit: r } = a;
  let s = 0, o = 0;
  if (n !== void 0 && Number.isFinite(n) && Number.isFinite(e) && Number.isFinite(i)) {
    let c = -1;
    const l = ie.fromMillis(e), u = ie.fromMillis(i);
    switch (r) {
      case j.Second:
        c = u.diff(l, "seconds").get("seconds");
        break;
      case j.Minute:
        c = u.diff(l, "minutes").get("minutes");
        break;
      case j.Hour:
        c = u.diff(l, "hours").get("hours");
        break;
      case j.Day:
      case j.Month:
      case j.Year:
        c = u.diff(l, "days").get("days");
        break;
      case j.Week:
        c = u.diff(l, "weeks").get("weeks");
        break;
    }
    Number.isFinite(c) && (o = Math.ceil(c) + 1, s = n === 1 ? o : Math.ceil(o / n));
  }
  return { numberOfFinalBinsWithinDataRange: s, numberOfSingleBinsWithinDataRange: o };
}
function Pi(t) {
  const e = t[0].temporalBinning?.nullPolicy;
  return t.reduce(
    (a, n) => {
      a[b.dateBinModel] = void 0;
      const r = n.query?.outStatistics?.[0].outStatisticFieldName ?? [n.y].flat()[0];
      return e !== ne.Interpolate && (a[r] = e === ne.Zero ? 0 : null), a;
    },
    {}
  );
}
function $r(t) {
  const {
    dateMaxTimestamp: e,
    numberOfFinalBinsWithinDataRange: i,
    numberOfSingleBinsWithinDataRange: a,
    data: n,
    seriesConfig: r,
    timeIntervalInfo: s
  } = t, { size: o, unit: c } = s, { x: l } = r[0], u = r[0].temporalBinning?.timeAggregationType;
  let d = n[0][l], f = e;
  if (o !== void 0 && Number.isFinite(o) && a / i !== o) {
    let g = Math.ceil(a / i) * i - a;
    c === j.Week && (g *= 7);
    const y = Pi(r);
    if (u === G.End) {
      let p = n[0][l];
      for (let C = 0; C < g; C += 1)
        p = ve({
          date: p,
          unit: c,
          size: 1,
          nextOrPrevious: "previous"
        }), n.push({
          ...y,
          [l]: p,
          [b.xAxisField]: p
        });
      g > 0 && (d = n[n.length - 1][l]);
    } else {
      let p = n[n.length - 1][l];
      for (let C = 0; C < g; C += 1)
        p = ve({
          date: p,
          unit: c,
          size: 1,
          nextOrPrevious: "next"
        }), n.push({
          ...y,
          [l]: p,
          [b.xAxisField]: p
        });
      f = n[n.length - 1][l];
    }
  }
  return { newDateMin: d, newDateMax: f };
}
function Rr(t) {
  const { numberOfSingleBinsWithinDataRange: e, dataLength: i, unit: a } = t;
  return Ti(i, a) >= e;
}
async function kr(t) {
  const { queryObject: e, queryConfig: i, x: a } = t, n = `MIN_${a}`, r = `MAX_${a}`, s = `COUNT_${a}`, o = {
    ...i,
    outStatistics: [
      {
        statisticType: P.Minimum,
        onStatisticField: a,
        outStatisticFieldName: n
      },
      {
        statisticType: P.Maximum,
        onStatisticField: a,
        outStatisticFieldName: r
      },
      {
        statisticType: P.Count,
        onStatisticField: a,
        outStatisticFieldName: s
      }
    ]
  };
  delete o.groupByFieldsForStatistics, delete o.orderByFields;
  const c = await _e({
    queryObject: e,
    queryConfig: o
  });
  let l = c.get(n), u = c.get(r);
  const d = c.get(s);
  return typeof l == "string" && (l = new Date(l).valueOf()), typeof u == "string" && (u = new Date(u).valueOf()), { dateRange: { dateMinTimestamp: l, dateMaxTimestamp: u }, numberOfFeatures: d };
}
function jr(t) {
  const {
    newDateMin: e,
    newDateMax: i,
    seriesConfig: a,
    data: n,
    numberOfSingleBinsWithinDataRange: r,
    initialNumberOfBins: s,
    timeIntervalInfo: o
  } = t, { unit: c } = o, l = n;
  if (!Rr({
    numberOfSingleBinsWithinDataRange: r,
    dataLength: s,
    unit: c
  })) {
    const { x: d } = a[0], f = a[0].temporalBinning?.timeAggregationType, m = Pi(a);
    let y = f === G.End ? i : e, p = f === G.End ? n.length - 1 : 0;
    for (; p < n.length && (f === G.End && y > e || f !== G.End && y < i); )
      y !== n[p][d] ? l.push({
        ...m,
        [d]: y,
        [b.xAxisField]: y
      }) : p = f === G.End ? p - 1 : p + 1, y = ve({
        date: y,
        unit: c === j.Month || c === j.Year ? j.Day : c,
        size: 1,
        nextOrPrevious: f === G.End ? "previous" : "next"
      });
  }
  return l;
}
function Qr(t) {
  const { data: e, seriesConfig: i, dateMinTimestamp: a, dateMaxTimestamp: n } = t, r = e;
  if (i[0].temporalBinning?.trimIncompleteTimeInterval !== !1) {
    const { timeAggregationType: s } = i[0].temporalBinning ?? {}, o = e[0]?.[b.dateBinningRange]?.[0], c = e[e.length - 1]?.[b.dateBinningRange]?.[1];
    if (s === G.End ? o < a : c > n)
      if (s === G.End) {
        let u = o;
        for (; u < a && e.length > 0; )
          e.shift(), e.length > 0 && (u = e[0][b.dateBinningRange]?.[0]);
      } else {
        let u = c;
        for (; u > n && e.length > 0; )
          e.pop(), e.length > 0 && (u = e[e.length - 1][b.dateBinningRange]?.[1]);
      }
  }
  return r;
}
function Wr(t) {
  const { groupByFieldsForStatistics: e, dateField: i, queryStartDate: a, queryEndDate: n, y: r, binIndex: s, lastBin: o } = t;
  let c = e === "" ? Me.groupByCaseBegin : e;
  return c = ue(da, {
    groupByFieldsForStatistics: c,
    dateField: i,
    startDate: `${a}`,
    endDate: `${n}`,
    y: [r].flat()[0],
    binIndex: `${s}`,
    endDateOperand: o ? "<=" : "<"
    // we use <= to catch the last bin's value, < otherwise
  }), c;
}
function* Hr(t) {
  const { queryObject: e, seriesConfig: i, queryConfig: a, completeData: n } = t;
  for (let r = 0; r < i.length; r += 1) {
    const s = i[r], { query: o, x: c, y: l } = s, d = [
      {
        onStatisticField: o?.outStatistics?.[0]?.onStatisticField ?? "",
        outStatisticFieldName: P.ContinuousPercentile,
        statisticType: P.ContinuousPercentile,
        statisticParameters: { value: 0.5 }
      }
    ];
    let f = Me.groupByCaseBegin;
    for (let g = 0; g < n.length; g += 1) {
      const y = n[g], [p, C] = y[b.dateBinningRange], F = Ve(p), x = Ve(C);
      f = Wr({
        groupByFieldsForStatistics: f,
        queryStartDate: F,
        queryEndDate: x,
        dateField: c,
        y: [l].flat()[0],
        binIndex: g,
        lastBin: g === n.length - 1
      });
    }
    f = `${f} ${Me.groupByCaseEnd}`;
    const m = {
      ...a,
      groupByFieldsForStatistics: [f],
      outStatistics: d,
      orderByFields: void 0
    };
    yield ge({
      queryObject: e,
      queryConfig: m,
      noBatch: !0
    });
  }
}
async function zr(t) {
  const { queryObject: e, data: i, seriesConfig: a, queryConfig: n } = t, r = i, { statisticType: s } = a[0].query?.outStatistics?.[0] ?? zt;
  if (s === P.ContinuousPercentile && r.length > 0) {
    const o = Hr({
      queryObject: e,
      completeData: r,
      seriesConfig: a,
      queryConfig: n
    }), c = (await Promise.all(o)).flat();
    if (c.length > 0) {
      const { isInItem: l, expr: u } = lt(c[0].attributes);
      l && c.forEach((d) => {
        const f = d.attributes[`${u}`];
        if (f !== void 0) {
          const [m, g] = f.split("|");
          if (g !== void 0) {
            const y = d.attributes[P.ContinuousPercentile];
            r[g][`${m}`] = y;
          }
        }
      });
    }
  }
  return r;
}
async function Gr(t) {
  const { chartConfig: e, queryResults: i, mapToStatField: a, splitByField: n, x: r, y: s, nullPolicy: o, queryObject: c } = t, l = ua(r), d = (await Te(c)).find((p) => p.name === r)?.type, f = [], m = e.series[0], g = "temporalBinning" in m ? m.temporalBinning?.trimIncompleteTimeInterval : !1, y = "temporalBinning" in m ? m.temporalBinning?.timeAggregationType : !1;
  return i.forEach((p, C) => {
    if (!(g && (C === 0 && y === G.End || C === i.length - 1 && y === G.Start))) {
      const { attributes: x, stackedAttributes: B } = p;
      let N = x[l.lowerBoundaryAlias], v = x[l.upperBoundaryAlias];
      const A = N, w = v, L = (M, O) => {
        let q = M;
        if (O === Ye.DateOnly && (typeof M == "string" && M.length === 10 || typeof M == "number"))
          if (typeof M == "string") {
            const T = M.split("-");
            T.length === 3 && (q = ie.local(Number(T[0]), Number(T[1]), Number(T[2])).valueOf());
          } else
            q = new Date(M), q = new Date(q.valueOf() + q.getTimezoneOffset() * 6e4), q = ie.local(q.getFullYear(), q.getMonth() + 1, q.getDate()).valueOf();
        else typeof M == "string" && ["+", "-"].forEach((T) => {
          T && M.lastIndexOf(T) === M.length - 6 && (q = new Date(M.slice(0, M.lastIndexOf(T))).valueOf());
        });
        return q;
      };
      N = L(N, d), v = L(v, d);
      const D = (M, O) => {
        if (O)
          switch (!0) {
            case (o === ne.Zero && (M[O] === void 0 || M[O] === null)):
              M[O] = 0;
              break;
            case o === ne.Null:
              break;
            case (o === ne.Interpolate && (M[O] === void 0 || M[O] === null)):
              delete M[O];
              break;
          }
      };
      if (typeof N == "number" && typeof v == "number") {
        const M = { ...x };
        M[b.originalServerBinningRange] = [A, w], M[r] = N, M[b.xAxisField] = N, M[b.dateBinningRange] = [N, v], delete M[l.lowerBoundaryAlias], delete M[l.upperBoundaryAlias], B && n && !Z(n) && a ? B.forEach((T) => {
          const E = T[n];
          if (E === null || typeof E == "string" || typeof E == "number") {
            const H = a?.get(E);
            H !== void 0 && (M[H] = T[Y.outStatistics?.outStatisticFieldName ?? ""], D(M, H));
          }
        }) : D(M, s);
        const { featureExtent: O, featureExtentKey: q } = Li({
          feature: p,
          splitByField: n
        });
        O && (M[q] = O), f.push(M);
      }
    }
  }), f;
}
async function Ur(t) {
  const { queryObject: e, queryResults: i, x: a, queryConfig: n, seriesConfig: r, dateRange: s, timeIntervalInfo: o } = t;
  let c = i;
  const { dateMinTimestamp: l, dateMaxTimestamp: u } = s;
  if (l && u) {
    const d = i.length;
    if (Ge({
      arrayToSort: c,
      sortingField: a
    }), d > 1) {
      const { numberOfFinalBinsWithinDataRange: f, numberOfSingleBinsWithinDataRange: m } = Ai({
        dateMinTimestamp: l,
        dateMaxTimestamp: u,
        timeIntervalInfo: o
      }), { newDateMin: g, newDateMax: y } = $r({
        dateMaxTimestamp: u,
        data: c,
        numberOfFinalBinsWithinDataRange: f,
        numberOfSingleBinsWithinDataRange: m,
        seriesConfig: r,
        timeIntervalInfo: o
      });
      c = jr({
        newDateMin: g,
        newDateMax: y,
        seriesConfig: r,
        data: c,
        initialNumberOfBins: d,
        numberOfSingleBinsWithinDataRange: m,
        timeIntervalInfo: o
      }), Ge({
        arrayToSort: c,
        sortingField: a
      }), c = Ir({
        data: c,
        seriesConfig: r,
        dateMinTimestamp: l,
        dateMaxTimestamp: u,
        timeIntervalInfo: o
      }), c = Qr({
        data: c,
        seriesConfig: r,
        dateMinTimestamp: l,
        dateMaxTimestamp: u
      }), c = await zr({ queryObject: e, data: c, seriesConfig: r, queryConfig: n });
    }
  }
  return c;
}
function _r(t) {
  return Math.floor(Math.min(Math.max(8, Math.sqrt(t ?? 8)), 128) + 0.5);
}
function Yr(t) {
  const { dateRange: e, numberOfFeatures: i } = t;
  let a, n, { dateMinTimestamp: r, dateMaxTimestamp: s } = e;
  if (r && s) {
    typeof r == "string" && (r = new Date(r).valueOf()), typeof s == "string" && (s = new Date(s).valueOf());
    const o = _r(i), c = (s - r) / o, l = It.findIndex((C) => C.threshold > c), u = It[l], { unitMs: d, preferredIntervalSize: f } = u;
    ({ unit: a } = u);
    const m = c / d, g = f.findIndex(
      (C) => C >= m
    ), y = f[g], p = g === 0 ? f[0] : f[g - 1];
    n = y - m < m - p ? y : p;
  }
  return { size: n, unit: a };
}
function Kr(t) {
  const { series: e, isTimeBinningSeries: i, setTimeBinningInfoWhenNotProvided: a } = t;
  let n = !1;
  if (se(e) && i) {
    const { unit: r, size: s } = e.temporalBinning ?? {};
    n = !St(r, s) && a === !0;
  }
  return n;
}
function Jr(t) {
  const e = [];
  for (let i = 1; i <= 6; i += 1) {
    const a = t[`EXPR_${i}`] ?? t[`Expr${i}`] ?? t[`expr${i}`] ?? t[`EXPR${i}`];
    a !== null && e.push(a);
  }
  return ie.local(
    Number(e[0] ?? 1969),
    Number(e[1] ?? 1),
    Number(e[2] ?? 1),
    Number(e[3] ?? 0),
    Number(e[4] ?? 0),
    Number(e[5] ?? 0)
  ).valueOf();
}
function Li(t) {
  const { feature: e, splitByField: i, chartSubType: a } = t;
  let n;
  e.aggregateGeometries && "Extent" in e.aggregateGeometries ? n = e.aggregateGeometries.Extent : { extent: n } = e.aggregateGeometries ?? e.geometry ?? {};
  const r = n?.toJSON();
  let s = xe;
  return r !== void 0 && i !== void 0 && a !== void 0 && a === h.BarAndLineSplitBy && (s = e.attributes[i] !== void 0 ? `${xe}_${e.attributes[i]}` : xe), { featureExtent: r, featureExtentKey: s };
}
function Xr(t) {
  const { input: e, x: i, splitByField: a } = t;
  return e.reduce((r, s) => (a !== void 0 && a !== i && !(b.technicalFieldSplitByField in s) && delete s[a], Object.assign(r, s)), {});
}
function Lt(t) {
  const { data: e, x: i, splitByField: a } = t;
  let n = e;
  return e !== void 0 && e.length > 0 && (n = [...zi(
    e,
    (s) => Xr({ input: s, x: i, splitByField: a }),
    (s) => s[i]
    // the field used to regroup the stats (ex: 'Year' category)
  ).values()]), n;
}
function Zr(t, e) {
  const i = t, a = Q(e);
  if (a !== S.PieSeries && a !== S.BoxPlotSeries) {
    const n = re(e), r = e[0].y;
    t.forEach((s) => {
      let o = 0;
      if (n.forEach((c) => {
        const l = s[c];
        Number.isFinite(l) && (o += l);
      }), s[b.technicalSortingFieldBySum] = o, Number.isFinite(o) && o > 0) {
        const c = s[r];
        if (Number.isFinite(c)) {
          const l = c / o;
          s[b.technicalSortingFieldByPercent] = l;
        }
      }
    });
  }
  return i;
}
function es(t, e) {
  const i = e, a = re(t), n = a.length === 1;
  return a.forEach((r) => {
    const s = je(n ? void 0 : r), o = i[s[I.FirstQuartile]], c = i[s[I.ThirdQuartile]];
    Number.isFinite(o) && Number.isFinite(c) && c >= o && (i[s[I.IQR]] = c - o);
  }), i;
}
function ts(t, e) {
  const i = e.series[0], a = t;
  if (i.type === S.HeatSeries) {
    const { x: n, y: r } = i;
    a[k.xField] = a[n]?.toString(), delete a[n], a[k.yField] = a[r]?.toString(), delete a[r];
    const s = i.query?.outStatistics?.[0]?.outStatisticFieldName;
    s && (a[k.valueField] = a[s], delete a[s]);
  }
  return a;
}
function Mt(t, e) {
  [e].flat().forEach((i) => {
    i && (t[i] === void 0 && (t[i] = t[i.toUpperCase()] !== void 0 ? t[i.toUpperCase()] : t[i.toLowerCase()]), t[i] !== void 0 ? (i !== i.toUpperCase() && delete t[i.toUpperCase()], i !== i.toLowerCase() && delete t[i.toLowerCase()]) : delete t[i]);
  });
}
function is(t, e) {
  const i = Array.from(
    new Set(
      e.flatMap((a) => a.query?.outStatistics?.map((n) => n.outStatisticFieldName))
    )
  );
  i.push(Y.outStatistics.outStatisticFieldName), Mt(t, i);
}
function as(t, e) {
  let i = { ...t };
  return t !== void 0 && e[0] !== void 0 && (i = Object.keys(t).reduce((a, n) => {
    const r = e.find(
      (s) => s.outStatisticFieldName?.toLowerCase() === n.toLowerCase()
    )?.onStatisticField;
    return r !== void 0 && t[n] !== void 0 && r !== n ? a[r] = t[n] : a[n] = t[n], a;
  }, {})), i;
}
function ns(t) {
  const { dataItem: e, splitByField: i, y: a } = t;
  if (e !== void 0 && !Z(i) && !Z(a)) {
    const n = e[i], r = `${a}_${n?.toString()}`;
    e[r] = e[a], delete e[a];
  }
}
function rs(t, e) {
  Object.keys(t).forEach((a) => {
    if (a.startsWith(`${e}_`)) {
      const n = a.slice(e.length + 1);
      t[n] = t[a], delete t[a];
    }
  });
}
function ss(t, e) {
  let i = 1;
  switch (t) {
    case h.BarAndLineFromFields:
    case h.PieFromFields:
      i = e.series[0].query?.outStatistics?.length ?? 1;
      break;
    case h.BoxPlotMultiFields:
    case h.BoxPlotMultiFieldsAndSplitBy:
      i = e.series[0].y.length;
      break;
    case h.BarAndLineNoAggregation:
    case h.BoxPlotMonoField:
    case h.BoxPlotMonoFieldAndCategory:
    case h.BoxPlotMultiFieldsAndCategory:
    case h.BoxPlotMonoFieldAndSplitBy:
    case h.BoxPlotMonoFieldAndCategoryAndSplitBy:
    case h.PieFromCategory:
    case h.BarAndLineSplitByNoAggregation:
    case h.PieNoAggregation:
    case h.BarAndLineSplitBy:
    case h.BarAndLineMonoField:
    case h.BarAndLineMultiFields:
    case h.NonSpecific:
  }
  return i;
}
function os(t) {
  const { attributes: e, showMean: i, chartSubType: a } = t;
  i && (a === h.BoxPlotMonoFieldAndSplitBy || a === h.BoxPlotMultiFieldsAndSplitBy || a === h.BoxPlotMonoFieldAndCategoryAndSplitBy) && (e[b.boxPlot.boxPlotMeanLineMarkerId] = !0);
}
function ls(t) {
  const { queryResponse: e, chartConfig: i, maxCategoryCount: a } = t, n = V(i.series);
  return a && Number.isFinite(a) && a < e.length && Ni.includes(n) ? e.slice(0, a) : e;
}
function cs(t) {
  const { attributes: e, uniqueCategoryList: i, maxCategoryCount: a, x: n, chartSubType: r } = t;
  let s = !1;
  if (n && a && Number.isFinite(a) && !Ni.includes(r))
    if ((r === h.BarAndLineFromFields || r === h.PieFromFields) && Object.keys(e).length > a)
      Object.keys(e).filter((o) => o !== P.EnvelopeAggregate).forEach((o, c) => {
        c >= a && delete e[o];
      });
    else {
      const o = e[n];
      o !== void 0 && (i.size === a && !i.has(o) ? s = !0 : i.add(o));
    }
  return s;
}
function Mi(t) {
  const {
    queryResponse: e,
    chartConfig: i,
    mapToStatField: a,
    splitByField: n,
    fieldOID: r,
    isDateField: s,
    isTimeBinningSeries: o,
    subtypeInfo: c,
    resultLimit: l,
    showMean: u,
    chartLimits: d,
    fieldList: f
  } = t, { series: m } = i, g = V(m), y = Q(m), { x: p } = m[0], C = "y" in m[0] ? m[0].y : void 0, F = m[0].query?.outStatistics ?? [], { originalCategoryValue: x, originalDateValue: B, typeOrDomainFieldName: N, typeOrDomainIdValue: v } = b, A = [];
  let w = 0;
  const L = /* @__PURE__ */ new Set(), { maxCategoryCount: D } = Re(d), M = ls({ queryResponse: e, chartConfig: i, maxCategoryCount: D });
  for (let O = 0; M[O] && O < M.length && !(l !== void 0 && w >= l); O += 1) {
    w += ss(g, i);
    const q = M[O];
    let T = { ...q.attributes };
    if (cs({ attributes: T, uniqueCategoryList: L, maxCategoryCount: D, x: p, chartSubType: g }))
      continue;
    is(T, m), g === h.PieFromFields || g === h.BarAndLineFromFields ? T = as(T, F) : typeof C == "string" && g === h.BarAndLineSplitByNoAggregation ? ns({ dataItem: T, splitByField: n, y: C }) : C && (g === h.BoxPlotMonoField || g === h.BoxPlotMonoFieldAndCategory || g === h.BoxPlotMonoFieldAndSplitBy || g === h.BoxPlotMonoFieldAndCategoryAndSplitBy) && rs(
      T,
      typeof C == "string" ? C : C[0]
    ), os({ attributes: T, showMean: u, chartSubType: g });
    let E = T[p];
    E === null && m[0]?.query?.fetchNullValues === !0 && g !== h.PieFromFields && (T[x] = null, E = b.nullValue), s && typeof E == "string" ? E = new Date(E).valueOf() : o && (E = Jr(T));
    const { outStatisticFieldName: H } = Y.outStatistics ?? {}, { featureExtent: Fe, featureExtentKey: $ } = Li({ feature: q, splitByField: n, chartSubType: g });
    if (Fe && (T[$] = Fe), g === h.BarAndLineSplitBy && H !== void 0) {
      const ce = T[n], ee = a?.get(ce);
      ee !== void 0 && (ce === n && (T[b.technicalFieldSplitByField] = T[ee]), T[ee] = T[H]), delete T[H];
    } else (g === h.PieNoAggregation || g === h.BarAndLineNoAggregation || g === h.BarAndLineSplitByNoAggregation) && (s ? T[B] = E : E !== b.nullValue && (T[x] = E), Ra({ isXAxis: !0, chartType: y, valueFormat: i.axes?.[0]?.valueFormat }) && (T[b.xAxisField] = `${E}-${O}`), T[Y.uniqueIdsName] = T[r]);
    const X = ha({
      subtypeInfo: c,
      fieldList: f,
      fieldName: p,
      fieldValueToMatch: E
    });
    X !== void 0 && X !== E && g !== h.PieFromFields && (T[x] = X, T[N] = p, T[v] = E), y === S.BoxPlotSeries && (T = es(m, T)), y === S.PieSeries && typeof E == "number" && (T[x] === void 0 && (T[x] = T[p]), E = `${E}`), E !== void 0 && (T[x] === void 0 && (T[x] = T[p]), T[p] = X ?? E, T[p] === null && (T[p] = b.nullValue), T[b.xAxisField] === void 0 && (T[b.xAxisField] = T[v] ?? T[p])), T = ts(T, i), A.push(T);
  }
  return A;
}
async function ut(t) {
  const {
    queryObject: e,
    uniqueQuery: i,
    chartConfig: a,
    mapToStatField: n,
    abortKey: r,
    elementCount: s,
    isTimeBinningSeries: o,
    showMean: c,
    chartLimits: l,
    usePopupTemplateFieldsInfo: u
  } = t, { series: d } = a, f = V(d);
  let m = [];
  const g = f === h.BarAndLineSplitBy || f === h.BarAndLineSplitByNoAggregation ? K(d[0].query?.where) : "", y = await ge({
    queryObject: e,
    queryConfig: i,
    featureCount: s,
    abortKey: r
  }), p = await Te(e, u), F = z(e).objectIdField, x = pa(p), { x: B } = d[0], N = x.includes(B), v = ni(e);
  return m = Mi({
    queryResponse: y,
    chartConfig: a,
    mapToStatField: n,
    splitByField: g,
    fieldOID: F,
    isDateField: N,
    isTimeBinningSeries: o,
    subtypeInfo: v,
    fieldList: p,
    resultLimit: i.num,
    showMean: c,
    chartLimits: l
  }), f !== h.BarAndLineSplitByNoAggregation && f !== h.BarAndLineFromFields && (g !== "" && (m = Lt({ data: m, x: B, splitByField: g })), m = Zr(
    m,
    d
  )), m;
}
async function wi(t) {
  const { chartConfig: e, queryObject: i, queryConfig: a, numberMaxOfFeaturesToFetch: n, behaviorAfterLimit: r, isGaugeByFeature: s } = t, { series: o } = e, c = V(o), { x: l } = o[0], u = o.length;
  let d, f;
  if (c === h.BoxPlotMonoField || c === h.BoxPlotMonoFieldAndSplitBy ? (f = u, d = f) : c === h.BoxPlotMultiFields || c === h.BoxPlotMultiFieldsAndSplitBy ? (f = e.series[0].y.length, d = f) : c === h.PieFromFields || c === h.BarAndLineFromFields ? (f = o[0].query?.outStatistics?.filter(
    (m) => m.statisticType !== P.EnvelopeAggregate
  ).length ?? 0, d = f) : d = await ya({ queryObject: i, x: l, chartSubType: c, queryConfig: a, isGaugeByFeature: s }), d !== void 0) {
    const m = c === h.BoxPlotMonoField || c === h.BoxPlotMonoFieldAndCategory || c === h.BoxPlotMonoFieldAndSplitBy;
    f = Ft(c) && !m ? d * u : d;
  }
  return r === $e.RenderUpToTheLimit && f !== void 0 && n !== void 0 && n < f && (f = n, d = Math.ceil(f / u)), { categoryOrDateCount: d, elementCount: f };
}
function Ke(t) {
  const { arrayToSort: e, chartConfig: i, fieldList: a, isTimeBinningSeries: n } = t;
  if (n !== !0) {
    const { series: r } = i, s = V(r), o = Q(r), c = ye(i), l = xt(i);
    if (o === S.HeatSeries)
      l !== void 0 && Ge({
        arrayToSort: e,
        orderBy: l.orderBy,
        sortingField: l.sortingField
      });
    else if (l !== void 0 && e !== void 0 && e.length > 1) {
      const { orderBy: u } = l;
      let { sortingField: d } = l;
      const f = i.orderOptions?.data?.orderType === be.Category, m = l.preferLabel !== !1, g = s === h.BarAndLineFromFields || s === h.PieFromFields || s === h.BoxPlotMultiFields || s === h.BoxPlotMultiFieldsAndSplitBy, y = g || o === S.PieSeries, p = s === h.PieNoAggregation || s === h.BarAndLineNoAggregation || s === h.BarAndLineSplitByNoAggregation, C = g ? !1 : e?.length > 0 && e.some((F) => Object.hasOwn(F, b.typeOrDomainIdValue));
      if (f && (!m || o === S.LineSeries && c === S.NumberAxisFormat) && (C ? d = b.typeOrDomainIdValue : y && (d = b.originalCategoryValue)), Array.isArray(u))
        Ga({
          arrayToSort: e,
          orderBy: u,
          sortingField: d,
          fieldList: a,
          isByFieldsChart: g,
          preferLabel: m
        });
      else {
        const F = c === S.DateAxisFormat && f;
        Ge({
          arrayToSort: e,
          orderBy: u,
          sortingField: d,
          forceAscendingOrder: F,
          isNonAggregated: p,
          sortByCategory: f,
          preferLabel: m,
          isPieOrByFieldsChart: y
        });
      }
    }
  }
}
async function Bt(t) {
  const { chartConfig: e, queryConfig: i, fetchFullBoxPlotData: a, options: n, queryObject: r, abortKey: s, fieldList: o } = t, c = "showMean" in e && typeof e.showMean == "boolean" ? e.showMean : !1, { chartLimits: l, usePopupTemplateFieldsInfo: u } = n ?? {}, d = n?.replaceNoValueCategoryWithZero ?? b.options.replaceNoValueCategoryWithZero, { behaviorAfterLimit: f } = l ?? {}, m = { valid: !0 };
  let g, y = !1;
  const p = e.series, C = p[0], F = V(e.series);
  if (C !== void 0 && r !== void 0) {
    const x = Q(p), { uniqueQuery: B, mapToStatField: N } = await ct({
      chartConfig: e,
      queryObject: r,
      queryConfig: i,
      fetchFullBoxPlotData: a,
      options: n
    });
    let { categoryOrDateCount: v, elementCount: A } = await wi({
      chartConfig: e,
      queryObject: r,
      queryConfig: i,
      behaviorAfterLimit: f,
      numberMaxOfFeaturesToFetch: B.num
    });
    const w = !Number.isFinite(A);
    let L = w || he({
      count: A ?? 0,
      seriesCount: p.length,
      chartType: x,
      chartLimits: l
    });
    if (L && (g = await ut({
      queryObject: r,
      uniqueQuery: B,
      chartConfig: e,
      mapToStatField: N,
      elementCount: A,
      isTimeBinningSeries: !1,
      showMean: c,
      chartLimits: l,
      usePopupTemplateFieldsInfo: u,
      abortKey: s
    }), x === S.BoxPlotSeries && (m.data = await wn({
      data: g,
      queryObject: r,
      fetchFullBoxPlotData: a,
      uniqueQuery: B,
      chartConfig: e,
      elementCount: A,
      chartLimits: l,
      abortKey: s
    }), l?.maxBoxPlotOutlierLimit !== void 0 && (L = (m.data.outliers ?? []).length <= l.maxBoxPlotOutlierLimit, y = !L)), w && (v = g.length, A = Ft(F) ? v * p.length : v, L = he({
      count: A,
      seriesCount: p.length,
      chartType: x,
      chartLimits: l
    })), L)) {
      if (x === S.PieSeries) {
        F === h.PieFromFields && (g = st({
          dataToConvert: g[0],
          x: ae,
          y: pe,
          fieldList: o
        }));
        let D = "";
        F === h.PieFromFields ? D = pe : "y" in C && typeof C.y == "string" && (D = C.y), cn(g, D) ? m.data = { dataItems: g } : Sn(m, R.PieChartMixOfNegativePositiveSlices);
      } else if ((x === S.RadarSeries || x === S.BarSeries || x === S.LineSeries || x === S.ComboLineAndBarSeries) && (F === h.BarAndLineFromFields && "y" in C && typeof C.y == "string" ? g = st({
        dataToConvert: g[0],
        x: C.x,
        y: C.y,
        fieldList: o
      }) : g = await wr({
        queryObject: r,
        seriesData: g,
        chartConfig: e,
        queryConfig: i,
        categoryOrDateCount: v,
        behaviorAfterLimit: f,
        abortKey: s
      }), A = Ft(F) ? g.length * p.length : g.length, L = he({
        count: A,
        seriesCount: p.length,
        chartType: x,
        chartLimits: l
      }), L)) {
        d && (g = Dr(g, e)), Ke({ arrayToSort: g, chartConfig: e, fieldList: o });
        let D = {};
        if (se(C)) {
          const { size: M, unit: O } = C.temporalBinning ?? {};
          M !== void 0 && O !== void 0 && (D = { size: M, unit: O });
        }
        m.data = { dataItems: g, timeIntervalInfo: D };
      }
    }
    L || ot({ dataInfo: m, chartType: x, subError: { outlierLimit: y } }), m.count = A;
  }
  return m;
}
function us(t) {
  let e;
  const { start: i, end: a } = ti({ field: "", unit: t, addIntervalStatement: !1 });
  return a && (e = Array.from({ length: a + (i === 0 ? 1 : 0) }, (n, r) => (r + (i ?? 1)).toString())), e;
}
async function Di(t) {
  const {
    chartConfig: e,
    queryConfig: i,
    queryObject: a,
    completeHeatChartDataset: n = !0,
    errorStrings: r,
    options: s,
    abortKey: o
  } = t, c = { valid: !0 };
  let l;
  const u = e.series[0], { nullPolicy: d } = "nullPolicy" in e ? e : {};
  if (u.type === S.HeatSeries) {
    const { x: f, y: m, query: g, yTemporalBinning: y } = u, p = g?.outStatistics?.[0]?.outStatisticFieldName ?? "";
    if (mi(e)) {
      const C = await ma({
        chartConfig: e,
        queryObject: a,
        queryConfig: i,
        returnFeaturesExtent: s?.returnFeaturesExtent,
        errorStrings: r,
        abortKey: o
      });
      if (!he({
        count: C?.length ?? 0,
        seriesCount: 1,
        chartType: S.HeatSeries,
        chartLimits: s?.chartLimits
      }))
        ot({ dataInfo: c, chartType: S.HeatSeries });
      else if (typeof C?.[0] == "object") {
        const F = await Te(a, s?.usePopupTemplateFieldsInfo), x = ni(a);
        l = Mi({
          queryResponse: C,
          chartConfig: e,
          splitByField: "",
          fieldOID: z(a).objectIdField,
          isDateField: !1,
          isTimeBinningSeries: !1,
          chartLimits: s?.chartLimits,
          resultLimit: i.num,
          subtypeInfo: x,
          fieldList: F
        });
        const B = await yt({ queryObject: a, queryConfig: i, category: f, abortKey: o }), N = await yt({ queryObject: a, queryConfig: i, category: m, abortKey: o });
        if (l.length !== B?.length * N?.length) {
          const v = B.flatMap(
            (A) => N.map((w) => ({
              [k.xField]: A,
              [k.yField]: w,
              [k.valueField]: d === ne.Zero ? 0 : null
            }))
          );
          l = [
            ...l,
            ...v.filter(
              (A) => !l.some(
                (w) => `${w[k.xField]}${w[k.yField]}` == `${A[k.xField]}${A[k.yField]}`
              )
            )
          ];
        }
      }
    } else {
      const C = await ga({
        chartConfig: e,
        queryObject: a,
        queryConfig: i,
        errorStrings: r
      }), F = y ? us(y.unit) : await yt({ queryObject: a, queryConfig: i, category: m, abortKey: o });
      let x = 0;
      l = C?.features.flatMap((B) => {
        const N = [], { attributes: v, stackedAttributes: A } = B, w = [];
        return A?.forEach((L) => {
          const D = `${L[m]}`;
          w.push(D), N.push({
            [k.xField]: `${v.lowerBoundary}`,
            [k.yField]: D,
            [k.valueField]: L[p]
          });
        }), n && F && w.length !== F?.length && F.filter((D) => !w.includes(D.toString())).forEach((D) => {
          N.push({
            [k.xField]: `${v.lowerBoundary}`,
            [k.yField]: D,
            [k.valueField]: d === ne.Zero ? 0 : null
          });
        }), x += N.length, N;
      }), he({
        count: x,
        seriesCount: 1,
        chartType: S.HeatSeries,
        chartLimits: s?.chartLimits
      }) ? l && Ke({ arrayToSort: l, chartConfig: e }) : ot({ dataInfo: c, chartType: S.HeatSeries });
    }
  }
  return l && (c.data = { dataItems: l }), c;
}
function ds(t) {
  const { chartConfig: e, options: i, data: a } = t, n = e.series;
  let r = a;
  const s = fi(e, i?.chartLimits);
  if (s !== void 0) {
    const o = re(n);
    if (o.length === 1)
      r = a.filter((c) => Number.isFinite(c[o[0]])).slice(0, s);
    else if (a.length * o.length > s) {
      const c = [];
      let l = 0, u = 0;
      for (; l <= s && u < a.length; ) {
        const d = a[u];
        if (c.push(d), l += o.filter((f) => Number.isFinite(d[f])).length, l > s) {
          let f = l - s, m = o.length - 1;
          for (; f !== 0 && m >= 0; ) {
            const g = o[m];
            Number.isFinite(d[g]) && (delete d[g], f -= 1), m -= 1;
          }
        }
        u += 1;
      }
      r = c;
    }
  }
  return r;
}
async function wt(t) {
  const { chartConfig: e, queryConfig: i, queryObject: a, abortKey: n, binnedServerData: r, options: s } = t, { chartLimits: o, usePopupTemplateFieldsInfo: c } = s ?? {}, { behaviorAfterLimit: l } = o ?? {}, u = e.series, d = u[0], { x: f } = d, m = K(d.query?.where), g = { valid: !0 };
  let y;
  if (se(d)) {
    const { temporalBinning: p } = d;
    if (a && p) {
      const { unit: C, size: F } = p;
      let x = 1, B = { unit: C, size: F }, N = !1;
      const v = Kr({
        series: d,
        isTimeBinningSeries: !0,
        setTimeBinningInfoWhenNotProvided: s?.setTimeBinningInfoWhenNotProvided
      });
      let A = r?.timeBinningStats;
      !A && (!We(a) || v) && (A = await kr({ queryObject: a, queryConfig: i, x: f })), v && A && A.numberOfFeatures > 0 && A.dateRange.dateMaxTimestamp !== void 0 && A.dateRange.dateMinTimestamp !== void 0 && (B = Yr(A), (await Te(a)).find((q) => q.name === f)?.type === Ye.DateOnly && B.unit !== void 0 && [
        j.Hour,
        j.Minute,
        j.Second
      ].includes(B.unit) && (B.unit = j.Day, B.size = 1), p.size = B.size, p.unit = B.unit);
      const { uniqueQuery: w, mapToStatField: L } = await ct({
        chartConfig: e,
        queryConfig: i,
        queryObject: a,
        timeIntervalInfo: B,
        options: s
      });
      let D = he({
        count: x ?? 0,
        seriesCount: u.length,
        chartType: S.LineSeries,
        chartLimits: o
      });
      if (D) {
        if (We(a)) {
          const M = await ai({
            queryObject: a,
            dateField: f,
            splitByField: m,
            queryConfig: w,
            temporalBinning: p
          }), O = "y" in d && typeof d.y == "string" ? d.y : void 0;
          if (y = await Gr({
            chartConfig: e,
            queryResults: M,
            mapToStatField: L,
            splitByField: m,
            x: f,
            y: O,
            nullPolicy: p.nullPolicy,
            queryObject: a
          }), !he({
            count: y.length,
            seriesCount: u.length,
            chartType: S.LineSeries,
            chartLimits: o
          })) {
            const q = re(u), T = y.filter(
              (E) => q.some((H) => H in E && Number.isFinite(E[H]))
            ).length;
            he({
              count: T,
              seriesCount: u.length,
              chartType: S.LineSeries,
              chartLimits: o
            }) || (D = !1);
          }
        } else if (A?.dateRange.dateMinTimestamp && A.dateRange.dateMaxTimestamp) {
          const { numberOfFinalBinsWithinDataRange: M } = Ai({
            dateMinTimestamp: A.dateRange.dateMinTimestamp,
            dateMaxTimestamp: A.dateRange.dateMaxTimestamp,
            timeIntervalInfo: B
          });
          x = M * u.length, x = Ti(x, B.unit), y = r?.data ?? await ut({
            queryObject: a,
            uniqueQuery: w,
            chartConfig: e,
            mapToStatField: L,
            elementCount: x,
            chartLimits: o,
            isTimeBinningSeries: !0,
            usePopupTemplateFieldsInfo: c,
            abortKey: n
          }), g.binnedServerData = { data: Ce(y), timeBinningStats: A }, y = await Ur({
            queryObject: a,
            queryConfig: i,
            queryResults: y,
            x: f,
            seriesConfig: u,
            dateRange: A.dateRange,
            timeIntervalInfo: B
          });
        }
        fa(a) && y && y?.length === Or && (N = !0), l === $e.RenderUpToTheLimit && y && (y = ds({ chartConfig: e, options: s, data: y }));
      }
      D || (g.valid = !1, g.invalidType = R.LineChartExceedsLimit), y && y.length > 0 && (y[y.length - 1][b.lastTemporalBin] = !0), g.data = { dataItems: y, timeIntervalInfo: B, serverLimitReached: N }, g.count = x;
    }
  }
  return g;
}
async function fs(t) {
  const { chartConfig: e, queryConfig: i, queryObject: a, abortKey: n, options: r } = t, s = He(e), { setTimeBinningInfoWhenNotProvided: o, chartLimits: c, usePopupTemplateFieldsInfo: l } = r ?? {}, u = { valid: !0 };
  if (a !== void 0) {
    const d = e.series, f = Ne({
      seriesConfig: d[0],
      xAxisValueFormatType: ye(e),
      setTimeBinningInfoWhenNotProvided: o
    }), { uniqueQuery: m, mapToStatField: g } = await ct({
      chartConfig: e,
      queryObject: a,
      queryConfig: i,
      fetchFullBoxPlotData: !s,
      options: r
    });
    let y = await ut({
      queryObject: a,
      uniqueQuery: m,
      elementCount: 1,
      // this will skip the query counting the number of features, not needed for selection
      chartConfig: e,
      mapToStatField: g,
      isTimeBinningSeries: f,
      showMean: s,
      chartLimits: c,
      usePopupTemplateFieldsInfo: l,
      abortKey: n
    });
    Q(e.series) === S.BoxPlotSeries && (y = yi({ chartConfig: e, data: y, calculateZScore: !1 })), u.data = { dataItems: y };
  }
  return u;
}
async function ms(t) {
  const { chartConfig: e, queryConfig: i, queryObject: a, abortKey: n, options: r, errorStrings: s } = t, o = "showMean" in e ? e.showMean : !1, c = await Pt({
    queryObject: a,
    chartConfig: e,
    queryConfig: i,
    options: r,
    errorStrings: s,
    abortKey: n
  });
  return o && c.data && "dataItems" in c.data && "meanLines" in c.data && c.data.meanLines && (c.data.dataItems = [...c.data.dataItems, ...c.data.meanLines]), c;
}
function Oi(t) {
  return t?.[nt.defaultGroupOfSlicesId] === !0;
}
function tl(t, e) {
  const i = t.filter(
    (a) => !Oi(a)
  );
  return !Le(i, e);
}
function gs(t, e) {
  let i = t.reduce((a, n) => {
    if (n[nt.defaultGroupOfSlicesId] === !0) {
      const r = n[b.pieChart.technicalFieldGroupedSlices];
      r !== void 0 && r.forEach((s) => {
        a.push(s);
      });
    } else
      a.push(n);
    return a;
  }, []);
  return Ke({
    arrayToSort: i,
    chartConfig: e
  }), i = ci({
    data: { dataItems: i },
    seriesConfig: e.series
  })?.dataItems ?? [], i;
}
function ys(t) {
  const { stringToTruncate: e, characterLimit: i, ellipsis: a = b.chartEllipsis } = t;
  let n = e;
  return typeof i == "number" && Number.isFinite(i) && i > 0 && i < e.length && (n = e.slice(0, i), n = `${n}${a}`), n;
}
function il(t, e = ":") {
  return t ? `${e}` : `${e}`;
}
function al(t) {
  return (i) => {
    let a = typeof i != "string" ? i?.toString() ?? "" : i;
    return !Z(a) && a !== b.htmlEmptyContent && (a = ys({
      stringToTruncate: a,
      characterLimit: t
    })), a;
  };
}
function ps(t) {
  const e = /[[]/gu, i = /[\]]/gu, a = /[{]/gu, n = /[}]/gu, r = /[']/gu;
  return t = t.replace(e, "[["), t = t.replace(i, "]]"), t = t.replace(a, "{{"), t = t.replace(n, "}}"), t = t.replace(r, "''"), t;
}
function hs(t, e) {
  let i = "";
  return t !== void 0 && (i = `${e === "amChartsV5" ? "fontStyle" : "font-style"}:${t};`), i;
}
function Ss(t, e) {
  let i = "";
  return t === !0 && (i = `${e === "amChartsV5" ? "letterSpacing" : "letter-spacing"}:1px;`), i;
}
function nl(t) {
  const { textSymbol: e, placeholderString: i, format: a, axisLabelsBehavior: n, defaults: r } = t, s = hs(e?.font?.style, a), o = Ss(e?.kerning, a);
  let c = i ?? e?.text ?? "";
  if (a === "html") {
    let { wrap: l, maxWidth: u } = r ?? {};
    n === $i.Wrap && (l = !0, u = u ?? b.xAxisLabelMaxWidth);
    const d = l === !0 && Number.isFinite(u) ? `max-width: ${u}px; word-break: break-word;` : "";
    c = `<p style="margin:0;${s}${o}${d}">${c}</p>`;
  } else
    c = ps(c), (s !== "" || o !== "") && (c = `[${s}${o}]${c}[/]`);
  return c;
}
function Fs(t) {
  return t ? t.replace(/[A-Z]/gu, (e) => `-${e.toLowerCase()}`) : void 0;
}
const Ee = {
  ChartRenderer: 1,
  LayerRenderer: 2
};
function rl(t) {
  const { chartConfig: e, queryObject: i } = t;
  let a = !1;
  if (e.chartRenderer)
    a = !0;
  else {
    const { series: n } = e, r = Q(n), s = V(n), o = we(e), c = Ne({
      seriesConfig: o
    }), u = z(i)?.renderer;
    switch (u?.type) {
      case te.Simple:
        a = r === S.HistogramSeries || r === S.ScatterSeries || s === h.BarAndLineMonoField || s === h.BoxPlotMonoField || s === h.BoxPlotMultiFields || s === h.BoxPlotMonoFieldAndCategory || s === h.BarAndLineNoAggregation && n.length === 1 && !c;
        break;
      case te.UniqueValue:
        {
          const f = u?.field, m = K(o.query?.where), { x: g } = o;
          a = (s === h.BoxPlotMonoFieldAndSplitBy || s === h.BoxPlotMultiFieldsAndSplitBy || s === h.BoxPlotMonoFieldAndCategoryAndSplitBy || s === h.BarAndLineSplitByNoAggregation || s === h.BarAndLineSplitBy) && f === m || (s === h.BoxPlotMonoFieldAndCategory || s === h.PieFromCategory || s === h.BarAndLineMonoField) && f === g || s === h.BarAndLineNoAggregation || s === h.PieNoAggregation || r === S.ScatterSeries;
        }
        break;
      case te.PieChart:
        a = s === h.PieFromFields || s === h.BarAndLineFromFields || s === h.BarAndLineMultiFields || s === h.BarAndLineMonoField || s === h.BoxPlotMonoField || s === h.BoxPlotMultiFields || s === h.BoxPlotMonoFieldAndCategory || s === h.BoxPlotMultiFieldsAndCategory;
        break;
      case te.ClassBreaks:
        a = r === S.ScatterSeries || s === h.BarAndLineNoAggregation || s === h.PieNoAggregation;
        break;
      case te.Dictionary:
      case te.DotDensity:
      case te.Heatmap:
        break;
    }
  }
  return a;
}
function bs(t, e) {
  return Fs(t?.type) ?? e?.type;
}
function xs(t) {
  const e = b.rendererSymbolField;
  let i = e in t ? e : void 0;
  if (!i) {
    const a = t[b.originalCategoryValue];
    i = Object.keys(t).find((n) => {
      const r = t[n];
      return n.includes(e) && r?.label && r?.uniqueValue === a;
    }), i || (i = Object.keys(t).find((n) => n.includes(e)) ?? "");
  }
  return t[i]?.label;
}
function Cs(t) {
  return t?.type !== void 0 && (t.color !== void 0 || t.label !== void 0 || t.style !== void 0 || t.outline !== void 0);
}
function qi(t) {
  const { symbolField: e, dataItem: i, rendererSymbol: a, rendererOrigin: n } = t;
  let r = !1;
  if (!Cs(a))
    delete i[e];
  else {
    const s = { ...a };
    s.color !== void 0 && n === Ee.LayerRenderer && (s.color[3] = ri * 255), n === Ee.LayerRenderer && (delete s.style, delete s.outline, delete s.label), i[e] = s, r = !0;
  }
  return r;
}
function Bs(t) {
  const { renderer: e, seriesConfig: i, chartSubType: a, dataItem: n, rendererOrigin: r } = t;
  let s, o = !1;
  const c = Q(i), { outline: l, attributes: u } = e;
  return u.forEach(
    (d) => {
      let { field: f } = d;
      const { color: m, label: g } = d;
      let y;
      Array.isArray(m) && m?.length === 4 ? y = m : m && "toRgba" in m && (y = m.toRgba());
      let p = !1, C = !0;
      switch (c) {
        case S.BarSeries:
        case S.LineSeries:
        case S.ComboLineAndBarSeries:
        case S.RadarSeries:
          if (a !== h.BarAndLineFromFields) {
            const F = i.find((x) => x.query?.outStatistics?.[0]?.onStatisticField === f);
            F !== void 0 && "y" in F ? f = [F.y].flat()[0] : f = "";
          }
          p = a !== h.BarAndLineFromFields || f === n[b.originalCategoryValue];
          break;
        case S.PieSeries:
          p = a === h.PieFromFields && f === n[b.originalCategoryValue];
          break;
        case S.BoxPlotSeries:
          a === h.BoxPlotMonoField || a === h.BoxPlotMonoFieldAndCategory ? p = f === i[0].y : f && (a === h.BoxPlotMultiFields || a === h.BoxPlotMultiFieldsAndCategory) && (p = i.map((x) => x.y).flat().includes(f)), C = !1;
          break;
      }
      p && y && (s = {
        type: rt.SMS,
        color: y,
        label: C && g ? g : void 0
      }, l != null && (s.outline = l), qi({
        dataItem: n,
        symbolField: a === h.BarAndLineFromFields || a === h.PieFromFields ? b.rendererSymbolField : `${b.rendererSymbolField}_${f}`,
        rendererSymbol: s,
        rendererOrigin: r
      }) && (o = !0));
    }
  ), { rendererSymbol: s, colorMatchApplied: o };
}
function vs(t) {
  const { seriesConfig: e, chartSubType: i, rendererType: a } = t;
  let r = b.rendererSymbolField;
  if (a === te.UniqueValue) {
    if (Kt(i)) {
      const s = me({
        where: e.query?.where,
        keepSurroundingQuotes: !1,
        escape: !1
      });
      s === null ? r = b.nullValue : i === h.BarAndLineSplitBy && typeof e.y == "string" ? r = e.y : i === h.BarAndLineSplitByNoAggregation && typeof e.y == "string" ? r = `${e.y}_${s}` : r = `${s}`;
    }
  } else if (a === te.PieChart)
    switch (i) {
      case h.BoxPlotMultiFields:
        r = Array.isArray(e.y) ? e.y.flat() : e.y;
        break;
      case h.BarAndLineMonoField:
      case h.BarAndLineMultiFields:
      case h.BoxPlotMonoField:
      case h.BoxPlotMonoFieldAndCategory:
      case h.BoxPlotMultiFieldsAndCategory:
        r = e.y;
        break;
    }
  return r;
}
function Ei(t) {
  const { seriesConfig: e, chartSubType: i, rendererType: a, dataItem: n } = t;
  let r = vs({
    seriesConfig: e,
    chartSubType: i,
    rendererType: a
  });
  return r instanceof Array && e.type === S.BoxPlotSeries && a === te.PieChart && n !== void 0 && (r = r.find((s) => s === n[Jt]) ?? r[0]), r = r !== b.rendererSymbolField ? `${b.rendererSymbolField}_${r.toString()}` : r, r;
}
function Ns(t) {
  const { chartRenderer: e, queryObject: i } = t, a = e !== void 0 ? {
    // TODO: find a better way to copy the layer. For now it's all right as the information we need are not lost with the spread operator
    // eslint-disable-next-line @typescript-eslint/no-misused-spread
    ...z(i),
    renderer: xa.fromJSON(e)
  } : z(i);
  return new Ca({
    layer: a
  });
}
async function Ts(t) {
  const {
    seriesConfig: e,
    dataItem: i,
    renderer: a,
    rendererType: n,
    rendererOrigin: r,
    chartSubType: s,
    splitByField: o,
    graphicTemplate: c,
    rendererFieldNames: l,
    mapAttributesToSymbol: u
  } = t;
  let d, f = !1;
  if (n === te.PieChart) {
    const m = Bs({
      renderer: a,
      seriesConfig: e,
      chartSubType: s,
      dataItem: i,
      rendererOrigin: r
    });
    d = m.rendererSymbol, f = m.colorMatchApplied;
  } else if (!Oi(i)) {
    const { x: m } = e[0], g = /* @__PURE__ */ new Map();
    o && o.trim() !== "" ? e.forEach((y) => {
      if (y.type === S.BarSeries || y.type === S.LineSeries || y.type === S.BoxPlotSeries || y.type === S.RadarSeries) {
        const p = Ei({
          seriesConfig: y,
          chartSubType: s,
          rendererType: n,
          dataItem: i
        }), C = me({
          where: y.query?.where,
          normalize: !0,
          keepSurroundingQuotes: !1,
          escape: !1
        });
        g.set(p, {
          ...i,
          [o]: C
        });
      }
    }) : g.set(b.rendererSymbolField, {
      ...i,
      [m]: za(i)
    });
    try {
      const y = Array.from(g.entries()), p = c.clone();
      p.layer = c.layer;
      const C = a?.uniqueValueInfos;
      for (let F = 0; F < y.length; F += 1) {
        const [x, B] = y[F];
        if (Ht({
          mode: "encode",
          x: m,
          splitByField: o,
          attributes: B
        }), l && l.length > 0 && Object.keys(B).forEach((v) => {
          l.includes(v) || delete B[v];
        }), p.attributes = B, u?.has(JSON.stringify(B)))
          d = u.get(JSON.stringify(B));
        else {
          if (d = (await gt.getDisplayedSymbol(p))?.toJSON(), d != null) {
            d.color === void 0 && (d.color = (await gt.getDisplayedColor(p))?.toJSON());
            const v = await gt.getLegendLabel(p);
            v != null && v !== "" && (d.label = v, d.uniqueValue = C?.find((A) => A.label === v)?.value ?? void 0);
          }
          u?.set(JSON.stringify(B), d);
        }
        Ht({
          mode: "revert",
          x: m,
          splitByField: o,
          attributes: i
        }), qi({
          dataItem: i,
          symbolField: x,
          rendererSymbol: d,
          rendererOrigin: r
        }) && (f = !0);
      }
    } catch {
    }
  }
  return { rendererSymbol: d, colorMatchApplied: f };
}
function As(t) {
  const e = t;
  return t?.type === "uniqueValue" && (t.uniqueValueInfos = t.uniqueValueInfos.map((i) => {
    const a = i.value === null ? b.nullValue : i.value;
    return { ...i, value: a };
  })), e;
}
function Ht(t) {
  const { splitByField: e, attributes: i, x: a, mode: n } = t;
  [a, e ?? ""].forEach((r) => {
    i[r] === (n === "encode" ? null : b.nullValue) && (i[r] = n === "encode" ? b.nullValue : null);
  });
}
async function sl(t) {
  const { data: e, queryObject: i, chartConfig: a, allowColorMatch: n } = t;
  let r = !1, s = [];
  if (n) {
    const { series: o, chartRenderer: c } = a, l = As(c), u = l ? Ee.ChartRenderer : Ee.LayerRenderer, d = i ? z(i) : void 0, f = l ?? d?.renderer;
    let m;
    d && u === Ee.LayerRenderer ? s = await Zt(d) : u === Ee.ChartRenderer && (s = Ms(f));
    const g = bs(l, d?.renderer), y = Ns({
      chartRenderer: c,
      queryObject: i
    }), p = V(o), C = we(a), F = K(C.query?.where);
    m = /* @__PURE__ */ new Map();
    for (let x = 0; x < e.length; x += 1) {
      const B = e[x], N = await Ts({
        seriesConfig: a.series,
        dataItem: B,
        renderer: f,
        rendererType: g,
        rendererOrigin: u,
        chartSubType: p,
        splitByField: F,
        graphicTemplate: y,
        mapAttributesToSymbol: m,
        rendererFieldNames: s
      });
      r = r || N.colorMatchApplied;
    }
  }
  return { dataItems: e, colorMatchApplied: r, rendererFieldNames: s };
}
function Ps(t) {
  const { dataItem: e, seriesConfig: i, chartSubType: a, colorMatch: n, rendererType: r } = t;
  let s;
  if (n && e !== void 0) {
    const o = Ei({
      seriesConfig: i,
      chartSubType: a,
      rendererType: r,
      dataItem: e
    });
    s = e[o];
  }
  return s;
}
function ol(t) {
  const { seriesSymbol: e, rendererSymbol: i, colorIndex: a } = t;
  let n = i?.color ?? e.color;
  n = n ?? Ut({ colorIndex: a, opacity: ri });
  const r = {
    ...e,
    color: n
  };
  return i?.type === e.type && i.style !== void 0 && (r.style = i.style), r.type !== rt.SLS && (r.outline = {
    type: rt.SLS,
    style: i?.outline?.style ?? r.outline?.style,
    width: i?.outline?.width ?? r.outline?.width,
    color: i?.outline?.color ?? r.outline?.color ?? i?.color
  }), r;
}
function Ls(t) {
  let e = [];
  return t && (e = t.series.flatMap((i) => i.query?.outStatistics?.map((a) => a.onStatisticField)).filter((i) => i !== void 0), e.length === 0 && (e = re(t.series))), e;
}
function ll(t, e) {
  let i = !1;
  if (t && e && e.length > 0 && Gt(t)) {
    const n = Qa(t), r = we(t);
    n ? i = Ls(t).some((o) => e.includes(o)) : i = e.includes(r.x);
  }
  return i;
}
function Ms(t) {
  let e = [];
  if (t && "type" in t && typeof t.type == "string")
    switch (t.type) {
      case "uniqueValue":
        "field1" in t && typeof t.field1 == "string" && (e = [t.field1]);
        break;
      case "classBreaks":
        "field" in t && typeof t.field == "string" && (e = [t.field]);
        break;
      case "pieChart":
        "attributes" in t && Array.isArray(t.attributes) && (e = t.attributes.map((i) => i.field));
        break;
    }
  return e;
}
function cl(t, e) {
  let i;
  return e !== void 0 && (i = { ...e }, i.legend !== void 0 && (i.legend.position = t)), i;
}
function ul(t, e) {
  let i;
  return e !== void 0 && (i = { ...e }, i.legend !== void 0 && (i.legend.visible = t)), i;
}
function dl(t) {
  let e;
  return t !== void 0 && (e = { ...t }, delete e.axes?.[0]?.minimum, delete e.axes?.[0]?.maximum, delete e.axes?.[1]?.minimum, delete e.axes?.[1]?.maximum), e;
}
function fl(t, e) {
  return e != null || La(t);
}
async function ws(t) {
  const { queryObject: e, chartConfig: i, options: a, splitByField: n } = t;
  let r = [];
  const s = i.series[0], o = await Pa(i, e), c = ii({
    queryObject: e,
    chartConfig: o,
    runtimeDataFilters: a?.runtimeDataFilters,
    ignoreViewExtent: a?.ignoreViewExtent
  });
  if (c.outStatistics?.[0]?.outStatisticFieldName && (c.outStatistics[0].outStatisticFieldName = Y.outStatistics.outStatisticFieldName), se(s) && Ne({
    xAxisValueFormatType: ye(o),
    setTimeBinningInfoWhenNotProvided: a?.setTimeBinningInfoWhenNotProvided,
    seriesConfig: s
  }) && We(e)) {
    const { temporalBinning: l, x: u } = s, d = await ai({
      queryObject: e,
      dateField: u,
      splitByField: n,
      queryConfig: c,
      temporalBinning: l
    });
    r = Array.from(
      new Set(
        d.flatMap((f) => {
          const { stackedAttributes: m } = f;
          let g = [];
          return m && (g = m.map((y) => y[n]).filter((y) => y !== void 0)), g;
        })
      ).values()
    );
  } else {
    const { uniqueQuery: l } = await ct({
      chartConfig: o,
      queryObject: e,
      queryConfig: c,
      options: a
    }), u = await ge({
      queryObject: e,
      queryConfig: l,
      featureCount: 1
    });
    r = Array.from(
      new Set(
        u.map((d) => d.attributes[n]).filter((d) => d !== void 0)
      ).values()
    );
  }
  return r;
}
function Ds(t, e) {
  const i = /* @__PURE__ */ new Map();
  return t.series.forEach((a) => {
    let n = me({
      where: a.query?.where,
      // normalize the value so it matches what we get from getAllValues()
      // Refer to https://devtopia.esri.com/WebGIS/arcgis-charts/issues/8127
      normalize: !0,
      // we do not escape the characters so they match what we get from getAllValues()
      // Refer to https://devtopia.esri.com/WebGIS/arcgis-charts/issues/8078
      escape: !1
    });
    e && n !== null && (n = Number(n));
    const r = Q([a]);
    r !== void 0 && i.set(r, [
      ...i.get(r) ?? [],
      n
    ]);
  }), i;
}
function Os(t) {
  const { allValues: e, configUniqueValuesPerSeriesType: i, initialConfigWasEmpty: a } = t, n = /* @__PURE__ */ new Map();
  return Array.from(i.keys()).forEach((r) => {
    const s = i.get(r) ?? [];
    let o = [];
    a ? o = e : e.forEach((c) => {
      s.includes(c) || o.push(c);
    }), n.set(r, o);
  }), n;
}
function qs(t) {
  const { chartConfig: e, missingValue: i, splitByField: a, seriesTemplate: n } = t, r = JSON.parse(
    JSON.stringify({
      ...e.series[0],
      ...n
    })
  );
  if (r.query) {
    if (r.id = `${i}-${e.series.length}-${Date.now()}`, r.name = `${i}`, r.query.outStatistics?.[0] !== void 0) {
      const o = r.id;
      r.query.outStatistics[0].outStatisticFieldName = o, "y" in r && (r.y = o);
    }
    const s = typeof i == "number" || i === null ? i : `'${i}'`;
    r.query.where = `${a}=${s}`;
  }
  return r;
}
async function ml(t, e, i) {
  const { updateSplitBySeries: a } = t, { seriesTemplate: n } = a ?? {};
  if (a !== void 0 && e !== void 0 && (e.series.length > 0 || n !== void 0) && a.addMissingSeries) {
    const r = e.series.length === 0;
    e.series.length === 0 && n !== void 0 && e.series.push(n);
    const s = V(e.series);
    if (s === h.BoxPlotMonoFieldAndSplitBy || s === h.BoxPlotMultiFieldsAndSplitBy || s === h.BoxPlotMonoFieldAndCategoryAndSplitBy || s === h.BarAndLineSplitBy || s === h.BarAndLineSplitByNoAggregation) {
      const o = await Sa({
        chartConfig: e,
        layer: t.layer,
        view: t.view
      });
      if (o !== void 0) {
        const c = K(e.series[0]?.query?.where), l = z(o);
        await l.load();
        const u = l.getField(c)?.toJSON(), d = Qe(u), f = await ws({
          queryObject: o,
          chartConfig: e,
          splitByField: c,
          options: i
        });
        if (f.length > 0) {
          const m = Ds(e, d), g = Os({
            allValues: f,
            configUniqueValuesPerSeriesType: m,
            initialConfigWasEmpty: r
          });
          Array.from(g.keys()).forEach((y) => {
            (g.get(y) ?? []).forEach((C) => {
              e.series.push(
                qs({
                  chartConfig: e,
                  seriesTemplate: n,
                  missingValue: C,
                  splitByField: c
                })
              );
            }), r && e.series.shift();
          });
        }
      }
    }
  }
}
export {
  el as $,
  Xo as A,
  Zo as B,
  si as C,
  Nr as D,
  pr as E,
  Lt as F,
  yo as G,
  ys as H,
  Ma as I,
  fo as J,
  Oo as K,
  ko as L,
  Jo as M,
  jt as N,
  lo as O,
  uo as P,
  de as Q,
  Ee as R,
  Lo as S,
  jo as T,
  hn as U,
  al as V,
  Ka as W,
  ye as X,
  Ko as Y,
  qo as Z,
  Yo as _,
  nl as a,
  sl as a0,
  No as a1,
  Po as a2,
  mo as a3,
  Go as a4,
  Co as a5,
  $o as a6,
  Ro as a7,
  po as a8,
  Ho as a9,
  zo as aa,
  Eo as ab,
  Uo as ac,
  ho as ad,
  So as ae,
  co as af,
  _o as ag,
  Fo as ah,
  Ft as ai,
  Ra as aj,
  ci as ak,
  To as al,
  tl as am,
  Vo as an,
  Io as ao,
  Qo as ap,
  Wo as aq,
  Bo as ar,
  xo as as,
  bo as at,
  go as au,
  ml as av,
  fl as aw,
  cl as ax,
  ul as ay,
  ui as b,
  oo as c,
  il as d,
  vo as e,
  He as f,
  ze as g,
  za as h,
  Oi as i,
  ps as j,
  ll as k,
  Pe as l,
  ol as m,
  Ao as n,
  J as o,
  Ps as p,
  Do as q,
  dl as r,
  Ke as s,
  Mo as t,
  Ns as u,
  bs as v,
  rl as w,
  Ts as x,
  wo as y,
  Wa as z
};
