import { W as a } from "./series-types.js";
import "@arcgis/toolkit/intl";
import "lodash-es";
import "d3-array";
import { aJ as g, aC as l, az as c } from "./interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import "./runtime.js";
import { n as f, j as r, l as n } from "./index4.js";
import "@arcgis/toolkit/dom";
import { g as h, s as d, a as m, b as y } from "./bar-chart-series.js";
import { g as u, a as b, e as p, b as _, f as C, s as L, h as v, c as k, i as O, d as A, j as F, k as M, l as B, m as S, n as z, o as V, p as w, q as U, r as j } from "./baseline-stacking.js";
import { S as D, s as H } from "./serial-chart-model.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
class te extends D {
  constructor() {
    super(...arguments), this._chartType = a.ComboLineAndBarSeries;
  }
  get config() {
    return this._config;
  }
  async setup(e) {
    await this.loadConfigFromLayer(e), this.setupLocalProps(), e.config !== void 0 && (f(e.config?.series) && this.initDefaultSeries(), await this.updateSeriesFromLayerFilter()), typeof this.resolveSetup == "function" && this.resolveSetup();
  }
  // ---------------------------------------------------------------------------------------------
  // Protected Methods
  // ---------------------------------------------------------------------------------------------
  generateDefaultConfig() {
    const e = g(this.commonStrings);
    return e.series = [
      l({
        commonStrings: this.commonStrings,
        objectIDField: this.layerInfo?.objectIdField
      })
    ], e;
  }
  /**
   * Initializes the default series for the combo bar-line chart. Used in resetting the series styling.
   * @category Private
   */
  initDefaultSeries() {
    this.defaultSeries = c({
      commonStrings: this.commonStrings,
      objectIDField: this.layerInfo?.objectIdField
    });
  }
  // ---------------------------------------------------------------------------------------------
  // Series Methods
  // ---------------------------------------------------------------------------------------------
  /**
   * Changes the chart series type at the specified index from bar to line and vice-versa.
   * @param {number} seriesIndex - The index of the series to update.
   * @param {WebChartTypes} seriesType - The new chart series type to apply.
   */
  setSeriesType(e, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      if (e < this._config.series.length && e >= 0) {
        const t = this._config.series[e];
        let o;
        if (i === a.BarSeries && r(t)) {
          const s = { ...t };
          delete s.lineSymbol, delete s.markerSymbol, delete s.lineSmoothed, delete s.markerVisible, delete s.areaColor, delete s.stackNegativeValuesToBaseline, o = {
            ...l({
              commonStrings: this.commonStrings,
              objectIDField: this.layerInfo?.objectIdField
            }),
            ...s,
            type: a.BarSeries,
            y: [t.y].flat()[0]
          }, o.fillSymbol && (o.fillSymbol = {
            ...o.fillSymbol,
            color: t.lineSymbol?.color
          });
        } else if (i === a.LineSeries && n(t)) {
          const s = { ...t };
          delete s.fillSymbol, delete s.hideOversizedStackedLabels, delete s.hideOversizedSideBySideLabels, o = {
            ...c({
              commonStrings: this.commonStrings,
              objectIDField: this.layerInfo?.objectIdField
            }),
            ...s,
            type: a.LineSeries
          }, o.lineSymbol && (o.lineSymbol = {
            ...o.lineSymbol,
            color: t.fillSymbol?.color
          });
        }
        o !== void 0 && (this._config.series[e] = o, this.emitConfigUpdate("setSeriesType"));
      }
    });
  }
  /**
   * Gets the line style of the series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {RESTSimpleLineSymbolStyle | undefined}
   */
  getSeriesLineStyle(e) {
    return u(e, this._config);
  }
  /**
   * Sets the line style of the series based on the series index.
   * **Note:** This method will only work if the series is a line chart series.
   * @param {RESTSimpleLineSymbolStyle | undefined} newStyle The new style for the series.
   * @param {number} seriesIndex The index of the series.
   */
  setSeriesLineStyle(e, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      const t = this._config.series?.[i];
      r(t) && (b(e, i, this._config), this.emitConfigUpdate("setSeriesLineStyle"));
    });
  }
  /**
   * Gets the line width of the series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {number | undefined}
   */
  getSeriesLineWidth(e) {
    return p(e, this._config);
  }
  /**
   * Sets the line width of the series based on the series index.
   * **Note:** This method will only work if the series is a line chart series.
   * @param {number | undefined} newWidth The new width for the series.
   * @param {number} seriesIndex The index of the series.
   */
  setSeriesLineWidth(e, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      const t = this._config.series?.[i];
      r(t) && (_(e, i, this._config), this.emitConfigUpdate("setSeriesLineWidth"));
    });
  }
  /**
   * Gets the marker color of the series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {Color | undefined}
   */
  getSeriesMarkerColor(e) {
    return C(e, this._config);
  }
  /**
   * Sets the marker color of the series based on the series index.
   * **Note:** This method will only work if the series is a line chart series.
   * @param {Color | undefined} newColor The new color for the series.
   * @param {number} seriesIndex The index of the series.
   */
  setSeriesMarkerColor(e, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      const t = this._config.series?.[i];
      r(t) && (L(e, i, this._config), this.emitConfigUpdate("setSeriesMarkerColor"));
    });
  }
  /**
   * Gets the marker style of the series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {RESTSimpleMarkerSymbolStyle | undefined}
   */
  getSeriesMarkerStyle(e) {
    return v(e, this._config);
  }
  /**
   * Sets the marker style of the series based on the series index.
   * **Note:** This method will only work if the series is a line chart series.
   * @param {RESTSimpleMarkerSymbolStyle | undefined} newStyle The new style for the series.
   * @param {number} seriesIndex The index of the series.
   */
  setSeriesMarkerStyle(e, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      const t = this._config.series?.[i];
      r(t) && (k(e, i, this._config), this.emitConfigUpdate("setSeriesMarkerStyle"));
    });
  }
  /**
   * Gets the marker size of the series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {number | undefined}
   */
  getSeriesMarkerSize(e) {
    return O(e, this._config);
  }
  /**
   * Sets the marker size of the series based on the series index.
   * **Note:** This method will only work if the series is a line chart series.
   * @param {number | undefined} newSize The new size for the series.
   * @param {number} seriesIndex The index of the series.
   */
  setSeriesMarkerSize(e, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      const t = this._config.series?.[i];
      r(t) && (A(e, i, this._config), this.emitConfigUpdate("setSeriesMarkerSize"));
    });
  }
  /**
   * Specify whether line segments of the series should be smoothed.
   * @param {number} seriesIndex - The index of the series.
   *
   * @default false
   * @returns {boolean}
   */
  isLineSmoothed(e) {
    return F(e, this._config);
  }
  /**
   * Specify whether line segments of the series should be smoothed.
   * **Note:** This method will only work if the series is a line chart series.
   * @param {boolean} smoothed - `true` if line segment of the series should be smoothed, `false` otherwise.
   * @param {number} seriesIndex - The index of the series.
   * @default false
   */
  setLineSmoothed(e, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      const t = this._config.series?.[i];
      r(t) && (M({
        smoothed: e,
        seriesIndex: i,
        config: this._config
      }), this.emitConfigUpdate("setLineSmoothed"));
    });
  }
  /**
   * Specify whether the line series should show area.
   * @param {number} seriesIndex - The index of the series.
   *
   * @default false
   * @returns {boolean}
   */
  isAreaVisible(e) {
    return B(e, this._config);
  }
  /**
   * Specify whether the line series should show area.
   * **Note:** This method will only work if the series is a line chart series.
   * @param {boolean} visible - `true` if the line series should show area, `false` otherwise.
   * @param {number} seriesIndex - The index of the series.
   */
  setAreaVisible(e, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      const t = this._config.series?.[i];
      r(t) && (S({
        visible: e,
        seriesIndex: i,
        config: this._config
      }), this.emitConfigUpdate("setAreaVisible"));
    });
  }
  /**
   * Indicate whether to show or hide the markers/bullets of the line series.
   * @param {number} seriesIndex - The index of the series.
   *
   * @default true
   * @returns {boolean}
   */
  isMarkerVisible(e) {
    return z(e, this._config);
  }
  /**
   * Indicate whether to show or hide the markers/bullets of the line series.
   * **Note:** This method will only work if the series is a line chart series.
   * @param {boolean} visible - `true` if the markers/bullets of the line series should be shown, `false` otherwise.
   * @param {number} seriesIndex - The index of the series.
   */
  setMarkerVisible(e, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      const t = this._config.series?.[i];
      r(t) && (V({
        visible: e,
        seriesIndex: i,
        config: this._config
      }), this.emitConfigUpdate("setMarkerVisible"));
    });
  }
  /**
   * Specify the color of the filled area for line chart.
   * **Note:** `areaColor` will be applied only if `showArea` is true, and is defaulted to the line color if not provided.
   * @param {number} seriesIndex - The index of the series.
   * @returns {Color | undefined}
   */
  getAreaColor(e) {
    return w(e, this._config);
  }
  /**
   * Specify the color of the filled area for line chart.
   * **Note:** This method will only work if the series is a line chart series.
   * @param {Color | undefined} color The color of the filled area for line chart.
   * @param {number} seriesIndex The index of the series.
   */
  setAreaColor(e, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      const t = this._config.series?.[i];
      r(t) && (S({
        visible: !0,
        seriesIndex: i,
        config: this._config
      }), H(e, i, this._config), this.emitConfigUpdate("setAreaColor"));
    });
  }
  /**
   * Specify how negative values are treated in stacked series.
   * **Note:** If true, negative values will be stacked on the base line. If false, negative values will be stacked in relation to their previous values in the stack.
   * @param {number} seriesIndex - The index of the series.
   * @default true
   * @returns {boolean}
   */
  isNegativeValuesStackedToBaseline(e) {
    return U(e, this._config);
  }
  /**
   * Specify how negative values are treated in stacked series.
   * **Note:** If true, negative values will be stacked on the base line. If false, negative values will be stacked in relation to their previous values in the stack.
   * **Note:** This method will only work if the series is a line chart series.
   * @param {boolean} stackNegativeValuesToBaseline - `true` if negative values should be stacked on the base line, `false` otherwise.
   * @param {number} seriesIndex - The index of the series.
   */
  setNegativeValuesStackedToBaseline(e, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      const t = this._config.series?.[i];
      r(t) && (j({
        stackNegativeValuesToBaseline: e,
        seriesIndex: i,
        config: this._config
      }), this.emitConfigUpdate("setNegativeValuesStackedToBaseline"));
    });
  }
  /**
   * Gets whether to hide oversized data labels of the side-by-side series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {boolean | undefined}
   */
  getSeriesHideOversizedSideBySideLabels(e) {
    return h(e, this._config);
  }
  /**
   * Sets whether to hide oversized data labels of the side-by-side series based on the series index.
   * @param {boolean} hide The value for hiding oversized labels.
   * @param {number} seriesIndex The index of the series.
   *
   * **Note:** This method will only work if the series is a bar chart series.
   */
  setSeriesHideOversizedSideBySideLabels(e, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      const t = this._config.series?.[i];
      n(t) && (d(e, i, this._config), this.emitConfigUpdate("setSeriesHideOversizedSideBySideLabels"));
    });
  }
  /**
   * Gets whether to hide oversized data labels of the stacked series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {boolean | undefined}
   */
  getSeriesHideOversizedStackedLabels(e) {
    return m(e, this._config);
  }
  /**
   * Sets whether to hide oversized data labels of the stacked series based on the series index.
   * **Note:** This method will only work if the series is a bar chart series.
   * @param {boolean} hide The value for hiding oversized stacked labels.
   * @param {number} seriesIndex The index of the series.
   */
  setSeriesHideOversizedStackedLabels(e, i) {
    this.guardSetterFromAsyncOverwrite(() => {
      const t = this._config.series?.[i];
      n(t) && (y(e, i, this._config), this.emitConfigUpdate("setSeriesHideOversizedStackedLabels"));
    });
  }
}
export {
  te as ComboBarLineChartModel
};
