import "@arcgis/toolkit/intl";
import "lodash-es";
import { W as O } from "./series-types.js";
import "d3-array";
import { a3 as n, aK as I, aD as x, ci as A, a6 as b, Y as U, b2 as l, a0 as g, a1 as c } from "./interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import "./runtime.js";
import { j as o } from "./index4.js";
import "@arcgis/toolkit/dom";
import { C as P, M as W, a as D } from "./model-with-multi-axes.js";
import { B as N } from "./common.js";
import { M as V, a as E, b as T, c as R } from "./model-with-data-labels.js";
import "@arcgis/core/intl.js";
import { M as z } from "./model-with-rotation.js";
import { i as K, e as Y, d as k } from "./data2.js";
import { g as j, s as d, a as q, b as f } from "./series.js";
import { s as G, g as X, a as H, b as J, c as Q, d as m, e as u, f as y, h as S, i as p, j as Z, k as $, l as ee, m as C, n as te, o as ie, p as se, q as re, r as L, t as oe, u as _, v as ne, w as F, x as ae, y as he, z as le, A as ge, B as ce, C as de, D as w } from "./box-plot-data.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
class fe extends P {
  constructor() {
    super(...arguments), this._chartType = O.BoxPlotSeries, this._category = n, this._splitByField = "", this._numericFields = [];
  }
  async setup(e) {
    await this.loadConfigFromLayer(e), this.setupLocalProps(), e.config !== void 0 && await this.updateSeriesFromLayerFilter(), typeof this.resolveSetup == "function" && this.resolveSetup();
  }
  // ---------------------------------------------------------------------------------------------
  // #region Data Props
  // ---------------------------------------------------------------------------------------------
  /**
   * The category field for the box plot.
   */
  get category() {
    return this._category;
  }
  set category(e) {
    const t = e.trim() === "";
    this._category = t ? n : e, this.dirtyAsyncSetters.push("category"), this.processSeriesRebuild();
  }
  /**
   * The numeric fields array for the box plot.
   */
  get numericFields() {
    return this._numericFields;
  }
  set numericFields(e) {
    const { layerFieldsInfo: t } = this.layerInfo;
    typeof e == "string" && (e = [e]), K(t, e) ? (this._numericFields = e, this.dirtyAsyncSetters.push("numericFields"), G(this._category, this._numericFields) && (this._splitByField = "", this.dirtyAsyncSetters.push("splitByField")), this.processSeriesRebuild()) : console.log("Invalid numericFields");
  }
  /**
   * The split-by field for the box plot.
   */
  get splitByField() {
    return this._splitByField;
  }
  set splitByField(e) {
    Y(this.layerInfo.layerFieldsInfo, e) ? (this._splitByField = e, this.dirtyAsyncSetters.push("splitByField"), this.processSeriesRebuild()) : console.log("Invalid splitByField");
  }
  /**
   * Whether outliers are shown.
   */
  get showOutliers() {
    return X(this._config);
  }
  set showOutliers(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      H({
        newShowOutliers: e,
        config: this._config,
        layerInfo: this.layerInfo,
        commonStrings: this.commonStrings
      }), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("showOutliers");
    });
  }
  /**
   * Whether values are standardized as z-scores.
   */
  get standardizeValues() {
    return J(this._config);
  }
  set standardizeValues(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      Q({
        newStandardizeValues: e,
        config: this._config,
        layerInfo: this.layerInfo,
        commonStrings: this.commonStrings
      }), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("standardizeValues");
    });
  }
  /**
   * Gets the sort order of the box plot data.
   * @returns {"xAxisAsc" | "xAxisDesc"| "meanAsc" | "meanDesc" | "medianAsc" | "medianDesc" | "customSort"}
   */
  getSortOrder() {
    return m(this._config);
  }
  /**
   * Sets the sort order of the box plot data.
   * @param {"xAxisAsc" | "xAxisDesc"| "meanAsc" | "meanDesc" | "medianAsc" | "medianDesc" | "customSort"} newSortOrder The new sort order.
   * @param {string[]} orderByList The new list of category's values for custom sort.
   */
  setSortOrder(e, t) {
    this.guardSetterFromAsyncOverwrite(() => {
      u(e, this._config, t), this.emitConfigUpdate("setSortOrder");
    });
  }
  /**
   * Gets the list of the category values for the chart.
   * @returns {string[]}
   */
  async getCustomSortValues() {
    return await y(this._config, this.layerInfo);
  }
  /**
   * Sets the data filter for the bar chart.
   * @param {WebChartDataFilters | undefined} newDataFilter The new data filter.
   */
  async setDataFilters(e) {
    super.setDataFilters(e);
    const t = m(this._config);
    if (t === N.customSort) {
      const i = await y(this._config, this.layerInfo);
      u(t, this._config, i);
    }
    this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("setDataFilter");
  }
  /**
   * The list of category's values for custom sort
   */
  get orderByList() {
    return S(this._config);
  }
  set orderByList(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      p(e, this._config), this.emitConfigUpdate("orderByList");
    });
  }
  /**
   * Updates the series based on the layer filter.
   * @async **This method is `async` and must be awaited for the changes to take effect.*
   */
  async updateSeriesFromLayerFilter() {
    this.dirtyAsyncSetters.push("updateSeriesFromLayerFilter"), await this.processSeriesRebuild();
  }
  // ---------------------------------------------------------------------------------------------
  // #region  Series Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Whether mean lines are shown.
   */
  get showMeanLines() {
    return Z(this._config);
  }
  set showMeanLines(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      const { previousMeanLinesBoxColor: t } = $({
        newShowMeanLines: e,
        config: this._config,
        commonStrings: this.commonStrings,
        previousMeanLinesBoxColor: this.previousMeanLinesBoxColor
      });
      this.previousMeanLinesBoxColor = t, this.emitConfigUpdate("showMeanLines");
    });
  }
  /**
   * The color of the boxes when showing mean lines. Only applicable when mean lines are shown.
   */
  get meanLinesBoxColor() {
    return ee(this._config);
  }
  set meanLinesBoxColor(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      C(e, this._config), this.emitConfigUpdate("meanLinesBoxColor");
    });
  }
  // ---------------------------------------------------------------------------------------------
  // #region Protected Methods
  // ---------------------------------------------------------------------------------------------
  /**
   * Sets up the local props based on the current config.
   * @category Protected
   */
  setupLocalProps() {
    this._category = te(this._config), this._splitByField = ie(this._config), this._numericFields = se(this._config);
  }
  generateDefaultConfig() {
    const e = I(this.commonStrings);
    return e.series = [x(this.commonStrings)], e;
  }
  /**
   * Resets the config to the default config
   */
  resetConfig() {
    const e = this._config.id;
    this._config = this.generateDefaultConfig(), this._config.id = e, this.setupLocalProps(), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("resetConfig");
  }
  /**
   * Determines if we can rebuild the series synchronously.
   * We can call the build new series function synchronously when either is true:
   * - there is no split-by field
   * - there are multiple numeric fields
   * @category Protected
   */
  canUseSynchronousSeriesRebuild() {
    return !re(this.category, this.numericFields, this.splitByField);
  }
  /**
   * Processes the series rebuild.
   * If multiple async setters are called in succession, this function will only rebuild the series once after all setters have been called.
   * @category Protected
   * @async
   */
  async processSeriesRebuild() {
    if (this.layerInfo !== void 0) {
      const e = this.dirtyAsyncSetters[this.dirtyAsyncSetters.length - 1];
      if (this.canUseSynchronousSeriesRebuild())
        this.dirtyAsyncSetters = [], L(this.getBuildNewSeriesProps());
      else if (!this.asyncConfigUpdateInProgress) {
        for (this.asyncConfigUpdateInProgress = !0, this.setupFinished = new Promise((t) => {
          this.resolveSetup = t;
        }); this.dirtyAsyncSetters.length > 0; )
          this.dirtyAsyncSetters = [], await L(this.getBuildNewSeriesProps());
        this.asyncConfigUpdateInProgress = !1, this.resolveSetup?.();
      }
      this.setupLocalProps(), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate(e);
    }
  }
  //#endregion
  // #region Private Methods
  /**
   * Gets the properties needed to build a new series array.
   */
  getBuildNewSeriesProps() {
    return {
      category: this.category,
      splitByField: this.splitByField,
      numericFields: this.numericFields,
      config: this._config,
      layerInfo: this.layerInfo,
      commonStrings: this.commonStrings
    };
  }
  // #endregion
  // ---------------------------------------------------------------------------------------------
  // #region Series Methods
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets the name of the series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {string | undefined}
   */
  getSeriesName(e) {
    return oe(e, this._config);
  }
  /**
   * Sets name of the series based on the series index.
   * @param {string} newName The new name for the series.
   * @param {number} seriesIndex The index of the series.
   */
  setSeriesName(e, t) {
    this.guardSetterFromAsyncOverwrite(() => {
      _(e, t, this._config), this.emitConfigUpdate("setSeriesName");
    });
  }
  /**
   * Gets the color of the series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {Color | undefined}
   */
  getSeriesColor(e) {
    return ne(e, this._config);
  }
  /**
   * Sets the color of the series based on the series index.
   * @param {Color | undefined} newColor The new color for the series.
   * @param {number} seriesIndex The index of the series.
   */
  setSeriesColor(e, t) {
    this.guardSetterFromAsyncOverwrite(() => {
      F(e, t, this._config), this.emitConfigUpdate("setSeriesColor");
    });
  }
  /**
   * Gets the line style of the series based on the series index. If the index is out of bounds, it will return `undefined`.
   *
   * **Only applicable when mean lines are shown.**
   *
   * @param {number} seriesIndex The index of the series.
   * @returns {RESTSimpleLineSymbolStyle | undefined}
   */
  getSeriesLineStyle(e) {
    const t = this._config.series[e];
    if (this.showMeanLines === !0 && o(t))
      return j(t);
  }
  /**
   * Sets the line style of the series based on the series index.
   *
   * **Only applicable when mean lines are shown.**
   *
   * @param {RESTSimpleLineSymbolStyle | undefined} newStyle The new style for the series.
   * @param {number} seriesIndex The index of the series.
   */
  setSeriesLineStyle(e, t) {
    this.guardSetterFromAsyncOverwrite(() => {
      const i = this._config.series[t];
      this.showMeanLines === !0 && o(i) && d(e, i), this.emitConfigUpdate("setSeriesLineStyle");
    });
  }
  /**
   * Gets the line width of the series based on the series index. If the index is out of bounds, it will return `undefined`.
   *
   * **Only applicable when mean lines are shown.**
   *
   * @param {number} seriesIndex The index of the series.
   * @returns {number | undefined}
   */
  getSeriesLineWidth(e) {
    const t = this._config.series[e];
    if (this.showMeanLines === !0 && o(t))
      return q(t);
  }
  /**
   * Sets the line width of the series based on the series index.
   *
   * **Only applicable when mean lines are shown.**
   *
   * @param {number | undefined} newWidth The new width for the series.
   * @param {number} seriesIndex The index of the series.
   */
  setSeriesLineWidth(e, t) {
    this.guardSetterFromAsyncOverwrite(() => {
      const i = this._config.series[t];
      this.showMeanLines === !0 && o(i) && f(e, i), this.emitConfigUpdate("setSeriesLineWidth");
    });
  }
  /**
   * The order of the series array by returning an array of series ids.
   */
  get orderOfSeries() {
    return ae(this._config);
  }
  set orderOfSeries(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      he(e, this._config), this.emitConfigUpdate("orderOfSeries");
    });
  }
  /**
   * Moves a series from one index in the series array to another.
   * @param {number} fromIndex Index to move the series from.
   * @param {number} toIndex Index to move the series to.
   */
  moveSeries(e, t) {
    this.guardSetterFromAsyncOverwrite(() => {
      le(e, t, this._config), this.emitConfigUpdate("moveSeries");
    });
  }
  /**
   * The index of the box plot series in the series array in config object when show mean is true.
   * **Note:** There is only one box plot series when show mean is true. The function returns '-1' if show mean is false.
   */
  get boxPlotSeriesIndexWhenMeanLinesShown() {
    return ge(this._config);
  }
  /**
   * Move the custom sort values in-place for the order by list in the config.
   * **Note:** This method should be only used when the sort order is set to `BoxPlotDataSortingKinds.customSort`.
   * @param {number} fromIndex The index to move the custom sort item from.
   * @param {number} toIndex The index to move the category item to.
   */
  moveCustomSortValuesInOrderByList(e, t) {
    this.guardSetterFromAsyncOverwrite(() => {
      const i = S(this._config), [s] = i.splice(e, 1);
      i.splice(t, 0, s), p(i, this._config), this.emitConfigUpdate("moveCustomSortValuesInOrderByList");
    });
  }
  // ---------------------------------------------------------------------------------------------
  // #region General Methods
  // ---------------------------------------------------------------------------------------------
  /**
   * Generate the proper chart title given the current config.
   */
  generateChartTitle() {
    return ce(this._config, this.layerInfo, this.commonStrings);
  }
  /**
   * Generate the proper x-axis title given the current config.
   *
   * @returns {string}
   */
  generateXAxisTitle() {
    return this._category !== n ? A(this.layerInfo.layerFieldsInfo, this._category) : "";
  }
  /**
   * Generate the proper y-axis title given the current config.
   */
  generateYAxisTitle() {
    return de(this._config, this.layerInfo, this.commonStrings);
  }
  // ---------------------------------------------------------------------------------------------
  // #region Reset Methods
  // ---------------------------------------------------------------------------------------------
  /**
   * Resets the series styling to the default styling.
   */
  resetSeriesStyling() {
    this.guardSetterFromAsyncOverwrite(() => {
      for (let e = this.showMeanLines === !0 ? 1 : 0; e < this.seriesLength; e += 1) {
        const t = this.getSeriesId(e), i = b({
          colorIndex: e,
          opacity: U
        }), s = this._config.series[e];
        F(i, e, this._config);
        const r = w({
          series: s,
          splitByField: this._splitByField,
          layerInfo: this.layerInfo,
          commonStrings: this.commonStrings
        });
        _(r ?? t, e, this._config), this.showMeanLines === !0 && o(s) && (d(g, s), f(c, s));
      }
      this.showMeanLines === !0 && C(l, this._config), this._config.colorMatch = !0, this.emitConfigUpdate("resetSeriesStyling");
    });
  }
  /**
   * Returns whether the series styling is able to be reset.
   * @returns {boolean}
   */
  resetAvailable() {
    const e = !this.colorMatch, t = this.showMeanLines === !0 && this.meanLinesBoxColor !== l;
    let i = !1, s = !1;
    if (!e)
      for (let r = this.showMeanLines === !0 ? 1 : 0; r < this.seriesLength; r += 1) {
        const a = this._config.series[r], h = w({
          series: a,
          splitByField: this._splitByField,
          layerInfo: this.layerInfo,
          commonStrings: this.commonStrings
        }), B = this.getSeriesName(r);
        if (h !== void 0 && h !== B) {
          i = !0;
          break;
        }
        if (this.showMeanLines === !0 && o(a)) {
          const v = this.getSeriesLineStyle(r), M = this.getSeriesLineWidth(r);
          if (v !== g || M !== c) {
            s = !0;
            break;
          }
        }
      }
    return e || t || i || s;
  }
}
k(fe, [
  W,
  V,
  E,
  T,
  z,
  R,
  D
]);
export {
  fe as BoxPlotModel
};
