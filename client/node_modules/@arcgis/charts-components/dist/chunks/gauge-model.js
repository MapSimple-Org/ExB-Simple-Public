import { W as h, G as x, a as u } from "./series-types.js";
import "@arcgis/toolkit/intl";
import "lodash-es";
import "d3-array";
import { ax as a, ac as f, an as b, aH as m, aO as S } from "./interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import "./runtime.js";
import "@arcgis/toolkit/dom";
import { C as v, c as C, b as I } from "./model-with-multi-axes.js";
import "@arcgis/core/intl.js";
import { b as A, d as _ } from "./data2.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
const F = (t) => t.axes[0].needle?.visible ?? !0, L = (t, e) => {
  e.axes[0].needle === void 0 && (e.axes[0].needle = a()), e.axes[0].needle.visible = t;
}, w = (t) => t.axes[0].needle?.symbol, T = (t, e) => {
  e.axes[0].needle === void 0 && (e.axes[0].needle = a()), e.axes[0].needle.symbol = t;
}, O = (t) => t.axes[0].needle?.startWidth, W = (t, e) => {
  e.axes[0].needle === void 0 && (e.axes[0].needle = a()), e.axes[0].needle.startWidth = t;
}, U = (t) => t.axes[0].needle?.endWidth, V = (t, e) => {
  e.axes[0].needle === void 0 && (e.axes[0].needle = a()), e.axes[0].needle.endWidth = t;
}, D = (t) => t.axes[0].needle?.innerRadius, E = (t, e) => {
  e.axes[0].needle === void 0 && (e.axes[0].needle = a()), e.axes[0].needle.innerRadius = t;
}, N = (t) => t.axes[0].needle?.displayPin ?? !1, M = (t, e) => {
  e.axes[0].needle === void 0 && (e.axes[0].needle = a()), e.axes[0].needle.displayPin = t;
}, R = (t) => t.axes[0].innerLabel?.visible ?? !0, G = (t, e) => {
  e.axes[0].innerLabel === void 0 && (e.axes[0].innerLabel = f()), e.axes[0].innerLabel.visible = t;
}, k = (t) => t.axes[0].innerLabel?.content, P = (t, e) => {
  e.axes[0].innerLabel === void 0 && (e.axes[0].innerLabel = f()), t !== void 0 && (e.axes[0].innerLabel.content = t);
}, $ = (t) => t.axes[0].ticks?.visible ?? !0, q = (t, e) => {
  e.axes[0].ticks === void 0 && (e.axes[0].ticks = {
    type: h.GaugeAxisTick
  }), e.axes[0].ticks.visible = t;
}, j = (t) => t.axes[0].labelsIncrement, X = (t, e) => {
  e.axes[0].labelsIncrement = t;
}, B = (t) => t.axes[0].onlyShowFirstAndLastLabels ?? !1, H = (t, e) => {
  e.axes[0].onlyShowFirstAndLastLabels = t;
}, Q = (t) => t.series[0]?.valueConversion, Y = (t, e) => {
  e.series[0] !== void 0 && (e.series[0].valueConversion = t);
}, y = (t) => t.series[0]?.featureIndex, c = (t) => {
  const { featureIndex: e, config: i, layerInfo: s, commonStrings: n } = t, r = g(i), p = l(i);
  e === null ? delete i.series[0].featureIndex : i.series[0] !== void 0 && (i.series[0].featureIndex = e), o({ config: i, layerInfo: s, field: r, aggregationType: p, commonStrings: n });
}, z = (t) => t.subType ?? x.StatisticGauge, J = (t) => {
  const { config: e, field: i, aggregationType: s } = t;
  if (s !== u.NoAggregation) {
    const n = y(e), r = d(n) ? {} : {
      outStatistics: [
        {
          statisticType: s,
          onStatisticField: i,
          outStatisticFieldName: `${s}_${i}`
        }
      ]
    };
    e.series[0].query = r;
  }
}, K = (t) => {
  const { config: e, layerInfo: i, commonStrings: s, field: n, aggregationType: r } = t;
  e.title && (e.title.content.text = A({
    config: e,
    layerInfo: i,
    commonStrings: s,
    numericFields: [n],
    aggregationType: r
  }));
}, o = (t) => {
  const { config: e, field: i, aggregationType: s } = t;
  e.series[0] === void 0 && (e.series = [m({})]);
  const n = d(e.series[0]?.featureIndex);
  let r = n ? i : `${s}_${i}`;
  n && i.startsWith(`${s}_`) && (r = i.replace(`${s}_`, "")), e.series[0].x = r, J({ config: e, field: i, aggregationType: s }), K(t);
}, l = (t) => t.series[0]?.query?.outStatistics?.[0]?.statisticType ?? u.Count, Z = (t) => {
  const { config: e, layerInfo: i, commonStrings: s, aggregationType: n } = t, r = g(e);
  o({
    config: e,
    layerInfo: i,
    commonStrings: s,
    field: r,
    aggregationType: n
  });
}, d = (t) => typeof t == "number" && t >= 0, g = (t) => d(t.series[0]?.featureIndex) ? t.series[0]?.x : t.series[0]?.query?.outStatistics?.[0]?.onStatisticField ?? "", ee = (t) => {
  const { field: e, config: i, layerInfo: s, commonStrings: n } = t, r = l(i);
  o({ config: i, layerInfo: s, commonStrings: n, field: e, aggregationType: r });
}, te = (t) => t.innerRadius ?? 50, ie = (t, e) => {
  e.innerRadius = t;
}, se = (t) => t.startAngle ?? -90, ne = (t, e) => {
  e.startAngle = t;
}, re = (t) => t.endAngle ?? 270, ae = (t, e) => {
  e.endAngle = t;
};
function oe(t) {
  return b(t);
}
class le extends v {
  constructor() {
    super(...arguments), this._chartType = h.GaugeSeries;
  }
  /**
   * Generate the proper chart title given the current config.
   *
   * @returns {string}
   */
  generateChartTitle() {
    return oe(this.commonStrings);
  }
  async setup(e) {
    await this.loadConfigFromLayer(e), typeof this.resolveSetup == "function" && this.resolveSetup();
  }
  // ---------------------------------------------------------------------------------------------
  // Data Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Data field used for the gauge.
   */
  get field() {
    return g(this._config);
  }
  set field(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      ee({ field: e, config: this._config, layerInfo: this.layerInfo, commonStrings: this.commonStrings }), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("field");
    });
  }
  /**
   * Aggregation type used for the gauge.
   *
   * Must be one of the values allowed by `WebChartStatisticType`, excluding `"no_aggregation"`.
   */
  get aggregationType() {
    return l(this._config);
  }
  set aggregationType(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      Z({
        aggregationType: e,
        config: this._config,
        layerInfo: this.layerInfo,
        commonStrings: this.commonStrings
      }), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("aggregationType");
    });
  }
  /**
   * Inner radius of the gauge.
   */
  get innerRadius() {
    return te(this._config);
  }
  set innerRadius(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      ie(e, this._config), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("innerRadius");
    });
  }
  /**
   * Start angle of the gauge.
   */
  get startAngle() {
    return se(this._config);
  }
  set startAngle(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      ne(e, this._config), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("startAngle");
    });
  }
  /**
   * End angle of the gauge.
   */
  get endAngle() {
    return re(this._config);
  }
  set endAngle(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      ae(e, this._config), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("endAngle");
    });
  }
  // ---------------------------------------------------------------------------------------------
  // Series Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Conversion to apply to the gauge value.
   */
  get valueConversion() {
    return Q(this._config);
  }
  set valueConversion(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      Y(e, this._config), this.emitConfigUpdate("valueConversion");
    });
  }
  /**
   * Gets the index of the feature to be rendered.
   *
   * @remarks
   * This property will be ignored for a statistic gauge (indicated via `WebGaugeChart.subType` property).
   * For feature-based gauge, if this property is not present, the first feature will be used (featureIndex = 0)
   */
  get featureIndex() {
    return y(this._config);
  }
  set featureIndex(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      c({
        featureIndex: e,
        config: this._config,
        layerInfo: this.layerInfo,
        commonStrings: this.commonStrings
      }), this.emitConfigUpdate("featureIndex");
    });
  }
  /**
   * Removes the existing feature index from the config object
   */
  removeFeatureIndex() {
    this.guardSetterFromAsyncOverwrite(() => {
      c({
        featureIndex: null,
        config: this._config,
        layerInfo: this.layerInfo,
        commonStrings: this.commonStrings
      }), this.emitConfigUpdate("removeFeatureIndex");
    });
  }
  /**
   * Type of Gauge chart, like FeatureGauge and StatisticGauge.
   *
   * @remarks When this property is not specified, it will be defaulted to GaugeChartSubTypes.StatisticGauge.
   */
  get gaugeSubType() {
    return z(this._config);
  }
  // ---------------------------------------------------------------------------------------------
  // Axes Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Visibility of the gauge's needle.
   */
  get needleVisibility() {
    return F(this._config);
  }
  set needleVisibility(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      L(e, this._config), this.emitConfigUpdate("needleVisibility");
    });
  }
  /**
   * Symbol of the gauge's needle.
   */
  get needleSymbol() {
    return w(this._config);
  }
  set needleSymbol(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      T(e, this._config), this.emitConfigUpdate("needleSymbol");
    });
  }
  /**
   * Start width of the gauge's needle.
   */
  get needleStartWidth() {
    return O(this._config);
  }
  set needleStartWidth(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      W(e, this._config), this.emitConfigUpdate("needleStartWidth");
    });
  }
  /**
   * End width of the gauge's needle.
   */
  get needleEndWidth() {
    return U(this._config);
  }
  set needleEndWidth(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      V(e, this._config), this.emitConfigUpdate("needleEndWidth");
    });
  }
  /**
   * Inner radius of the gauge's needle.
   */
  get needleInnerRadius() {
    return D(this._config);
  }
  set needleInnerRadius(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      E(e, this._config), this.emitConfigUpdate("needleInnerRadius");
    });
  }
  /**
   * Whether to display the pin for the gauge's needle.
   */
  get needleDisplayPin() {
    return N(this._config);
  }
  set needleDisplayPin(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      M(e, this._config), this.emitConfigUpdate("needleDisplayPin");
    });
  }
  /**
   * Whether the inner label is visible.
   */
  get innerLabelVisible() {
    return R(this._config);
  }
  set innerLabelVisible(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      G(e, this._config), this.emitConfigUpdate("innerLabelVisible");
    });
  }
  /**
   * Content symbol for the inner label.
   */
  get innerLabelContent() {
    return k(this._config);
  }
  set innerLabelContent(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      P(e, this._config), this.emitConfigUpdate("innerLabelContent");
    });
  }
  /**
   * Whether axis ticks are visible.
   */
  get axisTickVisibility() {
    return $(this._config);
  }
  set axisTickVisibility(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      q(e, this._config), this.emitConfigUpdate("axisTickVisibility");
    });
  }
  /**
   * Labels increment for the gauge.
   */
  get labelsIncrement() {
    return j(this._config);
  }
  set labelsIncrement(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      X(e, this._config), this.emitConfigUpdate("labelsIncrement");
    });
  }
  /**
   * Whether to only show the first and last axis labels.
   */
  get onlyShowFirstAndLastLabels() {
    return B(this._config);
  }
  set onlyShowFirstAndLastLabels(e) {
    this.guardSetterFromAsyncOverwrite(() => {
      H(e, this._config), this.emitConfigUpdate("onlyShowFirstAndLastLabels");
    });
  }
  // ---------------------------------------------------------------------------------------------
  // Protected Methods
  // ---------------------------------------------------------------------------------------------
  generateDefaultConfig() {
    const e = S(this.commonStrings);
    return e.series = [m({ objectIDField: this.layerInfo?.objectIdField })], e;
  }
}
_(le, [C, I]);
export {
  le as GaugeModel
};
