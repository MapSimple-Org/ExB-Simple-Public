/// <reference types="@arcgis/core/interfaces.d.ts" />
import { IFeatureLayer, IField, SupportedLayer, WebChart, WebChartDataFilters, WebChartQuery } from '../../spec';
import { default as FeatureLayer } from '@arcgis/core/layers/FeatureLayer.js';
import { default as SubtypeGroupLayer } from '@arcgis/core/layers/SubtypeGroupLayer.js';
import { default as Renderer } from '@arcgis/core/renderers/Renderer';
import { default as FeatureLayerView } from '@arcgis/core/views/layers/FeatureLayerView';
import { IFeatureType, QueryObject, QueryObjectProps, RendererInfo, SubtypeInfo } from './interfaces';
/**
 * Returns the renderer type and the field and normalization field if applicable.
 * @param layerRenderer
 */
export declare function getRendererInfo(layerRenderer?: Renderer): RendererInfo;
/**
 * Function creating a FeatureLayer from a set of parameters.
 * It returns the created Feature Layer.
 * It is memoized (cached) to avoid multiple requests for a same feature layer.
 */
export declare const getFeatureLayer: (featureLayer: IFeatureLayer) => Promise<FeatureLayer>;
/**
 * Returns the proper query object to use according to the situation.
 * If can return either a FeatureLayer or a FeatureLayerView (and possibly nothing)
 * @param props
 */
export declare function getQueryObject(props: QueryObjectProps): Promise<QueryObject>;
/**
 * Fetches all the fields info a feature layer.
 * @param queryObject
 * @param usePopupTemplateFieldsInfo whether to use the aliases from the popupTemplate
 */
export declare function fetchLayerFieldsInfo(queryObject: QueryObject, usePopupTemplateFieldsInfo?: boolean): Promise<IField[]>;
/**
 * Looks into a list of fields for one having a specific name, and returning it if found.
 * Returns nothing if the field is not found.
 * @param fields The list of fields containing all the information regarding the fields, including the name
 */
export declare function getFieldFromName(fieldName: string, fields?: IField[]): IField | undefined;
/**
 * Look for an OID field among a list of feature layer fields.
 * The function `find` used can return in theory an `undefined` value, but in our case we're sure to bring back
 * the field ID (every feature layer has one).
 * As a consequence the backup value returned if `oidField.name` is `undefined` doesn't matter because it will not happen.
 */
export declare function getObjectIdField(layerFieldsInfo: IField[]): string;
/**
 * Checks whether the given field has a valid numeric type.
 * Fields descriptions are [here](http://resources.esri.com/help/9.3/ArcGISEngine/ArcObjects/esriGeoDatabase/esriFieldType.htm).
 * @param field
 */
export declare function isNumericField(field: IField): boolean;
/**
 * Checks whether the given field has a valid date type.
 * Fields descriptions are [here](http://resources.esri.com/help/9.3/ArcGISEngine/ArcObjects/esriGeoDatabase/esriFieldType.htm).
 * @param field
 */
export declare function isDateField(field: IField): boolean;
/**
 * Checks whether the given field has a valid integer type.
 * Fields descriptions are [here](http://resources.esri.com/help/9.3/ArcGISEngine/ArcObjects/esriGeoDatabase/esriFieldType.htm).
 * @param field
 */
export declare function isIntegerField(field: IField): boolean;
/**
 * Returns list of date field names from an array of fields of type IField
 * @param fieldsInfo
 */
export declare function getLayerDateFields(fieldsInfo: IField[]): string[];
/**
 * Returns list of numeric field names from an array of fields of type IField
 * @param fieldsInfo
 */
export declare function getLayerNumericFields(fieldsInfo: IField[]): string[];
/**
 * Retrieve the subtype name from the subtype id, if available.
 * Otherwise, just simply returns the original value.
 * @param props.subtypeInfo The subtypeInfo which consists of a typeIdField and a list of subtypes.
 * @param props.fieldName The field name to check against the subtype's typeIdField
 * @param props.fieldValueToMatch The field value, mainly the subtype id, to find the matching subtype name (if it's from a field that holds the subtypes for the features).
 * @returns The matching subtype name if it's a subtype field; otherwise undefined.
 * //TODO: may need to revise regrading the typeIdField property (See https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/42555)
 */
declare function getSubtypeName(props: {
    subtypeInfo?: SubtypeInfo;
    fieldName: string;
    fieldValueToMatch: number | string;
}): string | undefined;
/**
 * Get the feature types from the layer, including all coded-value domains
 * defined in the feature types.
 * @param layer The layer to retrieve the information.
 * @param propName Whether to fetch the types or subtypes
 * @returns the feature types or undefined
 */
declare function getFeatureTypes(layer: FeatureLayer, propName: "types"): IFeatureType[] | undefined;
declare function getFeatureTypes(layer: FeatureLayer | SubtypeGroupLayer, propName: "subtypes"): IFeatureType[] | undefined;
/**
 * Retrieve subtype information from the query object.
 * @param queryObject The query object from which to retrieve the feature layer.
 * @returns subtype info like typeIdField and the subtypes, if defined; otherwise undefined.
 * //TODO: may need to revise regrading the typeIdField property (See https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/42555)
 */
export declare function getLayerSubtypeInfo(queryObject: QueryObject): SubtypeInfo | undefined;
/**
 * Get the field description if the field contains subtype or domain value.
 * This field description is mainly for displaying purpose (while its id is used in queries).
 * @param props.fieldName the name of the field
 * @param props.fieldValueToMatch the value to search for a match in the subtypes or domains; if the field contains subtype or domain it's likely the id.
 * @param props.subtypeInfo the subtype information, which includes typeIdField and types.
 * @param props.fieldList the list of fields
 * @returns The field description if available; otherwise undefined.
 */
export declare function getFieldDescription(props: {
    fieldName: string;
    fieldValueToMatch: number | string;
    subtypeInfo?: SubtypeInfo;
    fieldList?: IField[];
}): string | undefined;
/**
 * Returns feature layer field names used in its renderer.
 * @param {FeatureLayer} layer
 * @returns {Promise<string[]>}
 */
export declare function getRendererFieldNames(layer: SupportedLayer): Promise<string[]>;
/**
 * Returns the ArcGIS server's rest/info url of the feature server given a feature layer url.
 * @example   getServerRestInfo(https://servicesdev.arcgis.com/b5ADkBof6gCHCFQm/arcgis/rest/services/Steph_Curry/FeatureServer/2
 * returns https://servicesdev.arcgis.com/b5ADkBof6gCHCFQm/arcgis/rest/info
 * @param {string} resUrl
 * @returns {string}
 */
declare function getServerRestInfo(resUrl: string): string;
/**
 * Returns a boolean to indicate if the feature layer is on standard feature data store or not.
 * https://doc.arcgis.com/en/arcgis-online/reference/faq.htm#anchor7
 * @param {FeatureLayer} layer
 * @returns {Promise<boolean>}
 */
export declare function isStandardLayer(layer: SupportedLayer): Promise<boolean>;
/**
 * Finds the matching field name for a given layer based on the fieldToMatch parameter.
 * @param {QueryObject} props.queryObject
 * @param {string} props.fieldToMatch
 * @param {boolean} props.returnUndefinedIfNotFound
 * @returns {Promise<string>}
 */
export declare function findMatchingLayerFieldName(props: {
    queryObject: QueryObject;
    fieldToMatch: string;
    returnUndefinedIfNotFound?: boolean;
}): Promise<string>;
/**
 * Find the matching field in a list of fields based on the fieldToMatch parameter.
 * It first looks for a perfect match (case-sensitive), then for an approximate match (case-insensitive).
 * @param {IField[]} layerFieldList - The list of fields to search in.
 * @param {string} fieldToMatch - The field name to match.
 * @returns {IField | undefined} - The matching field if found, otherwise undefined.
 *
 * We look for a match in 2 steps:
 *
 * 1. Perfect match: the case of the fields is exactly the same. This helps when the layer has fields with the same name but with a
 * different case (e.g. "field" and "FiElD"). Refer to https://devtopia.esri.com/WebGIS/arcgis-charts/issues/8305
 *
 * 2: Approximate match: we upper-case the fields to compare them
 */
export declare function findMatchingField(layerFieldList: IField[], fieldToMatch: string): IField | undefined;
/**
 * Finds the matching layer fields for a list of fields.
 *
 * @param {(string[] | undefined)} props.fields
 * @param {SupportedLayer} props.queryObject
 * @param {boolean} props.returnUndefinedIfNotFound
 * @returns
 */
export declare function matchFieldsList(props: {
    fieldsList: string[] | undefined;
    queryObject: SupportedLayer;
    returnUndefinedIfNotFound?: boolean;
}): Promise<string[] | undefined>;
/**
 * Builds a WebChartQuery based on information coming from the runtime filters (chart options), the config and the data source.
 * The filters by attributes from all sources are all combined together (using the AND operator).
 * Regarding the other filters (by geometry, gdb version and time extent) only one of each can be applied. The runtime
 * filters are chosen over the config filters.
 * @param props.queryObject The query object (feature layer or feature layer view)
 * @param props.chartConfig The chart's config
 * @param props.runtimeDataFilters The runtime data filters
 * @param props.ignoreViewExtent Whether to ignore the view extent
 */
export declare function buildQueryConfig(props: {
    queryObject?: QueryObject;
    chartConfig: WebChart;
    runtimeDataFilters?: WebChartDataFilters;
    ignoreViewExtent?: boolean;
}): WebChartQuery;
/**
 * Ger the list of the fields used in the charts
 * @category Public
 *
 *
 * @param {WebChart[] | undefined} layer - the supported layer
 * @param {WebChart[] | undefined} chartList - List of charts stored in the layer
 *
 * @returns {Promise<string[]>} - The list of fields used in the charts
 */
export declare function getFieldsUsedInCharts(layer: SupportedLayer): Promise<string[]>;
/**
 * Fetches the fields used in the chart configuration and returns the matching fields from the feature layer.
 * @param {ChartConfig} config The chart configuration
 * @param {SupportedLayer} layer The feature layer
 *
 * @returns {Promise<string[]>} The list of matching fields
 */
export declare function extractFieldsUsedInConfig(config: WebChart, layer: SupportedLayer | undefined): Promise<string[]>;
/**
 * Get the list of layer fields from the series list of the chart config.
 * @param {SupportedLayer} layer The layer
 *
 * @returns {string[]} The list of layer fields
 */
export declare function extractFieldsFromConfigList(layer: SupportedLayer): Promise<string[]>;
/**
 * Finds the matching layer in the view based on the provided layer's portal item id.
 * The matching is done based on the portalItem id.
 * If no matching layer is found, returns `undefined`.
 * @param {__esri.MapView | __esri.SceneView | undefined} props.view The map or scene view
 * @param {string} props.portalItemId The portal item id of the layer
 *
 * @returns {FeatureLayerView | SupportedLayer | undefined} The matching layer in the view or undefined if not found
 *
 * @requires
 * - view
 * - portalItemId
 *
 * ```
 *
 * @example
 * ```ts
 * const matchingLayer = findMatchingLayerFromView({ view, portalItemId: 'abc123' });
 * ```
 *
 * @category Public
 */
export declare function findMatchingLayerFromView(props: {
    view?: __esri.MapView | __esri.SceneView;
    portalItemId: string;
}): FeatureLayerView | SupportedLayer | undefined;
export declare const layerPrivateFunctions: {
    getServerRestInfo: typeof getServerRestInfo;
    getSubtypeName: typeof getSubtypeName;
    getFeatureTypes: typeof getFeatureTypes;
};
export {};
