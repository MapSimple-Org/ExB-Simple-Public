import { default as Graphic } from '@arcgis/core/Graphic';
import { IExtent, IField, IStatisticDefinition, WebChart, WebChartBarChartSeries, WebChartBoxPlotSeries, WebChartCalendarDatePartsUnits, WebChartDataItem, WebChartDataItemValue, WebChartLineChartSeries, WebChartPieChartSeries, WebChartQuery, WebChartSeriesType } from '../../../../../spec';
import { DataInfo, QueryObject, ChartSubType, LimitBehavior } from '../../../../../utils';
import { ChartOptions, FetchDataProps } from '../../../interfaces';
import { ProcessUniqueQueryProps } from './interfaces';
/**
 * Returns the feature extent and the extent key for a feature.
 *
 * @param props.feature The feature to fetch the extent from
 * @param props.splitByField The split-by field from the config
 * @param props.chartSubType The chart subtype
 * @returns
 */
export declare function getFeatureGeometryExtent(props: {
    feature: Graphic;
    splitByField?: string;
    chartSubType?: ChartSubType;
}): {
    featureExtent: IExtent | undefined;
    featureExtentKey: string;
};
/**
 * Regroups all the data items related to a same category together.
 *
 * @param props.input The scattered list of data items
 * @param props.x The category field used to group the data
 * @param props.splitByField The split-by field from the config
 */
declare function mergeDataItems(props: {
    input: WebChartDataItem[];
    x: string;
    splitByField?: string;
}): WebChartDataItem;
/**
 * Group a dataset over a x field
 *
 * Notes: we regroup the data for:
 * - processed data on split-by bar and line charts
 * - selection data on multi-series bar and line charts
 *
 * @param props.data the input data to be grouped
 * @param props.x the category field used to group the data
 * @param props.splitByField the split-by field from the config
 */
export declare function groupDataByCategory(props: {
    data: WebChartDataItem[];
    x: string;
    splitByField?: string;
}): WebChartDataItem[];
/**
 * Calculates for each data item (category) for bar and line:
 *   - the category's sum
 *   - the percent for the first series
 *
 * @param data The chart's data
 * @param seriesConfig The series config
 * @returns
 */
declare function calculateSeriesPercent(data: WebChartDataItem[], seriesConfig: WebChartBarChartSeries[] | WebChartBoxPlotSeries[] | WebChartLineChartSeries[] | WebChartPieChartSeries[]): WebChartDataItem[];
/**
 * Calculate the Interquartile Range (IQR) for the given attributes and return the processed attributes objects with calculated IQR property .
 *   IQR is the difference between the first quartile and the third quartile.
 *   `@param` {WebChartBoxPlotSeries[]} seriesConfig - The list of series in the box plot chart config
 *   `@param` {WebChartDataItem} attributes - The data object containing the first and third quartile values.
 */
declare function calculateInterQuartileRange(seriesConfig: WebChartBoxPlotSeries[], attributes: WebChartDataItem): WebChartDataItem;
/**
 * Assigns the specified property to a best-guessed value from the query results.
 * If its upper-cased or lowercased corresponding properties (that are not coming from the config) exist, remove them as well.
 *
 * @param attributes The attributes associated with a feature returned from the query result
 * @param propertyNames The properties referencing the proper case
 */
export declare function restoreAttributesCase(attributes: WebChartDataItem, propertyNames: (string | undefined)[] | string): void;
/**
 * Builds a list of the outStatisticFieldName used in the config and restore their case to prevent a shift between
 * the query results' case and the config's.
 * See issues:
 * - https://devtopia.esri.com/webgis/arcgis-charts/issues/6038
 * - https://devtopia.esri.com/WebGIS/arcgis-charts/issues/7837
 *
 * @param attributes The attributes associated with a feature returned from the query result
 * @param seriesConfig The series config
 */
declare function restoreStatFieldNamesCase(attributes: WebChartDataItem, seriesConfig: WebChartSeriesType[]): void;
/**
 * This function goes through the properties of the dataItem and compare them with the outStatisticFieldNames
 * in the list of outStatistics. If a match is found, swap that property to its corresponding onStatisticField
 * property instead.
 *
 * Refer to issue https://devtopia.esri.com/webgis/arcgis-charts/issues/6018 for details
 *
 * @param dataItem The dataItem of which properties may change.
 * @param outStatistics The list of outStatistics to find the matching onStatisticFields for the properties in the dataItem.
 */
declare function swapStatFieldNamesToStatisticFields(dataItem: WebChartDataItem, outStatistics: IStatisticDefinition[]): WebChartDataItem;
/**
 * Since the series's dataFields.valueY was set to `${y}_${splitByValue},
 * we need to add a new property to the dataItem using that format and populate it with the value from to the y property.
 *
 * @param props.dataItem The dataItem of which properties are to be manipulated.
 * @param props.splitByField The split-by-field
 * @param props.y The y property for all series.
 */
declare function renameYFieldForSplitByNoAggregation(props: {
    dataItem: WebChartDataItem;
    splitByField: string;
    y: string;
}): void;
/**
 * Removes a prefix added to the box plot out statistic field names by `buildUniqueBoxPlotOutStatistics()`.
 * The prefix was added to avoid the queries to fail on some specific services. Refer to https://devtopia.esri.com/WebGIS/arcgis-charts/issues/7376
 *
 * @param attributes The attributes to be modified
 * @param y The numeric field name used as a prefix
 */
declare function removeBoxPlotOutStatisticFieldNamePrefix(attributes: WebChartDataItem, y: string): void;
/**
 * Trims the number of categories based on the provided `maxCategoryCount`. This is possible only for charts having
 * a query response for which each result is a category. If a result contains potentially multiple categories it will
 * be handled by the `limitCategories()` function.
 *
 * @param props.queryResponse The query response to be trimmed
 * @param props.chartConfig The chart configuration
 * @param props.maxCategoryCount The maximum number of categories to keep
 */
declare function trimCategories(props: {
    queryResponse: Graphic[];
    chartConfig: WebChart;
    maxCategoryCount?: number;
}): Graphic[];
/**
 * Limits the number of categories based on the provided `maxCategoryCount`.
 * This function is called for each data item and will decide whether to keep the item or not.
 *
 * @param props.attributes The attributes to be checked
 * @param props.uniqueCategoryList The list of unique categories to keep track of how many categories have been processed
 * @param props.maxCategoryCount The maximum number of categories to keep
 * @param props.x The x field
 * @param props.chartSubType The chart sub-type
 */
declare function limitCategories(props: {
    attributes: WebChartDataItem;
    uniqueCategoryList: Set<WebChartDataItemValue>;
    maxCategoryCount?: number;
    x: string;
    chartSubType: ChartSubType;
}): boolean;
/**
 * Function executing a unique query and processing its results.
 *
 * @param props
 */
export declare function processUniqueQueryResults(props: ProcessUniqueQueryProps): Promise<WebChartDataItem[]>;
/**
 * Returns the number total of elements (bar | markers | slices) to be displayed on a chart.
 * It considers the chart will display all the categories/dates (filter on).
 * TODO: that is only necessary because the REST API doesn't return (yet?) the features for which the result (sum, count...) is 0.
 *
 * @param props
 */
export declare function getTotalElementCount(props: {
    chartConfig: WebChart;
    queryObject: QueryObject;
    queryConfig: WebChartQuery;
    behaviorAfterLimit?: LimitBehavior;
    numberMaxOfFeaturesToFetch?: number;
    isGaugeByFeature?: boolean;
}): Promise<{
    categoryOrDateCount?: number;
    elementCount?: number;
}>;
/**
 * Sort bar/line/pie chart data.
 * No sorting will be performed if no sorting instruction is provided via the chart config's `orderOptions.data` property.
 * Also, if it's a time binning series, the data is already sorted by the query and other routines, we won't need to resort them.
 *
 * @param props.arrayToSort The data array to sort
 * @param props.chartConfig The chart's config
 * @param props.fieldList The layer field list
 * @param props.isTimeBinningSeries Whether the series is a time binning series
 */
export declare function sortFetchedData(props: {
    arrayToSort: WebChartDataItem[];
    chartConfig: WebChart;
    fieldList?: IField[];
    isTimeBinningSeries?: boolean;
}): void;
/**
 * Fetching the data for multiple types of chart.
 *
 * @param props
 */
export declare function fetchFinishedGenericChartData(props: FetchDataProps): Promise<DataInfo>;
/**
 * Generates an array of values based on the given unit
 * @param unit The unit used to generate the values to return
 * @returns an array of string values, from "1" to the maximum value of the unit (e.g. "12" for MonthOfYear)
 */
declare function getExpectedValuesFromDatePartsUnit(unit: WebChartCalendarDatePartsUnits): string[] | undefined;
/**
 * Fetching the data for a heat chart.
 * It fetches the data from the attribute bins and processes it to match the heat chart data structure.
 * @param props The list of properties required to fetch the data
 */
export declare function fetchFinishedHeatChartData(props: FetchDataProps): Promise<DataInfo>;
/**
 * Function trimming the temporal dataset by considering the rendering limits.
 * @param props.chartConfig The chart's config
 * @param props.options The chart's options
 * @param props.data The data to trim
 */
declare function trimTemporalDataset(props: {
    chartConfig: WebChart;
    options?: ChartOptions;
    data: WebChartDataItem[];
}): WebChartDataItem[];
/**
 * Fetching the data for specifically a line chart using time binning options.
 *
 * @param props
 */
export declare function fetchFinishedBinnedTemporalData(props: FetchDataProps): Promise<DataInfo>;
/**
 * Fetching selection data for multiple types of chart.
 * This function is a subset of `fetchFinishedGenericChartData` and was created to avoid bringing too much
 * complexity to it. They need to evolve together if the data fetching pattern changes.
 *
 * @param props
 */
export declare function fetchFinishedGenericChartSelectionData(props: FetchDataProps): Promise<DataInfo>;
/**
 * Fetching selection data for box plot.
 *
 * @param props.chartConfig The chart config
 * @param props.queryConfig The query config
 * @param props.queryObject The query object
 * @param props.options The runtime chart options
 * @param props.errorStrings The t9n error strings
 * @param props.abortKey The abort key to cancel queries
 */
export declare function fetchFinishedBoxPlotSelectionData(props: FetchDataProps): Promise<DataInfo>;
export declare const commonUtilsSummarizeDataPrivateFunctions: {
    restoreStatFieldNamesCase: typeof restoreStatFieldNamesCase;
    mergeDataItems: typeof mergeDataItems;
    removeBoxPlotOutStatisticFieldNamePrefix: typeof removeBoxPlotOutStatisticFieldNamePrefix;
    calculateSeriesPercent: typeof calculateSeriesPercent;
    calculateInterQuartileRange: typeof calculateInterQuartileRange;
    getFeatureGeometryExtent: typeof getFeatureGeometryExtent;
    swapStatFieldNamesToStatisticFields: typeof swapStatFieldNamesToStatisticFields;
    renameYFieldForSplitByNoAggregation: typeof renameYFieldForSplitByNoAggregation;
    trimCategories: typeof trimCategories;
    limitCategories: typeof limitCategories;
    getExpectedValuesFromDatePartsUnit: typeof getExpectedValuesFromDatePartsUnit;
    trimTemporalDataset: typeof trimTemporalDataset;
};
export {};
