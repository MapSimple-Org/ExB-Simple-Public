import { IExtent, IField, TimeIntervalInfo, ValueConversion, WebBoxPlot, WebChart, WebChartBin, WebChartDataItem, WebChartDataItemValue, WebChartDataTypes, WebChartSeriesType, WebGaugeChart, WebChartDataTransformations, WebChartSortOrderKinds } from '../../../../../spec';
import { ChartElementLimit, SelectionIndexes, LimitBehavior } from '../../../../../utils';
import { ChartOptions } from '../../../interfaces';
import { DataUpdateNeededDetails } from './interfaces';
/**
 * Merges an array of IExtent into one IExtent
 *
 * @param extentList
 * @returns
 */
export declare function mergeExtents(extentList?: IExtent[]): IExtent | undefined;
/**
 * Checks in the data context if some extra values has been stored.
 * - `typeOrDomainIdValue` is used for when preferLabel is false
 * - `originalCategoryValue` is used for the non-aggregated bar charts in order to handle the duplicated
 *   category names. In that case the categories are replaced by a unique key, different from the original category name.
 * - `originalDateValue` is used for storing the original non formatted category when it's a date
 * - `defaultPieFromFieldsName` is used by pie chart from field.
 *
 * @param props.value The default value
 * @param props.dataContext The data context
 * @param props.useRendererLabel Whether to use the renderer label
 * @param props.specificField A specific field to look for
 * @param props.preferLabel Whether to use field label instead of value
 * @param props.keepNullValues Whether to keep the null values
 * @param props.config The chart's config
 */
export declare function getXAxisValueFromContext(props: {
    value: Date | number | string;
    dataContext?: WebChartDataItem;
    useRendererLabel?: boolean;
    specificField?: string;
    preferLabel?: boolean;
    keepNullValues?: boolean;
    config?: WebChart;
}): Date | number | string;
/**
 * Looks for the original x value in the data context. Chooses by order of priority:
 * - the type or domain id value
 * - the original category value
 *
 * @param dataContext The data context
 */
export declare function getOriginalXValueFromContext(dataContext?: WebChartDataItem): WebChartDataItemValue | undefined;
/**
 * Sorting an array WebChartDataItem by either ascending or descending order.
 *
 * @param props.arrayToSort The array to sort
 * @param props.sortingField The field to sort by
 * @param props.orderBy The order by
 * @param props.forceAscendingOrder Whether to force the ascending order; only applies for non-heat charts
 * @param props.isNonAggregated Whether the chart is non-aggregated; only applies for non-heat charts
 * @param props.sortByCategory Whether to sort by the x-axis field; only applies for non-heat charts
 * @param props.preferLabel Whether to use data labels; only applies for non-heat charts
 * @param props.isPieOrByFieldsChart Whether it is a pie or by fields chart
 */
export declare function sortWebChartDataItemsUsingDirectionalSort(props: {
    arrayToSort: WebChartDataItem[];
    sortingField: string;
    orderBy?: WebChartSortOrderKinds;
    forceAscendingOrder?: boolean;
    isNonAggregated?: boolean;
    sortByCategory?: boolean;
    preferLabel?: boolean;
    isPieOrByFieldsChart?: boolean;
}): void;
/**
 * Sorting an array WebChartDataItem according to the predefined labels.
 *
 * @param props.arrayToSort The array to sort
 * @param props.orderBy The order by object
 * @param props.sortingField The field to sort by
 * @param props.fieldList The layer field list
 * @param props.isByFieldsChart Whether the chart is a by fields chart (bar, line, pie from fields)
 * @param props.preferLabel Whether or not to use labels like field alias
 */
export declare function sortWebChartDataItemsUsingPredefinedLabels(props: {
    arrayToSort: WebChartDataItem[];
    orderBy: string[];
    sortingField: string;
    fieldList?: IField[];
    isByFieldsChart?: boolean;
    preferLabel?: boolean;
}): void;
/**
 * This function reassigns the category/field name and stat value to the series x and y, while deleting the
 * technical field used during the rendering for technical reasons.
 *
 * @param modifiedData The data to revert
 * @param seriesConfig The series config
 */
export declare function revertPieFromFieldsProperties<T extends WebChartDataItem[] | WebChartDataTypes>(modifiedData: T, seriesConfig?: WebChart["series"]): T;
/**
 * This function reverts some changes done to process the chart's data set:
 * - removes the formatted dates used specifically for the queries
 * - switches back the values of the modified dates/categories to accommodate the rendering (axis labels, sort...)
 *
 * @param data The data containing modified x values
 * @param seriesConfig The series config
 */
export declare function revertOriginalXValues<T extends WebChartDataItem[] | WebChartDataTypes>(data: T, seriesConfig?: WebChart["series"]): T;
/**
 * Removes some technical properties including color ones from a data item
 *
 * @param dataItem The data item to sanitize
 * @returns The sanitized data item
 */
export declare function removeAdditionalStatisticsPerItem(dataItem: WebChartDataItem): WebChartDataItem;
/**
 * Before sending the event payload containing the data, we need to revert some changes done to sort the charts.
 *
 * @param data The data set to modify
 * @param seriesConfig The series config
 * @returns The sanitized data
 */
export declare function removeAdditionalStatistics(data: WebChartDataTypes, seriesConfig: WebChartSeriesType[]): WebChartDataTypes;
/**
 * Sanitizes data by reverting technical changes made to the data set.
 * The point is to send meaningful data to the user through events or the `chartWillRender()` function.
 *
 * @param props.data The data to sanitize
 * @param props.seriesConfig The series config
 */
export declare function sanitizeData(props: {
    data?: WebChartDataTypes;
    seriesConfig: WebChartSeriesType[];
}): WebChartDataTypes | undefined;
/**
 * A function to determine whether the scatterplot is aggregated.
 * It can use a map of statistics containing the number of points (computed from the data side) or
 * a data context object usually stored within each marker.
 *
 * @param props
 */
export declare function isScatterplotAggregated(props: {
    statsMap?: Map<string, number>;
    dataContext?: WebChartDataItem;
    chartLimits?: ChartElementLimit;
}): boolean;
/**
 * A function to determine whether a chart is aggregated.
 * Supports scatterplot, bar chart and pie chart. Defaults to true for the other types of chart.
 *
 * @param props
 */
export declare function isChartAggregated(props: {
    dataContext?: WebChartBin | WebChartDataItem;
    chartConfig: WebChart;
    chartLimits?: ChartElementLimit;
}): boolean;
/**
 * Converts the field to have the transform functions applied in where clause.
 * Use by histogram.
 *
 * @param xAxisField
 * @param type
 */
export declare function getTransformedQuery(xAxisField: string, type?: WebChartDataTransformations): string;
/**
 * Transform a date into a format that can be used for querying.
 * Ex:
 *   - 1629862814560 => "8/25/2021 3:40:14 AM"
 *   - new Date(2005, 5, 5, 5, 5, 5) => "6/5/2005 12:05:05 PM"
 *
 * @param date
 * @returns
 */
export declare function transformDateToQueryFormat(date: Date | number): number | string;
/**
 * Construct an array of WebChartDataItem using every key/value pairs from the input data (of type WebChartDataItem).
 *
 * Currently only Pie chart uses this function.
 *
 * @param data The data to convert
 * @param x The x field name
 * @param y The y field name
 * @param fieldList The field list
 */
export declare function convertMultipleNumericFieldsData(props: {
    dataToConvert: WebChartDataItem | undefined;
    x: string;
    y: string;
    fieldList?: IField[];
}): WebChartDataItem[];
/**
 * Compares two gauge configs and indicates whether the series value conversion changed
 *
 * @param oldConfig The previous config
 * @param newConfig The updated config
 */
declare function hasGaugeValueConversionChanged(oldConfig: WebChart, newConfig: WebChart): boolean;
/**
 * Compares two heat chart configs to see if binning has changed
 *
 * @param oldConfig The previous config
 * @param newConfig The updated config
 */
declare function hasHeatChartBinningChanged(oldConfig: WebChart, newConfig: WebChart): boolean;
/**
 * Compares two configs and indicates whether additional tooltip fields (only non-numeric) changed
 *
 * **NOTE**: (only for scatterplot)
 *
 * @param {WebChart} props.oldConfig The previous config
 * @param {WebChart} props.newConfig The updated config
 * @param {IField[]|undefined} props.fieldList The layer field list
 */
export declare function hasAdditionalTooltipFieldsChanged(props: {
    oldConfig: WebChart;
    newConfig: WebChart;
    fieldList?: IField[];
}): boolean;
/**
 * Compares two configs and indicates whether the color type change
 *
 * @param oldConfig The previous config
 * @param newConfig The updated config
 */
export declare function hasColorMatchChanged(oldConfig: WebChart, newConfig: WebChart): boolean;
/**
 * Compares two configs and indicates whether the legend visibilty changed
 *
 * @param oldConfig The previous config
 * @param newConfig The updated config
 */
export declare function hasHeatLegendConfigChanged(oldConfig: WebChart, newConfig: WebChart): boolean;
/**
 * Compares two configs and indicates whether the gradient rules changed
 *
 * @param oldConfig The previous config
 * @param newConfig The updated config
 */
export declare function hasGradientRulesChanged(oldConfig: WebChart, newConfig: WebChart): boolean;
/**
 * Compares the 'slices' array from the pie series, and indicates whether they are different.
 * Compare only the slices id and label to avoid false positives.
 *
 * @param props.oldConfig The previous chart config
 * @param props.newConfig The newest chart config
 */
export declare function hasSlicesConfigChanged(props: {
    oldConfig: WebChart;
    newConfig: WebChart;
}): boolean;
/**
 * Compares the queries from two configs and indicates whether a query changed.  Noted that the query comparison
 * includes the orderByFields from the orderOptions.
 *
 * A sort on the series is made before comparing to prevent a false positive on query reorder.
 *
 * @param props.oldConfig The former chart config
 * @param props.newConfig The new chart config
 * @param props.behaviorAfterLimit The chart's behavior once the data limit is reached
 */
declare function hasQueryChanged(props: {
    oldConfig: WebChart;
    newConfig: WebChart;
    behaviorAfterLimit?: LimitBehavior;
}): boolean;
declare function hasFilterBySelectionChanged(filterBySelection?: boolean, options?: ChartOptions): boolean;
export declare function hasDataForFilterBySelectionChanged(props: {
    currentSelectionOIDs?: number[];
    options?: ChartOptions;
}): boolean;
/**
 * Compares the `binTemporalData` property from two configs and returns true if they are identical, false otherwise
 *
 * @param oldConfig
 * @param newConfig
 */
declare function hasBinTemporalDataChanged(oldConfig: WebChart, newConfig: WebChart): boolean;
/**
 * Compares the split by value for each series element in the box plot config and returns true if the series has different split by value between new and old box plot config, false otherwise.
 *
 * @param oldSeries The former series config
 * @param newSeries The new series config
 */
export declare function hasSplitByValueChanged(oldSeries: WebChart["series"], newSeries: WebChart["series"]): boolean;
/**
 * Verify if the order of the numeric fields has changed
 *
 * @param oldSeries - The previous series config
 * @param newSeries - The new series config
 */
export declare function hasNumericFieldsChanged(oldSeries: WebChart["series"], newSeries: WebChart["series"]): boolean;
/**
 * Compares the `showMean` from two configs and indicates whether they are different
 *
 * @param oldConfig The former chart config
 * @param newConfig The new chart config
 */
declare function hasShowMeanChanged(oldConfig: WebBoxPlot | WebChart, newConfig: WebBoxPlot | WebChart): boolean;
/**
 * Indicates whether a change of value format type requires new data. Two cases require it:
 * - change from date format to numeric format
 * - specific to non aggregated charts: change from category format to value format
 *
 * @param oldConfig The former chart config
 * @param newConfig The new chart config
 */
declare function isNewDataRequiredForValueFormatChange(oldConfig: WebBoxPlot | WebChart, newConfig: WebBoxPlot | WebChart): boolean;
/**
 * Function saying if a data update is needed. We compare different properties from the former config and the new one
 * in order to decide if the update is needed.
 *
 * @param props
 */
export declare function isDataUpdateNeeded(props: {
    forceDataUpdate?: boolean;
    oldConfig: WebBoxPlot | WebChart;
    newConfig: WebBoxPlot | WebChart;
    options?: ChartOptions;
    formerFilterBySelection?: boolean;
    timeIntervalInfo?: TimeIntervalInfo;
    currentSelectionDataItems?: WebChartDataItem[];
    currentSelectionOIDs?: number[];
    currentSelectionIndexes?: SelectionIndexes;
    fieldList?: IField[];
}): {
    dataUpdateNeeded: boolean;
    updateNeededDetails: DataUpdateNeededDetails;
};
/**
 * Function used on temporal charts.
 * Indicates whether resetting the previously fetched binned data is necessary.
 * It is necessary when the time interval unit or any common data property changes.
 *
 * @param dataUpdateNeededDetails
 */
export declare function isBinnedServerDataResetNeeded(dataUpdateNeededDetails: DataUpdateNeededDetails): boolean;
/**
 * Check if the Pie chart data has slices with all positive or all negative values.
 *
 * Note: Pie with the following character is supported:
 * - no slice with positive and no slice with negative values
 * - the slices can have 0, null, or undefined values
 *
 * @param data the data to check for positive and negative values
 * @param fieldToCheckForValue to field containing the values
 */
export declare function checkForSupportedPieChart(data: WebChartDataItem[], fieldToCheckForValue: string): boolean;
/**
 * Calculates the limit for a given chart, considering a limit on the number of series and a limit
 * on the total number of elements on the chart.
 * For instance:
 * - if count total is 1,000, count per series is 100 and there are 5 series, the limit is 500
 * - if count total is 1,000, count per series is 100 and there are 20 series, the limit is 1,000
 *
 * @param props.countTotal The number max of elements for the whole chart
 * @param props.countPerSeries The number max of elements per series
 * @param props.numberOfSeries The number of series
 * @returns
 */
declare function getMultiSeriesLimit(props: {
    countTotal?: number;
    countPerSeries?: number;
    numberOfSeries: number;
}): number | undefined;
/**
 * Calculates the maximum number of features to fetch according to the runtime chart options 'chartLimits'.
 * For instance:
 * - on a pie chart, the limit is the maximum number of slices (`maxPieChartSliceCountTotal`)
 * - on a bar or line chart, the limits vary depending on number of series. Maximum number of series count is (`maxBarChartSeriesCount`) and (`maxLineChartSeriesCount`)
 *
 * @param chartConfig The chart's config
 * @param chartLimits The runtime chart limits
 */
export declare function getMaximumNumberOfFeaturesToFetch(chartConfig: WebChart | WebGaugeChart, chartLimits?: ChartElementLimit): number | undefined;
/**
 * Apply a conversion (from a factor and an offset) to a numeric value.
 * The factor is applied first and then the offset (when both are provided).
 *
 * @param value The value to convert
 * @param valueConversion The information regarding the conversion to apply
 * @returns The converted value, or the original value if the `valueConversion` is undefined or invalid
 */
export declare function applyValueConversion(value: number, valueConversion?: ValueConversion): number;
/**
 * Check if an input string represents a percentage value; meaning a string that:
 * - only contains digits (dot for decimal included), and
 * - has % symbol at the end (for LTR) or at the beginning (for RTL)
 * - the value falls between 0 - 100
 *
 * @param inputValue input string
 */
declare function isValidPercentValue(inputValue: string): boolean;
/**
 * Extract the value from the input string, without the %; valid percent value is between 0 - 100
 * it's safe that we extract upto 3 digits and not worry about having an invalid number like 100.5
 *
 * @param inputValue input string
 * @returns
 */
export declare function extractPercentValue(inputValue: string): number | undefined;
export declare const commonUtilsMiscPrivateFunctions: {
    getMultiSeriesLimit: typeof getMultiSeriesLimit;
    hasFilterBySelectionChanged: typeof hasFilterBySelectionChanged;
    hasBinTemporalDataChanged: typeof hasBinTemporalDataChanged;
    hasGaugeValueConversionChanged: typeof hasGaugeValueConversionChanged;
    isNewDataRequiredForValueFormatChange: typeof isNewDataRequiredForValueFormatChange;
    hasShowMeanChanged: typeof hasShowMeanChanged;
    hasHeatChartBinningChanged: typeof hasHeatChartBinningChanged;
    hasQueryChanged: typeof hasQueryChanged;
    isValidPercentValue: typeof isValidPercentValue;
};
export {};
