import * as I from "@arcgis/core/layers/support/fieldUtils.js";
import Q from "@arcgis/core/layers/support/FeatureReductionBinning.js";
import K from "@arcgis/core/layers/support/FeatureReductionCluster.js";
import * as T from "@arcgis/core/renderers/support/jsonUtils.js";
import L from "@arcgis/core/request.js";
import * as v from "@arcgis/core/core/sql.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
var b = /* @__PURE__ */ ((e) => (e.expression = "expression/", e.raster = "Raster.", e.relationship = "relationships/", e))(b || {});
const _ = ["feature"];
function H(e) {
  return "fieldConfigurations" in e && _.includes(e.type);
}
function x(e) {
  return e != null;
}
function ve(e, t, r) {
  const i = t.fieldName;
  if (i.includes(b.expression)) {
    const s = r.get(i);
    return s?.title ? s.title : i;
  } else return H(e) && e.getFieldConfiguration(i) ? e.getFieldAlias(i) || i : t.label || i;
}
function Oe(e, t, r) {
  let i = "";
  if (/^raster.(?:item|service)pixelvalue/iu.test(e))
    i = "number";
  else if (t.has(e)) {
    const s = t.get(e);
    i = s.type ? s.type.toLowerCase() : "";
  } else if (r.has(e)) {
    const s = r.get(e);
    i = s.returnType ? s.returnType.toLowerCase() : "";
  } else
    i = "number";
  return i;
}
async function be(e) {
  return new Map(
    (await z(e)).filter((t) => t.visible).map((t) => [t.name, t])
  );
}
function Re(e) {
  const t = /* @__PURE__ */ new Map();
  return e?.expressionInfos && e.expressionInfos.forEach((r) => {
    const i = `${b.expression}${r.name}`;
    t.set(i, r);
  }), t;
}
async function z(e) {
  return await new Promise((t, r) => {
    switch (e.type) {
      case "feature":
      case "ogc-feature":
      case "stream":
        t(e.fields);
        break;
      case "sublayer": {
        const i = e, s = i?.layer;
        s?.portalItem && s.url.includes("https://demographics") && s.url.includes(".arcgis.com") ? s.portalItem?.fetchData().then((n) => {
          if (n?.thematicGroup) {
            const a = new Map(
              i.fields.map((l) => [l.name, l])
            ), u = n.thematicGroup.fieldNames, c = [];
            u.forEach((l) => {
              a.has(l) && c.push(a.get(l));
            }), t(c);
          } else
            t(i.fields);
        }).catch((n) => {
          r(new Error(n));
        }) : t(i.fields);
        break;
      }
      case "imagery":
      case "imagery-tile":
      case "wcs":
        t(e.rasterFields);
        break;
      default:
        t("fields" in e ? e.fields ?? [] : []);
    }
  });
}
const X = (e) => e && !e.endsWith("/") ? `${e}/` : e;
function O(e) {
  return X(e.restUrl);
}
function P(e, t) {
  return J(e, t) || Y(e, t);
}
function J(e, t) {
  return e.owner === t.username;
}
function Y(e, t) {
  const r = e.owner, i = e.itemControl === "admin", s = ["esri_livingatlas", "esri_demographics", "esri_boundaries"];
  return e.portal?.isPortal && !J(e, t) && i && r?.includes("esri_") && // portal incorrectly returns "itemControl="admin" for esri owned items
  !s.includes(r) ? !1 : i;
}
function Z(e) {
  return e.typeKeywords?.includes("Spatiotemporal");
}
function N(e) {
  return e.typeKeywords?.includes("View Service");
}
function E(e) {
  return e.typeKeywords?.includes("Hosted Service");
}
function V(e) {
  return e.typeKeywords?.includes("Multi Services View");
}
function D(e) {
  return e?.hasViews && !e.sourceSchemaChangesAllowed;
}
async function G(e) {
  const t = e?.portalItem;
  if (!t)
    return await Promise.resolve(null);
  const r = t.portal;
  if (r?.user) {
    const i = `${O(r)}community/users/${r.user.username}`;
    return await L(i, {
      query: {
        f: "json",
        token: t.portal.credential?.token
      },
      responseType: "json"
    }).then(
      async (s) => {
        const n = s.data?.groups ?? [];
        return await Promise.resolve(n);
      },
      async () => await Promise.reject(new Error("Failed to fetch user groups"))
    );
  }
  return await Promise.resolve(null);
}
async function k(e) {
  const t = e?.portalItem;
  if (!t)
    return await Promise.resolve(null);
  const r = t.portal, i = `${O(r)}content/items/${t.id}/groups`;
  return await L(i, {
    query: {
      f: "json",
      token: t.portal.credential?.token
    },
    responseType: "json"
  }).then(
    async (s) => {
      const n = s.data?.admin ?? [], a = s.data?.member ?? [], u = s.data?.other ?? [], c = [...n, ...a, ...u];
      return await Promise.resolve(c);
    },
    async () => await Promise.reject(new Error("Failed to fetch item groups"))
  );
}
async function C(e, t, { relationshipType: r, direction: i }) {
  const s = `${O(t)}content/items/${e}/relatedItems`;
  return await L(s, {
    query: { f: "json", relationshipType: r, direction: i },
    responseType: "json"
  });
}
function A(e, t) {
  return e?.some(
    (r) => t?.some(
      (i) => r.id === i.id && r.capabilities.includes("updateitemcontrol")
    )
  );
}
function o(e, t) {
  return !e || !t ? !1 : e.toLocaleLowerCase() === t.toLocaleLowerCase();
}
async function xe(e) {
  const t = ["feature", "oriented-imagery"].includes(e.type), r = e?.portalItem, i = e.sourceJSON;
  if (!t || !r)
    return !1;
  const s = r.portal;
  if (!s?.user || N(r) || !E(r) || V(r) || D(i))
    return !1;
  const l = P(r, s.user), w = await G(e) ?? [], F = await k(e) ?? [], f = A(w, F);
  if (!l && !f)
    return !1;
  const m = await C(r.id, s, {
    relationshipType: "Service2Service"
  });
  return !(m?.data?.relatedItems && m.data.relatedItems.some(
    (S) => ["WMTS", "Map Service", "Vector Tile Service"].includes(S.type)
  ));
}
async function Te(e, t, r, i) {
  if (!r)
    return !1;
  const s = ["feature", "oriented-imagery"].includes(t.type), n = i?.item ?? t.portalItem, a = t.sourceJSON;
  if (!s || !n || !n.portal.user || !E(n) || N(n) || V(n) || D(a) || n.portal.isPortal && Z(n) || ["oid", "global-id", "geometry"].includes(r.type))
    return !1;
  const m = t.sourceJSON.geometryProperties, y = m?.shapeLengthFieldName, S = m?.shapeAreaFieldName;
  if (o(y, r.name) || o(S, r.name))
    return !1;
  const g = t.editFieldsInfo;
  if (g && (o(g.creationDateField, r.name) || o(g.creatorField, r.name) || o(g.editDateField, r.name) || o(g.editorField, r.name)) || o(t.objectIdField, r.name) || o(t.displayField, r.name) || o(t.typeIdField, r.name) || o(t.subtypeField, r.name) || t.timeInfo && (o(t.timeInfo.startField, r.name) || o(t.timeInfo.endField, r.name) || o(t.timeInfo.trackIdField, r.name)))
    return !1;
  if (!i?.ignoreLayerRenderer && t.featureReduction) {
    const d = /* @__PURE__ */ new Set();
    if (await I.collectFeatureReductionFields(
      d,
      t,
      t.featureReduction
    ), Array.from(d).some(
      (h) => o(h, r.name)
    ))
      return !1;
  }
  if (!i?.ignoreLayerRenderer && (await I.getRendererFields(t.renderer, t.fieldsIndex)).some((h) => o(h, r.name)))
    return !1;
  if (!i?.ignoreLayerLabelingInfo) {
    const d = t.labelingInfo?.map(
      (p) => p.labelExpressionInfo?.expression
    );
    if (d && ((await I.getExpressionFields(t, d)).some((q) => o(q, r.name)) || await j(t, r, "layer")))
      return !1;
  }
  if (!i?.ignoreLayerDefinitionExpression && t.definitionExpression && (await v.parseWhereClause(t.definitionExpression, t.fieldsIndex)).fieldNames.some((h) => o(h, r.name)) || await te(t, r, i) || await re(t, r))
    return !1;
  if (await ie(t, r))
    return await Promise.resolve(!1);
  if (await se(t, r))
    return await Promise.resolve(!1);
  if (ee(e, t, r) || t.relationships?.map((d) => d.keyField)?.some((d) => o(d, r.name)))
    return !1;
  const M = P(n, n.portal.user), $ = i?.userItemInfo?.userGroups ?? await G(t) ?? [], W = i?.userItemInfo?.itemGroups ?? await k(t) ?? [], B = A($, W);
  if (!M && !B)
    return !1;
  const R = i?.userItemInfo?.relatedItems ?? await C(n.id, n.portal, {
    relationshipType: "Service2Service"
  });
  return !(R?.data?.relatedItems && R.data.relatedItems.some(
    (p) => ["WMTS", "Map Service", "Vector Tile Service"].includes(p.type)
  ));
}
function ee(e, t, r) {
  if (!e)
    return !1;
  const i = e.map?.applicationProperties?.viewing?.search;
  if (i) {
    const s = i.layers?.find((n) => n.id === t.id);
    if (s) {
      const n = s?.field?.name;
      if (n)
        return o(n, r.name);
    }
  }
  return !1;
}
async function j(e, t, r) {
  const i = r === "layer" ? e.labelingInfo?.filter((a) => x(a.where)) : e.sourceJSON?.drawingInfo?.labelingInfo?.filter((a) => x(a.where));
  if (!i?.length)
    return !1;
  const s = [
    ...await Promise.all(
      i.map(
        async (a) => await v.parseWhereClause(a.where, e.fieldsIndex)
      )
    )
  ];
  let n = !1;
  for (let a = 0; a < s.length; a++) {
    const u = s[a].fieldNames?.some((c) => o(c, t.name));
    if (!n && u) {
      n = !0;
      break;
    }
  }
  return await Promise.resolve(n);
}
async function te(e, t, r) {
  const i = e.portalItem;
  if (!i)
    return !1;
  const s = `${O(i.portal)}content/items/${i.id}/data`, a = (r?.userItemInfo?.itemData ?? await L(s, {
    query: { f: "json" },
    responseType: "json"
  }))?.data;
  if (!a)
    return !1;
  if (a?.layers) {
    const c = a.layers.find((f) => f.id === e.layerId), l = c?.layerDefinition?.drawingInfo?.renderer, w = c?.layerDefinition?.featureReduction, F = c?.layerDefinition?.definitionExpression;
    if (!l && !w && !F)
      return !1;
    if (!r?.ignoreItemRenderer && l) {
      const f = T.fromJSON(l);
      if ((await I.getRendererFields(f, e.fieldsIndex)).some((S) => o(S, t.name)))
        return !0;
    }
    if (!r?.ignoreItemFeatureReduction && w && await U(e, t, w) || F && (await v.parseWhereClause(F, e.fieldsIndex)).fieldNames.some((y) => o(y, t.name)))
      return !0;
  }
  return !1;
}
async function re(e, t) {
  const r = e.sourceJSON, i = r?.drawingInfo?.renderer, s = r?.featureReduction;
  if (!i && !s)
    return !1;
  if (i) {
    const n = T.fromJSON(i);
    if ((await I.getRendererFields(n, e.fieldsIndex)).some((c) => o(c, t.name)))
      return !0;
  }
  return !!(s && await U(
    e,
    t,
    s
  ));
}
async function ie(e, t) {
  const i = e.sourceJSON?.drawingInfo?.labelingInfo;
  if (!i)
    return await Promise.resolve(!1);
  const s = i?.map(
    (n) => n.labelExpressionInfo?.expression
  );
  if (s) {
    if ((await I.getExpressionFields(e, s)).some((c) => o(c, t.name)))
      return await Promise.resolve(!0);
    if (await j(e, t, "service"))
      return await Promise.resolve(!0);
  }
  return await Promise.resolve(!1);
}
async function se(e, t) {
  const i = e.sourceJSON?.definitionQuery;
  return i ? (await v.parseWhereClause(i, e.fieldsIndex)).fieldNames.some((a) => o(a, t.name)) ? await Promise.resolve(!0) : await Promise.resolve(!1) : await Promise.resolve(!1);
}
async function U(e, t, r) {
  const i = r.type === "binning" ? Q.fromJSON(r) : K.fromJSON(r), s = /* @__PURE__ */ new Set();
  return await I.collectFeatureReductionFields(s, e, i), !!Array.from(s).some(
    (a) => o(a, t.name)
  );
}
export {
  Te as a,
  Re as b,
  xe as c,
  ve as d,
  O as e,
  Oe as f,
  be as g,
  x as i,
  H as s
};
