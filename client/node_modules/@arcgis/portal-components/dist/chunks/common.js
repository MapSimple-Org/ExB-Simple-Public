import i from "@arcgis/core/request.js";
import { once as l } from "@arcgis/core/core/reactiveUtils.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
const U = (t, e, s) => {
  let r = d(
    t,
    e,
    s
  );
  return r = f(s, r), r;
}, d = (t, e, s) => {
  const r = s.classificationMetadata.defaultValue, n = structuredClone(t) ?? { [e]: r };
  return n[e] ??= r, n;
}, C = (t, e) => t && Object.fromEntries(
  Object.entries(t).filter(([s]) => e.get(s)?.enabled !== !1)
), f = (t, e) => {
  const s = structuredClone(e);
  return Object.entries(t.attributes).forEach(([n, a]) => {
    if (s?.[n])
      return;
    const { uiElement: o, defaultValue: c } = a;
    switch (o) {
      case "date":
        s && (s[n] = p(a));
        break;
      case "multi-select":
      case "multi-grouped-select-nested":
        c && s && (s[n] = [c]);
        break;
      case "checkbox":
        c && s && (s[n] = c === "true");
        break;
      case "single-select":
      case "text":
        c && s && (s[n] = c);
        break;
    }
  }), s?.fgi || delete s?.fgiOptions, s;
}, p = (t) => {
  const e = /* @__PURE__ */ new Date(), { type: s, defaultDateTimeline: r, defaultDateTimelineUnits: n } = t;
  if (s === "date" && r && n)
    switch (n.toLowerCase()) {
      case "years":
        e.setFullYear(e.getFullYear() + r);
        break;
      case "months":
        e.setMonth(e.getMonth() + r);
        break;
      case "days":
        e.setDate(e.getDate() + r);
        break;
    }
  const a = (e.getMonth() + 1).toString(), o = e.getDate().toString();
  return `${e.getFullYear()}-${a.length === 1 ? `0${a}` : a}-${o.length === 1 ? `0${o}` : o}`;
}, G = (t, e, s) => {
  const r = e?.createdUser, n = e?.createdDate;
  return e = {
    [s]: t,
    ...r ? { createdUser: r } : {},
    ...n ? { createdDate: n } : {}
  }, e;
}, $ = async (t) => {
  try {
    if (!t)
      return !1;
    t.loaded || await t.load();
    const e = t.portal.user ?? await l(() => t?.portal.user);
    if (!e)
      return !1;
    const s = e.privileges.includes("portal:admin:updateItems");
    return u(t, e) || m(t, e) || s || t.access === "shared" && await g(t, e);
  } catch (e) {
    return console.error(e), !1;
  }
};
function u(t, e) {
  return t.owner === e.username;
}
function m(t, e) {
  const s = t.owner, r = t.itemControl === "admin", n = ["esri_livingatlas", "esri_demographics", "esri_boundaries"];
  return t.portal?.isPortal && !u(t, e) && r && s?.includes("esri_") && // portal incorrectly returns "itemControl="admin" for esri owned items
  !n.includes(s) ? !1 : r;
}
const g = async (t, e) => {
  const s = t.portal.restUrl, r = (await h(e, s)).result ?? [], n = (await y(t, s)).result ?? [];
  return r?.some(
    (a) => n?.some(
      (o) => a.id === o.id && a.capabilities.includes("updateitemcontrol")
    )
  );
}, h = async (t, e) => {
  const s = `${e}/community/users/${t.username}`;
  try {
    return { result: (await i(s, {
      query: {
        f: "json"
      },
      responseType: "json"
    })).data?.groups ?? [] };
  } catch {
    return { error: { code: "unhandledError" } };
  }
}, y = async (t, e) => {
  const s = t.id, r = `${e}/content/items/${s}/groups`;
  try {
    const n = await i(r, {
      query: {
        f: "json",
        method: "post"
      },
      responseType: "json"
    }), a = n.data?.admin ?? [], o = n.data?.member ?? [], c = n.data?.other ?? [];
    return { result: [...a, ...o, ...c] };
  } catch {
    return { error: { code: "unhandledError" } };
  }
}, k = (t, e) => {
  const s = Date.now(), r = t?.portal.user?.username ?? "", { createdUser: n = r, createdDate: a = s } = e ?? {};
  return { createdUser: n, createdDate: a, lastEditedUser: r, lastEditedDate: s };
};
export {
  C as a,
  G as b,
  $ as c,
  U as d,
  k as g,
  f as r
};
