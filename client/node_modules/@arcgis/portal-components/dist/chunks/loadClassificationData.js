import d from "@arcgis/core/core/Accessor.js";
import { property as n, subclass as p } from "@arcgis/core/core/accessorSupport/decorators.js";
import { a as m, v as u } from "./requests.js";
import { Deferred as h } from "@arcgis/toolkit/promise";
import { makeAccessorController as C } from "@arcgis/lumina/controllers/accessor";
import { Task as v } from "@lit/task";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
var w = Object.defineProperty, g = Object.getOwnPropertyDescriptor, e = (i, a, s, t) => {
  for (var r = t > 1 ? void 0 : t ? g(a, s) : a, l = i.length - 1, c; l >= 0; l--)
    (c = i[l]) && (r = (t ? c(a, s, r) : c(r)) || r);
  return t && r && w(a, s, r), r;
};
let o = class extends d {
  constructor() {
    super(...arguments), this.fetching = !1, this.status = "idle", this.error = void 0, this.portalUrl = void 0, this._itemClassificationValidationErrors = /* @__PURE__ */ new Map(), this.fetchingPromise = new h();
  }
  // #endregion
  // #region Accessors
  /**
   * The primary attribute of the classification schema metadata.
   */
  get primaryAttribute() {
    return this.portalClassificationSchema?.classificationMetadata.primaryAttribute;
  }
  // #endregion
  // #region Methods
  /**
   * Sets the portal classification schema and updates the portal URL.
   */
  setPortalClassificationData({
    portalUrl: i,
    schema: a
  }) {
    this.portalUrl = i, this.portalClassificationSchema = a, this.status = "loaded", this.fetchingPromise.resolve(!0);
  }
  /**
   * Sets the fetching state.
   */
  setFetching(i) {
    this.fetching = i;
  }
  /**
   * Loads and sets the classification schema from the portal.
   */
  async loadPortalClassificationData(i, { signal: a }) {
    this.status = "loading";
    const { result: s, error: t } = await m(i, a);
    if (t) {
      t.name === "AbortError" ? console.log("Request aborted.") : (this.error = t, this.status = "error", this.fetchingPromise.reject(t));
      return;
    } else
      this.setPortalClassificationData({ schema: s, portalUrl: i });
  }
  async validateClassification(i, a, s, t) {
    if (!a)
      return "";
    const r = i ? this._itemClassificationValidationErrors.get(i) : void 0;
    if (r)
      return await r;
    const l = (async () => {
      const { error: c } = await u(s, a, t ?? {});
      return c ? c?.details.raw.messages.join(", ") : "";
    })();
    return i && this._itemClassificationValidationErrors.set(i, l), i ? await this._itemClassificationValidationErrors.get(i) : await l;
  }
  // #endregion
};
e([
  n()
], o.prototype, "portalClassificationSchema", 2);
e([
  n()
], o.prototype, "fetching", 2);
e([
  n()
], o.prototype, "status", 2);
e([
  n()
], o.prototype, "error", 2);
e([
  n()
], o.prototype, "portalUrl", 2);
e([
  n()
], o.prototype, "_itemClassificationValidationErrors", 2);
o = e([
  p("custom.ClassificationModel")
], o);
let f;
function P(i) {
  return f ??= new o(i), f;
}
const A = C(P), S = (i) => new v(i, {
  task: async ([a], { signal: s }) => {
    if (!a)
      throw new Error("Portal item is required to load classification data");
    if (a.loaded || await a.load({ signal: s }), i.itemClassification = a.classification, i.classificationModel.status === "loading" && await i.classificationModel.fetchingPromise.promise, !i.portalItem?.portal.hasClassificationSchema) {
      i.classificationModel.setPortalClassificationData({
        portalUrl: a.portal.restUrl,
        schema: void 0
      });
      return;
    }
    // Only fetch if the data has not been fetched
    (i.classificationModel.status === "idle" || // or if the portal url changes
    i.classificationModel.status === "loaded" && i.classificationModel.portalUrl !== a.portal.restUrl) && await i.classificationModel.loadPortalClassificationData(a.portal.restUrl, { signal: s });
  },
  args: () => [i.portalItem]
});
export {
  S as c,
  A as u
};
