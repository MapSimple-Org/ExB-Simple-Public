/// <reference types="@arcgis/core/interfaces.d.ts" />
type ClassificationType = Readonly<{
    [index: string]: string | undefined;
    value: string;
    acronym?: string;
    backgroundColor?: string;
    textColor?: string;
}>;
type ClassificationMetadata = Readonly<{
    primaryAttribute: string;
    defaultValue: string;
    classificationValueProperties: ClassificationType[];
}>;
export type ValueOption = Readonly<{
    label: string;
    value: string;
}>;
export type BaseAttributesValues = Readonly<{
    label: string;
    description?: string;
    type: string;
    uiElement: string;
    isRequired?: boolean;
    defaultValue?: string;
    defaultDateTimeline?: number;
    defaultDateTimelineUnits?: string;
    validValues?: ValueOption[];
    validValuesMap?: Record<string, ValueOption[]>;
    isAttributeEnabled?: string;
    valueExpression?: string;
    attributeValidation?: string;
    arcadeResultLookup?: Record<string, ValueOption[]>;
    attributeCategory?: string;
    selectionDisplayOrder?: number;
    selectionDisplayLabel?: string;
    bannerOrder?: number;
    bannerLabel?: string;
    labelDelimiter?: string;
    labelTooltip?: string;
    valueDelimiter?: string;
    attributeDelimiter?: string;
}>;
/**
 * Create narrowed types for each of the possible UI elements.
 * Never is used to inform users that the property will never be defined
 * when uiElement is a specific value.
 */
type SingleSelectAttributesValues = BaseAttributesValues & Readonly<{
    uiElement: "single-select";
    validValues?: ValueOption[];
    validValuesMap?: never;
}>;
type MultiSelectAttributesValues = BaseAttributesValues & Readonly<{
    uiElement: "multi-select";
    validValues?: ValueOption[];
    validValuesMap?: never;
}>;
type MultiGroupedSelectNestedAttributesValues = BaseAttributesValues & Readonly<{
    uiElement: "multi-grouped-select-nested";
    validValuesMap: Record<string, ValueOption[]>;
    validValues?: never;
}>;
type CheckboxAttributesValues = BaseAttributesValues & Readonly<{
    uiElement: "checkbox";
    type: "boolean";
    validValues?: never;
    validValuesMap?: never;
    defaultDateTimeline?: never;
    defaultDateTimelineUnits?: never;
}>;
type DateAttributesValues = BaseAttributesValues & Readonly<{
    uiElement: "date";
    type: "date";
    defaultDateTimeline: number;
    defaultDateTimelineUnits: string;
    validValues?: never;
    validValuesMap?: never;
}>;
type TextAttributesValues = BaseAttributesValues & Readonly<{
    uiElement: "text";
    type: "string";
    validValues?: never;
    validValuesMap?: never;
    defaultDateTimeline?: never;
    defaultDateTimelineUnits?: never;
}>;
export type ClassificationAttributesValues = CheckboxAttributesValues | DateAttributesValues | MultiGroupedSelectNestedAttributesValues | MultiSelectAttributesValues | SingleSelectAttributesValues | TextAttributesValues;
export declare function isAttributesValuesOfUIElement<T extends BaseAttributesValues>(attributes: BaseAttributesValues, uiElement: T["uiElement"]): attributes is T;
type ClassificationLayoutElements = Readonly<{
    formDisplayOrder: number;
}>;
type DefaultLayout = Readonly<{
    layoutElements: Record<string, ClassificationLayoutElements>;
}>;
/**
 * The classification schema defined on the portal.
 */
export type ClassificationSchema = Readonly<{
    attributeCategories?: string[];
    attributes: Record<string, ClassificationAttributesValues>;
    bannerExpression?: string;
    classificationMetadata: ClassificationMetadata;
    grammarVersion: string;
    layouts: Record<string, DefaultLayout>;
    name: string;
    selectionTextExpression?: string;
    version: string;
    helpUrl?: string;
    helpTooltip?: string;
}>;
/**
 * The result of a request for a classification schema from
 * the portal /portals/self/classification/classificationSchema endpoint
 */
export type SchemaResult = {
    result?: ClassificationSchema;
    error?: {
        name: string;
        message: string;
        details: Record<string, unknown>;
    };
};
export interface ValidationResult {
    result?: {
        success: string;
    };
    error?: {
        code: string;
        details: {
            raw: {
                messages: string[];
            };
            name: string;
        };
        message: string;
        name: string;
    };
}
declare const portalErrorList: readonly ["unhandledError"];
export type PortalErrorType = (typeof portalErrorList)[number];
export interface Result<ResultT = any, ErrorT extends PortalErrorType = PortalErrorType> {
    result?: ResultT;
    error?: PortalError<ErrorT>;
}
export interface PortalError<Error extends PortalErrorType = PortalErrorType> {
    code: Error;
    translatedMessage?: string;
    message?: string;
    details?: any;
}
export type EditInfo = Readonly<{
    createdUser: string;
    createdDate: number;
    lastEditedUser: string;
    lastEditedDate: number;
}>;
export type SelectionText = Readonly<{
    elementType: string;
    selectionDisplayLabel: string;
    labelDelimiter: string;
    classificationProp: string;
    valueDelimiter: string;
}>;
export interface FavoriteClassification {
    name: string;
    classification: __esri.PortalItem["classification"];
}
export interface FavoriteClassificationResult {
    result?: {
        favorites: FavoriteClassification[];
    };
    error?: {
        details: {
            raw: {
                code: string;
                messages: string[];
                messageCode: string;
            };
        };
        message: string;
        name: string;
    };
}
export interface ClassificationAlertIndicator {
    alertIndicatorType?: HTMLCalciteAlertElement["kind"];
    alertIndicatorIcon?: string;
    alertIndicatorInfo: string;
}
export interface AddFavoriteClassificationResult {
    result?: {
        success: boolean;
    };
    error?: {
        name: string;
        message: string;
        details?: {
            raw: {
                messages: string[];
            };
            name: string;
        };
        url?: string;
    };
}
/**
 * State object that is used to store arcade expression results from expressions
 * that are evaluated for each attribute in the classification schema.
 **/
export type AttributeExpressionResults = Map<string, {
    enabled: boolean;
    valueExpressionResult: Record<string, ValueOption[]> | ValueOption[] | null;
    attributeValidationResult: string | null;
}>;
export {};
