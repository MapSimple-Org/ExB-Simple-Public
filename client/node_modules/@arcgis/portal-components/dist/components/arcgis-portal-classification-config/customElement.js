import { c as g } from "../../chunks/runtime.js";
import { LitElement as b, nothing as C } from "@arcgis/lumina";
import { css as v, html as n } from "lit";
import { Task as E, TaskStatus as y } from "@lit/task";
import { createRef as x, ref as I } from "lit/directives/ref.js";
import { usePropertyChange as w } from "@arcgis/lumina/controllers";
import { getClosestElement as $ } from "@arcgis/toolkit/dom";
import { u as P, c as S } from "../../chunks/loadClassificationData.js";
import { createArcadeExecutor as V } from "@arcgis/core/arcade.js";
import { u as O } from "../../chunks/useT9n.js";
import { d as h, a as d, g as R, r as m, c as A, b as _ } from "../../chunks/common.js";
import { watch as F } from "@arcgis/core/core/reactiveUtils.js";
import { r as D } from "../../chunks/requests.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
async function T({
  portalClassificationSchema: s,
  itemClassification: t
}) {
  const i = Object.entries(s.attributes).map(async ([a]) => {
    const r = await j(a, s, t);
    return { [a]: { enabled: r } };
  }), e = await Promise.all(i);
  return Object.assign({}, ...e);
}
async function j(s, t, i) {
  const e = t?.attributes?.[s];
  if (!e)
    return !1;
  const { isAttributeEnabled: a } = e;
  return a ? await f(
    a,
    JSON.stringify(t),
    i
  ) : !0;
}
async function M({
  portalClassificationSchema: s,
  itemClassification: t
}) {
  const i = Object.entries(s.attributes).map(async ([a]) => {
    const r = await N(a, s, t);
    return { [a]: { valueExpressionResult: r } };
  }), e = await Promise.all(i);
  return Object.assign({}, ...e);
}
async function N(s, t, i) {
  const e = t.attributes[s];
  if (!e)
    throw Error(`Attribute ${s} not found in schema`);
  const a = e.valueExpression, r = e.validValues, o = e.validValuesMap;
  return r?.length ? r : o && Object.keys(o)?.length ? o : a ? await f(
    a,
    t,
    i,
    s
  ) : null;
}
async function q({
  portalClassificationSchema: s,
  itemClassification: t
}) {
  const i = Object.entries(s.attributes).map(async ([a]) => {
    const r = await H(
      a,
      s,
      t
    );
    return { [a]: { attributeValidationResult: r } };
  }), e = await Promise.all(i);
  return Object.assign({}, ...e);
}
async function H(s, t, i) {
  const e = t?.attributes?.[s];
  if (!e)
    return null;
  const a = e?.attributeValidation;
  return a ? await f(
    a,
    JSON.stringify(t),
    i,
    s
  ) : null;
}
const u = async (s, t) => {
  const i = s?.bannerExpression;
  return i?.length ? await f(
    i,
    s,
    t
  ) : k(s, t);
}, k = (s, t) => {
  const i = Object.entries(s.attributes).sort(
    ([, o], [, l]) => (o?.bannerOrder ?? 0) - (l?.bannerOrder ?? 0)
  ), e = [], a = [];
  return i.forEach(([o, l]) => {
    const c = t?.[o];
    c && l.bannerOrder && (e.push(
      U({
        elementType: l.uiElement ?? "",
        selectionDisplayLabel: l.bannerLabel ?? "",
        labelDelimiter: l.labelDelimiter ?? "",
        classificationProp: c,
        valueDelimiter: l.valueDelimiter ?? ""
      })
    ), a.push(l.attributeDelimiter ?? ""));
  }), e.length > 0 ? e.reduce(
    (o, l, c) => c === 0 ? l : `${o}${a[c - 1]}${l}`,
    // avoiding to have delimiter at the start
    ""
  ) : "";
}, U = ({
  elementType: s,
  selectionDisplayLabel: t,
  labelDelimiter: i,
  classificationProp: e,
  valueDelimiter: a
}) => {
  const r = s.includes("multi") && e ? e.split("").join(a) : e;
  return `${t}${i}${r}`;
};
async function f(s, t, i, e = "") {
  const a = {
    schemaJsonString: typeof t == "string" ? t : JSON.stringify(t),
    valueJsonString: JSON.stringify(i),
    attributeId: e
  };
  return (await L(s)).execute(a);
}
async function L(s) {
  return await V(s, {
    variables: [
      {
        name: "schemaJsonString",
        type: "text"
      },
      {
        name: "valueJsonString",
        type: "text"
      },
      {
        name: "attributeId",
        type: "text"
      }
    ]
  });
}
const B = v`:host{height:100%;box-sizing:border-box;display:flex;flex-direction:column}.header-section{padding:var(--calcite-spacing-sm)}.header-section__title-container{display:flex;align-items:center;justify-content:space-between}.header-section__title-text{margin:unset;font-weight:unset;font-size:var(--calcite-font-size)}.header-section__title-popover{padding:var(--calcite-spacing-md)}.form-section{display:flex;border-top:var(--calcite-border-width-sm) solid var(--calcite-color-border-1);padding:var(--calcite-spacing-sm);height:100%;overflow:hidden}.form-section__sidebar{flex:1;padding:var(--calcite-spacing-sm)}.form-section__main-content{flex:3;padding:var(--calcite-spacing-sm);overflow:auto}.danger{color:var(--calcite-color-status-danger)}.spacing-y{margin:var(--calcite-spacing-md) 0}`;
class J extends b {
  constructor() {
    super(), this.classificationModel = P(this), this.messages = O(), this.formMainContentRef = x(), this._classificationDataTask = S(this), this._formCreationTask = new E(this, {
      task: async () => {
        if (await this._classificationDataTask.taskComplete, !this.portalClassificationSchema || !this.portalItem)
          throw new Error("Portal item and classification schema are required to render the form");
        const t = this.portalItem.clone();
        if (await t.load(), !this.primaryAttribute)
          throw new Error("primaryAttribute is required but was undefined.");
        this.existingClassification = !!t.classification, t.classification = h(t.classification, this.primaryAttribute, this.portalClassificationSchema), t.classification && (t.classification.banner = await u(this.portalClassificationSchema, t.classification)), this.pendingPortalItem = t, this._itemClassificationWatchHandle && (this._itemClassificationWatchHandle.remove(), this.portalItem.removeHandles("arcgis-classification-config"), this._itemClassificationWatchHandle = void 0), this._itemClassificationWatchHandle = F(() => this.portalItem.classification, (i) => {
          if (this.pendingPortalItem) {
            const e = this.pendingPortalItem.clone();
            e.load().then(() => {
              e.classification = i, this.pendingPortalItem = e;
            }).catch((a) => {
              console.error(a);
            });
          }
        }), this.portalItem.addHandles(this._itemClassificationWatchHandle, "arcgis-classification-config"), await this.evaluateAttributeExpressions(this.portalClassificationSchema, this.pendingPortalItem), this.pendingPortalItem.classification = d(this.pendingPortalItem.classification, this.attributeExpressionResults), this.existingClassification && this.validateForm();
      },
      args: () => [this.portalItem, this.portalClassificationSchema]
    }), this.getFormDisplayOrder = (t) => this.portalClassificationSchema?.layouts.default.layoutElements[t].formDisplayOrder ?? 0, this.addEditInfoAttributes = () => {
      if (!this.pendingPortalItem?.classification)
        return {};
      const t = structuredClone(this.pendingPortalItem.classification), i = R(this.pendingPortalItem, t);
      return { ...t, ...i };
    }, this.updateFavoriteClassification = (t) => {
      this.favoriteClassifications = t;
    }, this.updateClassificationData = async (t) => {
      const i = t.classification;
      if (this.selectedFavoriteClassificationName = t.name, this.pendingPortalItem) {
        const e = this.pendingPortalItem.clone();
        if (await e.load(), e.classification = m(this.portalClassificationSchema, i), !this.portalClassificationSchema)
          return;
        await this.evaluateAttributeExpressions(this.portalClassificationSchema, e), e.classification = d(e.classification, this.attributeExpressionResults), this.pendingPortalItem = e;
      }
    }, this.existingClassification = !1, this.portalClassificationSchema = this.classificationModel.portalClassificationSchema, this.primaryAttribute = this.classificationModel.primaryAttribute, this.attributeExpressionResults = /* @__PURE__ */ new Map(), this.formValidationErrors = [], this.remoteValidationErrors = "", this.canUserConfigureClassification = !0, this.favoriteClassifications = [], this.status = this.classificationModel.status, this.values = {}, this.valid = !1, this.autoDestroyDisabled = !1, this.arcgisPropertyChange = w()("status", "values", "valid");
  }
  static {
    this.properties = { existingClassification: 16, portalClassificationSchema: 16, primaryAttribute: 16, attributeExpressionResults: 16, formValidationErrors: 16, itemClassification: 16, pendingPortalItem: 16, selectedCategory: 16, remoteValidationErrors: 16, canUserConfigureClassification: 16, favoriteClassifications: 16, selectedFavoriteClassificationName: 16, portalItem: 0, status: 35, values: [1, { type: Object }], valid: 7, autoDestroyDisabled: 5 };
  }
  static {
    this.styles = B;
  }
  async destroy() {
    await this.manager.destroy();
  }
  async resetForm() {
    if (this.existingClassification)
      this.pendingPortalItem = this.portalItem?.clone(), this.portalClassificationSchema && this.pendingPortalItem && (await this.evaluateAttributeExpressions(this.portalClassificationSchema, this.pendingPortalItem), this.pendingPortalItem.classification = d(this.pendingPortalItem.classification, this.attributeExpressionResults), this.validateForm());
    else if (this.portalItem && this.primaryAttribute && this.portalClassificationSchema) {
      const t = this.portalItem.clone();
      await t.load(), this.pendingPortalItem = this.portalItem?.clone(), this.pendingPortalItem.classification = h(t.classification, this.primaryAttribute, this.portalClassificationSchema), this.portalClassificationSchema && this.pendingPortalItem && (await this.evaluateAttributeExpressions(this.portalClassificationSchema, this.pendingPortalItem), this.pendingPortalItem.classification = d(this.pendingPortalItem.classification, this.attributeExpressionResults));
    }
  }
  async validateForm() {
    this.updateFormValidationErrors(), await this.updateRemoteValidationErrors();
  }
  async load() {
    try {
      await A(this.portalItem) || (this.canUserConfigureClassification = !1);
      const t = await D(this.portalItem);
      if (t) {
        const { result: i, error: e } = t;
        if (e && e.details.raw.messageCode !== "COM_1177") {
          console.error(e);
          return;
        }
        i && (this.favoriteClassifications = i.favorites);
      }
    } catch (t) {
      console.error("Error occured while loading arcgis-classification-config:", t);
    }
  }
  willUpdate(t) {
    if (t.has("pendingPortalItem")) {
      const i = this.addEditInfoAttributes();
      this.values = i;
    }
    (t.has("formValidationErrors") || t.has("remoteValidationErrors")) && (this.valid = !this.formValidationErrors.length && !this.remoteValidationErrors);
  }
  loaded() {
    const t = $(this.el, "form");
    t && (this.listenOn(t, "formdata", this.updateFormData), this.listenOn(t, "submit", this.handleFormSubmit)), this.listen("submit", this.handleFormSubmit);
  }
  async updateClassificationProperty(t) {
    if (!this.pendingPortalItem || !this.portalClassificationSchema)
      return;
    const i = this.pendingPortalItem.clone();
    await i.load(), Object.entries(t ?? {}).forEach(([e, a]) => {
      if (e === this.primaryAttribute) {
        let r = _(a, i.classification, this.primaryAttribute);
        r = m(this.portalClassificationSchema, r), i.classification = r;
      } else {
        const r = new Map(Object.entries(i.classification ?? {}));
        if (a === void 0 || a === "" || Array.isArray(a) && a.length === 0)
          r.delete(e);
        else if (r.set(e, a), e === "fgi" && !r.has("fgiOptions")) {
          const o = this.portalClassificationSchema?.attributes?.fgiOptions?.defaultValue ?? [];
          r.set("fgiOptions", Array.isArray(o) ? o : [o]);
        }
        i.classification = Object.fromEntries(r);
      }
    }), i.classification && !i.classification.fgi && delete i.classification.fgiOptions, await this.evaluateAttributeExpressions(this.portalClassificationSchema, i), i.classification = d(i.classification, this.attributeExpressionResults), i.classification && (i.classification.banner = await u(this.portalClassificationSchema, i.classification)), this.pendingPortalItem = i, this.existingClassification && this.validateForm();
  }
  handleCategorySelectChange(t) {
    this.selectedCategory = t.target.selectedItems[0].value;
  }
  async evaluateAttributeExpressions(t, i) {
    const e = await T({
      portalClassificationSchema: t,
      itemClassification: i.classification
    }), a = await M({
      portalClassificationSchema: t,
      itemClassification: i.classification
    }), r = await q({
      portalClassificationSchema: t,
      itemClassification: i.classification
    });
    Object.keys(t.attributes).forEach((o) => {
      const l = e[o]?.enabled ?? !0, c = a[o]?.valueExpressionResult, p = r[o]?.attributeValidationResult;
      this.attributeExpressionResults.set(o, { enabled: l, valueExpressionResult: c, attributeValidationResult: p });
    });
  }
  updateFormValidationErrors() {
    const t = [];
    Object.entries(this.portalClassificationSchema?.attributes ?? {})?.forEach(([i, e]) => {
      e.isRequired && /**
      * Because of the logic in updateClassificationProperty (we delete keys instead of setting falsy values),
      * we can assume that the classification property will not have valid falsy values beyond zero.
      */
      !this.pendingPortalItem?.classification?.[i] && this.pendingPortalItem?.classification?.[i] !== 0 && t.push({
        attribute: e.label,
        reason: this.messages.isrequired ?? "is required",
        category: e.attributeCategory
      }), this.attributeExpressionResults.get(i)?.attributeValidationResult && t.push({
        attribute: e.label,
        reason: this.attributeExpressionResults.get(i)?.attributeValidationResult ?? "",
        category: e.attributeCategory
      });
    }), this.formValidationErrors = t;
  }
  async updateRemoteValidationErrors() {
    if (!this.pendingPortalItem?.classification)
      return;
    const t = await this.classificationModel.validateClassification(
      // do not pass a key so that the validation is not cached while editing the item
      void 0,
      this.pendingPortalItem?.classification,
      this.pendingPortalItem.portal.restUrl
    );
    this.remoteValidationErrors = t;
  }
  async handleFormSubmit(t) {
    this.validateForm(), this.formMainContentRef.value?.scrollIntoView();
  }
  updateFormData(t) {
    const i = t.formData;
    let e = this.addEditInfoAttributes();
    e = d(e, this.attributeExpressionResults), Object.entries(e ?? {}).forEach(([a, r]) => {
      i.set(a, r);
    });
  }
  renderCategoryTabs() {
    return this._classificationDataTask.render({
      complete: () => {
        if (this.portalClassificationSchema?.attributeCategories?.length)
          return this.selectedCategory || (this.selectedCategory = this.portalClassificationSchema?.attributeCategories[0]), n`<calcite-list .label=${this.messages.selectcategory ?? "select category"} selection-appearance=border selection-mode=single-persist @calciteListChange=${this.handleCategorySelectChange}>${this.portalClassificationSchema.attributeCategories.map((t) => {
            const i = this.formValidationErrors.filter((e) => e.category === t).length;
            return n`<calcite-list-item .label=${t} .value=${t} .selected=${this.selectedCategory === t} .description=${i ? `${i} ${i > 1 ? this.messages.errors : this.messages.error}` : void 0}>${i && n`<div slot=content-end class="danger"><calcite-icon icon=exclamation-mark-triangle scale=s></calcite-icon></div>` || ""}</calcite-list-item>`;
          })}</calcite-list>`;
      }
    });
  }
  renderValidationErrors() {
    return this.formValidationErrors.length && (!this.selectedCategory || this.formValidationErrors.some((t) => this.selectedCategory === t.category)) ? n`<calcite-notice open icon=exclamation-mark-triangle class="spacing-y" kind=danger><div slot=message>${this.messages.bannererror ?? "Some fields are incomplete or contain errors. Check the highlighted fields for details."}</div></calcite-notice>` : null;
  }
  renderFavoriteClassification() {
    const t = this.portalClassificationSchema?.attributeCategories?.[0] ?? "Default";
    return this.selectedCategory = this.portalClassificationSchema?.attributeCategories?.length ? this.selectedCategory : "Default", this.selectedCategory === t ? n`<arcgis-portal-classification-favorite .portalItem=${this.pendingPortalItem ?? this.portalItem} .classificationValue=${this.pendingPortalItem?.classification} .favoriteClassifications=${this.favoriteClassifications} .selectedFavoriteClassificationName=${this.selectedFavoriteClassificationName} .attributeExpressionResults=${this.attributeExpressionResults} .resetFavoriteClassification=${(i) => this.updateFavoriteClassification(i)} .updateClassificationData=${async (i) => await this.updateClassificationData(i)}></arcgis-portal-classification-favorite>` : null;
  }
  renderForm() {
    return this._formCreationTask.render({
      pending: () => n`<calcite-loader .label=${this.messages.loading ?? "loading"}></calcite-loader>`,
      complete: () => {
        if (!this.pendingPortalItem || !this.portalClassificationSchema)
          return;
        const t = Object.entries(this.portalClassificationSchema.attributes).sort(([i], [e]) => this.getFormDisplayOrder(i) - this.getFormDisplayOrder(e));
        return n`${this.renderValidationErrors()}${this.renderFavoriteClassification()}${t.filter(([, { attributeCategory: i }]) => this.selectedCategory === i || !i).map(([i, e]) => {
          if (this.attributeExpressionResults.get(i)?.enabled === !1)
            return null;
          const a = this.pendingPortalItem?.classification?.[i];
          return n`<arcgis-portal-classification-form-element .attributeKey=${i} .attribute=${e} .value=${a} @arcgisAttributeValueChange=${(r) => void this.updateClassificationProperty(r.detail)} .renderingInfo=${this.attributeExpressionResults.get(i)}></arcgis-portal-classification-form-element>`;
        })}`;
      }
    });
  }
  renderNotice(t, i = "warning") {
    return n`<calcite-notice icon=exclamation-mark-triangle open class="spacing-y" .kind=${i}><div slot=message>${t}</div></calcite-notice>`;
  }
  renderHelpTooltip() {
    return this.portalClassificationSchema?.helpTooltip ? n`<calcite-action id=portal-classification-config-tooltip-button .text=${this.portalClassificationSchema?.helpTooltip} icon=information></calcite-action><calcite-popover .label=${this.portalClassificationSchema?.helpTooltip} reference-element=portal-classification-config-tooltip-button placement=bottom-end overlay-positioning=fixed auto-close><div class="header-section__title-popover"><calcite-link .href=${this.portalClassificationSchema?.helpUrl} target=_blank id=portal-classification-config-tooltip-button>${this.portalClassificationSchema?.helpTooltip}</calcite-link></div></calcite-popover>` : null;
  }
  render() {
    return this.portalItem ? this._classificationDataTask.render({
      pending: () => n`<calcite-loader .label=${this.messages.loading ?? "loading"}></calcite-loader>`,
      error: () => this.renderNotice(this.messages.anerroroccurred ?? "An error has occurred.", "danger"),
      complete: () => this.portalItem ? this.canUserConfigureClassification ? this.portalItem.portal.hasClassificationSchema ? n`<div class="header-section" role=region aria-label=${this.messages.documentbannerpreview ?? "documentbannerpreview" ?? C}><div class="header-section__title-container"><h2 class="header-section__title-text">${this.messages.documentbannerpreview ?? "documentbannerpreview"}</h2>${this.renderHelpTooltip()}</div>${this._formCreationTask.status === y.COMPLETE && n`<arcgis-portal-classification-banner .portalItem=${this.pendingPortalItem ?? this.portalItem} variant=preview .missingExistingClassification=${!this.existingClassification}></arcgis-portal-classification-banner>` || ""}</div><div class="form-section">${this.portalClassificationSchema?.attributeCategories?.length && n`<div class="form-section__sidebar">${this.renderCategoryTabs()}</div>` || ""}<div class="form-section__main-content" ${I(this.formMainContentRef)}>${this.renderForm()}</div></div>` : this.renderNotice(this.messages.missingclassificationschema ?? "Portal is missing classification schema.") : this.renderNotice(this.messages.userconfigurepermissionrequired ?? "User configuration permission is required.") : this.renderNotice(this.messages.portalitemrequired ?? "Portal item is required.")
    }) : this.renderNotice(this.messages.portalitemrequired ?? "Portal item is required.");
  }
}
g("arcgis-portal-classification-config", J);
export {
  J as ArcgisPortalClassificationConfig
};
