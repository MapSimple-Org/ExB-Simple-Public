import { c as k } from "../../chunks/runtime.js";
import { html as p, css as M } from "lit";
import { LitElement as O, createEvent as v, renderElement as T } from "@arcgis/lumina";
import { createRef as I, ref as N } from "lit/directives/ref.js";
import { Task as P } from "@lit/task";
import * as x from "@arcgis/core/core/lang.js";
import L from "@arcgis/core/layers/support/FeatureTemplate.js";
import S from "@arcgis/core/Graphic.js";
import j from "@arcgis/core/identity/IdentityManager.js";
import y from "@arcgis/core/request.js";
import { a as B, g as U, b as q, d as R, s as J, e as w, f as z, i as D } from "../../chunks/fieldAddDelete.js";
import { u as W } from "../../chunks/useT9n.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
v4.34.3 */
const n = /* @__PURE__ */ new Map();
n.set("oid", "key");
n.set("guid", "key");
n.set("global-id", "key");
n.set("blob", "binary");
n.set("integer", "integer");
n.set("small-integer", "integer");
n.set("big-integer", "integer");
n.set("single", "number");
n.set("double", "number");
n.set("long", "number");
n.set("number", "number");
n.set("date", "date-time");
n.set("date-only", "calendar");
n.set("time-only", "clock");
n.set("timestamp-offset", "time-zone");
n.set("string", "string");
const _ = ({ fieldType: $ }) => p`<calcite-icon scale=s .icon=${n.get($)}></calcite-icon>`, V = M`.dialog{--calcite-dialog-max-size-y: 60%}.dialog-content-wrapper{position:relative;min-height:100px}.hide-overflow{overflow:hidden}.field-icons{padding:0 var(--calcite-spacing-lg);display:flex;align-items:center}.warning{border-bottom:var(--calcite-border-width-sm) solid var(--calcite-color-border-3);margin-bottom:var(--calcite-spacing-md)}.warning-message{font-size:var(--calcite-font-size--1);font-weight:var(--calcite-font-weight-bold)}.loader-container{position:absolute;height:100%;width:100%;top:0;right:0;display:none;z-index:40;overflow:hidden;background:#fffffff2;padding:0}.active{display:flex;flex-direction:column;align-items:center;justify-content:center}.loader{padding:0}.loader-text{font-weight:var(--calcite-font-weight-medium);text-align:center;margin-right:6.25rem;margin-left:6.25rem}`;
class G extends O {
  constructor() {
    super(...arguments), this.arcadeExpMap = /* @__PURE__ */ new Map(), this.cancelNode = I(), this.dialogNode = I(), this.layerFields = [], this.layerFieldsMap = /* @__PURE__ */ new Map(), this.messages = W({ blocking: !0 }), this.deleteInProgress = !1, this.fieldsAreDeletable = !1, this._propWatcherTask = new P(this, {
      task: async ([e, t]) => {
        if (!(D(e) && D(t)))
          throw console.error("Required properties are missing."), new Error();
        this._propWatcherTask.autoRun = !1, await this.processProps();
      },
      args: () => [this.layer, this.fieldNames]
    }), this.arcgisBeforeModalClose = v(), this.arcgisClose = v(), this.arcgisFieldsDeleted = v();
  }
  static {
    this.properties = { config: 0, fieldNames: 0, layer: 0, mapView: 0, options: 0 };
  }
  static {
    this.styles = V;
  }
  async processProps() {
    const { layer: e, mapView: t, fieldNames: s } = this;
    if (!e || !s) {
      this.fieldsAreDeletable = !1;
      return;
    }
    e.loaded || await e.load(), this.layerFields = e.fields.filter((o) => s.includes(o.name));
    const a = s.some((o) => !e.fields.find((r) => r.name === o));
    if (!this.layerFields?.length || a)
      this.fieldsAreDeletable = !1;
    else {
      const o = await Promise.all(this.layerFields.map(async (r) => await B(t, e, r, this.options)));
      if (this.fieldsAreDeletable = o.every((r) => r), !this.fieldsAreDeletable)
        return;
    }
    if (this.layerFieldsMap = await U(e), this.options?.ignorePopupTemplate || (this.arcadeExpMap = q(e.popupTemplate)), this.portal = e.portalItem?.portal ?? this.options?.portal, this.item = e.portalItem ?? this.options?.item, !this.item) {
      this.fieldsAreDeletable = !1;
      return;
    }
    await j.getCredential(this.item.url.replace("rest/services", "rest/admin/services"));
  }
  getFieldLabel(e) {
    const { layer: t, arcadeExpMap: s } = this;
    if (this.options?.ignorePopupTemplate)
      return this.getFieldDisplayNameFromLayerFields(e);
    {
      const o = (t.popupTemplate ?? t.createPopupTemplate()).fieldInfos?.find((r) => r.fieldName === e);
      return o ? R(t, o, s) : this.getFieldDisplayNameFromLayerFields(e);
    }
  }
  getFieldDisplayNameFromLayerFields(e) {
    const { layer: t } = this, s = this.layerFieldsMap.get(e);
    return J(t) ? t.getFieldAlias(e) : s.alias ?? s.name;
  }
  async deleteFields() {
    const { layer: e, fieldNames: t } = this, s = `${e.url.replace("/rest/services", "/rest/admin/services")}/${e.layerId}/deleteFromDefinition`, a = {
      fields: t.map((r) => ({
        name: r
      }))
    }, o = {
      deleteFromDefinition: JSON.stringify(a)
    };
    await y(s, {
      query: { ...o, f: "json", async: !1 },
      method: "post",
      responseType: "json"
    }).then(async (r) => {
      if (r.data?.success) {
        const h = `${e.url}/${e.layerId}`;
        t.forEach((i) => {
          e.type === "feature" && e.floorInfo?.floorField === i && (e.floorInfo = null);
        });
        const u = await y(h, { query: { f: "json" }, responseType: "json" });
        if (u) {
          const i = u.data;
          this.currentLayerInfo = u.data, i && (this.updateTypesAndTemplatesOnLayer(), t.forEach((l) => {
            i.templates?.length ? i.templates.forEach((d) => delete d.prototype.attributes[l]) : i.types?.forEach((d) => {
              d.templates.forEach((m) => delete m.prototype.attributes[l]);
            });
          }), this.updateFeatureService(i));
        } else
          this.handleError();
      }
    }, () => this.handleError());
  }
  updateTypesAndTemplatesOnLayer() {
    const { currentLayerInfo: e } = this, t = e;
    if (t.templates?.length) {
      const s = this.updateTemplatesList(t.templates);
      t.templates = s;
    } else if (t.types) {
      const s = t.types;
      t.types = [], s.forEach((a) => {
        a.templates = this.updateTemplatesList(a.templates), this.addType(t, a);
      });
    }
  }
  updateTemplatesList(e) {
    const { currentLayerInfo: t, messages: s } = this, a = [];
    return (e ?? []).forEach((o) => {
      const r = new L();
      r.description = o.description ?? "", r.name = o.name || s.newFeature, r.drawingTool = o.drawingTool || "point";
      const h = {};
      t.fields.forEach((i) => {
        let l = !1;
        for (let d = 0; d < o.prototype.attributes.length; d++)
          if (o.prototype.attributes[d] === i.name) {
            l = !0, h[i.name] = o.prototype.attributes[i.name];
            break;
          }
        !l && i.editable && (h[i.name] = i.defaultValue || null);
      });
      const u = new S({ attributes: h });
      r.prototype = u, a.push(r);
    }), a;
  }
  addType(e, t) {
    e.types ? e.types.some((a) => a.id === t.id) || e.types.push(t) : e.types = [t];
  }
  async updateFeatureService(e) {
    const { layer: t, fieldNames: s } = this, a = {
      templates: e.templates,
      types: e.types
    }, o = `${t.url.replace("/rest/services", "/rest/admin/services")}/${t.layerId}/updateDefinition`, r = {
      f: "json",
      updateDefinition: JSON.stringify(a)
    };
    await y(o, {
      query: { ...r, f: "json" },
      method: "post",
      responseType: "json"
    }).then(async (h) => {
      if (h.data?.success) {
        const u = `${w(this.portal)}content/items/${this.item.id}/data`;
        if (this.options?.ignorePopupTemplate || s.forEach((i) => {
          t.popupTemplate?.fieldInfos && (t.popupTemplate.fieldInfos = t.popupTemplate.fieldInfos.filter((l) => l.fieldName !== i)), t.popupTemplate?.content?.forEach((l, d) => {
            l.type === "fields" && l.fieldInfos && ((t.popupTemplate?.content)[d].fieldInfos = (t.popupTemplate?.content)[d].fieldInfos?.filter((m) => m.fieldName !== i));
          });
        }), t.attributeTableTemplate) {
          const i = t.attributeTableTemplate.clone();
          i.elements = i.elements.filter((l) => !(l.type === "field" && s.includes(l.fieldName))), i.orderByFields = i.orderByFields.filter((l) => !s.includes(l.field)), t.attributeTableTemplate = i;
        }
        if (t.fieldConfigurations?.length) {
          const l = x.clone(t.fieldConfigurations).filter((d) => !s.includes(d.name));
          t.fieldConfigurations = l;
        }
        await y(u, {
          query: { f: "json" },
          responseType: "json"
        }).then(async (i) => {
          const l = i.data;
          if (l?.layers || l?.tables) {
            const d = t.isTable, m = d ? l.tables : l.layers, c = m?.find((g) => g.id === t.layerId);
            if (s.forEach((g) => {
              c?.attributeTableInfo?.attributeTableElements && (c.attributeTableInfo.attributeTableElements = c.attributeTableInfo.attributeTableElements.filter((f) => !(f.type === "field" && f.fieldName === g)), c.attributeTableInfo.orderByFields = c.attributeTableInfo.orderByFields.filter((f) => f.field !== g));
            }), c?.layerDefinition?.fieldConfigurations && (c.layerDefinition.fieldConfigurations = c.layerDefinition.fieldConfigurations.filter((g) => !s.includes(g.name))), c?.popupInfo) {
              s.forEach((b) => {
                c.popupInfo.fieldInfos = c.popupInfo.fieldInfos.filter((F) => F.fieldName !== b), c.popupInfo.popupElements?.forEach((F, E) => {
                  F.type === "fields" && F.fieldInfos && (c.popupInfo.popupElements[E].fieldInfos = c.popupInfo.popupElements[E].fieldInfos.filter((C) => C.fieldName !== b));
                });
              });
              const g = `${w(this.portal)}content/users/${this.item.owner}/items/${this.item.id}/update`, f = {};
              d ? (f.tables = m, l.layers && (f.layers = l.layers)) : (f.layers = m, l.tables && (f.tables = l.tables));
              const A = {
                f: "json",
                text: JSON.stringify(f)
              };
              await y(g, {
                query: {
                  ...A
                },
                method: "post",
                responseType: "json"
              }).then((b) => {
                b.data?.success ? this.handleSuccess() : this.handleError();
              }, () => this.handleError());
            } else
              this.handleSuccess();
          } else i.httpStatus === 200 && (!i.data || JSON.stringify(i.data) === "{}") ? this.handleSuccess() : this.handleError();
        }, () => this.handleError());
      }
    }, () => this.handleError());
  }
  handleSuccess() {
    this.arcgisFieldsDeleted.emit(), this.dialogNode?.value && (this.dialogNode.value.open = !1), this.options?.handleCloseOnConsumer ? this.arcgisBeforeModalClose.emit("success") : this.displaySuccessAlert();
  }
  handleError(e) {
    this.dialogNode?.value && (this.dialogNode.value.open = !1), e ? this.options?.handleCloseOnConsumer ? this.arcgisBeforeModalClose.emit("read-only-error") : this.displayReadOnlyErrorAlert() : this.options?.handleCloseOnConsumer ? this.arcgisBeforeModalClose.emit("error") : this.displayErrorAlert();
  }
  displaySuccessAlert() {
    const { messages: e, fieldNames: t } = this;
    this.successAlertNode && (this.successAlertNode.parentElement?.removeChild(this.successAlertNode), this.successAlertNode = void 0), this.successAlertNode = T(p`<calcite-alert .label=${t.length === 1 ? e.fieldDeleted : e.fieldsDeleted} kind=success icon=check-circle auto-close open><div slot=message>${t.length === 1 ? e.fieldDeleted : e.fieldsDeleted}</div></calcite-alert>`), document.body.append(this.successAlertNode);
  }
  displayErrorAlert() {
    const { messages: e } = this;
    this.errorAlertNode && (this.errorAlertNode.parentElement?.removeChild(this.errorAlertNode), this.errorAlertNode = void 0), this.errorAlertNode = T(p`<calcite-alert .label=${e.fieldDeletionUnsuccessful} kind=danger icon=exclamation-mark-triangle auto-close open><div slot=message>${e.fieldDeletionUnsuccessful}</div></calcite-alert>`), document.body.append(this.errorAlertNode);
  }
  displayReadOnlyErrorAlert() {
    const { messages: e, portal: t } = this;
    this.errorAlertNode && (this.errorAlertNode.parentElement?.removeChild(this.errorAlertNode), this.errorAlertNode = void 0), this.errorAlertNode = T(p`<calcite-alert .label=${e.fieldDeletionUnsuccessful} kind=danger icon=exclamation-mark-triangle auto-close auto-close-duration=slow open><div slot=title>${e.error}</div><div slot=message>${t.isPortal ? e.readOnlyErrorMessageEnterprise : e.readOnlyErrorMessage}</div>${!t.isPortal && p`<calcite-link slot=link target=_blank href=https://status.arcgis.com>${e.healthDashboard}</calcite-link>` || ""}</calcite-alert>`), document.body.append(this.errorAlertNode);
  }
  render() {
    const { messages: e, fieldsAreDeletable: t, fieldNames: s, deleteInProgress: a } = this;
    return this._propWatcherTask.render({
      complete: () => (t || (s?.length ? s?.length === 1 ? console.error("Field cannot be deleted") : console.error("One or more fields cannot be deleted") : console.error("You must select at least one field.")), p`<calcite-dialog class="dialog" width=s open modal outside-close-disabled escape-disabled @calciteDialogClose=${() => this.arcgisClose.emit()} .heading=${s?.length === 1 ? e.deleteField : e.deleteFields} ${N(this.dialogNode)}>${t ? p`<div class=${`dialog-content-wrapper ${a ? "hide-overflow" : ""}`}>${this.renderDeleteLoader()}<calcite-label>${s.length === 1 ? e.deletePrompt : e.deleteMultiplePrompt}</calcite-label>${this.renderFieldsPreview()}</div>${this.renderCancelButton()}${this.renderDeleteButton()}` : this.renderError()}</calcite-dialog>`)
    });
  }
  renderError() {
    const { messages: e } = this;
    return p`<div class="loader-container active"><div class="loader-text">${e.errorOccurred}</div></div>`;
  }
  renderDeleteLoader() {
    const { messages: e, fieldNames: t, deleteInProgress: s } = this;
    return p`<div class=${`loader-container ${s ? "active" : ""}`}><calcite-loader class="loader" .label=${t.length === 1 ? e.deletingField : e.deletingFields} .hidden=${!s}></calcite-loader><div class="loader-text">${t.length === 1 ? e.deletingField : e.deletingFields}</div></div>`;
  }
  renderFieldsPreview() {
    const { fieldNames: e, layerFields: t, layerFieldsMap: s, arcadeExpMap: a, messages: o } = this;
    return p`<calcite-list .label=${o.fields}>${e.map((r) => {
      const h = t.find((u) => u.name === r);
      return p`<calcite-list-item .label=${this.getFieldLabel(r)} .description=${`{${r}}`} .value=${r} .disabled=${!h.editable}><div slot=actions-end class="field-icons">${_({ fieldType: z(r, s, a) })}</div></calcite-list-item>`;
    })}</calcite-list>`;
  }
  renderCancelButton() {
    const { messages: e } = this;
    return p`<calcite-button @click=${() => this.dialogNode.value.open = !1} slot=footer-end appearance=outline ${N(this.cancelNode)}>${e.cancel}</calcite-button>`;
  }
  renderDeleteButton() {
    const { messages: e, fieldNames: t } = this;
    return p`<calcite-button kind=danger slot=footer-end @click=${async (s) => {
      const { portal: a } = this;
      s.currentTarget.disabled = !0, this.cancelNode.value.disabled = !0, this.dialogNode.value.closeDisabled = !0, a.sourceJSON?.isReadOnly ? this.handleError(!0) : (this.deleteInProgress = !0, this.requestUpdate(), await this.deleteFields());
    }}>${t.length === 1 ? e.deleteField : e.deleteFieldsWithNumber.replace("${number}", `${t.length}`)}</calcite-button>`;
  }
}
k("arcgis-portal-field-delete", G);
export {
  G as ArcgisPortalFieldDelete
};
